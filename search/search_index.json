{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Remember</p> <p>Please note the naff package is now deprecated. Please migrate to interactions.py, where future development will continue.  Interactions.py V5 is a combined release between interactions.py and naff. Migration is easy, and should only take an hour at most.</p> <p>We hope this documentation is helpful for you, but don't just Ctrl+C and Ctrl+V.</p>"},{"location":"#what-is-this","title":"<code>\"What is this?\"</code>","text":"<p>This is <code>NAFF</code>, an API wrapper for Discord, written in Python. This wrapper is designed to be easy to use, and easily modified to suit your needs.</p>"},{"location":"#features","title":"Features:","text":"<ul> <li> 100% coverage of the application commands API</li> <li> Modern and Pythonic API</li> <li> Asynchronous operation</li> <li> Proper rate limit handling</li> <li> Dynamic cache with TTL support</li> </ul>"},{"location":"#is-this-just-another-discordpy-fork","title":"<code>\"Is this just another discord.py fork?\"</code>","text":"<p>While this library shares some features and stylistic choice with <code>discord.py</code>, its completely separate from them. We think <code>discord.py</code> is a fantastic library, but we disagree with the direction and design decisions made by it.</p> <p>Compared to <code>discord.py</code>; <code>NAFF</code> starts faster, responds faster, and is simpler to use. Especially compared to <code>Views</code>.</p>"},{"location":"#i-dont-like-how-youve-done-x-feature","title":"<code>\"I don't like how you've done x feature\"</code>","text":"<p>Make an issue on our  GitHub Repo and we can have a discussion on it. Or if you want faster responses, join our Discord Server .</p>"},{"location":"#i-dont-understand-something","title":"<code>\"I don't understand something\"</code>","text":"<p>If you need help with something, don\u2019t hesitate to ask for help in the Discord Server !</p>"},{"location":"#can-i-contribute-to-this-project","title":"<code>\"Can I contribute to this project?\"</code>","text":"<p>Of course, you can contribute to this project by submitting a pull-request to the  GitHub Repo . We are open to all contributions, and we welcome everyone to join us.</p>"},{"location":"FAQ/","title":"FAQ","text":"<p>Notice</p> <p>This page is a placeholder, and will be populated at a later date.</p>"},{"location":"API%20Reference/AutoShardClient/","title":"AutoShardClient","text":""},{"location":"API%20Reference/AutoShardClient/#naff.client.auto_shard_client.AutoShardedClient","title":"<code>AutoShardedClient</code>","text":"<p>         Bases: <code>Client</code></p> <p>A client to automatically shard the bot.</p> <p>You can optionally specify the total number of shards to start with, or it will be determined automatically.</p> Source code in <code>naff\\client\\auto_shard_client.py</code> <pre><code>class AutoShardedClient(Client):\n\"\"\"\n    A client to automatically shard the bot.\n\n    You can optionally specify the total number of shards to start with, or it will be determined automatically.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -&gt; None:\n        if \"total_shards\" not in kwargs:\n            self.auto_sharding = True\n        else:\n            self.auto_sharding = False\n\n        super().__init__(*args, **kwargs)\n\n        self._connection_state = None\n\n        self._connection_states: list[ConnectionState] = []\n\n        self.max_start_concurrency: int = 1\n\n    @property\n    def gateway_started(self) -&gt; bool:\n\"\"\"Returns if the gateway has been started in all shards.\"\"\"\n        return all(state.gateway_started.is_set() for state in self._connection_states)\n\n    @property\n    def shards(self) -&gt; list[ConnectionState]:\n\"\"\"Returns a list of all shards currently in use.\"\"\"\n        return self._connection_states\n\n    @property\n    def latency(self) -&gt; float:\n\"\"\"The average latency of all active gateways.\"\"\"\n        if len(self._connection_states):\n            latencies = sum((g.latency for g in self._connection_states))\n            return latencies / len(self._connection_states)\n        else:\n            return float(\"inf\")\n\n    @property\n    def latencies(self) -&gt; dict[int, float]:\n\"\"\"\n        Return a dictionary of latencies for all shards.\n\n        Returns:\n            {shard_id: latency}\n        \"\"\"\n        return {state.shard_id: state.latency for state in self._connection_states}\n\n    async def stop(self) -&gt; None:\n\"\"\"Shutdown the bot.\"\"\"\n        self.logger.debug(\"Stopping the bot.\")\n        self._ready.clear()\n        await self.http.close()\n        await asyncio.gather(*(state.stop() for state in self._connection_states))\n\n    def get_guild_websocket(self, guild_id: \"Snowflake_Type\") -&gt; GatewayClient:\n\"\"\"\n        Get the appropriate websocket for a given guild\n\n        Args:\n            guild_id: The ID of the guild\n\n        Returns:\n            A gateway client for the given ID\n        \"\"\"\n        shard_id = (int(guild_id) &gt;&gt; 22) % self.total_shards\n        return next((state for state in self._connection_states if state.shard_id == shard_id), MISSING).gateway\n\n    def get_shards_guild(self, shard_id: int) -&gt; list[Guild]:\n\"\"\"\n        Returns the guilds that the specified shard can see\n\n        Args:\n            shard_id: The ID of the shard\n\n        Returns:\n            A list of guilds\n        \"\"\"\n        return [guild for key, guild in self.cache.guild_cache.items() if ((key &gt;&gt; 22) % self.total_shards) == shard_id]\n\n    def get_shard_id(self, guild_id: \"Snowflake_Type\") -&gt; int:\n\"\"\"\n        Get the shard ID for a given guild.\n\n        Args:\n            guild_id: The ID of the guild\n\n        Returns:\n            The shard ID for the guild\n        \"\"\"\n        return (int(guild_id) &gt;&gt; 22) % self.total_shards\n\n    @Listener.create()\n    async def _on_websocket_ready(self, event: events.RawGatewayEvent) -&gt; None:\n\"\"\"\n        Catches websocket ready and determines when to dispatch the client `READY` signal.\n\n        Args:\n            event: The websocket ready packet\n        \"\"\"\n        connection_data = event.data\n        expected_guilds = {to_snowflake(guild[\"id\"]) for guild in connection_data[\"guilds\"]}\n        shard_id, total_shards = connection_data[\"shard\"]\n        connection_state = next((state for state in self._connection_states if state.shard_id == shard_id), None)\n\n        if len(expected_guilds) != 0:\n            while True:\n                try:\n                    await asyncio.wait_for(self._guild_event.wait(), self.guild_event_timeout)\n                except asyncio.TimeoutError:\n                    self.logger.warning(\"Timeout waiting for guilds cache: Not all guilds will be in cache\")\n                    break\n                self._guild_event.clear()\n                if all(self.cache.get_guild(g_id) is not None for g_id in expected_guilds):\n                    # all guilds cached\n                    break\n\n            if self.fetch_members:\n                self.logger.info(f\"Shard {shard_id} is waiting for members to be chunked\")\n                await asyncio.gather(*(guild.chunked.wait() for guild in self.guilds if guild.id in expected_guilds))\n        else:\n            self.logger.warning(\n                f\"Shard {shard_id} reports it has 0 guilds, this is an indicator you may be using too many shards\"\n            )\n        # noinspection PyProtectedMember\n        connection_state._shard_ready.set()\n        self.dispatch(ShardConnect(shard_id))\n        self.logger.debug(f\"Shard {shard_id} is now ready\")\n\n        # noinspection PyProtectedMember\n        await asyncio.gather(*[shard._shard_ready.wait() for shard in self._connection_states])\n\n        # run any pending startup tasks\n        if self.async_startup_tasks:\n            try:\n                await asyncio.gather(*self.async_startup_tasks)\n            except Exception as e:\n                self.dispatch(events.Error(source=\"async-extension-loader\", error=e))\n\n        # cache slash commands\n        if not self._startup:\n            await self._init_interactions()\n\n        if not self._ready.is_set():\n            self._ready.set()\n            if not self._startup:\n                self._startup = True\n                self.dispatch(events.Startup())\n            self.dispatch(events.Ready())\n\n    async def astart(self, token: str) -&gt; None:\n\"\"\"\n        Asynchronous method to start the bot.\n\n        Args:\n            token: Your bot's token\n        \"\"\"\n        self.logger.debug(\"Starting http client...\")\n        await self.login(token)\n\n        tasks = []\n\n        # Sort shards into their respective ratelimit buckets\n        shard_buckets = defaultdict(list)\n        for shard in self._connection_states:\n            bucket = str(shard.shard_id % self.max_start_concurrency)\n            shard_buckets[bucket].append(shard)\n\n        for bucket in shard_buckets.values():\n            for shard in bucket:\n                self.logger.debug(f\"Starting {shard.shard_id}\")\n                start = time.perf_counter()\n                tasks.append(asyncio.create_task(shard.start()))\n\n                if self.max_start_concurrency == 1:\n                    # connection ratelimiting when discord has asked for one connection concurrently\n                    # noinspection PyProtectedMember\n                    await shard._shard_ready.wait()\n                    await asyncio.sleep(5.1 - (time.perf_counter() - start))\n\n            # wait for shards to finish starting\n            # noinspection PyProtectedMember\n            await asyncio.gather(*[shard._shard_ready.wait() for shard in self._connection_states])\n\n        try:\n            await asyncio.gather(*tasks)\n        finally:\n            await self.stop()\n\n    async def login(self, token) -&gt; None:\n\"\"\"\n        Login to discord via http.\n\n        !!! note\n            You will need to run Naff.start_gateway() before you start receiving gateway events.\n\n        Args:\n            token str: Your bot's token\n\n        \"\"\"\n        await super().login(token)\n        data = await self.http.get_gateway_bot()\n\n        self.max_start_concurrency = data[\"session_start_limit\"][\"max_concurrency\"]\n        if self.auto_sharding:\n            self.total_shards = data[\"shards\"]\n        elif data[\"shards\"] != self.total_shards:\n            recommended_shards = data[\"shards\"]\n            self.logger.info(\n                f\"Discord recommends you start with {recommended_shards} shard{'s' if recommended_shards != 1 else ''} instead of {self.total_shards}\"\n            )\n\n        self.logger.debug(f\"Starting bot with {self.total_shards} shard{'s' if self.total_shards != 1 else ''}\")\n        self._connection_states: list[ConnectionState] = [\n            ConnectionState(self, self.intents, shard_id) for shard_id in range(self.total_shards)\n        ]\n\n    async def change_presence(\n        self,\n        status: Optional[str | Status] = Status.ONLINE,\n        activity: Optional[str | Activity] = None,\n        *,\n        shard_id: int | None = None,\n    ) -&gt; None:\n\"\"\"\n        Change the bot's presence.\n\n        Args:\n            status: The status for the bot to be. i.e. online, afk, etc.\n            activity: The activity for the bot to be displayed as doing.\n            shard_id: The shard to change the presence on. If not specified, the presence will be changed on all shards.\n\n        !!! note\n            Bots may only be `playing` `streaming` `listening` `watching` or `competing`, other activity types are likely to fail.\n\n        \"\"\"\n        if shard_id is None:\n            await asyncio.gather(*[shard.change_presence(status, activity) for shard in self._connection_states])\n        else:\n            await self._connection_states[shard_id].change_presence(status, activity)\n</code></pre>"},{"location":"API%20Reference/AutoShardClient/#naff.client.auto_shard_client.AutoShardedClient.gateway_started","title":"<code>gateway_started: bool</code>  <code>property</code>","text":"<p>Returns if the gateway has been started in all shards.</p>"},{"location":"API%20Reference/AutoShardClient/#naff.client.auto_shard_client.AutoShardedClient.shards","title":"<code>shards: list[ConnectionState]</code>  <code>property</code>","text":"<p>Returns a list of all shards currently in use.</p>"},{"location":"API%20Reference/AutoShardClient/#naff.client.auto_shard_client.AutoShardedClient.latency","title":"<code>latency: float</code>  <code>property</code>","text":"<p>The average latency of all active gateways.</p>"},{"location":"API%20Reference/AutoShardClient/#naff.client.auto_shard_client.AutoShardedClient.latencies","title":"<code>latencies: dict[int, float]</code>  <code>property</code>","text":"<p>Return a dictionary of latencies for all shards.</p> <p>Returns:</p> Type Description <code>dict[int, float]</code> <p>{shard_id: latency}</p>"},{"location":"API%20Reference/AutoShardClient/#naff.client.auto_shard_client.AutoShardedClient.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Shutdown the bot.</p> Source code in <code>naff\\client\\auto_shard_client.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Shutdown the bot.\"\"\"\n    self.logger.debug(\"Stopping the bot.\")\n    self._ready.clear()\n    await self.http.close()\n    await asyncio.gather(*(state.stop() for state in self._connection_states))\n</code></pre>"},{"location":"API%20Reference/AutoShardClient/#naff.client.auto_shard_client.AutoShardedClient.get_guild_websocket","title":"<code>get_guild_websocket(guild_id)</code>","text":"<p>Get the appropriate websocket for a given guild</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <p>Returns:</p> Type Description <code>GatewayClient</code> <p>A gateway client for the given ID</p> Source code in <code>naff\\client\\auto_shard_client.py</code> <pre><code>def get_guild_websocket(self, guild_id: \"Snowflake_Type\") -&gt; GatewayClient:\n\"\"\"\n    Get the appropriate websocket for a given guild\n\n    Args:\n        guild_id: The ID of the guild\n\n    Returns:\n        A gateway client for the given ID\n    \"\"\"\n    shard_id = (int(guild_id) &gt;&gt; 22) % self.total_shards\n    return next((state for state in self._connection_states if state.shard_id == shard_id), MISSING).gateway\n</code></pre>"},{"location":"API%20Reference/AutoShardClient/#naff.client.auto_shard_client.AutoShardedClient.get_shards_guild","title":"<code>get_shards_guild(shard_id)</code>","text":"<p>Returns the guilds that the specified shard can see</p> <p>Parameters:</p> Name Type Description Default <code>shard_id</code> <code>int</code> <p>The ID of the shard</p> required <p>Returns:</p> Type Description <code>list[Guild]</code> <p>A list of guilds</p> Source code in <code>naff\\client\\auto_shard_client.py</code> <pre><code>def get_shards_guild(self, shard_id: int) -&gt; list[Guild]:\n\"\"\"\n    Returns the guilds that the specified shard can see\n\n    Args:\n        shard_id: The ID of the shard\n\n    Returns:\n        A list of guilds\n    \"\"\"\n    return [guild for key, guild in self.cache.guild_cache.items() if ((key &gt;&gt; 22) % self.total_shards) == shard_id]\n</code></pre>"},{"location":"API%20Reference/AutoShardClient/#naff.client.auto_shard_client.AutoShardedClient.get_shard_id","title":"<code>get_shard_id(guild_id)</code>","text":"<p>Get the shard ID for a given guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <p>Returns:</p> Type Description <code>int</code> <p>The shard ID for the guild</p> Source code in <code>naff\\client\\auto_shard_client.py</code> <pre><code>def get_shard_id(self, guild_id: \"Snowflake_Type\") -&gt; int:\n\"\"\"\n    Get the shard ID for a given guild.\n\n    Args:\n        guild_id: The ID of the guild\n\n    Returns:\n        The shard ID for the guild\n    \"\"\"\n    return (int(guild_id) &gt;&gt; 22) % self.total_shards\n</code></pre>"},{"location":"API%20Reference/AutoShardClient/#naff.client.auto_shard_client.AutoShardedClient.astart","title":"<code>astart(token)</code>  <code>async</code>","text":"<p>Asynchronous method to start the bot.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Your bot's token</p> required Source code in <code>naff\\client\\auto_shard_client.py</code> <pre><code>async def astart(self, token: str) -&gt; None:\n\"\"\"\n    Asynchronous method to start the bot.\n\n    Args:\n        token: Your bot's token\n    \"\"\"\n    self.logger.debug(\"Starting http client...\")\n    await self.login(token)\n\n    tasks = []\n\n    # Sort shards into their respective ratelimit buckets\n    shard_buckets = defaultdict(list)\n    for shard in self._connection_states:\n        bucket = str(shard.shard_id % self.max_start_concurrency)\n        shard_buckets[bucket].append(shard)\n\n    for bucket in shard_buckets.values():\n        for shard in bucket:\n            self.logger.debug(f\"Starting {shard.shard_id}\")\n            start = time.perf_counter()\n            tasks.append(asyncio.create_task(shard.start()))\n\n            if self.max_start_concurrency == 1:\n                # connection ratelimiting when discord has asked for one connection concurrently\n                # noinspection PyProtectedMember\n                await shard._shard_ready.wait()\n                await asyncio.sleep(5.1 - (time.perf_counter() - start))\n\n        # wait for shards to finish starting\n        # noinspection PyProtectedMember\n        await asyncio.gather(*[shard._shard_ready.wait() for shard in self._connection_states])\n\n    try:\n        await asyncio.gather(*tasks)\n    finally:\n        await self.stop()\n</code></pre>"},{"location":"API%20Reference/AutoShardClient/#naff.client.auto_shard_client.AutoShardedClient.login","title":"<code>login(token)</code>  <code>async</code>","text":"<p>Login to discord via http.</p> <p>Note</p> <p>You will need to run Naff.start_gateway() before you start receiving gateway events.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Your bot's token</p> required Source code in <code>naff\\client\\auto_shard_client.py</code> <pre><code>async def login(self, token) -&gt; None:\n\"\"\"\n    Login to discord via http.\n\n    !!! note\n        You will need to run Naff.start_gateway() before you start receiving gateway events.\n\n    Args:\n        token str: Your bot's token\n\n    \"\"\"\n    await super().login(token)\n    data = await self.http.get_gateway_bot()\n\n    self.max_start_concurrency = data[\"session_start_limit\"][\"max_concurrency\"]\n    if self.auto_sharding:\n        self.total_shards = data[\"shards\"]\n    elif data[\"shards\"] != self.total_shards:\n        recommended_shards = data[\"shards\"]\n        self.logger.info(\n            f\"Discord recommends you start with {recommended_shards} shard{'s' if recommended_shards != 1 else ''} instead of {self.total_shards}\"\n        )\n\n    self.logger.debug(f\"Starting bot with {self.total_shards} shard{'s' if self.total_shards != 1 else ''}\")\n    self._connection_states: list[ConnectionState] = [\n        ConnectionState(self, self.intents, shard_id) for shard_id in range(self.total_shards)\n    ]\n</code></pre>"},{"location":"API%20Reference/AutoShardClient/#naff.client.auto_shard_client.AutoShardedClient.change_presence","title":"<code>change_presence(status=Status.ONLINE, activity=None, *, shard_id=None)</code>  <code>async</code>","text":"<p>Change the bot's presence.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Optional[str | Status]</code> <p>The status for the bot to be. i.e. online, afk, etc.</p> <code>Status.ONLINE</code> <code>activity</code> <code>Optional[str | Activity]</code> <p>The activity for the bot to be displayed as doing.</p> <code>None</code> <code>shard_id</code> <code>int | None</code> <p>The shard to change the presence on. If not specified, the presence will be changed on all shards.</p> <code>None</code> <p>Note</p> <p>Bots may only be <code>playing</code> <code>streaming</code> <code>listening</code> <code>watching</code> or <code>competing</code>, other activity types are likely to fail.</p> Source code in <code>naff\\client\\auto_shard_client.py</code> <pre><code>async def change_presence(\n    self,\n    status: Optional[str | Status] = Status.ONLINE,\n    activity: Optional[str | Activity] = None,\n    *,\n    shard_id: int | None = None,\n) -&gt; None:\n\"\"\"\n    Change the bot's presence.\n\n    Args:\n        status: The status for the bot to be. i.e. online, afk, etc.\n        activity: The activity for the bot to be displayed as doing.\n        shard_id: The shard to change the presence on. If not specified, the presence will be changed on all shards.\n\n    !!! note\n        Bots may only be `playing` `streaming` `listening` `watching` or `competing`, other activity types are likely to fail.\n\n    \"\"\"\n    if shard_id is None:\n        await asyncio.gather(*[shard.change_presence(status, activity) for shard in self._connection_states])\n    else:\n        await self._connection_states[shard_id].change_presence(status, activity)\n</code></pre>"},{"location":"API%20Reference/Client/","title":"Client","text":"<p>         Bases: <code>processors.AutoModEvents</code>, <code>processors.ChannelEvents</code>, <code>processors.GuildEvents</code>, <code>processors.IntegrationEvents</code>, <code>processors.MemberEvents</code>, <code>processors.MessageEvents</code>, <code>processors.ReactionEvents</code>, <code>processors.RoleEvents</code>, <code>processors.StageEvents</code>, <code>processors.ThreadEvents</code>, <code>processors.UserEvents</code>, <code>processors.VoiceEvents</code></p> <p>The bot client.</p> <p>Parameters:</p> Name Type Description Default <code>intents</code> <code>Union[int, Intents]</code> <p>The intents to use</p> <code>Intents.DEFAULT</code> <code>default_prefix</code> <code>str | Iterable[str]</code> <p>The default prefix (or prefixes) to use for prefixed commands. Defaults to your bot being mentioned.</p> <code>MENTION_PREFIX</code> <code>generate_prefixes</code> <code>Absent[Callable[..., Coroutine]]</code> <p>A coroutine that returns a string or an iterable of strings to determine prefixes.</p> <code>MISSING</code> <code>status</code> <code>Status</code> <p>The status the bot should log in with (IE ONLINE, DND, IDLE)</p> <code>Status.ONLINE</code> <code>activity</code> <code>Union[Activity, str]</code> <p>The activity the bot should log in \"playing\"</p> <code>None</code> <code>sync_interactions</code> <code>bool</code> <p>Should application commands be synced with discord?</p> <code>True</code> <code>delete_unused_application_cmds</code> <code>bool</code> <p>Delete any commands from discord that aren't implemented in this client</p> <code>False</code> <code>enforce_interaction_perms</code> <code>bool</code> <p>Enforce discord application command permissions, locally</p> <code>True</code> <code>fetch_members</code> <code>bool</code> <p>Should the client fetch members from guilds upon startup (this will delay the client being ready)</p> <code>False</code> <code>send_command_tracebacks</code> <code>bool</code> <p>Automatically send uncaught tracebacks if a command throws an exception</p> <code>True</code> <code>auto_defer</code> <code>Absent[Union[AutoDefer, bool]]</code> <code>MISSING</code> <code>interaction_context</code> <code>Type[InteractionContext]</code> <p>Type[InteractionContext]: InteractionContext: The object to instantiate for Interaction Context</p> <code>InteractionContext</code> <code>prefixed_context</code> <code>Type[PrefixedContext]</code> <p>Type[PrefixedContext]: The object to instantiate for Prefixed Context</p> <code>PrefixedContext</code> <code>component_context</code> <code>Type[ComponentContext]</code> <p>Type[ComponentContext]: The object to instantiate for Component Context</p> <code>ComponentContext</code> <code>autocomplete_context</code> <code>Type[AutocompleteContext]</code> <p>Type[AutocompleteContext]: The object to instantiate for Autocomplete Context</p> <code>AutocompleteContext</code> <code>modal_context</code> <code>Type[ModalContext]</code> <p>Type[ModalContext]: The object to instantiate for Modal Context</p> <code>ModalContext</code> <code>hybrid_context</code> <code>Type[HybridContext]</code> <p>Type[HybridContext]: The object to instantiate for Hybrid Context</p> <code>HybridContext</code> <code>total_shards</code> <code>int</code> <p>The total number of shards in use</p> <code>1</code> <code>shard_id</code> <code>int</code> <p>The zero based int ID of this shard</p> <code>0</code> <code>debug_scope</code> <code>Absent[Snowflake_Type]</code> <p>Force all application commands to be registered within this scope</p> <code>MISSING</code> <code>disable_dm_commands</code> <code>bool</code> <p>Should interaction commands be disabled in DMs?</p> <code>False</code> <code>basic_logging</code> <code>bool</code> <p>Utilise basic logging to output library data to console. Do not use in combination with <code>Client.logger</code></p> <code>False</code> <code>logging_level</code> <code>int</code> <p>The level of logging to use for basic_logging. Do not use in combination with <code>Client.logger</code></p> <code>logging.INFO</code> <code>logger</code> <code>logging.Logger</code> <p>The logger NAFF should use. Do not use in combination with <code>Client.basic_logging</code> and <code>Client.logging_level</code>. Note: Different loggers with multiple clients are not supported</p> <code>MISSING</code> <p>Optionally, you can configure the caches here, by specifying the name of the cache, followed by a dict-style object to use. It is recommended to use <code>smart_cache.create_cache</code> to configure the cache here. as an example, this is a recommended attribute <code>message_cache=create_cache(250, 50)</code>,</p> Intents Note <p>By default, all non-privileged intents will be enabled</p> Caching Note <p>Setting a message cache hard limit to None is not recommended, as it could result in extremely high memory usage, we suggest a sane limit.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>class Client(\n    processors.AutoModEvents,\n    processors.ChannelEvents,\n    processors.GuildEvents,\n    processors.IntegrationEvents,\n    processors.MemberEvents,\n    processors.MessageEvents,\n    processors.ReactionEvents,\n    processors.RoleEvents,\n    processors.StageEvents,\n    processors.ThreadEvents,\n    processors.UserEvents,\n    processors.VoiceEvents,\n):\n\"\"\"\n\n    The bot client.\n\n    Args:\n        intents: The intents to use\n\n        default_prefix: The default prefix (or prefixes) to use for prefixed commands. Defaults to your bot being mentioned.\n        generate_prefixes: A coroutine that returns a string or an iterable of strings to determine prefixes.\n        status: The status the bot should log in with (IE ONLINE, DND, IDLE)\n        activity: The activity the bot should log in \"playing\"\n\n        sync_interactions: Should application commands be synced with discord?\n        delete_unused_application_cmds: Delete any commands from discord that aren't implemented in this client\n        enforce_interaction_perms: Enforce discord application command permissions, locally\n        fetch_members: Should the client fetch members from guilds upon startup (this will delay the client being ready)\n        send_command_tracebacks: Automatically send uncaught tracebacks if a command throws an exception\n\n        auto_defer: AutoDefer: A system to automatically defer commands after a set duration\n        interaction_context: Type[InteractionContext]: InteractionContext: The object to instantiate for Interaction Context\n        prefixed_context: Type[PrefixedContext]: The object to instantiate for Prefixed Context\n        component_context: Type[ComponentContext]: The object to instantiate for Component Context\n        autocomplete_context: Type[AutocompleteContext]: The object to instantiate for Autocomplete Context\n        modal_context: Type[ModalContext]: The object to instantiate for Modal Context\n        hybrid_context: Type[HybridContext]: The object to instantiate for Hybrid Context\n\n        total_shards: The total number of shards in use\n        shard_id: The zero based int ID of this shard\n\n        debug_scope: Force all application commands to be registered within this scope\n        disable_dm_commands: Should interaction commands be disabled in DMs?\n        basic_logging: Utilise basic logging to output library data to console. Do not use in combination with `Client.logger`\n        logging_level: The level of logging to use for basic_logging. Do not use in combination with `Client.logger`\n        logger: The logger NAFF should use. Do not use in combination with `Client.basic_logging` and `Client.logging_level`. Note: Different loggers with multiple clients are not supported\n\n    Optionally, you can configure the caches here, by specifying the name of the cache, followed by a dict-style object to use.\n    It is recommended to use `smart_cache.create_cache` to configure the cache here.\n    as an example, this is a recommended attribute `message_cache=create_cache(250, 50)`,\n\n    ???+ note \"Intents Note\"\n        By default, all non-privileged intents will be enabled\n\n    ???+ note \"Caching Note\"\n        Setting a message cache hard limit to None is not recommended, as it could result in extremely high memory usage, we suggest a sane limit.\n\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        activity: Union[Activity, str] = None,\n        auto_defer: Absent[Union[AutoDefer, bool]] = MISSING,\n        autocomplete_context: Type[AutocompleteContext] = AutocompleteContext,\n        component_context: Type[ComponentContext] = ComponentContext,\n        debug_scope: Absent[\"Snowflake_Type\"] = MISSING,\n        default_prefix: str | Iterable[str] = MENTION_PREFIX,\n        delete_unused_application_cmds: bool = False,\n        disable_dm_commands: bool = False,\n        enforce_interaction_perms: bool = True,\n        fetch_members: bool = False,\n        generate_prefixes: Absent[Callable[..., Coroutine]] = MISSING,\n        global_post_run_callback: Absent[Callable[..., Coroutine]] = MISSING,\n        global_pre_run_callback: Absent[Callable[..., Coroutine]] = MISSING,\n        intents: Union[int, Intents] = Intents.DEFAULT,\n        interaction_context: Type[InteractionContext] = InteractionContext,\n        logger: logging.Logger = MISSING,\n        owner_ids: Iterable[\"Snowflake_Type\"] = (),\n        modal_context: Type[ModalContext] = ModalContext,\n        prefixed_context: Type[PrefixedContext] = PrefixedContext,\n        hybrid_context: Type[HybridContext] = HybridContext,\n        send_command_tracebacks: bool = True,\n        shard_id: int = 0,\n        status: Status = Status.ONLINE,\n        sync_interactions: bool = True,\n        sync_ext: bool = True,\n        total_shards: int = 1,\n        basic_logging: bool = False,\n        logging_level: int = logging.INFO,\n        **kwargs,\n    ) -&gt; None:\n        if logger is MISSING:\n            logger = constants.get_logger()\n\n        if basic_logging:\n            logging.basicConfig()\n            logger.setLevel(logging_level)\n\n        # Set Up logger and overwrite the constant\n        self.logger = logger\n\"\"\"The logger NAFF should use. Do not use in combination with `Client.basic_logging` and `Client.logging_level`.\n        !!! note\n            Different loggers with multiple clients are not supported\"\"\"\n        constants._logger = logger\n\n        # Configuration\n        self.sync_interactions: bool = sync_interactions\n\"\"\"Should application commands be synced\"\"\"\n        self.del_unused_app_cmd: bool = delete_unused_application_cmds\n\"\"\"Should unused application commands be deleted?\"\"\"\n        self.sync_ext: bool = sync_ext\n\"\"\"Should we sync whenever a extension is (un)loaded\"\"\"\n        self.debug_scope = to_snowflake(debug_scope) if debug_scope is not MISSING else MISSING\n\"\"\"Sync global commands as guild for quicker command updates during debug\"\"\"\n        self.default_prefix = default_prefix\n\"\"\"The default prefix to be used for prefixed commands\"\"\"\n        self.generate_prefixes = generate_prefixes if generate_prefixes is not MISSING else self.generate_prefixes\n\"\"\"A coroutine that returns a prefix or an iterable of prefixes, for dynamic prefixes\"\"\"\n        self.send_command_tracebacks: bool = send_command_tracebacks\n\"\"\"Should the traceback of command errors be sent in reply to the command invocation\"\"\"\n        if auto_defer is True:\n            auto_defer = AutoDefer(enabled=True)\n        else:\n            auto_defer = auto_defer or AutoDefer()\n        self.auto_defer = auto_defer\n\"\"\"A system to automatically defer commands after a set duration\"\"\"\n        self.intents = intents if isinstance(intents, Intents) else Intents(intents)\n\n        # resources\n\n        self.http: HTTPClient = HTTPClient(logger=self.logger)\n\"\"\"The HTTP client to use when interacting with discord endpoints\"\"\"\n\n        # context objects\n        self.interaction_context: Type[InteractionContext] = interaction_context\n\"\"\"The object to instantiate for Interaction Context\"\"\"\n        self.prefixed_context: Type[PrefixedContext] = prefixed_context\n\"\"\"The object to instantiate for Prefixed Context\"\"\"\n        self.component_context: Type[ComponentContext] = component_context\n\"\"\"The object to instantiate for Component Context\"\"\"\n        self.autocomplete_context: Type[AutocompleteContext] = autocomplete_context\n\"\"\"The object to instantiate for Autocomplete Context\"\"\"\n        self.modal_context: Type[ModalContext] = modal_context\n\"\"\"The object to instantiate for Modal Context\"\"\"\n        self.hybrid_context: Type[HybridContext] = hybrid_context\n\"\"\"The object to instantiate for Hybrid Context\"\"\"\n\n        # flags\n        self._ready = asyncio.Event()\n        self._closed = False\n        self._startup = False\n        self.disable_dm_commands = disable_dm_commands\n\n        self._guild_event = asyncio.Event()\n        self.guild_event_timeout = 3\n\"\"\"How long to wait for guilds to be cached\"\"\"\n\n        # Sharding\n        self.total_shards = total_shards\n        self._connection_state: ConnectionState = ConnectionState(self, intents, shard_id)\n\n        self.enforce_interaction_perms = enforce_interaction_perms\n\n        self.fetch_members = fetch_members\n\"\"\"Fetch the full members list of all guilds on startup\"\"\"\n\n        self._mention_reg = MISSING\n\n        # caches\n        self.cache: GlobalCache = GlobalCache(self, **{k: v for k, v in kwargs.items() if hasattr(GlobalCache, k)})\n        # these store the last sent presence data for change_presence\n        self._status: Status = status\n        if isinstance(activity, str):\n            self._activity = Activity.create(name=str(activity))\n        else:\n            self._activity: Activity = activity\n\n        self._user: Absent[NaffUser] = MISSING\n        self._app: Absent[Application] = MISSING\n\n        # collections\n        self.prefixed_commands: Dict[str, PrefixedCommand] = {}\n\"\"\"A dictionary of registered prefixed commands: `{name: command}`\"\"\"\n        self.interactions: Dict[\"Snowflake_Type\", Dict[str, InteractionCommand]] = {}\n\"\"\"A dictionary of registered application commands: `{cmd_id: command}`\"\"\"\n        self.interaction_tree: Dict[\n            \"Snowflake_Type\", Dict[str, InteractionCommand | Dict[str, InteractionCommand]]\n        ] = {}\n\"\"\"A dictionary of registered application commands in a tree\"\"\"\n        self._component_callbacks: Dict[str, Callable[..., Coroutine]] = {}\n        self._modal_callbacks: Dict[str, Callable[..., Coroutine]] = {}\n        self._interaction_scopes: Dict[\"Snowflake_Type\", \"Snowflake_Type\"] = {}\n        self.processors: Dict[str, Callable[..., Coroutine]] = {}\n        self.__modules = {}\n        self.ext = {}\n\"\"\"A dictionary of mounted ext\"\"\"\n        self.listeners: Dict[str, list[Listener]] = {}\n        self.waits: Dict[str, List] = {}\n        self.owner_ids: set[Snowflake_Type] = set(owner_ids)\n\n        self.async_startup_tasks: list[Coroutine] = []\n\"\"\"A list of coroutines to run during startup\"\"\"\n\n        # callbacks\n        if global_pre_run_callback:\n            if asyncio.iscoroutinefunction(global_pre_run_callback):\n                self.pre_run_callback: Callable[..., Coroutine] = global_pre_run_callback\n            else:\n                raise TypeError(\"Callback must be a coroutine\")\n        else:\n            self.pre_run_callback = MISSING\n\n        if global_post_run_callback:\n            if asyncio.iscoroutinefunction(global_post_run_callback):\n                self.post_run_callback: Callable[..., Coroutine] = global_post_run_callback\n            else:\n                raise TypeError(\"Callback must be a coroutine\")\n        else:\n            self.post_run_callback = MISSING\n\n        super().__init__()\n        self._sanity_check()\n\n    @property\n    def is_closed(self) -&gt; bool:\n\"\"\"Returns True if the bot has closed.\"\"\"\n        return self._closed\n\n    @property\n    def is_ready(self) -&gt; bool:\n\"\"\"Returns True if the bot is ready.\"\"\"\n        return self._ready.is_set()\n\n    @property\n    def latency(self) -&gt; float:\n\"\"\"Returns the latency of the websocket connection.\"\"\"\n        return self._connection_state.latency\n\n    @property\n    def average_latency(self) -&gt; float:\n\"\"\"Returns the average latency of the websocket connection.\"\"\"\n        return self._connection_state.average_latency\n\n    @property\n    def start_time(self) -&gt; datetime:\n\"\"\"The start time of the bot.\"\"\"\n        return self._connection_state.start_time\n\n    @property\n    def gateway_started(self) -&gt; bool:\n\"\"\"Returns if the gateway has been started.\"\"\"\n        return self._connection_state.gateway_started.is_set()\n\n    @property\n    def user(self) -&gt; NaffUser:\n\"\"\"Returns the bot's user.\"\"\"\n        return self._user\n\n    @property\n    def app(self) -&gt; Application:\n\"\"\"Returns the bots application.\"\"\"\n        return self._app\n\n    @property\n    def owner(self) -&gt; Optional[\"User\"]:\n\"\"\"Returns the bot's owner'.\"\"\"\n        try:\n            return self.app.owner\n        except TypeError:\n            return MISSING\n\n    @property\n    def owners(self) -&gt; List[\"User\"]:\n\"\"\"Returns the bot's owners as declared via `client.owner_ids`.\"\"\"\n        return [self.get_user(u_id) for u_id in self.owner_ids]\n\n    @property\n    def guilds(self) -&gt; List[\"Guild\"]:\n\"\"\"Returns a list of all guilds the bot is in.\"\"\"\n        return self.user.guilds\n\n    @property\n    def status(self) -&gt; Status:\n\"\"\"\n        Get the status of the bot.\n\n        IE online, afk, dnd\n\n        \"\"\"\n        return self._status\n\n    @property\n    def activity(self) -&gt; Activity:\n\"\"\"Get the activity of the bot.\"\"\"\n        return self._activity\n\n    @property\n    def application_commands(self) -&gt; List[InteractionCommand]:\n\"\"\"A list of all application commands registered within the bot.\"\"\"\n        commands = []\n        for scope in self.interactions.keys():\n            commands += [cmd for cmd in self.interactions[scope].values() if cmd not in commands]\n\n        return commands\n\n    @property\n    def ws(self) -&gt; GatewayClient:\n\"\"\"Returns the websocket client.\"\"\"\n        return self._connection_state.gateway\n\n    def get_guild_websocket(self, id: \"Snowflake_Type\") -&gt; GatewayClient:\n        return self.ws\n\n    def _sanity_check(self) -&gt; None:\n\"\"\"Checks for possible and common errors in the bot's configuration.\"\"\"\n        self.logger.debug(\"Running client sanity checks...\")\n        contexts = {\n            self.interaction_context: InteractionContext,\n            self.prefixed_context: PrefixedContext,\n            self.component_context: ComponentContext,\n            self.autocomplete_context: AutocompleteContext,\n            self.modal_context: ModalContext,\n            self.hybrid_context: HybridContext,\n        }\n        for obj, expected in contexts.items():\n            if not issubclass(obj, expected):\n                raise TypeError(f\"{obj.__name__} must inherit from {expected.__name__}\")\n\n        if self.del_unused_app_cmd:\n            self.logger.warning(\n                \"As `delete_unused_application_cmds` is enabled, the client must cache all guilds app-commands, this could take a while.\"\n            )\n\n        if Intents.GUILDS not in self._connection_state.intents:\n            self.logger.warning(\"GUILD intent has not been enabled; this is very likely to cause errors\")\n\n        if self.fetch_members and Intents.GUILD_MEMBERS not in self._connection_state.intents:\n            raise BotException(\"Members Intent must be enabled in order to use fetch members\")\n        elif self.fetch_members:\n            self.logger.warning(\"fetch_members enabled; startup will be delayed\")\n\n        if len(self.processors) == 0:\n            self.logger.warning(\"No Processors are loaded! This means no events will be processed!\")\n\n        caches = [\n            c[0]\n            for c in inspect.getmembers(self.cache, predicate=lambda x: isinstance(x, dict))\n            if not c[0].startswith(\"__\")\n        ]\n        for cache in caches:\n            _cache_obj = getattr(self.cache, cache)\n            if isinstance(_cache_obj, NullCache):\n                self.logger.warning(f\"{cache} has been disabled\")\n\n    async def generate_prefixes(self, bot: \"Client\", message: Message) -&gt; str | Iterable[str]:\n\"\"\"\n        A method to get the bot's default_prefix, can be overridden to add dynamic prefixes.\n\n        !!! note\n            To easily override this method, simply use the `generate_prefixes` parameter when instantiating the client\n\n        Args:\n            bot: A reference to the client\n            message: A message to determine the prefix from.\n\n        Example:\n            ```python\n            async def generate_prefixes(bot, message):\n                if message.guild.id == 870046872864165888:\n                    return [\"!\"]\n                return bot.default_prefix\n\n            bot = Client(generate_prefixes=generate_prefixes, ...)\n            ```\n\n        Returns:\n            A string or an iterable of strings to use as a prefix. By default, this will return `client.default_prefix`\n\n        \"\"\"\n        return self.default_prefix\n\n    def _queue_task(self, coro: Listener, event: BaseEvent, *args, **kwargs) -&gt; asyncio.Task:\n        async def _async_wrap(_coro: Listener, _event: BaseEvent, *_args, **_kwargs) -&gt; None:\n            try:\n                if not isinstance(_event, (events.Error, events.RawGatewayEvent)):\n                    if coro.delay_until_ready and not self.is_ready:\n                        await self.wait_until_ready()\n\n                if len(_event.__attrs_attrs__) == 2:\n                    # override_name &amp; bot\n                    await _coro()\n                else:\n                    await _coro(_event, *_args, **_kwargs)\n            except asyncio.CancelledError:\n                pass\n            except Exception as e:\n                if isinstance(event, events.Error):\n                    # No infinite loops please\n                    self.default_error_handler(repr(event), e)\n                else:\n                    self.dispatch(events.Error(source=repr(event), error=e))\n\n        wrapped = _async_wrap(coro, event, *args, **kwargs)\n\n        return asyncio.create_task(wrapped, name=f\"naff:: {event.resolved_name}\")\n\n    @staticmethod\n    def default_error_handler(source: str, error: BaseException) -&gt; None:\n\"\"\"\n        The default error logging behaviour.\n\n        Args:\n            source: The source of this error\n            error: The exception itself\n\n        \"\"\"\n        out = traceback.format_exception(error)\n\n        if isinstance(error, HTTPException):\n            # HTTPException's are of 3 known formats, we can parse them for human readable errors\n            try:\n                out = [str(error)]\n            except Exception:  # noqa : S110\n                pass\n\n        get_logger().error(\n            \"Ignoring exception in {}:{}{}\".format(source, \"\\n\" if len(out) &gt; 1 else \" \", \"\".join(out)),\n        )\n\n    @Listener.create(is_default_listener=True)\n    async def on_error(self, event: events.Error) -&gt; None:\n\"\"\"\n        Catches all errors dispatched by the library.\n\n        By default it will format and print them to console.\n\n        Listen to the `Error` event to overwrite this behaviour.\n\n        \"\"\"\n        self.default_error_handler(event.source, event.error)\n\n    @Listener.create(is_default_listener=True)\n    async def on_command_error(self, event: events.CommandError) -&gt; None:\n\"\"\"\n        Catches all errors dispatched by commands.\n\n        By default it will dispatch the `Error` event.\n\n        Listen to the `CommandError` event to overwrite this behaviour.\n\n        \"\"\"\n        self.dispatch(\n            events.Error(\n                source=f\"cmd `/{event.ctx.invoke_target}`\",\n                error=event.error,\n                args=event.args,\n                kwargs=event.kwargs,\n                ctx=event.ctx,\n            )\n        )\n        try:\n            if isinstance(event.error, errors.CommandOnCooldown):\n                await event.ctx.send(\n                    embeds=Embed(\n                        description=f\"This command is on cooldown!\\n\"\n                        f\"Please try again in {int(event.error.cooldown.get_cooldown_time())} seconds\",\n                        color=BrandColors.FUCHSIA,\n                    )\n                )\n            elif isinstance(event.error, errors.MaxConcurrencyReached):\n                await event.ctx.send(\n                    embeds=Embed(\n                        description=\"This command has reached its maximum concurrent usage!\\n\"\n                        \"Please try again shortly.\",\n                        color=BrandColors.FUCHSIA,\n                    )\n                )\n            elif isinstance(event.error, errors.CommandCheckFailure):\n                await event.ctx.send(\n                    embeds=Embed(\n                        description=\"You do not have permission to run this command!\",\n                        color=BrandColors.YELLOW,\n                    )\n                )\n            elif self.send_command_tracebacks:\n                out = \"\".join(traceback.format_exception(event.error))\n                if self.http.token is not None:\n                    out = out.replace(self.http.token, \"[REDACTED TOKEN]\")\n                await event.ctx.send(\n                    embeds=Embed(\n                        title=f\"Error: {type(event.error).__name__}\",\n                        color=BrandColors.RED,\n                        description=f\"```\\n{out[:EMBED_MAX_DESC_LENGTH-8]}```\",\n                    )\n                )\n        except errors.NaffException:\n            pass\n\n    @Listener.create(is_default_listener=True)\n    async def on_command_completion(self, event: events.CommandCompletion) -&gt; None:\n\"\"\"\n        Called *after* any command is ran.\n\n        By default, it will simply log the command.\n\n        Listen to the `CommandCompletion` event to overwrite this behaviour.\n\n        \"\"\"\n        if isinstance(event.ctx, PrefixedContext):\n            symbol = \"@\"\n        elif isinstance(event.ctx, InteractionContext):\n            symbol = \"/\"\n        elif isinstance(event.ctx, HybridContext):\n            symbol = \"@/\"\n        else:\n            symbol = \"?\"  # likely custom context\n        self.logger.info(\n            f\"Command Called: {symbol}{event.ctx.invoke_target} with {event.ctx.args = } | {event.ctx.kwargs = }\"\n        )\n\n    @Listener.create(is_default_listener=True)\n    async def on_component_error(self, event: events.ComponentError) -&gt; None:\n\"\"\"\n        Catches all errors dispatched by components.\n\n        By default it will dispatch the `Error` event.\n\n        Listen to the `ComponentError` event to overwrite this behaviour.\n\n        \"\"\"\n        self.dispatch(\n            events.Error(\n                source=f\"Component Callback for {event.ctx.custom_id}\",\n                error=event.error,\n                args=event.args,\n                kwargs=event.kwargs,\n                ctx=event.ctx,\n            )\n        )\n\n    @Listener.create(is_default_listener=True)\n    async def on_component_completion(self, event: events.ComponentCompletion) -&gt; None:\n\"\"\"\n        Called *after* any component callback is ran.\n\n        By default, it will simply log the component use.\n\n        Listen to the `ComponentCompletion` event to overwrite this behaviour.\n\n        \"\"\"\n        symbol = \"\u00a2\"\n        self.logger.info(\n            f\"Component Called: {symbol}{event.ctx.invoke_target} with {event.ctx.args = } | {event.ctx.kwargs = }\"\n        )\n\n    @Listener.create(is_default_listener=True)\n    async def on_autocomplete_error(self, event: events.AutocompleteError) -&gt; None:\n\"\"\"\n        Catches all errors dispatched by autocompletion options.\n\n        By default it will dispatch the `Error` event.\n\n        Listen to the `AutocompleteError` event to overwrite this behaviour.\n\n        \"\"\"\n        self.dispatch(\n            events.Error(\n                source=f\"Autocomplete Callback for /{event.ctx.invoke_target} - Option: {event.ctx.focussed_option}\",\n                error=event.error,\n                args=event.args,\n                kwargs=event.kwargs,\n                ctx=event.ctx,\n            )\n        )\n\n    @Listener.create(is_default_listener=True)\n    async def on_autocomplete_completion(self, event: events.AutocompleteCompletion) -&gt; None:\n\"\"\"\n        Called *after* any autocomplete callback is ran.\n\n        By default, it will simply log the autocomplete callback.\n\n        Listen to the `AutocompleteCompletion` event to overwrite this behaviour.\n\n        \"\"\"\n        symbol = \"$\"\n        self.logger.info(\n            f\"Autocomplete Called: {symbol}{event.ctx.invoke_target} with {event.ctx.focussed_option = } | {event.ctx.kwargs = }\"\n        )\n\n    @Listener.create(is_default_listener=True)\n    async def on_modal_error(self, event: events.ModalError) -&gt; None:\n\"\"\"\n        Catches all errors dispatched by modals.\n\n        By default it will dispatch the `Error` event.\n\n        Listen to the `ModalError` event to overwrite this behaviour.\n\n        \"\"\"\n        self.dispatch(\n            events.Error(\n                source=f\"Modal Callback for custom_id {event.ctx.custom_id}\",\n                error=event.error,\n                args=event.args,\n                kwargs=event.kwargs,\n                ctx=event.ctx,\n            )\n        )\n\n    @Listener.create(is_default_listener=True)\n    async def on_modal_completion(self, event: events.ModalCompletion) -&gt; None:\n\"\"\"\n        Called *after* any modal callback is ran.\n\n        By default, it will simply log the modal callback.\n\n        Listen to the `ModalCompletion` event to overwrite this behaviour.\n\n        \"\"\"\n        self.logger.info(f\"Modal Called: {event.ctx.custom_id = } with {event.ctx.responses = }\")\n\n    @Listener.create()\n    async def on_resume(self) -&gt; None:\n        self._ready.set()\n\n    @Listener.create(is_default_listener=True)\n    async def _on_websocket_ready(self, event: events.RawGatewayEvent) -&gt; None:\n\"\"\"\n        Catches websocket ready and determines when to dispatch the client `READY` signal.\n\n        Args:\n            event: The websocket ready packet\n\n        \"\"\"\n        data = event.data\n        expected_guilds = {to_snowflake(guild[\"id\"]) for guild in data[\"guilds\"]}\n        self._user._add_guilds(expected_guilds)\n\n        if not self._startup:\n            while True:\n                try:  # wait to let guilds cache\n                    await asyncio.wait_for(self._guild_event.wait(), self.guild_event_timeout)\n                except asyncio.TimeoutError:\n                    # this will *mostly* occur when a guild has been shadow deleted by discord T&amp;S.\n                    # there is no way to check for this, so we just need to wait for this to time out.\n                    # We still log it though, just in case.\n                    self.logger.debug(\"Timeout waiting for guilds cache\")\n                    break\n                self._guild_event.clear()\n\n                if len(self.cache.guild_cache) == len(expected_guilds):\n                    # all guilds cached\n                    break\n\n            if self.fetch_members:\n                # ensure all guilds have completed chunking\n                for guild in self.guilds:\n                    if guild and not guild.chunked.is_set():\n                        self.logger.debug(f\"Waiting for {guild.id} to chunk\")\n                        await guild.chunked.wait()\n\n            # cache slash commands\n            if not self._startup:\n                await self._init_interactions()\n\n            self._startup = True\n            self.dispatch(events.Startup())\n\n        else:\n            # reconnect ready\n            ready_guilds = set()\n\n            async def _temp_listener(_event: events.RawGatewayEvent) -&gt; None:\n                ready_guilds.add(_event.data[\"id\"])\n\n            listener = Listener.create(\"_on_raw_guild_create\")(_temp_listener)\n            self.add_listener(listener)\n\n            while True:\n                try:\n                    await asyncio.wait_for(self._guild_event.wait(), self.guild_event_timeout)\n                    if len(ready_guilds) == len(expected_guilds):\n                        break\n                except asyncio.TimeoutError:\n                    break\n\n            self.listeners[\"raw_guild_create\"].remove(listener)\n\n        self._ready.set()\n        self.dispatch(events.Ready())\n\n    async def login(self, token) -&gt; None:\n\"\"\"\n        Login to discord via http.\n\n        !!! note\n            You will need to run Naff.start_gateway() before you start receiving gateway events.\n\n        Args:\n            token str: Your bot's token\n\n        \"\"\"\n        # i needed somewhere to put this call,\n        # login will always run after initialisation\n        # so im gathering commands here\n        self._gather_commands()\n\n        self.logger.debug(\"Attempting to login\")\n        me = await self.http.login(token.strip())\n        self._user = NaffUser.from_dict(me, self)\n        self.cache.place_user_data(me)\n        self._app = Application.from_dict(await self.http.get_current_bot_information(), self)\n        self._mention_reg = re.compile(rf\"^(&lt;@!?{self.user.id}*&gt;\\s)\")\n\n        if self.app.owner:\n            self.owner_ids.add(self.app.owner.id)\n\n        self.dispatch(events.Login())\n\n    async def astart(self, token: str) -&gt; None:\n\"\"\"\n        Asynchronous method to start the bot.\n\n        Args:\n            token: Your bot's token\n        \"\"\"\n        await self.login(token)\n\n        # run any pending startup tasks\n        if self.async_startup_tasks:\n            try:\n                await asyncio.gather(*self.async_startup_tasks)\n            except Exception as e:\n                self.dispatch(events.Error(source=\"async-extension-loader\", error=e))\n        try:\n            await self._connection_state.start()\n        finally:\n            await self.stop()\n\n    def start(self, token: str) -&gt; None:\n\"\"\"\n        Start the bot.\n\n        info:\n            This is the recommended method to start the bot\n        \"\"\"\n        try:\n            asyncio.run(self.astart(token))\n        except KeyboardInterrupt:\n            # ignore, cus this is useless and can be misleading to the\n            # user\n            pass\n\n    async def start_gateway(self) -&gt; None:\n\"\"\"Starts the gateway connection.\"\"\"\n        try:\n            await self._connection_state.start()\n        finally:\n            await self.stop()\n\n    async def stop(self) -&gt; None:\n\"\"\"Shutdown the bot.\"\"\"\n        self.logger.debug(\"Stopping the bot.\")\n        self._ready.clear()\n        await self.http.close()\n        await self._connection_state.stop()\n\n    def dispatch(self, event: events.BaseEvent, *args, **kwargs) -&gt; None:\n\"\"\"\n        Dispatch an event.\n\n        Args:\n            event: The event to be dispatched.\n\n        \"\"\"\n        listeners = self.listeners.get(event.resolved_name, [])\n        if listeners:\n            self.logger.debug(f\"Dispatching Event: {event.resolved_name}\")\n            event.bot = self\n            for _listen in listeners:\n                try:\n                    self._queue_task(_listen, event, *args, **kwargs)\n                except Exception as e:\n                    raise BotException(\n                        f\"An error occurred attempting during {event.resolved_name} event processing\"\n                    ) from e\n\n        _waits = self.waits.get(event.resolved_name, [])\n        if _waits:\n            index_to_remove = []\n            for i, _wait in enumerate(_waits):\n                result = _wait(event)\n                if result:\n                    index_to_remove.append(i)\n\n            for idx in sorted(index_to_remove, reverse=True):\n                _waits.pop(idx)\n\n    async def wait_until_ready(self) -&gt; None:\n\"\"\"Waits for the client to become ready.\"\"\"\n        await self._ready.wait()\n\n    def wait_for(\n        self,\n        event: Union[str, \"BaseEvent\"],\n        checks: Absent[Optional[Callable[..., bool]]] = MISSING,\n        timeout: Optional[float] = None,\n    ) -&gt; Any:\n\"\"\"\n        Waits for a WebSocket event to be dispatched.\n\n        Args:\n            event: The name of event to wait.\n            checks: A predicate to check what to wait for.\n            timeout: The number of seconds to wait before timing out.\n\n        Returns:\n            The event object.\n\n        \"\"\"\n        event = get_event_name(event)\n\n        if event not in self.waits:\n            self.waits[event] = []\n\n        future = asyncio.Future()\n        self.waits[event].append(Wait(event, checks, future))\n\n        return asyncio.wait_for(future, timeout)\n\n    async def wait_for_modal(\n        self,\n        modal: \"Modal\",\n        author: Optional[\"Snowflake_Type\"] = None,\n        timeout: Optional[float] = None,\n    ) -&gt; ModalContext:\n\"\"\"\n        Wait for a modal response.\n\n        Args:\n            modal: The modal we're waiting for.\n            author: The user we're waiting for to reply\n            timeout: A timeout in seconds to stop waiting\n\n        Returns:\n            The context of the modal response\n\n        Raises:\n            asyncio.TimeoutError: if no response is received that satisfies the predicate before timeout seconds have passed\n\n        \"\"\"\n        author = to_snowflake(author) if author else None\n\n        def predicate(event) -&gt; bool:\n            if modal.custom_id != event.ctx.custom_id:\n                return False\n            if author and author != to_snowflake(event.ctx.author):\n                return False\n            return True\n\n        resp = await self.wait_for(\"modal_completion\", predicate, timeout)\n        return resp.ctx\n\n    async def wait_for_component(\n        self,\n        messages: Union[Message, int, list] = None,\n        components: Optional[\n            Union[List[List[Union[\"BaseComponent\", dict]]], List[Union[\"BaseComponent\", dict]], \"BaseComponent\", dict]\n        ] = None,\n        check: Optional[Callable] = None,\n        timeout: Optional[float] = None,\n    ) -&gt; \"Component\":\n\"\"\"\n        Waits for a component to be sent to the bot.\n\n        Args:\n            messages: The message object to check for.\n            components: The components to wait for.\n            check: A predicate to check what to wait for.\n            timeout: The number of seconds to wait before timing out.\n\n        Returns:\n            `Component` that was invoked. Use `.ctx` to get the `ComponentContext`.\n\n        Raises:\n            asyncio.TimeoutError: if timed out\n\n        \"\"\"\n        if not (messages or components):\n            raise ValueError(\"You must specify messages or components (or both)\")\n\n        message_ids = (\n            to_snowflake_list(messages) if isinstance(messages, list) else to_snowflake(messages) if messages else None\n        )\n        custom_ids = list(get_components_ids(components)) if components else None\n\n        # automatically convert improper custom_ids\n        if custom_ids and not all(isinstance(x, str) for x in custom_ids):\n            custom_ids = [str(i) for i in custom_ids]\n\n        def _check(event: Component) -&gt; bool:\n            ctx: ComponentContext = event.ctx\n            # if custom_ids is empty or there is a match\n            wanted_message = not message_ids or ctx.message.id in (\n                [message_ids] if isinstance(message_ids, int) else message_ids\n            )\n            wanted_component = not custom_ids or ctx.custom_id in custom_ids\n            if wanted_message and wanted_component:\n                if check is None or check(event):\n                    return True\n                return False\n            return False\n\n        return await self.wait_for(\"component\", checks=_check, timeout=timeout)\n\n    def listen(self, event_name: Absent[str] = MISSING) -&gt; Listener:\n\"\"\"\n        A decorator to be used in situations that Naff can't automatically hook your listeners. Ideally, the standard listen decorator should be used, not this.\n\n        Args:\n            event_name: The event name to use, if not the coroutine name\n\n        Returns:\n            A listener that can be used to hook into the event.\n\n        \"\"\"\n\n        def wrapper(coro: Callable[..., Coroutine]) -&gt; Listener:\n            listener = Listener.create(event_name)(coro)\n            self.add_listener(listener)\n            return listener\n\n        return wrapper\n\n    def add_event_processor(self, event_name: Absent[str] = MISSING) -&gt; Callable[..., Coroutine]:\n\"\"\"\n        A decorator to be used to add event processors.\n\n        Args:\n            event_name: The event name to use, if not the coroutine name\n\n        Returns:\n            A function that can be used to hook into the event.\n\n        \"\"\"\n\n        def wrapper(coro: Callable[..., Coroutine]) -&gt; Callable[..., Coroutine]:\n            name = event_name\n            if name is MISSING:\n                name = coro.__name__\n            name = name.lstrip(\"_\")\n            name = name.removeprefix(\"on_\")\n            self.processors[name] = coro\n            return coro\n\n        return wrapper\n\n    def add_listener(self, listener: Listener) -&gt; None:\n\"\"\"\n        Add a listener for an event, if no event is passed, one is determined.\n\n        Args:\n            listener Listener: The listener to add to the client\n\n        \"\"\"\n        if not listener.is_default_listener:\n            # check that the required intents are enabled\n\n            event_class_name = \"\".join([name.capitalize() for name in listener.event.split(\"_\")])\n            if event_class := globals().get(event_class_name):\n                if required_intents := _INTENT_EVENTS.get(event_class):  # noqa\n                    if not any(required_intent in self.intents for required_intent in required_intents):\n                        self.logger.warning(\n                            f\"Event `{listener.event}` will not work since the required intent is not set -&gt; Requires any of: `{required_intents}`\"\n                        )\n\n        if listener.event not in self.listeners:\n            self.listeners[listener.event] = []\n        self.listeners[listener.event].append(listener)\n\n        # check if other listeners are to be deleted\n        default_listeners = [c_listener.is_default_listener for c_listener in self.listeners[listener.event]]\n        removes_defaults = [c_listener.disable_default_listeners for c_listener in self.listeners[listener.event]]\n\n        if any(default_listeners) and any(removes_defaults):\n            self.listeners[listener.event] = [\n                c_listener for c_listener in self.listeners[listener.event] if not c_listener.is_default_listener\n            ]\n\n    def add_interaction(self, command: InteractionCommand) -&gt; bool:\n\"\"\"\n        Add a slash command to the client.\n\n        Args:\n            command InteractionCommand: The command to add\n\n        \"\"\"\n        if self.debug_scope:\n            command.scopes = [self.debug_scope]\n\n        if self.disable_dm_commands:\n            command.dm_permission = False\n\n        # for SlashCommand objs without callback (like objects made to hold group info etc)\n        if command.callback is None:\n            return False\n\n        base, group, sub, *_ = command.resolved_name.split(\" \") + [None, None]\n\n        for scope in command.scopes:\n            if scope not in self.interactions:\n                self.interactions[scope] = {}\n            elif command.resolved_name in self.interactions[scope]:\n                old_cmd = self.interactions[scope][command.resolved_name]\n                raise ValueError(f\"Duplicate Command! {scope}::{old_cmd.resolved_name}\")\n\n            if self.enforce_interaction_perms:\n                command.checks.append(command._permission_enforcer)  # noqa : w0212\n\n            self.interactions[scope][command.resolved_name] = command\n\n            if scope not in self.interaction_tree:\n                self.interaction_tree[scope] = {}\n\n            if group is None or isinstance(command, ContextMenu):\n                self.interaction_tree[scope][command.resolved_name] = command\n            elif group is not None:\n                if not (current := self.interaction_tree[scope].get(base)) or isinstance(current, SlashCommand):\n                    self.interaction_tree[scope][base] = {}\n                if sub is None:\n                    self.interaction_tree[scope][base][group] = command\n                else:\n                    if not (current := self.interaction_tree[scope][base].get(group)) or isinstance(\n                        current, SlashCommand\n                    ):\n                        self.interaction_tree[scope][base][group] = {}\n                    self.interaction_tree[scope][base][group][sub] = command\n\n        return True\n\n    def add_hybrid_command(self, command: HybridCommand) -&gt; bool:\n        if self.debug_scope:\n            command.scopes = [self.debug_scope]\n\n        if command.callback is None:\n            return False\n\n        if command.is_subcommand:\n            prefixed_base = self.prefixed_commands.get(str(command.name))\n            if not prefixed_base:\n                prefixed_base = _base_subcommand_generator(\n                    str(command.name), list(command.name.to_locale_dict().values()), str(command.description)\n                )\n                self.add_prefixed_command(prefixed_base)\n\n            if command.group_name:  # if this is a group command\n                _prefixed_cmd = prefixed_base\n                prefixed_base = prefixed_base.subcommands.get(str(command.group_name))\n\n                if not prefixed_base:\n                    prefixed_base = _base_subcommand_generator(\n                        str(command.group_name),\n                        list(command.group_name.to_locale_dict().values()),\n                        str(command.group_description),\n                        group=True,\n                    )\n                    _prefixed_cmd.add_command(prefixed_base)\n\n            new_command = _prefixed_from_slash(command)\n            new_command._parse_parameters()\n            prefixed_base.add_command(new_command)\n        else:\n            new_command = _prefixed_from_slash(command)\n            self.add_prefixed_command(new_command)\n\n        return self.add_interaction(command)\n\n    def add_prefixed_command(self, command: PrefixedCommand) -&gt; None:\n\"\"\"\n        Add a prefixed command to the client.\n\n        Args:\n            command PrefixedCommand: The command to add\n\n        \"\"\"\n        # check that the required intent is enabled or the prefix is a mention\n        prefixes = (\n            self.default_prefix\n            if not isinstance(self.default_prefix, str) and not self.default_prefix == MENTION_PREFIX\n            else (self.default_prefix,)\n        )\n        if (MENTION_PREFIX not in prefixes) and (Intents.GUILD_MESSAGE_CONTENT not in self.intents):\n            self.logger.warning(\n                f\"Prefixed commands will not work since the required intent is not set -&gt; Requires: `{Intents.GUILD_MESSAGE_CONTENT.__repr__()}` or usage of the default `MENTION_PREFIX` as the prefix\"\n            )\n\n        command._parse_parameters()\n\n        if self.prefixed_commands.get(command.name):\n            raise ValueError(f\"Duplicate command! Multiple commands share the name/alias: {command.name}.\")\n        self.prefixed_commands[command.name] = command\n\n        for alias in command.aliases:\n            if self.prefixed_commands.get(alias):\n                raise ValueError(f\"Duplicate command! Multiple commands share the name/alias: {alias}.\")\n            self.prefixed_commands[alias] = command\n\n    def add_component_callback(self, command: ComponentCommand) -&gt; None:\n\"\"\"\n        Add a component callback to the client.\n\n        Args:\n            command: The command to add\n\n        \"\"\"\n        for listener in command.listeners:\n            # I know this isn't an ideal solution, but it means we can lookup callbacks with O(1)\n            if listener not in self._component_callbacks.keys():\n                self._component_callbacks[listener] = command\n                continue\n            else:\n                raise ValueError(f\"Duplicate Component! Multiple component callbacks for `{listener}`\")\n\n    def add_modal_callback(self, command: ModalCommand) -&gt; None:\n\"\"\"\n        Add a modal callback to the client.\n\n        Args:\n            command: The command to add\n        \"\"\"\n        for listener in command.listeners:\n            if listener not in self._modal_callbacks.keys():\n                self._modal_callbacks[listener] = command\n                continue\n            else:\n                raise ValueError(f\"Duplicate Component! Multiple modal callbacks for `{listener}`\")\n\n    def _gather_commands(self) -&gt; None:\n\"\"\"Gathers commands from __main__ and self.\"\"\"\n\n        def process(_cmds) -&gt; None:\n\n            for func in _cmds:\n                if isinstance(func, ModalCommand):\n                    self.add_modal_callback(func)\n                elif isinstance(func, ComponentCommand):\n                    self.add_component_callback(func)\n                elif isinstance(func, HybridCommand):\n                    self.add_hybrid_command(func)\n                elif isinstance(func, InteractionCommand):\n                    self.add_interaction(func)\n                elif (\n                    isinstance(func, PrefixedCommand) and not func.is_subcommand\n                ):  # subcommands will be added with main comamnds\n                    self.add_prefixed_command(func)\n                elif isinstance(func, Listener):\n                    self.add_listener(func)\n\n            self.logger.debug(f\"{len(_cmds)} commands have been loaded from `__main__` and `client`\")\n\n        process(\n            [obj for _, obj in inspect.getmembers(sys.modules[\"__main__\"]) if isinstance(obj, (BaseCommand, Listener))]\n        )\n        process(\n            [\n                obj.copy_with_binding(self)\n                for _, obj in inspect.getmembers(self)\n                if isinstance(obj, (BaseCommand, Listener))\n            ]\n        )\n\n        [wrap_partial(obj, self) for _, obj in inspect.getmembers(self) if isinstance(obj, Task)]\n\n    async def _init_interactions(self) -&gt; None:\n\"\"\"\n        Initialise slash commands.\n\n        If `sync_interactions` this will submit all registered slash\n        commands to discord. Otherwise, it will get the list of\n        interactions and cache their scopes.\n\n        \"\"\"\n        # allow for ext and main to share the same decorator\n        try:\n            if self.sync_interactions:\n                await self.synchronise_interactions()\n            else:\n                await self._cache_interactions(warn_missing=False)\n        except Exception as e:\n            self.dispatch(events.Error(source=\"Interaction Syncing\", error=e))\n\n    async def _cache_interactions(self, warn_missing: bool = False) -&gt; None:\n\"\"\"Get all interactions used by this bot and cache them.\"\"\"\n        if warn_missing or self.del_unused_app_cmd:\n            bot_scopes = {g.id for g in self.cache.guild_cache.values()}\n            bot_scopes.add(GLOBAL_SCOPE)\n        else:\n            bot_scopes = set(self.interactions)\n\n        req_lock = asyncio.Lock()\n\n        async def wrap(*args, **kwargs) -&gt; Absent[List[Dict]]:\n            async with req_lock:\n                # throttle this\n                await asyncio.sleep(0.1)\n            try:\n                return await self.http.get_application_commands(*args, **kwargs)\n            except Forbidden:\n                return MISSING\n\n        results = await asyncio.gather(*[wrap(self.app.id, scope) for scope in bot_scopes])\n        results = dict(zip(bot_scopes, results))\n\n        for scope, remote_cmds in results.items():\n            if remote_cmds == MISSING:\n                self.logger.debug(f\"Bot was not invited to guild {scope} with `application.commands` scope\")\n                continue\n\n            remote_cmds = {cmd_data[\"name\"]: cmd_data for cmd_data in remote_cmds}\n            found = set()  # this is a temporary hack to fix subcommand detection\n            if scope in self.interactions:\n                for cmd in self.interactions[scope].values():\n                    cmd_name = str(cmd.name)\n                    cmd_data = remote_cmds.get(cmd_name, MISSING)\n                    if cmd_data is MISSING:\n                        if cmd_name not in found:\n                            if warn_missing:\n                                self.logger.error(\n                                    f'Detected yet to sync slash command \"/{cmd_name}\" for scope '\n                                    f\"{'global' if scope == GLOBAL_SCOPE else scope}\"\n                                )\n                        continue\n                    else:\n                        found.add(cmd_name)\n                    self._interaction_scopes[str(cmd_data[\"id\"])] = scope\n                    cmd.cmd_id[scope] = int(cmd_data[\"id\"])\n\n            if warn_missing:\n                for cmd_data in remote_cmds.values():\n                    self.logger.error(\n                        f\"Detected unimplemented slash command \\\"/{cmd_data['name']}\\\" for scope \"\n                        f\"{'global' if scope == GLOBAL_SCOPE else scope}\"\n                    )\n\n    async def synchronise_interactions(\n        self, *, scopes: Sequence[\"Snowflake_Type\"] = MISSING, delete_commands: Absent[bool] = MISSING\n    ) -&gt; None:\n\"\"\"\n        Synchronise registered interactions with discord.\n\n        Args:\n            scopes: Optionally specify which scopes are to be synced\n            delete_commands: Override the client setting and delete commands\n        \"\"\"\n        s = time.perf_counter()\n        _delete_cmds = self.del_unused_app_cmd if delete_commands is MISSING else delete_commands\n        await self._cache_interactions()\n\n        if scopes is not MISSING:\n            cmd_scopes = scopes\n        elif self.del_unused_app_cmd:\n            # if we're deleting unused commands, we check all scopes\n            cmd_scopes = [to_snowflake(g_id) for g_id in self._user._guild_ids] + [GLOBAL_SCOPE]\n        else:\n            # if we're not deleting, just check the scopes we have cmds registered in\n            cmd_scopes = list(set(self.interactions) | {GLOBAL_SCOPE})\n\n        local_cmds_json = application_commands_to_dict(self.interactions, self)\n\n        async def sync_scope(cmd_scope) -&gt; None:\n\n            sync_needed_flag = False  # a flag to force this scope to synchronise\n            sync_payload = []  # the payload to be pushed to discord\n\n            try:\n                try:\n                    remote_commands = await self.http.get_application_commands(self.app.id, cmd_scope)\n                except Forbidden:\n                    self.logger.warning(f\"Bot is lacking `application.commands` scope in {cmd_scope}!\")\n                    return\n\n                for local_cmd in self.interactions.get(cmd_scope, {}).values():\n                    # get remote equivalent of this command\n                    remote_cmd_json = next(\n                        (v for v in remote_commands if int(v[\"id\"]) == local_cmd.cmd_id.get(cmd_scope)), None\n                    )\n                    # get json representation of this command\n                    local_cmd_json = next((c for c in local_cmds_json[cmd_scope] if c[\"name\"] == str(local_cmd.name)))\n\n                    # this works by adding any command we *want* on Discord, to a payload, and synchronising that\n                    # this allows us to delete unused commands, add new commands, or do nothing in 1 or less API calls\n\n                    if sync_needed(local_cmd_json, remote_cmd_json):\n                        # determine if the local and remote commands are out-of-sync\n                        sync_needed_flag = True\n                        sync_payload.append(local_cmd_json)\n                    elif not _delete_cmds and remote_cmd_json:\n                        _remote_payload = {\n                            k: v for k, v in remote_cmd_json.items() if k not in (\"id\", \"application_id\", \"version\")\n                        }\n                        sync_payload.append(_remote_payload)\n                    elif _delete_cmds:\n                        sync_payload.append(local_cmd_json)\n\n                sync_payload = [json.loads(_dump) for _dump in {json.dumps(_cmd) for _cmd in sync_payload}]\n\n                if sync_needed_flag or (_delete_cmds and len(sync_payload) &lt; len(remote_commands)):\n                    # synchronise commands if flag is set, or commands are to be deleted\n                    self.logger.info(f\"Overwriting {cmd_scope} with {len(sync_payload)} application commands\")\n                    sync_response: list[dict] = await self.http.overwrite_application_commands(\n                        self.app.id, sync_payload, cmd_scope\n                    )\n                    self._cache_sync_response(sync_response, cmd_scope)\n                else:\n                    self.logger.debug(f\"{cmd_scope} is already up-to-date with {len(remote_commands)} commands.\")\n\n            except Forbidden as e:\n                raise InteractionMissingAccess(cmd_scope) from e\n            except HTTPException as e:\n                self._raise_sync_exception(e, local_cmds_json, cmd_scope)\n\n        await asyncio.gather(*[sync_scope(scope) for scope in cmd_scopes])\n\n        t = time.perf_counter() - s\n        self.logger.debug(f\"Sync of {len(cmd_scopes)} scopes took {t} seconds\")\n\n    def get_application_cmd_by_id(self, cmd_id: \"Snowflake_Type\") -&gt; Optional[InteractionCommand]:\n\"\"\"\n        Get a application command from the internal cache by its ID.\n\n        Args:\n            cmd_id: The ID of the command\n\n        Returns:\n            The command, if one with the given ID exists internally, otherwise None\n\n        \"\"\"\n        scope = self._interaction_scopes.get(str(cmd_id), MISSING)\n        cmd_id = int(cmd_id)  # ensure int ID\n        if scope != MISSING:\n            for cmd in self.interactions[scope].values():\n                if int(cmd.cmd_id.get(scope)) == cmd_id:\n                    return cmd\n        return None\n\n    def _raise_sync_exception(self, e: HTTPException, cmds_json: dict, cmd_scope: \"Snowflake_Type\") -&gt; NoReturn:\n        try:\n            if isinstance(e.errors, dict):\n                for cmd_num in e.errors.keys():\n                    cmd = cmds_json[cmd_scope][int(cmd_num)]\n                    output = e.search_for_message(e.errors[cmd_num], cmd)\n                    if len(output) &gt; 1:\n                        output = \"\\n\".join(output)\n                        self.logger.error(f\"Multiple Errors found in command `{cmd['name']}`:\\n{output}\")\n                    else:\n                        self.logger.error(f\"Error in command `{cmd['name']}`: {output[0]}\")\n            else:\n                raise e from None\n        except Exception:\n            # the above shouldn't fail, but if it does, just raise the exception normally\n            raise e from None\n\n    def _cache_sync_response(self, sync_response: list[dict], scope: \"Snowflake_Type\") -&gt; None:\n        for cmd_data in sync_response:\n            self._interaction_scopes[cmd_data[\"id\"]] = scope\n            if cmd_data[\"name\"] in self.interactions[scope]:\n                self.interactions[scope][cmd_data[\"name\"]].cmd_id[scope] = int(cmd_data[\"id\"])\n            else:\n                # sub_cmd\n                for sc in cmd_data[\"options\"]:\n                    if sc[\"type\"] == OptionTypes.SUB_COMMAND:\n                        if f\"{cmd_data['name']} {sc['name']}\" in self.interactions[scope]:\n                            self.interactions[scope][f\"{cmd_data['name']} {sc['name']}\"].cmd_id[scope] = int(\n                                cmd_data[\"id\"]\n                            )\n                    elif sc[\"type\"] == OptionTypes.SUB_COMMAND_GROUP:\n                        for _sc in sc[\"options\"]:\n                            if f\"{cmd_data['name']} {sc['name']} {_sc['name']}\" in self.interactions[scope]:\n                                self.interactions[scope][f\"{cmd_data['name']} {sc['name']} {_sc['name']}\"].cmd_id[\n                                    scope\n                                ] = int(cmd_data[\"id\"])\n\n    @overload\n    async def get_context(self, data: ComponentChannelInteractionData, interaction: Literal[True]) -&gt; ComponentContext:\n        ...\n\n    @overload\n    async def get_context(\n        self, data: AutocompleteChannelInteractionData, interaction: Literal[True]\n    ) -&gt; AutocompleteContext:\n        ...\n\n    # as of right now, discord_typings doesn't include anything like this\n    # @overload\n    # async def get_context(self, data: ModalSubmitInteractionData, interaction: Literal[True]) -&gt; ModalContext:\n    #     ...\n\n    @overload\n    async def get_context(self, data: InteractionData, interaction: Literal[True]) -&gt; InteractionContext:\n        ...\n\n    @overload\n    async def get_context(\n        self, data: dict, interaction: Literal[True]\n    ) -&gt; ComponentContext | AutocompleteContext | ModalContext | InteractionContext:\n        # fallback case since some data isn't typehinted properly\n        ...\n\n    @overload\n    async def get_context(self, data: Message, interaction: Literal[False] = False) -&gt; PrefixedContext:\n        ...\n\n    async def get_context(\n        self, data: InteractionData | dict | Message, interaction: bool = False\n    ) -&gt; ComponentContext | AutocompleteContext | ModalContext | InteractionContext | PrefixedContext:\n\"\"\"\n        Return a context object based on data passed.\n\n        !!! note\n            If you want to use custom context objects, this is the method to override. Your replacement must take the same arguments as this, and return a Context-like object.\n\n        Args:\n            data: The data of the event\n            interaction: Is this an interaction or not?\n\n        Returns:\n            Context object\n\n        \"\"\"\n        # this line shuts up IDE warnings\n        cls: ComponentContext | AutocompleteContext | ModalContext | InteractionContext | PrefixedContext\n\n        if interaction:\n            match data[\"type\"]:\n                case InteractionTypes.MESSAGE_COMPONENT:\n                    cls = self.component_context.from_dict(data, self)\n\n                case InteractionTypes.AUTOCOMPLETE:\n                    cls = self.autocomplete_context.from_dict(data, self)\n\n                case InteractionTypes.MODAL_RESPONSE:\n                    cls = self.modal_context.from_dict(data, self)\n\n                case _:\n                    cls = self.interaction_context.from_dict(data, self)\n\n            if not cls.channel:\n                try:\n                    cls.channel = await self.cache.fetch_channel(data[\"channel_id\"])\n                except Forbidden:\n                    cls.channel = BaseChannel.from_dict_factory(\n                        {\"id\": data[\"channel_id\"], \"type\": ChannelTypes.GUILD_TEXT}, self\n                    )\n\n        else:\n            cls = self.prefixed_context.from_message(self, data)\n            if not cls.channel:\n                cls.channel = await self.cache.fetch_channel(data._channel_id)\n\n        return cls\n\n    async def _run_slash_command(self, command: SlashCommand, ctx: InteractionContext) -&gt; Any:\n\"\"\"Overrideable method that executes slash commands, can be used to wrap callback execution\"\"\"\n        return await command(ctx, **ctx.kwargs)\n\n    async def _run_prefixed_command(self, command: PrefixedCommand, ctx: PrefixedContext) -&gt; Any:\n\"\"\"Overrideable method that executes prefixed commands, can be used to wrap callback execution\"\"\"\n        return await command(ctx)\n\n    @processors.Processor.define(\"raw_interaction_create\")\n    async def _dispatch_interaction(self, event: RawGatewayEvent) -&gt; None:\n\"\"\"\n        Identify and dispatch interaction of slash commands or components.\n\n        Args:\n            raw interaction event\n\n        \"\"\"\n        interaction_data = event.data\n\n        if interaction_data[\"type\"] in (\n            InteractionTypes.PING,\n            InteractionTypes.APPLICATION_COMMAND,\n            InteractionTypes.AUTOCOMPLETE,\n        ):\n            interaction_id = interaction_data[\"data\"][\"id\"]\n            name = interaction_data[\"data\"][\"name\"]\n            scope = self._interaction_scopes.get(str(interaction_id))\n\n            if scope in self.interactions:\n                ctx = await self.get_context(interaction_data, True)\n\n                ctx.command: SlashCommand = self.interactions[scope][ctx.invoke_target]  # type: ignore\n                self.logger.debug(f\"{scope} :: {ctx.command.name} should be called\")\n\n                if ctx.command.auto_defer:\n                    auto_defer = ctx.command.auto_defer\n                elif ctx.command.extension and ctx.command.extension.auto_defer:\n                    auto_defer = ctx.command.extension.auto_defer\n                else:\n                    auto_defer = self.auto_defer\n\n                if auto_opt := getattr(ctx, \"focussed_option\", None):\n                    try:\n                        await ctx.command.autocomplete_callbacks[auto_opt](ctx, **ctx.kwargs)\n                    except Exception as e:\n                        self.dispatch(events.AutocompleteError(ctx=ctx, error=e))\n                    finally:\n                        self.dispatch(events.AutocompleteCompletion(ctx=ctx))\n                else:\n                    try:\n                        await auto_defer(ctx)\n                        if self.pre_run_callback:\n                            await self.pre_run_callback(ctx, **ctx.kwargs)\n                        await self._run_slash_command(ctx.command, ctx)\n                        if self.post_run_callback:\n                            await self.post_run_callback(ctx, **ctx.kwargs)\n                    except Exception as e:\n                        self.dispatch(events.CommandError(ctx=ctx, error=e))\n                    finally:\n                        self.dispatch(events.CommandCompletion(ctx=ctx))\n            else:\n                self.logger.error(f\"Unknown cmd_id received:: {interaction_id} ({name})\")\n\n        elif interaction_data[\"type\"] == InteractionTypes.MESSAGE_COMPONENT:\n            # Buttons, Selects, ContextMenu::Message\n            ctx = await self.get_context(interaction_data, True)\n            component_type = interaction_data[\"data\"][\"component_type\"]\n\n            self.dispatch(events.Component(ctx=ctx))\n            if callback := self._component_callbacks.get(ctx.custom_id):\n                ctx.command = callback\n                try:\n                    if self.pre_run_callback:\n                        await self.pre_run_callback(ctx)\n                    await callback(ctx)\n                    if self.post_run_callback:\n                        await self.post_run_callback(ctx)\n                except Exception as e:\n                    self.dispatch(events.ComponentError(ctx=ctx, error=e))\n                finally:\n                    self.dispatch(events.ComponentCompletion(ctx=ctx))\n            if component_type == ComponentTypes.BUTTON:\n                self.dispatch(events.ButtonPressed(ctx))\n            if component_type == ComponentTypes.STRING_SELECT:\n                self.dispatch(events.Select(ctx))\n\n        elif interaction_data[\"type\"] == InteractionTypes.MODAL_RESPONSE:\n            ctx = await self.get_context(interaction_data, True)\n            self.dispatch(events.ModalCompletion(ctx=ctx))\n\n            # todo: Polls remove this icky code duplication - love from past-polls \u2764\ufe0f\n            if callback := self._modal_callbacks.get(ctx.custom_id):\n                ctx.command = callback\n\n                try:\n                    if self.pre_run_callback:\n                        await self.pre_run_callback(ctx)\n                    await callback(ctx)\n                    if self.post_run_callback:\n                        await self.post_run_callback(ctx)\n                except Exception as e:\n                    self.dispatch(events.ModalError(ctx=ctx, error=e))\n\n        else:\n            raise NotImplementedError(f\"Unknown Interaction Received: {interaction_data['type']}\")\n\n    @Listener.create(\"raw_message_create\", is_default_listener=True)\n    async def _dispatch_prefixed_commands(self, event: RawGatewayEvent) -&gt; None:\n\"\"\"Determine if a prefixed command is being triggered, and dispatch it.\"\"\"\n        # don't waste time processing this if there are no prefixed commands\n        if not self.prefixed_commands:\n            return\n\n        data = event.data\n\n        # many bots will not have the message content intent, and so will not have content\n        # for most messages. since there's nothing for prefixed commands to work off of,\n        # we might as well not waste time\n        if not data.get(\"content\"):\n            return\n\n        # webhooks and users labeled with the bot property are bots, and should be ignored\n        if data.get(\"webhook_id\") or data[\"author\"].get(\"bot\", False):\n            return\n\n        # now, we've done the basic filtering out, but everything from here on out relies\n        # on a proper message object, so now we either hope its already in the cache or wait\n        # on the processor\n\n        # first, let's check the cache...\n        message = self.cache.get_message(int(data[\"channel_id\"]), int(data[\"id\"]))\n\n        # this huge if statement basically checks if the message hasn't been fully processed by\n        # the processor yet, which would mean that these fields aren't fully filled\n        if message and (\n            (not message._guild_id and event.data.get(\"guild_id\"))\n            or (message._guild_id and not message.guild)\n            or not message.channel\n        ):\n            message = None\n\n        # if we didn't get a message, then we know we should wait for the message create event\n        if not message:\n            try:\n                # i think 2 seconds is a very generous timeout limit\n                event: MessageCreate = await self.wait_for(\n                    MessageCreate, checks=lambda e: int(e.message.id) == int(data[\"id\"]), timeout=2\n                )\n                message = event.message\n            except asyncio.TimeoutError:\n                return\n\n        # here starts the actual prefixed command parsing part\n        prefixes: str | Iterable[str] = await self.generate_prefixes(self, message)\n\n        if isinstance(prefixes, str) or prefixes == MENTION_PREFIX:\n            # its easier to treat everything as if it may be an iterable\n            # rather than building a special case for this\n            prefixes = (prefixes,)  # type: ignore\n\n        prefix_used = None\n\n        for prefix in prefixes:\n            if prefix == MENTION_PREFIX:\n                if mention := self._mention_reg.search(message.content):  # type: ignore\n                    prefix = mention.group()\n                else:\n                    continue\n\n            if message.content.startswith(prefix):\n                prefix_used = prefix\n                break\n\n        if not prefix_used:\n            return\n\n        context = await self.get_context(message)\n        context.prefix = prefix_used\n\n        # interestingly enough, we cannot count on ctx.invoke_target\n        # being correct as its hard to account for newlines and the like\n        # with the way we get subcommands here\n        # we'll have to reconstruct it by getting the content_parameters\n        # then removing the prefix and the parameters from the message\n        # content\n        content_parameters = message.content.removeprefix(prefix_used)  # type: ignore\n        command: \"Client | PrefixedCommand\" = self  # yes, this is a hack\n\n        while True:\n            first_word: str = get_first_word(content_parameters)  # type: ignore\n            if isinstance(command, PrefixedCommand):\n                new_command = command.subcommands.get(first_word)\n            else:\n                new_command = command.prefixed_commands.get(first_word)\n            if not new_command or not new_command.enabled:\n                break\n\n            command = new_command\n            content_parameters = content_parameters.removeprefix(first_word).strip()\n\n            if command.subcommands and command.hierarchical_checking:\n                try:\n                    await new_command._can_run(context)  # will error out if we can't run this command\n                except Exception as e:\n                    if new_command.error_callback:\n                        await new_command.error_callback(e, context)\n                    elif new_command.extension and new_command.extension.extension_error:\n                        await new_command.extension.extension_error(e, context)\n                    else:\n                        self.dispatch(events.CommandError(ctx=context, error=e))\n                    return\n\n        if not isinstance(command, PrefixedCommand) or not command.enabled:\n            return\n\n        context.command = command\n        context.invoke_target = message.content.removeprefix(prefix_used).removesuffix(content_parameters).strip()  # type: ignore\n        context.args = get_args(context.content_parameters)\n        try:\n            if self.pre_run_callback:\n                await self.pre_run_callback(context)\n            await self._run_prefixed_command(command, context)\n            if self.post_run_callback:\n                await self.post_run_callback(context)\n        except Exception as e:\n            self.dispatch(events.CommandError(ctx=context, error=e))\n        finally:\n            self.dispatch(events.CommandCompletion(ctx=context))\n\n    @Listener.create(\"disconnect\", is_default_listener=True)\n    async def _disconnect(self) -&gt; None:\n        self._ready.clear()\n\n    def get_extensions(self, name: str) -&gt; list[Extension]:\n\"\"\"\n        Get all ext with a name or extension name.\n\n        Args:\n            name: The name of the extension, or the name of it's extension\n\n        Returns:\n            List of Extensions\n        \"\"\"\n        if name not in self.ext.keys():\n            return [ext for ext in self.ext.values() if ext.extension_name == name]\n\n        return [self.ext.get(name, None)]\n\n    def get_ext(self, name: str) -&gt; Extension | None:\n\"\"\"\n        Get a extension with a name or extension name.\n\n        Args:\n            name: The name of the extension, or the name of it's extension\n\n        Returns:\n            A extension, if found\n        \"\"\"\n        if ext := self.get_extensions(name):\n            return ext[0]\n        return None\n\n    def load_extension(self, name: str, package: str | None = None, **load_kwargs: Any) -&gt; None:\n\"\"\"\n        Load an extension with given arguments.\n\n        Args:\n            name: The name of the extension.\n            package: The package the extension is in\n            **load_kwargs: The auto-filled mapping of the load keyword arguments\n\n        \"\"\"\n        module_name = importlib.util.resolve_name(name, package)\n        if module_name in self.__modules:\n            raise Exception(f\"{module_name} already loaded\")\n\n        module = importlib.import_module(module_name, package)\n        try:\n            setup = getattr(module, \"setup\", None)\n            if setup:\n                setup(self, **load_kwargs)\n            else:\n                self.logger.debug(\"No setup function found in %s\", module_name)\n\n                found = False\n                objects = {name: obj for name, obj in inspect.getmembers(module) if isinstance(obj, type)}\n                for obj_name, obj in objects.items():\n                    if Extension in obj.__bases__:\n                        self.logger.debug(f\"Found extension class {obj_name} in {module_name}: Attempting to load\")\n                        obj(self, **load_kwargs)\n                        found = True\n                if not found:\n                    raise Exception(f\"{module_name} contains no Extensions\")\n\n        except ExtensionLoadException:\n            raise\n        except Exception as e:\n            del sys.modules[module_name]\n            raise ExtensionLoadException(f\"Unexpected Error loading {module_name}\") from e\n\n        else:\n            self.logger.debug(f\"Loaded Extension: {module_name}\")\n            self.__modules[module_name] = module\n\n            if self.sync_ext and self._ready.is_set():\n                try:\n                    asyncio.get_running_loop()\n                except RuntimeError:\n                    return\n                asyncio.create_task(self.synchronise_interactions())\n\n    def unload_extension(self, name: str, package: str | None = None, **unload_kwargs: Any) -&gt; None:\n\"\"\"\n        Unload an extension with given arguments.\n\n        Args:\n            name: The name of the extension.\n            package: The package the extension is in\n            **unload_kwargs: The auto-filled mapping of the unload keyword arguments\n\n        \"\"\"\n        name = importlib.util.resolve_name(name, package)\n        module = self.__modules.get(name)\n\n        if module is None:\n            raise ExtensionNotFound(f\"No extension called {name} is loaded\")\n\n        try:\n            teardown = getattr(module, \"teardown\")\n            teardown(**unload_kwargs)\n        except AttributeError:\n            pass\n\n        for ext in self.get_extensions(name):\n            ext.drop(**unload_kwargs)\n\n        del sys.modules[name]\n        del self.__modules[name]\n\n        if self.sync_ext and self._ready.is_set():\n            if self.sync_ext and self._ready.is_set():\n                try:\n                    asyncio.get_running_loop()\n                except RuntimeError:\n                    return\n                asyncio.create_task(self.synchronise_interactions())\n\n    def reload_extension(\n        self,\n        name: str,\n        package: str | None = None,\n        *,\n        load_kwargs: Any = None,\n        unload_kwargs: Any = None,\n    ) -&gt; None:\n\"\"\"\n        Helper method to reload an extension. Simply unloads, then loads the extension with given arguments.\n\n        Args:\n            name: The name of the extension.\n            package: The package the extension is in\n            load_kwargs: The manually-filled mapping of the load keyword arguments\n            unload_kwargs: The manually-filled mapping of the unload keyword arguments\n\n        \"\"\"\n        name = importlib.util.resolve_name(name, package)\n        module = self.__modules.get(name)\n\n        if module is None:\n            self.logger.warning(\"Attempted to reload extension thats not loaded. Loading extension instead\")\n            return self.load_extension(name, package)\n\n        if not load_kwargs:\n            load_kwargs = {}\n        if not unload_kwargs:\n            unload_kwargs = {}\n\n        self.unload_extension(name, package, **unload_kwargs)\n        self.load_extension(name, package, **load_kwargs)\n\n        # todo: maybe add an ability to revert to the previous version if unable to load the new one\n\n    async def fetch_guild(self, guild_id: \"Snowflake_Type\") -&gt; Optional[Guild]:\n\"\"\"\n        Fetch a guild.\n\n        !!! note\n            This method is an alias for the cache which will either return a cached object, or query discord for the object\n            if its not already cached.\n\n        Args:\n            guild_id: The ID of the guild to get\n\n        Returns:\n            Guild Object if found, otherwise None\n\n        \"\"\"\n        try:\n            return await self.cache.fetch_guild(guild_id)\n        except NotFound:\n            return None\n\n    def get_guild(self, guild_id: \"Snowflake_Type\") -&gt; Optional[Guild]:\n\"\"\"\n        Get a guild.\n\n        !!! note\n            This method is an alias for the cache which will return a cached object.\n\n        Args:\n            guild_id: The ID of the guild to get\n\n        Returns:\n            Guild Object if found, otherwise None\n\n        \"\"\"\n        return self.cache.get_guild(guild_id)\n\n    async def create_guild_from_template(\n        self,\n        template_code: Union[\"GuildTemplate\", str],\n        name: str,\n        icon: Absent[UPLOADABLE_TYPE] = MISSING,\n    ) -&gt; Optional[Guild]:\n\"\"\"\n        Creates a new guild based on a template.\n\n        !!! note\n            This endpoint can only be used by bots in less than 10 guilds.\n\n        Args:\n            template_code: The code of the template to use.\n            name: The name of the guild (2-100 characters)\n            icon: Location or File of icon to set\n\n        Returns:\n            The newly created guild object\n\n        \"\"\"\n        if isinstance(template_code, GuildTemplate):\n            template_code = template_code.code\n\n        if icon:\n            icon = to_image_data(icon)\n        guild_data = await self.http.create_guild_from_guild_template(template_code, name, icon)\n        return Guild.from_dict(guild_data, self)\n\n    async def fetch_channel(self, channel_id: \"Snowflake_Type\") -&gt; Optional[\"TYPE_ALL_CHANNEL\"]:\n\"\"\"\n        Fetch a channel.\n\n        !!! note\n            This method is an alias for the cache which will either return a cached object, or query discord for the object\n            if its not already cached.\n\n        Args:\n            channel_id: The ID of the channel to get\n\n        Returns:\n            Channel Object if found, otherwise None\n\n        \"\"\"\n        try:\n            return await self.cache.fetch_channel(channel_id)\n        except NotFound:\n            return None\n\n    def get_channel(self, channel_id: \"Snowflake_Type\") -&gt; Optional[\"TYPE_ALL_CHANNEL\"]:\n\"\"\"\n        Get a channel.\n\n        !!! note\n            This method is an alias for the cache which will return a cached object.\n\n        Args:\n            channel_id: The ID of the channel to get\n\n        Returns:\n            Channel Object if found, otherwise None\n\n        \"\"\"\n        return self.cache.get_channel(channel_id)\n\n    async def fetch_user(self, user_id: \"Snowflake_Type\") -&gt; Optional[User]:\n\"\"\"\n        Fetch a user.\n\n        !!! note\n            This method is an alias for the cache which will either return a cached object, or query discord for the object\n            if its not already cached.\n\n        Args:\n            user_id: The ID of the user to get\n\n        Returns:\n            User Object if found, otherwise None\n\n        \"\"\"\n        try:\n            return await self.cache.fetch_user(user_id)\n        except NotFound:\n            return None\n\n    def get_user(self, user_id: \"Snowflake_Type\") -&gt; Optional[User]:\n\"\"\"\n        Get a user.\n\n        !!! note\n            This method is an alias for the cache which will return a cached object.\n\n        Args:\n            user_id: The ID of the user to get\n\n        Returns:\n            User Object if found, otherwise None\n\n        \"\"\"\n        return self.cache.get_user(user_id)\n\n    async def fetch_member(self, user_id: \"Snowflake_Type\", guild_id: \"Snowflake_Type\") -&gt; Optional[Member]:\n\"\"\"\n        Fetch a member from a guild.\n\n        !!! note\n            This method is an alias for the cache which will either return a cached object, or query discord for the object\n            if its not already cached.\n\n        Args:\n            user_id: The ID of the member\n            guild_id: The ID of the guild to get the member from\n\n        Returns:\n            Member object if found, otherwise None\n\n        \"\"\"\n        try:\n            return await self.cache.fetch_member(guild_id, user_id)\n        except NotFound:\n            return None\n\n    def get_member(self, user_id: \"Snowflake_Type\", guild_id: \"Snowflake_Type\") -&gt; Optional[Member]:\n\"\"\"\n        Get a member from a guild.\n\n        !!! note\n            This method is an alias for the cache which will return a cached object.\n\n        Args:\n            user_id: The ID of the member\n            guild_id: The ID of the guild to get the member from\n\n        Returns:\n            Member object if found, otherwise None\n\n        \"\"\"\n        return self.cache.get_member(guild_id, user_id)\n\n    async def fetch_scheduled_event(\n        self, guild_id: \"Snowflake_Type\", scheduled_event_id: \"Snowflake_Type\", with_user_count: bool = False\n    ) -&gt; Optional[\"ScheduledEvent\"]:\n\"\"\"\n        Fetch a scheduled event by id.\n\n        Args:\n            guild_id: The ID of the guild to get the scheduled event from\n            scheduled_event_id: The ID of the scheduled event to get\n            with_user_count: Whether to include the user count in the response\n\n        Returns:\n            The scheduled event if found, otherwise None\n\n        \"\"\"\n        try:\n            scheduled_event_data = await self.http.get_scheduled_event(guild_id, scheduled_event_id, with_user_count)\n            return ScheduledEvent.from_dict(scheduled_event_data, self)\n        except NotFound:\n            return None\n\n    async def fetch_custom_emoji(self, emoji_id: \"Snowflake_Type\", guild_id: \"Snowflake_Type\") -&gt; Optional[CustomEmoji]:\n\"\"\"\n        Fetch a custom emoji by id.\n\n        Args:\n            emoji_id: The id of the custom emoji.\n            guild_id: The id of the guild the emoji belongs to.\n\n        Returns:\n            The custom emoji if found, otherwise None.\n\n        \"\"\"\n        try:\n            return await self.cache.fetch_emoji(guild_id, emoji_id)\n        except NotFound:\n            return None\n\n    def get_custom_emoji(\n        self, emoji_id: \"Snowflake_Type\", guild_id: Optional[\"Snowflake_Type\"] = None\n    ) -&gt; Optional[CustomEmoji]:\n\"\"\"\n        Get a custom emoji by id.\n\n        Args:\n            emoji_id: The id of the custom emoji.\n            guild_id: The id of the guild the emoji belongs to.\n\n        Returns:\n            The custom emoji if found, otherwise None.\n\n        \"\"\"\n        emoji = self.cache.get_emoji(emoji_id)\n        if emoji and (not guild_id or emoji._guild_id == to_snowflake(guild_id)):\n            return emoji\n        return None\n\n    async def fetch_sticker(self, sticker_id: \"Snowflake_Type\") -&gt; Optional[Sticker]:\n\"\"\"\n        Fetch a sticker by ID.\n\n        Args:\n            sticker_id: The ID of the sticker.\n\n        Returns:\n            A sticker object if found, otherwise None\n\n        \"\"\"\n        try:\n            sticker_data = await self.http.get_sticker(sticker_id)\n            return Sticker.from_dict(sticker_data, self)\n        except NotFound:\n            return None\n\n    async def fetch_nitro_packs(self) -&gt; Optional[List[\"StickerPack\"]]:\n\"\"\"\n        List the sticker packs available to Nitro subscribers.\n\n        Returns:\n            A list of StickerPack objects if found, otherwise returns None\n\n        \"\"\"\n        try:\n            packs_data = await self.http.list_nitro_sticker_packs()\n            return [StickerPack.from_dict(data, self) for data in packs_data]\n\n        except NotFound:\n            return None\n\n    async def fetch_voice_regions(self) -&gt; List[\"VoiceRegion\"]:\n\"\"\"\n        List the voice regions available on Discord.\n\n        Returns:\n            A list of voice regions.\n\n        \"\"\"\n        regions_data = await self.http.list_voice_regions()\n        regions = VoiceRegion.from_list(regions_data)\n        return regions\n\n    async def connect_to_vc(\n        self, guild_id: \"Snowflake_Type\", channel_id: \"Snowflake_Type\", muted: bool = False, deafened: bool = False\n    ) -&gt; ActiveVoiceState:\n\"\"\"\n        Connect the bot to a voice channel.\n\n        Args:\n            guild_id: id of the guild the voice channel is in.\n            channel_id: id of the voice channel client wants to join.\n            muted: Whether the bot should be muted when connected.\n            deafened: Whether the bot should be deafened when connected.\n\n        Returns:\n            The new active voice state on successfully connection.\n\n        \"\"\"\n        return await self._connection_state.voice_connect(guild_id, channel_id, muted, deafened)\n\n    def get_bot_voice_state(self, guild_id: \"Snowflake_Type\") -&gt; Optional[ActiveVoiceState]:\n\"\"\"\n        Get the bot's voice state for a guild.\n\n        Args:\n            guild_id: The target guild's id.\n\n        Returns:\n            The bot's voice state for the guild if connected, otherwise None.\n\n        \"\"\"\n        return self._connection_state.get_voice_state(guild_id)\n\n    async def change_presence(\n        self, status: Optional[Union[str, Status]] = Status.ONLINE, activity: Optional[Union[Activity, str]] = None\n    ) -&gt; None:\n\"\"\"\n        Change the bots presence.\n\n        Args:\n            status: The status for the bot to be. i.e. online, afk, etc.\n            activity: The activity for the bot to be displayed as doing.\n\n        !!! note\n            Bots may only be `playing` `streaming` `listening` `watching` or `competing`, other activity types are likely to fail.\n\n        \"\"\"\n        await self._connection_state.change_presence(status, activity)\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.logger","title":"<code>logger = logger</code>  <code>instance-attribute</code>","text":"<p>The logger NAFF should use. Do not use in combination with <code>Client.basic_logging</code> and <code>Client.logging_level</code>.</p> <p>Note</p> <p>Different loggers with multiple clients are not supported</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.sync_interactions","title":"<code>sync_interactions: bool = sync_interactions</code>  <code>instance-attribute</code>","text":"<p>Should application commands be synced</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.del_unused_app_cmd","title":"<code>del_unused_app_cmd: bool = delete_unused_application_cmds</code>  <code>instance-attribute</code>","text":"<p>Should unused application commands be deleted?</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.sync_ext","title":"<code>sync_ext: bool = sync_ext</code>  <code>instance-attribute</code>","text":"<p>Should we sync whenever a extension is (un)loaded</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.debug_scope","title":"<code>debug_scope = to_snowflake(debug_scope) if debug_scope is not MISSING else MISSING</code>  <code>instance-attribute</code>","text":"<p>Sync global commands as guild for quicker command updates during debug</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.default_prefix","title":"<code>default_prefix = default_prefix</code>  <code>instance-attribute</code>","text":"<p>The default prefix to be used for prefixed commands</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.send_command_tracebacks","title":"<code>send_command_tracebacks: bool = send_command_tracebacks</code>  <code>instance-attribute</code>","text":"<p>Should the traceback of command errors be sent in reply to the command invocation</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.auto_defer","title":"<code>auto_defer = auto_defer</code>  <code>instance-attribute</code>","text":"<p>A system to automatically defer commands after a set duration</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.http","title":"<code>http: HTTPClient = HTTPClient(logger=self.logger)</code>  <code>instance-attribute</code>","text":"<p>The HTTP client to use when interacting with discord endpoints</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.interaction_context","title":"<code>interaction_context: Type[InteractionContext] = interaction_context</code>  <code>instance-attribute</code>","text":"<p>The object to instantiate for Interaction Context</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.prefixed_context","title":"<code>prefixed_context: Type[PrefixedContext] = prefixed_context</code>  <code>instance-attribute</code>","text":"<p>The object to instantiate for Prefixed Context</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.component_context","title":"<code>component_context: Type[ComponentContext] = component_context</code>  <code>instance-attribute</code>","text":"<p>The object to instantiate for Component Context</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.autocomplete_context","title":"<code>autocomplete_context: Type[AutocompleteContext] = autocomplete_context</code>  <code>instance-attribute</code>","text":"<p>The object to instantiate for Autocomplete Context</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.modal_context","title":"<code>modal_context: Type[ModalContext] = modal_context</code>  <code>instance-attribute</code>","text":"<p>The object to instantiate for Modal Context</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.hybrid_context","title":"<code>hybrid_context: Type[HybridContext] = hybrid_context</code>  <code>instance-attribute</code>","text":"<p>The object to instantiate for Hybrid Context</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.guild_event_timeout","title":"<code>guild_event_timeout = 3</code>  <code>instance-attribute</code>","text":"<p>How long to wait for guilds to be cached</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.fetch_members","title":"<code>fetch_members = fetch_members</code>  <code>instance-attribute</code>","text":"<p>Fetch the full members list of all guilds on startup</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.prefixed_commands","title":"<code>prefixed_commands: Dict[str, PrefixedCommand] = {}</code>  <code>instance-attribute</code>","text":"<p>A dictionary of registered prefixed commands: <code>{name: command}</code></p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.interactions","title":"<code>interactions: Dict[Snowflake_Type, Dict[str, InteractionCommand]] = {}</code>  <code>instance-attribute</code>","text":"<p>A dictionary of registered application commands: <code>{cmd_id: command}</code></p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.interaction_tree","title":"<code>interaction_tree: Dict[Snowflake_Type, Dict[str, InteractionCommand | Dict[str, InteractionCommand]]] = {}</code>  <code>instance-attribute</code>","text":"<p>A dictionary of registered application commands in a tree</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.ext","title":"<code>ext = {}</code>  <code>instance-attribute</code>","text":"<p>A dictionary of mounted ext</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.async_startup_tasks","title":"<code>async_startup_tasks: list[Coroutine] = []</code>  <code>instance-attribute</code>","text":"<p>A list of coroutines to run during startup</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.is_closed","title":"<code>is_closed: bool</code>  <code>property</code>","text":"<p>Returns True if the bot has closed.</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.is_ready","title":"<code>is_ready: bool</code>  <code>property</code>","text":"<p>Returns True if the bot is ready.</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.latency","title":"<code>latency: float</code>  <code>property</code>","text":"<p>Returns the latency of the websocket connection.</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.average_latency","title":"<code>average_latency: float</code>  <code>property</code>","text":"<p>Returns the average latency of the websocket connection.</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.start_time","title":"<code>start_time: datetime</code>  <code>property</code>","text":"<p>The start time of the bot.</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.gateway_started","title":"<code>gateway_started: bool</code>  <code>property</code>","text":"<p>Returns if the gateway has been started.</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.user","title":"<code>user: NaffUser</code>  <code>property</code>","text":"<p>Returns the bot's user.</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.app","title":"<code>app: Application</code>  <code>property</code>","text":"<p>Returns the bots application.</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.owner","title":"<code>owner: Optional[User]</code>  <code>property</code>","text":"<p>Returns the bot's owner'.</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.owners","title":"<code>owners: List[User]</code>  <code>property</code>","text":"<p>Returns the bot's owners as declared via <code>client.owner_ids</code>.</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.guilds","title":"<code>guilds: List[Guild]</code>  <code>property</code>","text":"<p>Returns a list of all guilds the bot is in.</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.status","title":"<code>status: Status</code>  <code>property</code>","text":"<p>Get the status of the bot.</p> <p>IE online, afk, dnd</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.activity","title":"<code>activity: Activity</code>  <code>property</code>","text":"<p>Get the activity of the bot.</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.application_commands","title":"<code>application_commands: List[InteractionCommand]</code>  <code>property</code>","text":"<p>A list of all application commands registered within the bot.</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.ws","title":"<code>ws: GatewayClient</code>  <code>property</code>","text":"<p>Returns the websocket client.</p>"},{"location":"API%20Reference/Client/#naff.client.client.Client.generate_prefixes","title":"<code>generate_prefixes(bot, message)</code>  <code>async</code>","text":"<p>A method to get the bot's default_prefix, can be overridden to add dynamic prefixes.</p> <p>Note</p> <p>To easily override this method, simply use the <code>generate_prefixes</code> parameter when instantiating the client</p> <p>Parameters:</p> Name Type Description Default <code>bot</code> <code>Client</code> <p>A reference to the client</p> required <code>message</code> <code>Message</code> <p>A message to determine the prefix from.</p> required Example <pre><code>async def generate_prefixes(bot, message):\n    if message.guild.id == 870046872864165888:\n        return [\"!\"]\n    return bot.default_prefix\n\nbot = Client(generate_prefixes=generate_prefixes, ...)\n</code></pre> <p>Returns:</p> Type Description <code>str | Iterable[str]</code> <p>A string or an iterable of strings to use as a prefix. By default, this will return <code>client.default_prefix</code></p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def generate_prefixes(self, bot: \"Client\", message: Message) -&gt; str | Iterable[str]:\n\"\"\"\n    A method to get the bot's default_prefix, can be overridden to add dynamic prefixes.\n\n    !!! note\n        To easily override this method, simply use the `generate_prefixes` parameter when instantiating the client\n\n    Args:\n        bot: A reference to the client\n        message: A message to determine the prefix from.\n\n    Example:\n        ```python\n        async def generate_prefixes(bot, message):\n            if message.guild.id == 870046872864165888:\n                return [\"!\"]\n            return bot.default_prefix\n\n        bot = Client(generate_prefixes=generate_prefixes, ...)\n        ```\n\n    Returns:\n        A string or an iterable of strings to use as a prefix. By default, this will return `client.default_prefix`\n\n    \"\"\"\n    return self.default_prefix\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.default_error_handler","title":"<code>default_error_handler(source, error)</code>  <code>staticmethod</code>","text":"<p>The default error logging behaviour.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The source of this error</p> required <code>error</code> <code>BaseException</code> <p>The exception itself</p> required Source code in <code>naff\\client\\client.py</code> <pre><code>@staticmethod\ndef default_error_handler(source: str, error: BaseException) -&gt; None:\n\"\"\"\n    The default error logging behaviour.\n\n    Args:\n        source: The source of this error\n        error: The exception itself\n\n    \"\"\"\n    out = traceback.format_exception(error)\n\n    if isinstance(error, HTTPException):\n        # HTTPException's are of 3 known formats, we can parse them for human readable errors\n        try:\n            out = [str(error)]\n        except Exception:  # noqa : S110\n            pass\n\n    get_logger().error(\n        \"Ignoring exception in {}:{}{}\".format(source, \"\\n\" if len(out) &gt; 1 else \" \", \"\".join(out)),\n    )\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.on_error","title":"<code>on_error(event)</code>  <code>async</code>","text":"<p>Catches all errors dispatched by the library.</p> <p>By default it will format and print them to console.</p> <p>Listen to the <code>Error</code> event to overwrite this behaviour.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>@Listener.create(is_default_listener=True)\nasync def on_error(self, event: events.Error) -&gt; None:\n\"\"\"\n    Catches all errors dispatched by the library.\n\n    By default it will format and print them to console.\n\n    Listen to the `Error` event to overwrite this behaviour.\n\n    \"\"\"\n    self.default_error_handler(event.source, event.error)\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.on_command_error","title":"<code>on_command_error(event)</code>  <code>async</code>","text":"<p>Catches all errors dispatched by commands.</p> <p>By default it will dispatch the <code>Error</code> event.</p> <p>Listen to the <code>CommandError</code> event to overwrite this behaviour.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>@Listener.create(is_default_listener=True)\nasync def on_command_error(self, event: events.CommandError) -&gt; None:\n\"\"\"\n    Catches all errors dispatched by commands.\n\n    By default it will dispatch the `Error` event.\n\n    Listen to the `CommandError` event to overwrite this behaviour.\n\n    \"\"\"\n    self.dispatch(\n        events.Error(\n            source=f\"cmd `/{event.ctx.invoke_target}`\",\n            error=event.error,\n            args=event.args,\n            kwargs=event.kwargs,\n            ctx=event.ctx,\n        )\n    )\n    try:\n        if isinstance(event.error, errors.CommandOnCooldown):\n            await event.ctx.send(\n                embeds=Embed(\n                    description=f\"This command is on cooldown!\\n\"\n                    f\"Please try again in {int(event.error.cooldown.get_cooldown_time())} seconds\",\n                    color=BrandColors.FUCHSIA,\n                )\n            )\n        elif isinstance(event.error, errors.MaxConcurrencyReached):\n            await event.ctx.send(\n                embeds=Embed(\n                    description=\"This command has reached its maximum concurrent usage!\\n\"\n                    \"Please try again shortly.\",\n                    color=BrandColors.FUCHSIA,\n                )\n            )\n        elif isinstance(event.error, errors.CommandCheckFailure):\n            await event.ctx.send(\n                embeds=Embed(\n                    description=\"You do not have permission to run this command!\",\n                    color=BrandColors.YELLOW,\n                )\n            )\n        elif self.send_command_tracebacks:\n            out = \"\".join(traceback.format_exception(event.error))\n            if self.http.token is not None:\n                out = out.replace(self.http.token, \"[REDACTED TOKEN]\")\n            await event.ctx.send(\n                embeds=Embed(\n                    title=f\"Error: {type(event.error).__name__}\",\n                    color=BrandColors.RED,\n                    description=f\"```\\n{out[:EMBED_MAX_DESC_LENGTH-8]}```\",\n                )\n            )\n    except errors.NaffException:\n        pass\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.on_command_completion","title":"<code>on_command_completion(event)</code>  <code>async</code>","text":"<p>Called after any command is ran.</p> <p>By default, it will simply log the command.</p> <p>Listen to the <code>CommandCompletion</code> event to overwrite this behaviour.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>@Listener.create(is_default_listener=True)\nasync def on_command_completion(self, event: events.CommandCompletion) -&gt; None:\n\"\"\"\n    Called *after* any command is ran.\n\n    By default, it will simply log the command.\n\n    Listen to the `CommandCompletion` event to overwrite this behaviour.\n\n    \"\"\"\n    if isinstance(event.ctx, PrefixedContext):\n        symbol = \"@\"\n    elif isinstance(event.ctx, InteractionContext):\n        symbol = \"/\"\n    elif isinstance(event.ctx, HybridContext):\n        symbol = \"@/\"\n    else:\n        symbol = \"?\"  # likely custom context\n    self.logger.info(\n        f\"Command Called: {symbol}{event.ctx.invoke_target} with {event.ctx.args = } | {event.ctx.kwargs = }\"\n    )\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.on_component_error","title":"<code>on_component_error(event)</code>  <code>async</code>","text":"<p>Catches all errors dispatched by components.</p> <p>By default it will dispatch the <code>Error</code> event.</p> <p>Listen to the <code>ComponentError</code> event to overwrite this behaviour.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>@Listener.create(is_default_listener=True)\nasync def on_component_error(self, event: events.ComponentError) -&gt; None:\n\"\"\"\n    Catches all errors dispatched by components.\n\n    By default it will dispatch the `Error` event.\n\n    Listen to the `ComponentError` event to overwrite this behaviour.\n\n    \"\"\"\n    self.dispatch(\n        events.Error(\n            source=f\"Component Callback for {event.ctx.custom_id}\",\n            error=event.error,\n            args=event.args,\n            kwargs=event.kwargs,\n            ctx=event.ctx,\n        )\n    )\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.on_component_completion","title":"<code>on_component_completion(event)</code>  <code>async</code>","text":"<p>Called after any component callback is ran.</p> <p>By default, it will simply log the component use.</p> <p>Listen to the <code>ComponentCompletion</code> event to overwrite this behaviour.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>@Listener.create(is_default_listener=True)\nasync def on_component_completion(self, event: events.ComponentCompletion) -&gt; None:\n\"\"\"\n    Called *after* any component callback is ran.\n\n    By default, it will simply log the component use.\n\n    Listen to the `ComponentCompletion` event to overwrite this behaviour.\n\n    \"\"\"\n    symbol = \"\u00a2\"\n    self.logger.info(\n        f\"Component Called: {symbol}{event.ctx.invoke_target} with {event.ctx.args = } | {event.ctx.kwargs = }\"\n    )\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.on_autocomplete_error","title":"<code>on_autocomplete_error(event)</code>  <code>async</code>","text":"<p>Catches all errors dispatched by autocompletion options.</p> <p>By default it will dispatch the <code>Error</code> event.</p> <p>Listen to the <code>AutocompleteError</code> event to overwrite this behaviour.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>@Listener.create(is_default_listener=True)\nasync def on_autocomplete_error(self, event: events.AutocompleteError) -&gt; None:\n\"\"\"\n    Catches all errors dispatched by autocompletion options.\n\n    By default it will dispatch the `Error` event.\n\n    Listen to the `AutocompleteError` event to overwrite this behaviour.\n\n    \"\"\"\n    self.dispatch(\n        events.Error(\n            source=f\"Autocomplete Callback for /{event.ctx.invoke_target} - Option: {event.ctx.focussed_option}\",\n            error=event.error,\n            args=event.args,\n            kwargs=event.kwargs,\n            ctx=event.ctx,\n        )\n    )\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.on_autocomplete_completion","title":"<code>on_autocomplete_completion(event)</code>  <code>async</code>","text":"<p>Called after any autocomplete callback is ran.</p> <p>By default, it will simply log the autocomplete callback.</p> <p>Listen to the <code>AutocompleteCompletion</code> event to overwrite this behaviour.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>@Listener.create(is_default_listener=True)\nasync def on_autocomplete_completion(self, event: events.AutocompleteCompletion) -&gt; None:\n\"\"\"\n    Called *after* any autocomplete callback is ran.\n\n    By default, it will simply log the autocomplete callback.\n\n    Listen to the `AutocompleteCompletion` event to overwrite this behaviour.\n\n    \"\"\"\n    symbol = \"$\"\n    self.logger.info(\n        f\"Autocomplete Called: {symbol}{event.ctx.invoke_target} with {event.ctx.focussed_option = } | {event.ctx.kwargs = }\"\n    )\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.on_modal_error","title":"<code>on_modal_error(event)</code>  <code>async</code>","text":"<p>Catches all errors dispatched by modals.</p> <p>By default it will dispatch the <code>Error</code> event.</p> <p>Listen to the <code>ModalError</code> event to overwrite this behaviour.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>@Listener.create(is_default_listener=True)\nasync def on_modal_error(self, event: events.ModalError) -&gt; None:\n\"\"\"\n    Catches all errors dispatched by modals.\n\n    By default it will dispatch the `Error` event.\n\n    Listen to the `ModalError` event to overwrite this behaviour.\n\n    \"\"\"\n    self.dispatch(\n        events.Error(\n            source=f\"Modal Callback for custom_id {event.ctx.custom_id}\",\n            error=event.error,\n            args=event.args,\n            kwargs=event.kwargs,\n            ctx=event.ctx,\n        )\n    )\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.on_modal_completion","title":"<code>on_modal_completion(event)</code>  <code>async</code>","text":"<p>Called after any modal callback is ran.</p> <p>By default, it will simply log the modal callback.</p> <p>Listen to the <code>ModalCompletion</code> event to overwrite this behaviour.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>@Listener.create(is_default_listener=True)\nasync def on_modal_completion(self, event: events.ModalCompletion) -&gt; None:\n\"\"\"\n    Called *after* any modal callback is ran.\n\n    By default, it will simply log the modal callback.\n\n    Listen to the `ModalCompletion` event to overwrite this behaviour.\n\n    \"\"\"\n    self.logger.info(f\"Modal Called: {event.ctx.custom_id = } with {event.ctx.responses = }\")\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.login","title":"<code>login(token)</code>  <code>async</code>","text":"<p>Login to discord via http.</p> <p>Note</p> <p>You will need to run Naff.start_gateway() before you start receiving gateway events.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Your bot's token</p> required Source code in <code>naff\\client\\client.py</code> <pre><code>async def login(self, token) -&gt; None:\n\"\"\"\n    Login to discord via http.\n\n    !!! note\n        You will need to run Naff.start_gateway() before you start receiving gateway events.\n\n    Args:\n        token str: Your bot's token\n\n    \"\"\"\n    # i needed somewhere to put this call,\n    # login will always run after initialisation\n    # so im gathering commands here\n    self._gather_commands()\n\n    self.logger.debug(\"Attempting to login\")\n    me = await self.http.login(token.strip())\n    self._user = NaffUser.from_dict(me, self)\n    self.cache.place_user_data(me)\n    self._app = Application.from_dict(await self.http.get_current_bot_information(), self)\n    self._mention_reg = re.compile(rf\"^(&lt;@!?{self.user.id}*&gt;\\s)\")\n\n    if self.app.owner:\n        self.owner_ids.add(self.app.owner.id)\n\n    self.dispatch(events.Login())\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.astart","title":"<code>astart(token)</code>  <code>async</code>","text":"<p>Asynchronous method to start the bot.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Your bot's token</p> required Source code in <code>naff\\client\\client.py</code> <pre><code>async def astart(self, token: str) -&gt; None:\n\"\"\"\n    Asynchronous method to start the bot.\n\n    Args:\n        token: Your bot's token\n    \"\"\"\n    await self.login(token)\n\n    # run any pending startup tasks\n    if self.async_startup_tasks:\n        try:\n            await asyncio.gather(*self.async_startup_tasks)\n        except Exception as e:\n            self.dispatch(events.Error(source=\"async-extension-loader\", error=e))\n    try:\n        await self._connection_state.start()\n    finally:\n        await self.stop()\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.start","title":"<code>start(token)</code>","text":"<p>Start the bot.</p> info <p>This is the recommended method to start the bot</p> Source code in <code>naff\\client\\client.py</code> <pre><code>def start(self, token: str) -&gt; None:\n\"\"\"\n    Start the bot.\n\n    info:\n        This is the recommended method to start the bot\n    \"\"\"\n    try:\n        asyncio.run(self.astart(token))\n    except KeyboardInterrupt:\n        # ignore, cus this is useless and can be misleading to the\n        # user\n        pass\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.start_gateway","title":"<code>start_gateway()</code>  <code>async</code>","text":"<p>Starts the gateway connection.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def start_gateway(self) -&gt; None:\n\"\"\"Starts the gateway connection.\"\"\"\n    try:\n        await self._connection_state.start()\n    finally:\n        await self.stop()\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Shutdown the bot.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Shutdown the bot.\"\"\"\n    self.logger.debug(\"Stopping the bot.\")\n    self._ready.clear()\n    await self.http.close()\n    await self._connection_state.stop()\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.dispatch","title":"<code>dispatch(event, *args, **kwargs)</code>","text":"<p>Dispatch an event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>events.BaseEvent</code> <p>The event to be dispatched.</p> required Source code in <code>naff\\client\\client.py</code> <pre><code>def dispatch(self, event: events.BaseEvent, *args, **kwargs) -&gt; None:\n\"\"\"\n    Dispatch an event.\n\n    Args:\n        event: The event to be dispatched.\n\n    \"\"\"\n    listeners = self.listeners.get(event.resolved_name, [])\n    if listeners:\n        self.logger.debug(f\"Dispatching Event: {event.resolved_name}\")\n        event.bot = self\n        for _listen in listeners:\n            try:\n                self._queue_task(_listen, event, *args, **kwargs)\n            except Exception as e:\n                raise BotException(\n                    f\"An error occurred attempting during {event.resolved_name} event processing\"\n                ) from e\n\n    _waits = self.waits.get(event.resolved_name, [])\n    if _waits:\n        index_to_remove = []\n        for i, _wait in enumerate(_waits):\n            result = _wait(event)\n            if result:\n                index_to_remove.append(i)\n\n        for idx in sorted(index_to_remove, reverse=True):\n            _waits.pop(idx)\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.wait_until_ready","title":"<code>wait_until_ready()</code>  <code>async</code>","text":"<p>Waits for the client to become ready.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def wait_until_ready(self) -&gt; None:\n\"\"\"Waits for the client to become ready.\"\"\"\n    await self._ready.wait()\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.wait_for","title":"<code>wait_for(event, checks=MISSING, timeout=None)</code>","text":"<p>Waits for a WebSocket event to be dispatched.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Union[str, BaseEvent]</code> <p>The name of event to wait.</p> required <code>checks</code> <code>Absent[Optional[Callable[..., bool]]]</code> <p>A predicate to check what to wait for.</p> <code>MISSING</code> <code>timeout</code> <code>Optional[float]</code> <p>The number of seconds to wait before timing out.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The event object.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>def wait_for(\n    self,\n    event: Union[str, \"BaseEvent\"],\n    checks: Absent[Optional[Callable[..., bool]]] = MISSING,\n    timeout: Optional[float] = None,\n) -&gt; Any:\n\"\"\"\n    Waits for a WebSocket event to be dispatched.\n\n    Args:\n        event: The name of event to wait.\n        checks: A predicate to check what to wait for.\n        timeout: The number of seconds to wait before timing out.\n\n    Returns:\n        The event object.\n\n    \"\"\"\n    event = get_event_name(event)\n\n    if event not in self.waits:\n        self.waits[event] = []\n\n    future = asyncio.Future()\n    self.waits[event].append(Wait(event, checks, future))\n\n    return asyncio.wait_for(future, timeout)\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.wait_for_modal","title":"<code>wait_for_modal(modal, author=None, timeout=None)</code>  <code>async</code>","text":"<p>Wait for a modal response.</p> <p>Parameters:</p> Name Type Description Default <code>modal</code> <code>Modal</code> <p>The modal we're waiting for.</p> required <code>author</code> <code>Optional[Snowflake_Type]</code> <p>The user we're waiting for to reply</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>A timeout in seconds to stop waiting</p> <code>None</code> <p>Returns:</p> Type Description <code>ModalContext</code> <p>The context of the modal response</p> <p>Raises:</p> Type Description <code>asyncio.TimeoutError</code> <p>if no response is received that satisfies the predicate before timeout seconds have passed</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def wait_for_modal(\n    self,\n    modal: \"Modal\",\n    author: Optional[\"Snowflake_Type\"] = None,\n    timeout: Optional[float] = None,\n) -&gt; ModalContext:\n\"\"\"\n    Wait for a modal response.\n\n    Args:\n        modal: The modal we're waiting for.\n        author: The user we're waiting for to reply\n        timeout: A timeout in seconds to stop waiting\n\n    Returns:\n        The context of the modal response\n\n    Raises:\n        asyncio.TimeoutError: if no response is received that satisfies the predicate before timeout seconds have passed\n\n    \"\"\"\n    author = to_snowflake(author) if author else None\n\n    def predicate(event) -&gt; bool:\n        if modal.custom_id != event.ctx.custom_id:\n            return False\n        if author and author != to_snowflake(event.ctx.author):\n            return False\n        return True\n\n    resp = await self.wait_for(\"modal_completion\", predicate, timeout)\n    return resp.ctx\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.wait_for_component","title":"<code>wait_for_component(messages=None, components=None, check=None, timeout=None)</code>  <code>async</code>","text":"<p>Waits for a component to be sent to the bot.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[Message, int, list]</code> <p>The message object to check for.</p> <code>None</code> <code>components</code> <code>Optional[Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict]]</code> <p>The components to wait for.</p> <code>None</code> <code>check</code> <code>Optional[Callable]</code> <p>A predicate to check what to wait for.</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>The number of seconds to wait before timing out.</p> <code>None</code> <p>Returns:</p> Type Description <code>Component</code> <p><code>Component</code> that was invoked. Use <code>.ctx</code> to get the <code>ComponentContext</code>.</p> <p>Raises:</p> Type Description <code>asyncio.TimeoutError</code> <p>if timed out</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def wait_for_component(\n    self,\n    messages: Union[Message, int, list] = None,\n    components: Optional[\n        Union[List[List[Union[\"BaseComponent\", dict]]], List[Union[\"BaseComponent\", dict]], \"BaseComponent\", dict]\n    ] = None,\n    check: Optional[Callable] = None,\n    timeout: Optional[float] = None,\n) -&gt; \"Component\":\n\"\"\"\n    Waits for a component to be sent to the bot.\n\n    Args:\n        messages: The message object to check for.\n        components: The components to wait for.\n        check: A predicate to check what to wait for.\n        timeout: The number of seconds to wait before timing out.\n\n    Returns:\n        `Component` that was invoked. Use `.ctx` to get the `ComponentContext`.\n\n    Raises:\n        asyncio.TimeoutError: if timed out\n\n    \"\"\"\n    if not (messages or components):\n        raise ValueError(\"You must specify messages or components (or both)\")\n\n    message_ids = (\n        to_snowflake_list(messages) if isinstance(messages, list) else to_snowflake(messages) if messages else None\n    )\n    custom_ids = list(get_components_ids(components)) if components else None\n\n    # automatically convert improper custom_ids\n    if custom_ids and not all(isinstance(x, str) for x in custom_ids):\n        custom_ids = [str(i) for i in custom_ids]\n\n    def _check(event: Component) -&gt; bool:\n        ctx: ComponentContext = event.ctx\n        # if custom_ids is empty or there is a match\n        wanted_message = not message_ids or ctx.message.id in (\n            [message_ids] if isinstance(message_ids, int) else message_ids\n        )\n        wanted_component = not custom_ids or ctx.custom_id in custom_ids\n        if wanted_message and wanted_component:\n            if check is None or check(event):\n                return True\n            return False\n        return False\n\n    return await self.wait_for(\"component\", checks=_check, timeout=timeout)\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.listen","title":"<code>listen(event_name=MISSING)</code>","text":"<p>A decorator to be used in situations that Naff can't automatically hook your listeners. Ideally, the standard listen decorator should be used, not this.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>Absent[str]</code> <p>The event name to use, if not the coroutine name</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Listener</code> <p>A listener that can be used to hook into the event.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>def listen(self, event_name: Absent[str] = MISSING) -&gt; Listener:\n\"\"\"\n    A decorator to be used in situations that Naff can't automatically hook your listeners. Ideally, the standard listen decorator should be used, not this.\n\n    Args:\n        event_name: The event name to use, if not the coroutine name\n\n    Returns:\n        A listener that can be used to hook into the event.\n\n    \"\"\"\n\n    def wrapper(coro: Callable[..., Coroutine]) -&gt; Listener:\n        listener = Listener.create(event_name)(coro)\n        self.add_listener(listener)\n        return listener\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.add_event_processor","title":"<code>add_event_processor(event_name=MISSING)</code>","text":"<p>A decorator to be used to add event processors.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>Absent[str]</code> <p>The event name to use, if not the coroutine name</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Callable[..., Coroutine]</code> <p>A function that can be used to hook into the event.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>def add_event_processor(self, event_name: Absent[str] = MISSING) -&gt; Callable[..., Coroutine]:\n\"\"\"\n    A decorator to be used to add event processors.\n\n    Args:\n        event_name: The event name to use, if not the coroutine name\n\n    Returns:\n        A function that can be used to hook into the event.\n\n    \"\"\"\n\n    def wrapper(coro: Callable[..., Coroutine]) -&gt; Callable[..., Coroutine]:\n        name = event_name\n        if name is MISSING:\n            name = coro.__name__\n        name = name.lstrip(\"_\")\n        name = name.removeprefix(\"on_\")\n        self.processors[name] = coro\n        return coro\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.add_listener","title":"<code>add_listener(listener)</code>","text":"<p>Add a listener for an event, if no event is passed, one is determined.</p> <p>Parameters:</p> Name Type Description Default <code>listener</code> <code>Listener</code> <p>The listener to add to the client</p> required Source code in <code>naff\\client\\client.py</code> <pre><code>def add_listener(self, listener: Listener) -&gt; None:\n\"\"\"\n    Add a listener for an event, if no event is passed, one is determined.\n\n    Args:\n        listener Listener: The listener to add to the client\n\n    \"\"\"\n    if not listener.is_default_listener:\n        # check that the required intents are enabled\n\n        event_class_name = \"\".join([name.capitalize() for name in listener.event.split(\"_\")])\n        if event_class := globals().get(event_class_name):\n            if required_intents := _INTENT_EVENTS.get(event_class):  # noqa\n                if not any(required_intent in self.intents for required_intent in required_intents):\n                    self.logger.warning(\n                        f\"Event `{listener.event}` will not work since the required intent is not set -&gt; Requires any of: `{required_intents}`\"\n                    )\n\n    if listener.event not in self.listeners:\n        self.listeners[listener.event] = []\n    self.listeners[listener.event].append(listener)\n\n    # check if other listeners are to be deleted\n    default_listeners = [c_listener.is_default_listener for c_listener in self.listeners[listener.event]]\n    removes_defaults = [c_listener.disable_default_listeners for c_listener in self.listeners[listener.event]]\n\n    if any(default_listeners) and any(removes_defaults):\n        self.listeners[listener.event] = [\n            c_listener for c_listener in self.listeners[listener.event] if not c_listener.is_default_listener\n        ]\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.add_interaction","title":"<code>add_interaction(command)</code>","text":"<p>Add a slash command to the client.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>InteractionCommand</code> <p>The command to add</p> required Source code in <code>naff\\client\\client.py</code> <pre><code>def add_interaction(self, command: InteractionCommand) -&gt; bool:\n\"\"\"\n    Add a slash command to the client.\n\n    Args:\n        command InteractionCommand: The command to add\n\n    \"\"\"\n    if self.debug_scope:\n        command.scopes = [self.debug_scope]\n\n    if self.disable_dm_commands:\n        command.dm_permission = False\n\n    # for SlashCommand objs without callback (like objects made to hold group info etc)\n    if command.callback is None:\n        return False\n\n    base, group, sub, *_ = command.resolved_name.split(\" \") + [None, None]\n\n    for scope in command.scopes:\n        if scope not in self.interactions:\n            self.interactions[scope] = {}\n        elif command.resolved_name in self.interactions[scope]:\n            old_cmd = self.interactions[scope][command.resolved_name]\n            raise ValueError(f\"Duplicate Command! {scope}::{old_cmd.resolved_name}\")\n\n        if self.enforce_interaction_perms:\n            command.checks.append(command._permission_enforcer)  # noqa : w0212\n\n        self.interactions[scope][command.resolved_name] = command\n\n        if scope not in self.interaction_tree:\n            self.interaction_tree[scope] = {}\n\n        if group is None or isinstance(command, ContextMenu):\n            self.interaction_tree[scope][command.resolved_name] = command\n        elif group is not None:\n            if not (current := self.interaction_tree[scope].get(base)) or isinstance(current, SlashCommand):\n                self.interaction_tree[scope][base] = {}\n            if sub is None:\n                self.interaction_tree[scope][base][group] = command\n            else:\n                if not (current := self.interaction_tree[scope][base].get(group)) or isinstance(\n                    current, SlashCommand\n                ):\n                    self.interaction_tree[scope][base][group] = {}\n                self.interaction_tree[scope][base][group][sub] = command\n\n    return True\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.add_prefixed_command","title":"<code>add_prefixed_command(command)</code>","text":"<p>Add a prefixed command to the client.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>PrefixedCommand</code> <p>The command to add</p> required Source code in <code>naff\\client\\client.py</code> <pre><code>def add_prefixed_command(self, command: PrefixedCommand) -&gt; None:\n\"\"\"\n    Add a prefixed command to the client.\n\n    Args:\n        command PrefixedCommand: The command to add\n\n    \"\"\"\n    # check that the required intent is enabled or the prefix is a mention\n    prefixes = (\n        self.default_prefix\n        if not isinstance(self.default_prefix, str) and not self.default_prefix == MENTION_PREFIX\n        else (self.default_prefix,)\n    )\n    if (MENTION_PREFIX not in prefixes) and (Intents.GUILD_MESSAGE_CONTENT not in self.intents):\n        self.logger.warning(\n            f\"Prefixed commands will not work since the required intent is not set -&gt; Requires: `{Intents.GUILD_MESSAGE_CONTENT.__repr__()}` or usage of the default `MENTION_PREFIX` as the prefix\"\n        )\n\n    command._parse_parameters()\n\n    if self.prefixed_commands.get(command.name):\n        raise ValueError(f\"Duplicate command! Multiple commands share the name/alias: {command.name}.\")\n    self.prefixed_commands[command.name] = command\n\n    for alias in command.aliases:\n        if self.prefixed_commands.get(alias):\n            raise ValueError(f\"Duplicate command! Multiple commands share the name/alias: {alias}.\")\n        self.prefixed_commands[alias] = command\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.add_component_callback","title":"<code>add_component_callback(command)</code>","text":"<p>Add a component callback to the client.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>ComponentCommand</code> <p>The command to add</p> required Source code in <code>naff\\client\\client.py</code> <pre><code>def add_component_callback(self, command: ComponentCommand) -&gt; None:\n\"\"\"\n    Add a component callback to the client.\n\n    Args:\n        command: The command to add\n\n    \"\"\"\n    for listener in command.listeners:\n        # I know this isn't an ideal solution, but it means we can lookup callbacks with O(1)\n        if listener not in self._component_callbacks.keys():\n            self._component_callbacks[listener] = command\n            continue\n        else:\n            raise ValueError(f\"Duplicate Component! Multiple component callbacks for `{listener}`\")\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.add_modal_callback","title":"<code>add_modal_callback(command)</code>","text":"<p>Add a modal callback to the client.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>ModalCommand</code> <p>The command to add</p> required Source code in <code>naff\\client\\client.py</code> <pre><code>def add_modal_callback(self, command: ModalCommand) -&gt; None:\n\"\"\"\n    Add a modal callback to the client.\n\n    Args:\n        command: The command to add\n    \"\"\"\n    for listener in command.listeners:\n        if listener not in self._modal_callbacks.keys():\n            self._modal_callbacks[listener] = command\n            continue\n        else:\n            raise ValueError(f\"Duplicate Component! Multiple modal callbacks for `{listener}`\")\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.synchronise_interactions","title":"<code>synchronise_interactions(*, scopes=MISSING, delete_commands=MISSING)</code>  <code>async</code>","text":"<p>Synchronise registered interactions with discord.</p> <p>Parameters:</p> Name Type Description Default <code>scopes</code> <code>Sequence[Snowflake_Type]</code> <p>Optionally specify which scopes are to be synced</p> <code>MISSING</code> <code>delete_commands</code> <code>Absent[bool]</code> <p>Override the client setting and delete commands</p> <code>MISSING</code> Source code in <code>naff\\client\\client.py</code> <pre><code>async def synchronise_interactions(\n    self, *, scopes: Sequence[\"Snowflake_Type\"] = MISSING, delete_commands: Absent[bool] = MISSING\n) -&gt; None:\n\"\"\"\n    Synchronise registered interactions with discord.\n\n    Args:\n        scopes: Optionally specify which scopes are to be synced\n        delete_commands: Override the client setting and delete commands\n    \"\"\"\n    s = time.perf_counter()\n    _delete_cmds = self.del_unused_app_cmd if delete_commands is MISSING else delete_commands\n    await self._cache_interactions()\n\n    if scopes is not MISSING:\n        cmd_scopes = scopes\n    elif self.del_unused_app_cmd:\n        # if we're deleting unused commands, we check all scopes\n        cmd_scopes = [to_snowflake(g_id) for g_id in self._user._guild_ids] + [GLOBAL_SCOPE]\n    else:\n        # if we're not deleting, just check the scopes we have cmds registered in\n        cmd_scopes = list(set(self.interactions) | {GLOBAL_SCOPE})\n\n    local_cmds_json = application_commands_to_dict(self.interactions, self)\n\n    async def sync_scope(cmd_scope) -&gt; None:\n\n        sync_needed_flag = False  # a flag to force this scope to synchronise\n        sync_payload = []  # the payload to be pushed to discord\n\n        try:\n            try:\n                remote_commands = await self.http.get_application_commands(self.app.id, cmd_scope)\n            except Forbidden:\n                self.logger.warning(f\"Bot is lacking `application.commands` scope in {cmd_scope}!\")\n                return\n\n            for local_cmd in self.interactions.get(cmd_scope, {}).values():\n                # get remote equivalent of this command\n                remote_cmd_json = next(\n                    (v for v in remote_commands if int(v[\"id\"]) == local_cmd.cmd_id.get(cmd_scope)), None\n                )\n                # get json representation of this command\n                local_cmd_json = next((c for c in local_cmds_json[cmd_scope] if c[\"name\"] == str(local_cmd.name)))\n\n                # this works by adding any command we *want* on Discord, to a payload, and synchronising that\n                # this allows us to delete unused commands, add new commands, or do nothing in 1 or less API calls\n\n                if sync_needed(local_cmd_json, remote_cmd_json):\n                    # determine if the local and remote commands are out-of-sync\n                    sync_needed_flag = True\n                    sync_payload.append(local_cmd_json)\n                elif not _delete_cmds and remote_cmd_json:\n                    _remote_payload = {\n                        k: v for k, v in remote_cmd_json.items() if k not in (\"id\", \"application_id\", \"version\")\n                    }\n                    sync_payload.append(_remote_payload)\n                elif _delete_cmds:\n                    sync_payload.append(local_cmd_json)\n\n            sync_payload = [json.loads(_dump) for _dump in {json.dumps(_cmd) for _cmd in sync_payload}]\n\n            if sync_needed_flag or (_delete_cmds and len(sync_payload) &lt; len(remote_commands)):\n                # synchronise commands if flag is set, or commands are to be deleted\n                self.logger.info(f\"Overwriting {cmd_scope} with {len(sync_payload)} application commands\")\n                sync_response: list[dict] = await self.http.overwrite_application_commands(\n                    self.app.id, sync_payload, cmd_scope\n                )\n                self._cache_sync_response(sync_response, cmd_scope)\n            else:\n                self.logger.debug(f\"{cmd_scope} is already up-to-date with {len(remote_commands)} commands.\")\n\n        except Forbidden as e:\n            raise InteractionMissingAccess(cmd_scope) from e\n        except HTTPException as e:\n            self._raise_sync_exception(e, local_cmds_json, cmd_scope)\n\n    await asyncio.gather(*[sync_scope(scope) for scope in cmd_scopes])\n\n    t = time.perf_counter() - s\n    self.logger.debug(f\"Sync of {len(cmd_scopes)} scopes took {t} seconds\")\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.get_application_cmd_by_id","title":"<code>get_application_cmd_by_id(cmd_id)</code>","text":"<p>Get a application command from the internal cache by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>cmd_id</code> <code>Snowflake_Type</code> <p>The ID of the command</p> required <p>Returns:</p> Type Description <code>Optional[InteractionCommand]</code> <p>The command, if one with the given ID exists internally, otherwise None</p> Source code in <code>naff\\client\\client.py</code> <pre><code>def get_application_cmd_by_id(self, cmd_id: \"Snowflake_Type\") -&gt; Optional[InteractionCommand]:\n\"\"\"\n    Get a application command from the internal cache by its ID.\n\n    Args:\n        cmd_id: The ID of the command\n\n    Returns:\n        The command, if one with the given ID exists internally, otherwise None\n\n    \"\"\"\n    scope = self._interaction_scopes.get(str(cmd_id), MISSING)\n    cmd_id = int(cmd_id)  # ensure int ID\n    if scope != MISSING:\n        for cmd in self.interactions[scope].values():\n            if int(cmd.cmd_id.get(scope)) == cmd_id:\n                return cmd\n    return None\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.get_context","title":"<code>get_context(data, interaction=False)</code>  <code>async</code>","text":"<p>Return a context object based on data passed.</p> <p>Note</p> <p>If you want to use custom context objects, this is the method to override. Your replacement must take the same arguments as this, and return a Context-like object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>InteractionData | dict | Message</code> <p>The data of the event</p> required <code>interaction</code> <code>bool</code> <p>Is this an interaction or not?</p> <code>False</code> <p>Returns:</p> Type Description <code>ComponentContext | AutocompleteContext | ModalContext | InteractionContext | PrefixedContext</code> <p>Context object</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def get_context(\n    self, data: InteractionData | dict | Message, interaction: bool = False\n) -&gt; ComponentContext | AutocompleteContext | ModalContext | InteractionContext | PrefixedContext:\n\"\"\"\n    Return a context object based on data passed.\n\n    !!! note\n        If you want to use custom context objects, this is the method to override. Your replacement must take the same arguments as this, and return a Context-like object.\n\n    Args:\n        data: The data of the event\n        interaction: Is this an interaction or not?\n\n    Returns:\n        Context object\n\n    \"\"\"\n    # this line shuts up IDE warnings\n    cls: ComponentContext | AutocompleteContext | ModalContext | InteractionContext | PrefixedContext\n\n    if interaction:\n        match data[\"type\"]:\n            case InteractionTypes.MESSAGE_COMPONENT:\n                cls = self.component_context.from_dict(data, self)\n\n            case InteractionTypes.AUTOCOMPLETE:\n                cls = self.autocomplete_context.from_dict(data, self)\n\n            case InteractionTypes.MODAL_RESPONSE:\n                cls = self.modal_context.from_dict(data, self)\n\n            case _:\n                cls = self.interaction_context.from_dict(data, self)\n\n        if not cls.channel:\n            try:\n                cls.channel = await self.cache.fetch_channel(data[\"channel_id\"])\n            except Forbidden:\n                cls.channel = BaseChannel.from_dict_factory(\n                    {\"id\": data[\"channel_id\"], \"type\": ChannelTypes.GUILD_TEXT}, self\n                )\n\n    else:\n        cls = self.prefixed_context.from_message(self, data)\n        if not cls.channel:\n            cls.channel = await self.cache.fetch_channel(data._channel_id)\n\n    return cls\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.get_extensions","title":"<code>get_extensions(name)</code>","text":"<p>Get all ext with a name or extension name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the extension, or the name of it's extension</p> required <p>Returns:</p> Type Description <code>list[Extension]</code> <p>List of Extensions</p> Source code in <code>naff\\client\\client.py</code> <pre><code>def get_extensions(self, name: str) -&gt; list[Extension]:\n\"\"\"\n    Get all ext with a name or extension name.\n\n    Args:\n        name: The name of the extension, or the name of it's extension\n\n    Returns:\n        List of Extensions\n    \"\"\"\n    if name not in self.ext.keys():\n        return [ext for ext in self.ext.values() if ext.extension_name == name]\n\n    return [self.ext.get(name, None)]\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.get_ext","title":"<code>get_ext(name)</code>","text":"<p>Get a extension with a name or extension name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the extension, or the name of it's extension</p> required <p>Returns:</p> Type Description <code>Extension | None</code> <p>A extension, if found</p> Source code in <code>naff\\client\\client.py</code> <pre><code>def get_ext(self, name: str) -&gt; Extension | None:\n\"\"\"\n    Get a extension with a name or extension name.\n\n    Args:\n        name: The name of the extension, or the name of it's extension\n\n    Returns:\n        A extension, if found\n    \"\"\"\n    if ext := self.get_extensions(name):\n        return ext[0]\n    return None\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.load_extension","title":"<code>load_extension(name, package=None, **load_kwargs)</code>","text":"<p>Load an extension with given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the extension.</p> required <code>package</code> <code>str | None</code> <p>The package the extension is in</p> <code>None</code> <code>**load_kwargs</code> <code>Any</code> <p>The auto-filled mapping of the load keyword arguments</p> <code>{}</code> Source code in <code>naff\\client\\client.py</code> <pre><code>def load_extension(self, name: str, package: str | None = None, **load_kwargs: Any) -&gt; None:\n\"\"\"\n    Load an extension with given arguments.\n\n    Args:\n        name: The name of the extension.\n        package: The package the extension is in\n        **load_kwargs: The auto-filled mapping of the load keyword arguments\n\n    \"\"\"\n    module_name = importlib.util.resolve_name(name, package)\n    if module_name in self.__modules:\n        raise Exception(f\"{module_name} already loaded\")\n\n    module = importlib.import_module(module_name, package)\n    try:\n        setup = getattr(module, \"setup\", None)\n        if setup:\n            setup(self, **load_kwargs)\n        else:\n            self.logger.debug(\"No setup function found in %s\", module_name)\n\n            found = False\n            objects = {name: obj for name, obj in inspect.getmembers(module) if isinstance(obj, type)}\n            for obj_name, obj in objects.items():\n                if Extension in obj.__bases__:\n                    self.logger.debug(f\"Found extension class {obj_name} in {module_name}: Attempting to load\")\n                    obj(self, **load_kwargs)\n                    found = True\n            if not found:\n                raise Exception(f\"{module_name} contains no Extensions\")\n\n    except ExtensionLoadException:\n        raise\n    except Exception as e:\n        del sys.modules[module_name]\n        raise ExtensionLoadException(f\"Unexpected Error loading {module_name}\") from e\n\n    else:\n        self.logger.debug(f\"Loaded Extension: {module_name}\")\n        self.__modules[module_name] = module\n\n        if self.sync_ext and self._ready.is_set():\n            try:\n                asyncio.get_running_loop()\n            except RuntimeError:\n                return\n            asyncio.create_task(self.synchronise_interactions())\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.unload_extension","title":"<code>unload_extension(name, package=None, **unload_kwargs)</code>","text":"<p>Unload an extension with given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the extension.</p> required <code>package</code> <code>str | None</code> <p>The package the extension is in</p> <code>None</code> <code>**unload_kwargs</code> <code>Any</code> <p>The auto-filled mapping of the unload keyword arguments</p> <code>{}</code> Source code in <code>naff\\client\\client.py</code> <pre><code>def unload_extension(self, name: str, package: str | None = None, **unload_kwargs: Any) -&gt; None:\n\"\"\"\n    Unload an extension with given arguments.\n\n    Args:\n        name: The name of the extension.\n        package: The package the extension is in\n        **unload_kwargs: The auto-filled mapping of the unload keyword arguments\n\n    \"\"\"\n    name = importlib.util.resolve_name(name, package)\n    module = self.__modules.get(name)\n\n    if module is None:\n        raise ExtensionNotFound(f\"No extension called {name} is loaded\")\n\n    try:\n        teardown = getattr(module, \"teardown\")\n        teardown(**unload_kwargs)\n    except AttributeError:\n        pass\n\n    for ext in self.get_extensions(name):\n        ext.drop(**unload_kwargs)\n\n    del sys.modules[name]\n    del self.__modules[name]\n\n    if self.sync_ext and self._ready.is_set():\n        if self.sync_ext and self._ready.is_set():\n            try:\n                asyncio.get_running_loop()\n            except RuntimeError:\n                return\n            asyncio.create_task(self.synchronise_interactions())\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.reload_extension","title":"<code>reload_extension(name, package=None, *, load_kwargs=None, unload_kwargs=None)</code>","text":"<p>Helper method to reload an extension. Simply unloads, then loads the extension with given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the extension.</p> required <code>package</code> <code>str | None</code> <p>The package the extension is in</p> <code>None</code> <code>load_kwargs</code> <code>Any</code> <p>The manually-filled mapping of the load keyword arguments</p> <code>None</code> <code>unload_kwargs</code> <code>Any</code> <p>The manually-filled mapping of the unload keyword arguments</p> <code>None</code> Source code in <code>naff\\client\\client.py</code> <pre><code>def reload_extension(\n    self,\n    name: str,\n    package: str | None = None,\n    *,\n    load_kwargs: Any = None,\n    unload_kwargs: Any = None,\n) -&gt; None:\n\"\"\"\n    Helper method to reload an extension. Simply unloads, then loads the extension with given arguments.\n\n    Args:\n        name: The name of the extension.\n        package: The package the extension is in\n        load_kwargs: The manually-filled mapping of the load keyword arguments\n        unload_kwargs: The manually-filled mapping of the unload keyword arguments\n\n    \"\"\"\n    name = importlib.util.resolve_name(name, package)\n    module = self.__modules.get(name)\n\n    if module is None:\n        self.logger.warning(\"Attempted to reload extension thats not loaded. Loading extension instead\")\n        return self.load_extension(name, package)\n\n    if not load_kwargs:\n        load_kwargs = {}\n    if not unload_kwargs:\n        unload_kwargs = {}\n\n    self.unload_extension(name, package, **unload_kwargs)\n    self.load_extension(name, package, **load_kwargs)\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.fetch_guild","title":"<code>fetch_guild(guild_id)</code>  <code>async</code>","text":"<p>Fetch a guild.</p> <p>Note</p> <p>This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to get</p> required <p>Returns:</p> Type Description <code>Optional[Guild]</code> <p>Guild Object if found, otherwise None</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def fetch_guild(self, guild_id: \"Snowflake_Type\") -&gt; Optional[Guild]:\n\"\"\"\n    Fetch a guild.\n\n    !!! note\n        This method is an alias for the cache which will either return a cached object, or query discord for the object\n        if its not already cached.\n\n    Args:\n        guild_id: The ID of the guild to get\n\n    Returns:\n        Guild Object if found, otherwise None\n\n    \"\"\"\n    try:\n        return await self.cache.fetch_guild(guild_id)\n    except NotFound:\n        return None\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.get_guild","title":"<code>get_guild(guild_id)</code>","text":"<p>Get a guild.</p> <p>Note</p> <p>This method is an alias for the cache which will return a cached object.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to get</p> required <p>Returns:</p> Type Description <code>Optional[Guild]</code> <p>Guild Object if found, otherwise None</p> Source code in <code>naff\\client\\client.py</code> <pre><code>def get_guild(self, guild_id: \"Snowflake_Type\") -&gt; Optional[Guild]:\n\"\"\"\n    Get a guild.\n\n    !!! note\n        This method is an alias for the cache which will return a cached object.\n\n    Args:\n        guild_id: The ID of the guild to get\n\n    Returns:\n        Guild Object if found, otherwise None\n\n    \"\"\"\n    return self.cache.get_guild(guild_id)\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.create_guild_from_template","title":"<code>create_guild_from_template(template_code, name, icon=MISSING)</code>  <code>async</code>","text":"<p>Creates a new guild based on a template.</p> <p>Note</p> <p>This endpoint can only be used by bots in less than 10 guilds.</p> <p>Parameters:</p> Name Type Description Default <code>template_code</code> <code>Union[GuildTemplate, str]</code> <p>The code of the template to use.</p> required <code>name</code> <code>str</code> <p>The name of the guild (2-100 characters)</p> required <code>icon</code> <code>Absent[UPLOADABLE_TYPE]</code> <p>Location or File of icon to set</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Optional[Guild]</code> <p>The newly created guild object</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def create_guild_from_template(\n    self,\n    template_code: Union[\"GuildTemplate\", str],\n    name: str,\n    icon: Absent[UPLOADABLE_TYPE] = MISSING,\n) -&gt; Optional[Guild]:\n\"\"\"\n    Creates a new guild based on a template.\n\n    !!! note\n        This endpoint can only be used by bots in less than 10 guilds.\n\n    Args:\n        template_code: The code of the template to use.\n        name: The name of the guild (2-100 characters)\n        icon: Location or File of icon to set\n\n    Returns:\n        The newly created guild object\n\n    \"\"\"\n    if isinstance(template_code, GuildTemplate):\n        template_code = template_code.code\n\n    if icon:\n        icon = to_image_data(icon)\n    guild_data = await self.http.create_guild_from_guild_template(template_code, name, icon)\n    return Guild.from_dict(guild_data, self)\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.fetch_channel","title":"<code>fetch_channel(channel_id)</code>  <code>async</code>","text":"<p>Fetch a channel.</p> <p>Note</p> <p>This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel to get</p> required <p>Returns:</p> Type Description <code>Optional[TYPE_ALL_CHANNEL]</code> <p>Channel Object if found, otherwise None</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def fetch_channel(self, channel_id: \"Snowflake_Type\") -&gt; Optional[\"TYPE_ALL_CHANNEL\"]:\n\"\"\"\n    Fetch a channel.\n\n    !!! note\n        This method is an alias for the cache which will either return a cached object, or query discord for the object\n        if its not already cached.\n\n    Args:\n        channel_id: The ID of the channel to get\n\n    Returns:\n        Channel Object if found, otherwise None\n\n    \"\"\"\n    try:\n        return await self.cache.fetch_channel(channel_id)\n    except NotFound:\n        return None\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.get_channel","title":"<code>get_channel(channel_id)</code>","text":"<p>Get a channel.</p> <p>Note</p> <p>This method is an alias for the cache which will return a cached object.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel to get</p> required <p>Returns:</p> Type Description <code>Optional[TYPE_ALL_CHANNEL]</code> <p>Channel Object if found, otherwise None</p> Source code in <code>naff\\client\\client.py</code> <pre><code>def get_channel(self, channel_id: \"Snowflake_Type\") -&gt; Optional[\"TYPE_ALL_CHANNEL\"]:\n\"\"\"\n    Get a channel.\n\n    !!! note\n        This method is an alias for the cache which will return a cached object.\n\n    Args:\n        channel_id: The ID of the channel to get\n\n    Returns:\n        Channel Object if found, otherwise None\n\n    \"\"\"\n    return self.cache.get_channel(channel_id)\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.fetch_user","title":"<code>fetch_user(user_id)</code>  <code>async</code>","text":"<p>Fetch a user.</p> <p>Note</p> <p>This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the user to get</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>User Object if found, otherwise None</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def fetch_user(self, user_id: \"Snowflake_Type\") -&gt; Optional[User]:\n\"\"\"\n    Fetch a user.\n\n    !!! note\n        This method is an alias for the cache which will either return a cached object, or query discord for the object\n        if its not already cached.\n\n    Args:\n        user_id: The ID of the user to get\n\n    Returns:\n        User Object if found, otherwise None\n\n    \"\"\"\n    try:\n        return await self.cache.fetch_user(user_id)\n    except NotFound:\n        return None\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.get_user","title":"<code>get_user(user_id)</code>","text":"<p>Get a user.</p> <p>Note</p> <p>This method is an alias for the cache which will return a cached object.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the user to get</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>User Object if found, otherwise None</p> Source code in <code>naff\\client\\client.py</code> <pre><code>def get_user(self, user_id: \"Snowflake_Type\") -&gt; Optional[User]:\n\"\"\"\n    Get a user.\n\n    !!! note\n        This method is an alias for the cache which will return a cached object.\n\n    Args:\n        user_id: The ID of the user to get\n\n    Returns:\n        User Object if found, otherwise None\n\n    \"\"\"\n    return self.cache.get_user(user_id)\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.fetch_member","title":"<code>fetch_member(user_id, guild_id)</code>  <code>async</code>","text":"<p>Fetch a member from a guild.</p> <p>Note</p> <p>This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the member</p> required <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to get the member from</p> required <p>Returns:</p> Type Description <code>Optional[Member]</code> <p>Member object if found, otherwise None</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def fetch_member(self, user_id: \"Snowflake_Type\", guild_id: \"Snowflake_Type\") -&gt; Optional[Member]:\n\"\"\"\n    Fetch a member from a guild.\n\n    !!! note\n        This method is an alias for the cache which will either return a cached object, or query discord for the object\n        if its not already cached.\n\n    Args:\n        user_id: The ID of the member\n        guild_id: The ID of the guild to get the member from\n\n    Returns:\n        Member object if found, otherwise None\n\n    \"\"\"\n    try:\n        return await self.cache.fetch_member(guild_id, user_id)\n    except NotFound:\n        return None\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.get_member","title":"<code>get_member(user_id, guild_id)</code>","text":"<p>Get a member from a guild.</p> <p>Note</p> <p>This method is an alias for the cache which will return a cached object.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the member</p> required <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to get the member from</p> required <p>Returns:</p> Type Description <code>Optional[Member]</code> <p>Member object if found, otherwise None</p> Source code in <code>naff\\client\\client.py</code> <pre><code>def get_member(self, user_id: \"Snowflake_Type\", guild_id: \"Snowflake_Type\") -&gt; Optional[Member]:\n\"\"\"\n    Get a member from a guild.\n\n    !!! note\n        This method is an alias for the cache which will return a cached object.\n\n    Args:\n        user_id: The ID of the member\n        guild_id: The ID of the guild to get the member from\n\n    Returns:\n        Member object if found, otherwise None\n\n    \"\"\"\n    return self.cache.get_member(guild_id, user_id)\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.fetch_scheduled_event","title":"<code>fetch_scheduled_event(guild_id, scheduled_event_id, with_user_count=False)</code>  <code>async</code>","text":"<p>Fetch a scheduled event by id.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to get the scheduled event from</p> required <code>scheduled_event_id</code> <code>Snowflake_Type</code> <p>The ID of the scheduled event to get</p> required <code>with_user_count</code> <code>bool</code> <p>Whether to include the user count in the response</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[ScheduledEvent]</code> <p>The scheduled event if found, otherwise None</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def fetch_scheduled_event(\n    self, guild_id: \"Snowflake_Type\", scheduled_event_id: \"Snowflake_Type\", with_user_count: bool = False\n) -&gt; Optional[\"ScheduledEvent\"]:\n\"\"\"\n    Fetch a scheduled event by id.\n\n    Args:\n        guild_id: The ID of the guild to get the scheduled event from\n        scheduled_event_id: The ID of the scheduled event to get\n        with_user_count: Whether to include the user count in the response\n\n    Returns:\n        The scheduled event if found, otherwise None\n\n    \"\"\"\n    try:\n        scheduled_event_data = await self.http.get_scheduled_event(guild_id, scheduled_event_id, with_user_count)\n        return ScheduledEvent.from_dict(scheduled_event_data, self)\n    except NotFound:\n        return None\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.fetch_custom_emoji","title":"<code>fetch_custom_emoji(emoji_id, guild_id)</code>  <code>async</code>","text":"<p>Fetch a custom emoji by id.</p> <p>Parameters:</p> Name Type Description Default <code>emoji_id</code> <code>Snowflake_Type</code> <p>The id of the custom emoji.</p> required <code>guild_id</code> <code>Snowflake_Type</code> <p>The id of the guild the emoji belongs to.</p> required <p>Returns:</p> Type Description <code>Optional[CustomEmoji]</code> <p>The custom emoji if found, otherwise None.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def fetch_custom_emoji(self, emoji_id: \"Snowflake_Type\", guild_id: \"Snowflake_Type\") -&gt; Optional[CustomEmoji]:\n\"\"\"\n    Fetch a custom emoji by id.\n\n    Args:\n        emoji_id: The id of the custom emoji.\n        guild_id: The id of the guild the emoji belongs to.\n\n    Returns:\n        The custom emoji if found, otherwise None.\n\n    \"\"\"\n    try:\n        return await self.cache.fetch_emoji(guild_id, emoji_id)\n    except NotFound:\n        return None\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.get_custom_emoji","title":"<code>get_custom_emoji(emoji_id, guild_id=None)</code>","text":"<p>Get a custom emoji by id.</p> <p>Parameters:</p> Name Type Description Default <code>emoji_id</code> <code>Snowflake_Type</code> <p>The id of the custom emoji.</p> required <code>guild_id</code> <code>Optional[Snowflake_Type]</code> <p>The id of the guild the emoji belongs to.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[CustomEmoji]</code> <p>The custom emoji if found, otherwise None.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>def get_custom_emoji(\n    self, emoji_id: \"Snowflake_Type\", guild_id: Optional[\"Snowflake_Type\"] = None\n) -&gt; Optional[CustomEmoji]:\n\"\"\"\n    Get a custom emoji by id.\n\n    Args:\n        emoji_id: The id of the custom emoji.\n        guild_id: The id of the guild the emoji belongs to.\n\n    Returns:\n        The custom emoji if found, otherwise None.\n\n    \"\"\"\n    emoji = self.cache.get_emoji(emoji_id)\n    if emoji and (not guild_id or emoji._guild_id == to_snowflake(guild_id)):\n        return emoji\n    return None\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.fetch_sticker","title":"<code>fetch_sticker(sticker_id)</code>  <code>async</code>","text":"<p>Fetch a sticker by ID.</p> <p>Parameters:</p> Name Type Description Default <code>sticker_id</code> <code>Snowflake_Type</code> <p>The ID of the sticker.</p> required <p>Returns:</p> Type Description <code>Optional[Sticker]</code> <p>A sticker object if found, otherwise None</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def fetch_sticker(self, sticker_id: \"Snowflake_Type\") -&gt; Optional[Sticker]:\n\"\"\"\n    Fetch a sticker by ID.\n\n    Args:\n        sticker_id: The ID of the sticker.\n\n    Returns:\n        A sticker object if found, otherwise None\n\n    \"\"\"\n    try:\n        sticker_data = await self.http.get_sticker(sticker_id)\n        return Sticker.from_dict(sticker_data, self)\n    except NotFound:\n        return None\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.fetch_nitro_packs","title":"<code>fetch_nitro_packs()</code>  <code>async</code>","text":"<p>List the sticker packs available to Nitro subscribers.</p> <p>Returns:</p> Type Description <code>Optional[List[StickerPack]]</code> <p>A list of StickerPack objects if found, otherwise returns None</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def fetch_nitro_packs(self) -&gt; Optional[List[\"StickerPack\"]]:\n\"\"\"\n    List the sticker packs available to Nitro subscribers.\n\n    Returns:\n        A list of StickerPack objects if found, otherwise returns None\n\n    \"\"\"\n    try:\n        packs_data = await self.http.list_nitro_sticker_packs()\n        return [StickerPack.from_dict(data, self) for data in packs_data]\n\n    except NotFound:\n        return None\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.fetch_voice_regions","title":"<code>fetch_voice_regions()</code>  <code>async</code>","text":"<p>List the voice regions available on Discord.</p> <p>Returns:</p> Type Description <code>List[VoiceRegion]</code> <p>A list of voice regions.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def fetch_voice_regions(self) -&gt; List[\"VoiceRegion\"]:\n\"\"\"\n    List the voice regions available on Discord.\n\n    Returns:\n        A list of voice regions.\n\n    \"\"\"\n    regions_data = await self.http.list_voice_regions()\n    regions = VoiceRegion.from_list(regions_data)\n    return regions\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.connect_to_vc","title":"<code>connect_to_vc(guild_id, channel_id, muted=False, deafened=False)</code>  <code>async</code>","text":"<p>Connect the bot to a voice channel.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>id of the guild the voice channel is in.</p> required <code>channel_id</code> <code>Snowflake_Type</code> <p>id of the voice channel client wants to join.</p> required <code>muted</code> <code>bool</code> <p>Whether the bot should be muted when connected.</p> <code>False</code> <code>deafened</code> <code>bool</code> <p>Whether the bot should be deafened when connected.</p> <code>False</code> <p>Returns:</p> Type Description <code>ActiveVoiceState</code> <p>The new active voice state on successfully connection.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def connect_to_vc(\n    self, guild_id: \"Snowflake_Type\", channel_id: \"Snowflake_Type\", muted: bool = False, deafened: bool = False\n) -&gt; ActiveVoiceState:\n\"\"\"\n    Connect the bot to a voice channel.\n\n    Args:\n        guild_id: id of the guild the voice channel is in.\n        channel_id: id of the voice channel client wants to join.\n        muted: Whether the bot should be muted when connected.\n        deafened: Whether the bot should be deafened when connected.\n\n    Returns:\n        The new active voice state on successfully connection.\n\n    \"\"\"\n    return await self._connection_state.voice_connect(guild_id, channel_id, muted, deafened)\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.get_bot_voice_state","title":"<code>get_bot_voice_state(guild_id)</code>","text":"<p>Get the bot's voice state for a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The target guild's id.</p> required <p>Returns:</p> Type Description <code>Optional[ActiveVoiceState]</code> <p>The bot's voice state for the guild if connected, otherwise None.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>def get_bot_voice_state(self, guild_id: \"Snowflake_Type\") -&gt; Optional[ActiveVoiceState]:\n\"\"\"\n    Get the bot's voice state for a guild.\n\n    Args:\n        guild_id: The target guild's id.\n\n    Returns:\n        The bot's voice state for the guild if connected, otherwise None.\n\n    \"\"\"\n    return self._connection_state.get_voice_state(guild_id)\n</code></pre>"},{"location":"API%20Reference/Client/#naff.client.client.Client.change_presence","title":"<code>change_presence(status=Status.ONLINE, activity=None)</code>  <code>async</code>","text":"<p>Change the bots presence.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Optional[Union[str, Status]]</code> <p>The status for the bot to be. i.e. online, afk, etc.</p> <code>Status.ONLINE</code> <code>activity</code> <code>Optional[Union[Activity, str]]</code> <p>The activity for the bot to be displayed as doing.</p> <code>None</code> <p>Note</p> <p>Bots may only be <code>playing</code> <code>streaming</code> <code>listening</code> <code>watching</code> or <code>competing</code>, other activity types are likely to fail.</p> Source code in <code>naff\\client\\client.py</code> <pre><code>async def change_presence(\n    self, status: Optional[Union[str, Status]] = Status.ONLINE, activity: Optional[Union[Activity, str]] = None\n) -&gt; None:\n\"\"\"\n    Change the bots presence.\n\n    Args:\n        status: The status for the bot to be. i.e. online, afk, etc.\n        activity: The activity for the bot to be displayed as doing.\n\n    !!! note\n        Bots may only be `playing` `streaming` `listening` `watching` or `competing`, other activity types are likely to fail.\n\n    \"\"\"\n    await self._connection_state.change_presence(status, activity)\n</code></pre>"},{"location":"API%20Reference/const/","title":"Const","text":"<p>Constants used throughout NAFF.</p> <p>Attributes:</p> Name Type Description <code>__version__</code> <code>str</code> <p>The version of the library.</p> <code>__repo_url__</code> <code>str</code> <p>The URL of the repository.</p> <code>__py_version__</code> <code>str</code> <p>The python version in use.</p> <code>logger_name</code> <code>str</code> <p>The name of NAFFs default logger. Invalid if a custom logger is passed to <code>Client</code> to replace the default logger.</p> <code>logger</code> <code>logging.Logger</code> <p>The logger used throughout NAFF. If a custom logger is passed to <code>Client</code>, this obj is replaced with the new logger.</p> <code>kwarg_spam</code> <code>bool</code> <p>Should <code>unused kwargs</code> be logged.</p> <code>ACTION_ROW_MAX_ITEMS</code> <code>int</code> <p>The maximum number of items in an action row.</p> <code>SELECTS_MAX_OPTIONS</code> <code>int</code> <p>The maximum number of options a select may have.</p> <code>SELECT_MAX_NAME_LENGTH</code> <code>int</code> <p>The max length of a select's name.</p> <code>CONTEXT_MENU_NAME_LENGTH</code> <code>int</code> <p>The max length of a context menu's name.</p> <code>SLASH_CMD_NAME_LENGTH</code> <code>int</code> <p>The max length of a slash command's name.</p> <code>SLASH_CMD_MAX_DESC_LENGTH</code> <code>int</code> <p>The maximum length of a slash command's description.</p> <code>SLASH_CMD_MAX_OPTIONS</code> <code>int</code> <p>The maximum number of options a slash command may have.</p> <code>SLASH_OPTION_NAME_LENGTH</code> <code>int</code> <p>The maximum length of a slash option's name.</p> <code>EMBED_MAX_NAME_LENGTH</code> <code>int</code> <p>The maximum length for an embed title</p> <code>EMBED_MAX_DESC_LENGTH</code> <code>int</code> <p>The maximum length for an embed description</p> <code>EMBED_MAX_FIELDS</code> <code>int</code> <p>The maximum number of fields for an embed</p> <code>EMBED_TOTAL_MAX</code> <code>int</code> <p>The total combined number of characters for an embed</p> <code>PREMIUM_GUILD_LIMITS</code> <code>dict</code> <p>Limits granted per premium level of a guild</p> <code>GLOBAL_SCOPE</code> <code>_sentinel</code> <p>A sentinel that represents a global scope for application commands.</p> <code>MENTION_PREFIX</code> <code>_sentinel</code> <p>A sentinel representing the bot will be mentioned for a prefix</p> <code>MISSING</code> <code>_sentinel</code> <p>A sentinel value that indicates something has not been set</p> <code>T</code> <code>TypeVar</code> <p>A type variable used for generic typing.</p> <code>Absent</code> <code>Union[T, Missing]</code> <p>A type hint for a value that may be MISSING.</p>"},{"location":"API%20Reference/errors/","title":"Errors","text":""},{"location":"API%20Reference/errors/#naff.client.errors.NaffException","title":"<code>NaffException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base Exception of Naff.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class NaffException(Exception):\n\"\"\"Base Exception of Naff.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.BotException","title":"<code>BotException</code>","text":"<p>         Bases: <code>NaffException</code></p> <p>An issue occurred in the client, likely user error.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class BotException(NaffException):\n\"\"\"An issue occurred in the client, likely user error.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.GatewayNotFound","title":"<code>GatewayNotFound</code>","text":"<p>         Bases: <code>NaffException</code></p> <p>An exception that is raised when the gateway for Discord could not be found.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class GatewayNotFound(NaffException):\n\"\"\"An exception that is raised when the gateway for Discord could not be found.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"Unable to find discord gateway!\")\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.LoginError","title":"<code>LoginError</code>","text":"<p>         Bases: <code>BotException</code></p> <p>The bot failed to login, check your token.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class LoginError(BotException):\n\"\"\"The bot failed to login, check your token.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.HTTPException","title":"<code>HTTPException</code>","text":"<p>         Bases: <code>NaffException</code></p> <p>A HTTP request resulted in an exception.</p> <p>Attributes:</p> Name Type Description <code>response</code> <code>aiohttp.ClientResponse</code> <p>The response of the HTTP request</p> <code>text</code> <code>str</code> <p>The text of the exception, could be None</p> <code>status</code> <code>int</code> <p>The HTTP status code</p> <code>code</code> <code>int</code> <p>The discord error code, if one is provided</p> <code>route</code> <code>Route</code> <p>The HTTP route that was used</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class HTTPException(NaffException):\n\"\"\"\n    A HTTP request resulted in an exception.\n\n    Attributes:\n        response aiohttp.ClientResponse: The response of the HTTP request\n        text str: The text of the exception, could be None\n        status int: The HTTP status code\n        code int: The discord error code, if one is provided\n        route Route: The HTTP route that was used\n\n    \"\"\"\n\n    def __init__(\n        self,\n        response: aiohttp.ClientResponse,\n        text: const.Absent[str] = const.MISSING,\n        discord_code: const.Absent[int] = const.MISSING,\n        **kwargs,\n    ) -&gt; None:\n        self.response: aiohttp.ClientResponse = response\n        self.status: int = response.status\n        self.code: const.Absent[int] = discord_code\n        self.text: const.Absent[str] = text\n        self.errors: const.Absent[Any] = const.MISSING\n        self.route = kwargs.get(\"route\", const.MISSING)\n\n        if data := kwargs.get(\"response_data\"):\n            if isinstance(data, dict):\n                self.text = data.get(\"message\", const.MISSING)\n                self.code = data.get(\"code\", const.MISSING)\n                self.errors = data.get(\"errors\", const.MISSING)\n            else:\n                self.text = data\n        super().__init__(f\"{self.status}|{self.response.reason}: {f'({self.code}) ' if self.code else ''}{self.text}\")\n\n    def __str__(self) -&gt; str:\n        if self.errors:\n            try:\n                errors = self.search_for_message(self.errors)\n            except (KeyError, ValueError, TypeError):\n                errors = [self.text]\n            out = f\"HTTPException: {self.status}|{self.response.reason}: \" + \"\\n\".join(errors)\n        else:\n            out = f\"HTTPException: {self.status}|{self.response.reason} || {self.text}\"\n        return out\n\n    def __repr__(self) -&gt; str:\n        return str(self)\n\n    @staticmethod\n    def search_for_message(errors: dict, lookup: Optional[dict] = None) -&gt; list[str]:\n\"\"\"\n        Search the exceptions error dictionary for a message explaining the issue.\n\n        Args:\n            errors: The error dictionary of the http exception\n            lookup: A lookup dictionary to use to convert indexes into named items\n\n        Returns:\n            A list of parsed error strings found\n\n        \"\"\"\n        messages: List[str] = []\n        errors = errors.get(\"errors\", errors)\n\n        def maybe_int(x: SupportsInt | Any) -&gt; Union[int, Any]:\n\"\"\"If something can be an integer, convert it to one, otherwise return its normal value\"\"\"\n            try:\n                return int(x)\n            except ValueError:\n                return x\n\n        def _parse(_errors: dict, keys: Optional[List[str]] = None) -&gt; None:\n\"\"\"Search through the entire dictionary for any errors defined\"\"\"\n            for key, val in _errors.items():\n                if key == \"_errors\":\n                    key_out = []\n                    if keys:\n                        if lookup:\n                            # this code simply substitutes keys for attribute names\n                            _lookup = lookup\n                            for _key in keys:\n                                _lookup = _lookup[maybe_int(_key)]\n\n                                if isinstance(_lookup, dict):\n                                    key_out.append(_lookup.get(\"name\", _key))\n                                else:\n                                    key_out.append(_key)\n                        else:\n                            key_out = keys\n\n                    for msg in val:\n                        messages.append(f\"{'-&gt;'.join(key_out)} {msg['code']}: {msg['message']}\")\n                else:\n                    if keys:\n                        keys.append(key)\n                    else:\n                        keys = [key]\n                    _parse(val, keys)\n\n        _parse(errors)\n\n        return messages\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.HTTPException.search_for_message","title":"<code>search_for_message(errors, lookup=None)</code>  <code>staticmethod</code>","text":"<p>Search the exceptions error dictionary for a message explaining the issue.</p> <p>Parameters:</p> Name Type Description Default <code>errors</code> <code>dict</code> <p>The error dictionary of the http exception</p> required <code>lookup</code> <code>Optional[dict]</code> <p>A lookup dictionary to use to convert indexes into named items</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of parsed error strings found</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>@staticmethod\ndef search_for_message(errors: dict, lookup: Optional[dict] = None) -&gt; list[str]:\n\"\"\"\n    Search the exceptions error dictionary for a message explaining the issue.\n\n    Args:\n        errors: The error dictionary of the http exception\n        lookup: A lookup dictionary to use to convert indexes into named items\n\n    Returns:\n        A list of parsed error strings found\n\n    \"\"\"\n    messages: List[str] = []\n    errors = errors.get(\"errors\", errors)\n\n    def maybe_int(x: SupportsInt | Any) -&gt; Union[int, Any]:\n\"\"\"If something can be an integer, convert it to one, otherwise return its normal value\"\"\"\n        try:\n            return int(x)\n        except ValueError:\n            return x\n\n    def _parse(_errors: dict, keys: Optional[List[str]] = None) -&gt; None:\n\"\"\"Search through the entire dictionary for any errors defined\"\"\"\n        for key, val in _errors.items():\n            if key == \"_errors\":\n                key_out = []\n                if keys:\n                    if lookup:\n                        # this code simply substitutes keys for attribute names\n                        _lookup = lookup\n                        for _key in keys:\n                            _lookup = _lookup[maybe_int(_key)]\n\n                            if isinstance(_lookup, dict):\n                                key_out.append(_lookup.get(\"name\", _key))\n                            else:\n                                key_out.append(_key)\n                    else:\n                        key_out = keys\n\n                for msg in val:\n                    messages.append(f\"{'-&gt;'.join(key_out)} {msg['code']}: {msg['message']}\")\n            else:\n                if keys:\n                    keys.append(key)\n                else:\n                    keys = [key]\n                _parse(val, keys)\n\n    _parse(errors)\n\n    return messages\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.DiscordError","title":"<code>DiscordError</code>","text":"<p>         Bases: <code>HTTPException</code></p> <p>A discord-side error.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class DiscordError(HTTPException):\n\"\"\"A discord-side error.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.BadRequest","title":"<code>BadRequest</code>","text":"<p>         Bases: <code>HTTPException</code></p> <p>A bad request was made.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class BadRequest(HTTPException):\n\"\"\"A bad request was made.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.Forbidden","title":"<code>Forbidden</code>","text":"<p>         Bases: <code>HTTPException</code></p> <p>You do not have access to this.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class Forbidden(HTTPException):\n\"\"\"You do not have access to this.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.NotFound","title":"<code>NotFound</code>","text":"<p>         Bases: <code>HTTPException</code></p> <p>This resource could not be found.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class NotFound(HTTPException):\n\"\"\"This resource could not be found.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.RateLimited","title":"<code>RateLimited</code>","text":"<p>         Bases: <code>HTTPException</code></p> <p>Discord is rate limiting this application.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class RateLimited(HTTPException):\n\"\"\"Discord is rate limiting this application.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.TooManyChanges","title":"<code>TooManyChanges</code>","text":"<p>         Bases: <code>NaffException</code></p> <p>You have changed something too frequently.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class TooManyChanges(NaffException):\n\"\"\"You have changed something too frequently.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.WebSocketClosed","title":"<code>WebSocketClosed</code>","text":"<p>         Bases: <code>NaffException</code></p> <p>The websocket was closed.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class WebSocketClosed(NaffException):\n\"\"\"The websocket was closed.\"\"\"\n\n    code: int = 0\n    codes: Dict[int, str] = {\n        1000: \"Normal Closure\",\n        4000: \"Unknown Error\",\n        4001: \"Unknown OpCode\",\n        4002: \"Decode Error\",\n        4003: \"Not Authenticated\",\n        4004: \"Authentication Failed\",\n        4005: \"Already Authenticated\",\n        4007: \"Invalid seq\",\n        4008: \"Rate limited\",\n        4009: \"Session Timed Out\",\n        4010: \"Invalid Shard\",\n        4011: \"Sharding Required\",\n        4012: \"Invalid API Version\",\n        4013: \"Invalid Intents\",\n        4014: \"Disallowed Intents\",\n    }\n\n    def __init__(self, code: int) -&gt; None:\n        self.code = code\n        super().__init__(f\"The Websocket closed with code: {code} - {self.codes.get(code, 'Unknown Error')}\")\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.VoiceWebSocketClosed","title":"<code>VoiceWebSocketClosed</code>","text":"<p>         Bases: <code>NaffException</code></p> <p>The voice websocket was closed.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class VoiceWebSocketClosed(NaffException):\n\"\"\"The voice websocket was closed.\"\"\"\n\n    code: int = 0\n    codes: Dict[int, str] = {\n        1000: \"Normal Closure\",\n        4000: \"Unknown Error\",\n        4001: \"Unknown OpCode\",\n        4002: \"Decode Error\",\n        4003: \"Not Authenticated\",\n        4004: \"Authentication Failed\",\n        4005: \"Already Authenticated\",\n        4006: \"Session no longer valid\",\n        4007: \"Invalid seq\",\n        4009: \"Session Timed Out\",\n        4011: \"Server not found\",\n        4012: \"Unknown protocol\",\n        4014: \"Disconnected\",\n        4015: \"Voice Server Crashed\",\n        4016: \"Unknown encryption mode\",\n    }\n\n    def __init__(self, code: int) -&gt; None:\n        self.code = code\n        super().__init__(f\"The Websocket closed with code: {code} - {self.codes.get(code, 'Unknown Error')}\")\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.WebSocketRestart","title":"<code>WebSocketRestart</code>","text":"<p>         Bases: <code>NaffException</code></p> <p>The websocket closed, and is safe to restart.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class WebSocketRestart(NaffException):\n\"\"\"The websocket closed, and is safe to restart.\"\"\"\n\n    resume: bool = False\n\n    def __init__(self, resume: bool = False) -&gt; None:\n        self.resume = resume\n        super().__init__(\"Websocket connection closed... reconnecting\")\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.ExtensionException","title":"<code>ExtensionException</code>","text":"<p>         Bases: <code>BotException</code></p> <p>An error occurred with an extension.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class ExtensionException(BotException):\n\"\"\"An error occurred with an extension.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.ExtensionNotFound","title":"<code>ExtensionNotFound</code>","text":"<p>         Bases: <code>ExtensionException</code></p> <p>The desired extension was not found.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class ExtensionNotFound(ExtensionException):\n\"\"\"The desired extension was not found.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.ExtensionLoadException","title":"<code>ExtensionLoadException</code>","text":"<p>         Bases: <code>ExtensionException</code></p> <p>An error occurred loading an extension.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class ExtensionLoadException(ExtensionException):\n\"\"\"An error occurred loading an extension.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.CommandException","title":"<code>CommandException</code>","text":"<p>         Bases: <code>BotException</code></p> <p>An error occurred trying to execute a command.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class CommandException(BotException):\n\"\"\"An error occurred trying to execute a command.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.CommandOnCooldown","title":"<code>CommandOnCooldown</code>","text":"<p>         Bases: <code>CommandException</code></p> <p>A command is on cooldown, and was attempted to be executed.</p> <p>Attributes:</p> Name Type Description <code>command</code> <code>BaseCommand</code> <p>The command that is on cooldown</p> <code>cooldown</code> <code>CooldownSystem</code> <p>The cooldown system</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class CommandOnCooldown(CommandException):\n\"\"\"\n    A command is on cooldown, and was attempted to be executed.\n\n    Attributes:\n        command BaseCommand: The command that is on cooldown\n        cooldown CooldownSystem: The cooldown system\n\n    \"\"\"\n\n    def __init__(self, command: \"BaseCommand\", cooldown: \"CooldownSystem\") -&gt; None:\n        self.command: \"BaseCommand\" = command\n        self.cooldown: \"CooldownSystem\" = cooldown\n\n        super().__init__(f\"Command on cooldown... {cooldown.get_cooldown_time():.2f} seconds until reset\")\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.MaxConcurrencyReached","title":"<code>MaxConcurrencyReached</code>","text":"<p>         Bases: <code>CommandException</code></p> <p>A command has exhausted the max concurrent requests.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class MaxConcurrencyReached(CommandException):\n\"\"\"A command has exhausted the max concurrent requests.\"\"\"\n\n    def __init__(self, command: \"BaseCommand\", max_conc: \"MaxConcurrency\") -&gt; None:\n        self.command: \"BaseCommand\" = command\n        self.max_conc: \"MaxConcurrency\" = max_conc\n\n        super().__init__(f\"Command has exhausted the max concurrent requests. ({max_conc.concurrent} simultaneously)\")\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.CommandCheckFailure","title":"<code>CommandCheckFailure</code>","text":"<p>         Bases: <code>CommandException</code></p> <p>A command check failed.</p> <p>Attributes:</p> Name Type Description <code>command</code> <code>BaseCommand</code> <p>The command that's check failed</p> <code>check</code> <code>Callable[..., Coroutine]</code> <p>The check that failed</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class CommandCheckFailure(CommandException):\n\"\"\"\n    A command check failed.\n\n    Attributes:\n        command BaseCommand: The command that's check failed\n        check Callable[..., Coroutine]: The check that failed\n\n    \"\"\"\n\n    def __init__(self, command: \"BaseCommand\", check: Callable[..., Coroutine], context: \"Context\") -&gt; None:\n        self.command: \"BaseCommand\" = command\n        self.check: Callable[..., Coroutine] = check\n        self.ctx = context\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.BadArgument","title":"<code>BadArgument</code>","text":"<p>         Bases: <code>CommandException</code></p> <p>A prefixed command encountered an invalid argument.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class BadArgument(CommandException):\n\"\"\"A prefixed command encountered an invalid argument.\"\"\"\n\n    def __init__(self, message: Optional[str] = None, *args: Any) -&gt; None:\n        if message is not None:\n            message = escape_mentions(message)\n            super().__init__(message, *args)\n        else:\n            super().__init__(*args)\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.MessageException","title":"<code>MessageException</code>","text":"<p>         Bases: <code>BotException</code></p> <p>A message operation encountered an exception.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class MessageException(BotException):\n\"\"\"A message operation encountered an exception.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.EmptyMessageException","title":"<code>EmptyMessageException</code>","text":"<p>         Bases: <code>MessageException</code></p> <p>You have attempted to send a message without any content or embeds</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class EmptyMessageException(MessageException):\n\"\"\"You have attempted to send a message without any content or embeds\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.EphemeralEditException","title":"<code>EphemeralEditException</code>","text":"<p>         Bases: <code>MessageException</code></p> <p>Your bot attempted to edit an ephemeral message. This is not possible.</p> <p>Its worth noting you can edit an ephemeral message with component's <code>edit_origin</code> method.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class EphemeralEditException(MessageException):\n\"\"\"\n    Your bot attempted to edit an ephemeral message. This is not possible.\n\n    Its worth noting you can edit an ephemeral message with component's\n    `edit_origin` method.\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\n            \"Ephemeral messages can only be edited with component's `edit_origin` method or using InteractionContext\"\n        )\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.ThreadException","title":"<code>ThreadException</code>","text":"<p>         Bases: <code>BotException</code></p> <p>A thread operation encountered an exception.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class ThreadException(BotException):\n\"\"\"A thread operation encountered an exception.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.ThreadOutsideOfGuild","title":"<code>ThreadOutsideOfGuild</code>","text":"<p>         Bases: <code>ThreadException</code></p> <p>A thread was attempted to be created outside of a guild.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class ThreadOutsideOfGuild(ThreadException):\n\"\"\"A thread was attempted to be created outside of a guild.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"Threads cannot be created outside of guilds\")\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.InteractionException","title":"<code>InteractionException</code>","text":"<p>         Bases: <code>BotException</code></p> <p>An error occurred with an interaction.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class InteractionException(BotException):\n\"\"\"An error occurred with an interaction.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.InteractionMissingAccess","title":"<code>InteractionMissingAccess</code>","text":"<p>         Bases: <code>InteractionException</code></p> <p>The bot does not have access to the specified scope.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class InteractionMissingAccess(InteractionException):\n\"\"\"The bot does not have access to the specified scope.\"\"\"\n\n    def __init__(self, scope: \"Snowflake_Type\") -&gt; None:\n        self.scope: \"Snowflake_Type\" = scope\n\n        if scope == const.GLOBAL_SCOPE:\n            err_msg = \"Unable to sync commands global commands\"\n        else:\n            err_msg = (\n                f\"Unable to sync commands for guild `{scope}` -- Ensure the bot properly added to that guild \"\n                f\"with `application.commands` scope. \"\n            )\n\n        super().__init__(err_msg)\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.AlreadyDeferred","title":"<code>AlreadyDeferred</code>","text":"<p>         Bases: <code>BotException</code></p> <p>An interaction was already deferred, and you attempted to defer it again.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class AlreadyDeferred(BotException):\n\"\"\"An interaction was already deferred, and you attempted to defer it again.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.ForeignWebhookException","title":"<code>ForeignWebhookException</code>","text":"<p>         Bases: <code>NaffException</code></p> <p>Raised when you attempt to send using a webhook you did not create.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class ForeignWebhookException(NaffException):\n\"\"\"Raised when you attempt to send using a webhook you did not create.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.EventLocationNotProvided","title":"<code>EventLocationNotProvided</code>","text":"<p>         Bases: <code>BotException</code></p> <p>Raised when you have entity_type external and no location is provided.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class EventLocationNotProvided(BotException):\n\"\"\"Raised when you have entity_type external and no location is provided.\"\"\"\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.VoiceAlreadyConnected","title":"<code>VoiceAlreadyConnected</code>","text":"<p>         Bases: <code>BotException</code></p> <p>Raised when you attempt to connect a voice channel that is already connected.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class VoiceAlreadyConnected(BotException):\n\"\"\"Raised when you attempt to connect a voice channel that is already connected.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"Bot already connected to the voice channel\")\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.VoiceNotConnected","title":"<code>VoiceNotConnected</code>","text":"<p>         Bases: <code>BotException</code></p> <p>Raised when you attempt to connect a voice channel that is not connected.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class VoiceNotConnected(BotException):\n\"\"\"Raised when you attempt to connect a voice channel that is not connected.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"Bot is not connected to any voice channels in given guild\")\n</code></pre>"},{"location":"API%20Reference/errors/#naff.client.errors.VoiceConnectionTimeout","title":"<code>VoiceConnectionTimeout</code>","text":"<p>         Bases: <code>NaffException</code></p> <p>Raised when the bot fails to connect to a voice channel.</p> Source code in <code>naff\\client\\errors.py</code> <pre><code>class VoiceConnectionTimeout(NaffException):\n\"\"\"Raised when the bot fails to connect to a voice channel.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"Failed to connect to voice channel. Did not receive a response from Discord\")\n</code></pre>"},{"location":"API%20Reference/utils/","title":"Utils","text":"<p>These are a collection of utility methods that are used throughout the library. There are several more that are not included here, as they are reserved for internal use.</p> <p>Info</p> <p>All of these methods can be imported from the <code>naff.client.utils</code> namespace</p>"},{"location":"API%20Reference/utils/#formatting","title":"Formatting","text":"<p>These methods are to help you format strings for messages.</p>"},{"location":"API%20Reference/utils/#naff.client.utils.formatting.bold","title":"<code>bold(text)</code>","text":"<p>Formats text for discord message as bold</p> Source code in <code>naff\\client\\utils\\formatting.py</code> <pre><code>def bold(text: str) -&gt; str:\n\"\"\"Formats text for discord message as bold\"\"\"\n    return f\"**{text}**\"\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.formatting.italic","title":"<code>italic(text)</code>","text":"<p>Formats text for discord message as italic</p> Source code in <code>naff\\client\\utils\\formatting.py</code> <pre><code>def italic(text: str) -&gt; str:\n\"\"\"Formats text for discord message as italic\"\"\"\n    return f\"*{text}*\"\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.formatting.underline","title":"<code>underline(text)</code>","text":"<p>Formats text for discord message as underlined</p> Source code in <code>naff\\client\\utils\\formatting.py</code> <pre><code>def underline(text: str) -&gt; str:\n\"\"\"Formats text for discord message as underlined\"\"\"\n    return f\"__{text}__\"\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.formatting.strikethrough","title":"<code>strikethrough(text)</code>","text":"<p>Formats text for discord message as strikethrough</p> Source code in <code>naff\\client\\utils\\formatting.py</code> <pre><code>def strikethrough(text: str) -&gt; str:\n\"\"\"Formats text for discord message as strikethrough\"\"\"\n    return f\"~~{text}~~\"\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.formatting.spoiler","title":"<code>spoiler(text)</code>","text":"<p>Formats text for discord message as spoiler</p> Source code in <code>naff\\client\\utils\\formatting.py</code> <pre><code>def spoiler(text: str) -&gt; str:\n\"\"\"Formats text for discord message as spoiler\"\"\"\n    return f\"||{text}||\"\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.formatting.no_embed_link","title":"<code>no_embed_link(url)</code>","text":"<p>Makes link in discord message display without embedded website preview</p> Source code in <code>naff\\client\\utils\\formatting.py</code> <pre><code>def no_embed_link(url: str) -&gt; str:\n\"\"\"Makes link in discord message display without embedded website preview\"\"\"\n    return f\"&lt;{url}&gt;\"\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.formatting.link_in_embed","title":"<code>link_in_embed(text, url)</code>","text":"<p>Makes a clickable link inside Embed object</p> Source code in <code>naff\\client\\utils\\formatting.py</code> <pre><code>def link_in_embed(text: str, url: str) -&gt; str:\n\"\"\"Makes a clickable link inside Embed object\"\"\"\n    return f\"[{text}]({url})\"\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.formatting.quote_line","title":"<code>quote_line(line)</code>","text":"<p>Formats a text line for discord message as quote</p> Source code in <code>naff\\client\\utils\\formatting.py</code> <pre><code>def quote_line(line: str) -&gt; str:\n\"\"\"Formats a text line for discord message as quote\"\"\"\n    return f\"&gt; {line}\"\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.formatting.inline_code","title":"<code>inline_code(text)</code>","text":"<p>Formats text for discord message as inline code</p> Source code in <code>naff\\client\\utils\\formatting.py</code> <pre><code>def inline_code(text: str) -&gt; str:\n\"\"\"Formats text for discord message as inline code\"\"\"\n    return f\"`{text}`\"\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.formatting.code_block","title":"<code>code_block(text, language)</code>","text":"<p>Formats text for discord message as code block</p> Source code in <code>naff\\client\\utils\\formatting.py</code> <pre><code>def code_block(text: str, language: Optional[str]) -&gt; str:\n\"\"\"Formats text for discord message as code block\"\"\"\n    return f\"```{language or ''}\\n\" f\"{text}\" f\"```\"\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.formatting.ansi_block","title":"<code>ansi_block(text)</code>","text":"<p>Formats text for discord message as code block that allows for arbitrary coloring and formatting</p> Source code in <code>naff\\client\\utils\\formatting.py</code> <pre><code>def ansi_block(text: str) -&gt; str:\n\"\"\"Formats text for discord message as code block that allows for arbitrary coloring and formatting\"\"\"\n    return code_block(text, \"ansi\")\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.formatting.ansi_format","title":"<code>ansi_format(style=None, color=None, background=None)</code>","text":"<p>Gives format prefix for ansi code block with selected styles</p> Source code in <code>naff\\client\\utils\\formatting.py</code> <pre><code>def ansi_format(\n    style: Optional[AnsiStyles] = None,\n    color: Optional[AnsiColors] = None,\n    background: Optional[AnsiBackgrounds] = None,\n) -&gt; str:\n\"\"\"Gives format prefix for ansi code block with selected styles\"\"\"\n    text_style = \";\".join(str(_style.value) for _style in (style, color, background) if _style)\n    return f\"\u001b[{text_style}m\"\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.formatting.ansi_styled","title":"<code>ansi_styled(text, style=None, color=None, background=None)</code>","text":"<p>Formats text for ansi code block with selected styles</p> Source code in <code>naff\\client\\utils\\formatting.py</code> <pre><code>def ansi_styled(\n    text: str,\n    style: Optional[AnsiStyles] = None,\n    color: Optional[AnsiColors] = None,\n    background: Optional[AnsiBackgrounds] = None,\n) -&gt; str:\n\"\"\"Formats text for ansi code block with selected styles\"\"\"\n    return f\"{ansi_format(style, color, background)}{text}{ansi_escape}\"\n</code></pre>"},{"location":"API%20Reference/utils/#attrs-utilities","title":"Attrs Utilities","text":"<p>These methods are intended to be used with attrs dataclasses</p>"},{"location":"API%20Reference/utils/#naff.client.utils.attr_converters.timestamp_converter","title":"<code>timestamp_converter(value)</code>","text":"<p>Converts a datetime, int, float, or str to a Timestamp object</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[datetime, int, float, str]</code> <p>The time value to convert</p> required <p>Returns:</p> Type Description <code>Timestamp</code> <p>A Timestamp object</p> Source code in <code>naff\\client\\utils\\attr_converters.py</code> <pre><code>def timestamp_converter(value: Union[datetime, int, float, str]) -&gt; Timestamp:\n\"\"\"\n    Converts a datetime, int, float, or str to a Timestamp object\n\n    Args:\n        value: The time value to convert\n\n    Returns:\n        A Timestamp object\n\n    \"\"\"\n    if isinstance(value, str):\n        return Timestamp.fromisoformat(value)\n    elif isinstance(value, (float, int)):\n        return Timestamp.fromtimestamp(float(value))\n    elif isinstance(value, datetime):\n        return Timestamp.fromdatetime(value)\n    raise TypeError(\"Timestamp must be one of: datetime, int, float, ISO8601 str\")\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.attr_converters.list_converter","title":"<code>list_converter(converter)</code>","text":"<p>Converts a list of values to a list of converted values</p> Source code in <code>naff\\client\\utils\\attr_converters.py</code> <pre><code>def list_converter(converter) -&gt; Callable[[list], list]:\n\"\"\"Converts a list of values to a list of converted values\"\"\"\n\n    def convert_action(value: list) -&gt; list:\n        return [converter(element) for element in value]\n\n    return convert_action\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.attr_converters.optional","title":"<code>optional(converter)</code>","text":"<p>A modified version of attrs optional converter that supports both <code>None</code> and <code>MISSING</code></p> <p>Type annotations will be inferred from the wrapped converter's, if it has any.</p> <p>Parameters:</p> Name Type Description Default <code>converter</code> <code>typing.Callable</code> <p>The convertor that is used for the non-None or MISSING</p> required Source code in <code>naff\\client\\utils\\attr_converters.py</code> <pre><code>def optional(converter: typing.Callable) -&gt; typing.Any:\n\"\"\"\n    A modified version of attrs optional converter that supports both `None` and `MISSING`\n\n    Type annotations will be inferred from the wrapped converter's, if it\n    has any.\n\n    Args:\n        converter: The convertor that is used for the non-None or MISSING\n\n    \"\"\"\n\n    def optional_converter(val) -&gt; typing.Any:\n        if val is None or val is MISSING:\n            return val\n        return converter(val)\n\n    sig = None\n    try:\n        sig = inspect.signature(converter)\n    except (ValueError, TypeError):  # inspect failed\n        pass\n    if sig:\n        params = list(sig.parameters.values())\n        if params and params[0].annotation is not inspect.Parameter.empty:\n            optional_converter.__annotations__[\"val\"] = typing.Optional[params[0].annotation]\n        if sig.return_annotation is not inspect.Signature.empty:\n            optional_converter.__annotations__[\"return\"] = typing.Optional[sig.return_annotation]\n\n    return optional_converter\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.attr_utils.docs","title":"<code>docs(doc_string)</code>","text":"<p>Makes it easier to quickly type attr documentation.</p> <p>Parameters:</p> Name Type Description Default <code>doc_string</code> <code>str</code> <p>The documentation string.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>The processed metadata dict</p> Source code in <code>naff\\client\\utils\\attr_utils.py</code> <pre><code>def docs(doc_string: str) -&gt; Dict[str, str]:\n\"\"\"\n    Makes it easier to quickly type attr documentation.\n\n    Args:\n        doc_string: The documentation string.\n\n    Returns:\n        The processed metadata dict\n    \"\"\"\n    return {\"docs\": doc_string}\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.attr_utils.str_validator","title":"<code>str_validator(self, attribute, value)</code>","text":"<p>Validates that the value is a string. Helps convert and ives a warning if it isn't.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The instance of the class.</p> required <code>attribute</code> <code>attrs.Attribute</code> <p>The attr attribute being validated.</p> required <code>value</code> <code>Any</code> <p>The value being validated.</p> required Source code in <code>naff\\client\\utils\\attr_utils.py</code> <pre><code>def str_validator(self: Any, attribute: attrs.Attribute, value: Any) -&gt; None:\n\"\"\"\n    Validates that the value is a string. Helps convert and ives a warning if it isn't.\n\n    Args:\n        self: The instance of the class.\n        attribute: The attr attribute being validated.\n        value: The value being validated.\n\n    \"\"\"\n    if not isinstance(value, str):\n        if value is MISSING:\n            return\n        setattr(self, attribute.name, str(value))\n        get_logger().warning(\n            f\"Value of {attribute.name} has been automatically converted to a string. Please use strings in future.\\n\"\n            \"Note: Discord will always return value as a string\"\n        )\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.attr_utils.attrs_validator","title":"<code>attrs_validator(validator, skip_fields=None)</code>","text":"<p>Sets a validator to all fields of an attrs-dataclass.</p> <p>Parameters:</p> Name Type Description Default <code>validator</code> <code>Callable</code> <p>The validator to set</p> required <code>skip_fields</code> <code>list[str] | None</code> <p>A list of fields to skip adding the validator to</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Any, list[Attribute]], list[Attribute]]</code> <p>The new fields for the attrs class</p> Source code in <code>naff\\client\\utils\\attr_utils.py</code> <pre><code>def attrs_validator(\n    validator: Callable, skip_fields: list[str] | None = None\n) -&gt; Callable[[Any, list[Attribute]], list[Attribute]]:\n\"\"\"\n    Sets a validator to all fields of an attrs-dataclass.\n\n    Args:\n        validator: The validator to set\n        skip_fields: A list of fields to skip adding the validator to\n\n    Returns:\n        The new fields for the attrs class\n    \"\"\"\n\n    def operation(_, attributes: list[Attribute]) -&gt; list[Attribute]:\n        new_attrs = []\n        for attr in attributes:\n            if skip_fields and attr.name in skip_fields:\n                new_attrs.append(attr)\n            else:\n                new_attrs.append(attr.evolve(validator=validator))\n        return new_attrs\n\n    return operation\n</code></pre>"},{"location":"API%20Reference/utils/#misc-utilities","title":"Misc Utilities","text":"<p>Uncategorized utilities, might be useful, might not.</p>"},{"location":"API%20Reference/utils/#naff.client.utils.misc_utils.escape_mentions","title":"<code>escape_mentions(content)</code>","text":"<p>Escape mentions that could ping someone in a string.</p> <p>Note</p> <p>This does not escape channel mentions as they do not ping anybody</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The string to escape</p> required <p>Returns:</p> Type Description <code>str</code> <p>Processed string</p> Source code in <code>naff\\client\\utils\\misc_utils.py</code> <pre><code>def escape_mentions(content: str) -&gt; str:\n\"\"\"\n    Escape mentions that could ping someone in a string.\n\n    !!! note\n        This does not escape channel mentions as they do not ping anybody\n\n    Args:\n        content: The string to escape\n\n    Returns:\n        Processed string\n\n    \"\"\"\n    return mention_reg.sub(\"@\\u200b\\\\1\", content)\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.misc_utils.find","title":"<code>find(predicate, sequence)</code>","text":"<p>Find the first element in a sequence that matches the predicate.</p> Example Usage: <pre><code>member = find(lambda m: m.name == \"UserName\", guild.members)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>A callable that returns a boolean value</p> required <code>sequence</code> <code>Iterable[T]</code> <p>A sequence to be searched</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>A match if found, otherwise None</p> Source code in <code>naff\\client\\utils\\misc_utils.py</code> <pre><code>def find(predicate: Callable[[T], bool], sequence: Iterable[T]) -&gt; Optional[T]:\n\"\"\"\n    Find the first element in a sequence that matches the predicate.\n\n    ??? Hint \"Example Usage:\"\n        ```python\n        member = find(lambda m: m.name == \"UserName\", guild.members)\n        ```\n    Args:\n        predicate: A callable that returns a boolean value\n        sequence: A sequence to be searched\n\n    Returns:\n        A match if found, otherwise None\n\n    \"\"\"\n    for el in sequence:\n        if predicate(el):\n            return el\n    return None\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.misc_utils.find_all","title":"<code>find_all(predicate, sequence)</code>","text":"<p>Find all elements in a sequence that match the predicate.</p> Example Usage: <pre><code>members = find_all(lambda m: m.name == \"UserName\", guild.members)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>A callable that returns a boolean value</p> required <code>sequence</code> <code>Iterable[T]</code> <p>A sequence to be searched</p> required <p>Returns:</p> Type Description <code>List[T]</code> <p>A list of matches</p> Source code in <code>naff\\client\\utils\\misc_utils.py</code> <pre><code>def find_all(predicate: Callable[[T], bool], sequence: Iterable[T]) -&gt; List[T]:\n\"\"\"\n    Find all elements in a sequence that match the predicate.\n\n    ??? Hint \"Example Usage:\"\n        ```python\n        members = find_all(lambda m: m.name == \"UserName\", guild.members)\n        ```\n    Args:\n        predicate: A callable that returns a boolean value\n        sequence: A sequence to be searched\n\n    Returns:\n        A list of matches\n\n    \"\"\"\n    return [el for el in sequence if predicate(el)]\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.misc_utils.get","title":"<code>get(sequence, **kwargs)</code>","text":"<p>Find the first element in a sequence that matches all attrs.</p> Example Usage: <pre><code>channel = get(guild.channels, nsfw=False, category=\"General\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Iterable[T]</code> <p>A sequence to be searched</p> required <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to search the sequence for</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>A match if found, otherwise None</p> Source code in <code>naff\\client\\utils\\misc_utils.py</code> <pre><code>def get(sequence: Iterable[T], **kwargs: Any) -&gt; Optional[T]:\n\"\"\"\n    Find the first element in a sequence that matches all attrs.\n\n    ??? Hint \"Example Usage:\"\n        ```python\n        channel = get(guild.channels, nsfw=False, category=\"General\")\n        ```\n\n    Args:\n        sequence: A sequence to be searched\n        **kwargs: Keyword arguments to search the sequence for\n\n    Returns:\n        A match if found, otherwise None\n\n    \"\"\"\n    if not kwargs:\n        return sequence[0]\n\n    for el in sequence:\n        if any(not hasattr(el, attr) for attr in kwargs.keys()):\n            continue\n        if all(getattr(el, attr) == value for attr, value in kwargs.items()):\n            return el\n    return None\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.misc_utils.get_all","title":"<code>get_all(sequence, **kwargs)</code>","text":"<p>Find all elements in a sequence that match all attrs.</p> Example Usage: <pre><code>channels = get_all(guild.channels, nsfw=False, category=\"General\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Iterable[T]</code> <p>A sequence to be searched</p> required <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to search the sequence for</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[T]</code> <p>A list of matches</p> Source code in <code>naff\\client\\utils\\misc_utils.py</code> <pre><code>def get_all(sequence: Iterable[T], **kwargs: Any) -&gt; List[T]:\n\"\"\"\n    Find all elements in a sequence that match all attrs.\n\n    ??? Hint \"Example Usage:\"\n        ```python\n        channels = get_all(guild.channels, nsfw=False, category=\"General\")\n        ```\n\n    Args:\n        sequence: A sequence to be searched\n        **kwargs: Keyword arguments to search the sequence for\n\n    Returns:\n        A list of matches\n\n    \"\"\"\n    if not kwargs:\n        return sequence\n\n    matches = []\n    for el in sequence:\n        if any(not hasattr(el, attr) for attr in kwargs.keys()):\n            continue\n        if all(getattr(el, attr) == value for attr, value in kwargs.items()):\n            matches.append(el)\n    return matches\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.misc_utils.wrap_partial","title":"<code>wrap_partial(obj, cls)</code>","text":"<p>\ud83c\udf81 Wraps a commands callback objects into partials.</p> <p>Note</p> <p>This is used internally, you shouldn't need to use this function</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The command object to process</p> required <code>cls</code> <code>Any</code> <p>The class to use in partials</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The original command object with its callback methods wrapped</p> Source code in <code>naff\\client\\utils\\misc_utils.py</code> <pre><code>def wrap_partial(obj: Any, cls: Any) -&gt; Callable:\n\"\"\"\n    \ud83c\udf81 Wraps a commands callback objects into partials.\n\n    !!! note\n        This is used internally, you shouldn't need to use this function\n\n    Args:\n        obj: The command object to process\n        cls: The class to use in partials\n\n    Returns:\n        The original command object with its callback methods wrapped\n\n    \"\"\"\n    if obj.callback is None or isinstance(obj.callback, functools.partial):\n        return obj\n    if \"_no_wrap\" not in getattr(obj.callback, \"__name__\", \"\"):\n        obj.callback = functools.partial(obj.callback, cls)\n\n    if getattr(obj, \"error_callback\", None):\n        obj.error_callback = functools.partial(obj.error_callback, cls)\n    if getattr(obj, \"pre_run_callback\", None):\n        obj.pre_run_callback = functools.partial(obj.pre_run_callback, cls)\n    if getattr(obj, \"post_run_callback\", None):\n        obj.post_run_callback = functools.partial(obj.post_run_callback, cls)\n    if getattr(obj, \"autocomplete_callbacks\", None):\n        obj.autocomplete_callbacks = {k: functools.partial(v, cls) for k, v in obj.autocomplete_callbacks.items()}\n    if getattr(obj, \"subcommands\", None):\n        obj.subcommands = {k: wrap_partial(v, cls) for k, v in obj.subcommands.items()}\n\n    return obj\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.misc_utils.get_parameters","title":"<code>get_parameters(callback)</code>","text":"<p>Gets all the parameters of a callback.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable</code> <p>The callback to get the parameters of</p> required <p>Returns:</p> Type Description <code>dict[str, inspect.Parameter]</code> <p>A dictionary of parameters</p> Source code in <code>naff\\client\\utils\\misc_utils.py</code> <pre><code>def get_parameters(callback: Callable) -&gt; dict[str, inspect.Parameter]:\n\"\"\"\n    Gets all the parameters of a callback.\n\n    Args:\n        callback: The callback to get the parameters of\n\n    Returns:\n        A dictionary of parameters\n\n    \"\"\"\n    return {p.name: p for p in inspect.signature(callback).parameters.values()}\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.misc_utils.get_event_name","title":"<code>get_event_name(event)</code>","text":"<p>Get the event name smartly from an event class or string name.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Union[str, BaseEvent]</code> <p>The event to parse the name of</p> required <p>Returns:</p> Type Description <code>str</code> <p>The event name</p> Source code in <code>naff\\client\\utils\\misc_utils.py</code> <pre><code>def get_event_name(event: Union[str, \"events.BaseEvent\"]) -&gt; str:\n\"\"\"\n    Get the event name smartly from an event class or string name.\n\n    Args:\n        event: The event to parse the name of\n\n    Returns:\n        The event name\n\n    \"\"\"\n    name = event\n\n    if inspect.isclass(name) and issubclass(name, events.BaseEvent):\n        name = name.__name__\n\n    # convert CamelCase to snake_case\n    name = camel_to_snake.sub(r\"_\\1\", name).lower()\n    # remove any leading underscores\n    name = name.lstrip(\"_\")\n    # remove any `on_` prefixes\n    name = name.removeprefix(\"on_\")\n\n    return name\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.misc_utils.get_object_name","title":"<code>get_object_name(x)</code>","text":"<p>Gets the name of virtually any object.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>The object to get the name of.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the object.</p> Source code in <code>naff\\client\\utils\\misc_utils.py</code> <pre><code>def get_object_name(x: Any) -&gt; str:\n\"\"\"Gets the name of virtually any object.\n\n    Args:\n        x (Any): The object to get the name of.\n\n    Returns:\n        str: The name of the object.\n    \"\"\"\n    try:\n        return x.__name__\n    except AttributeError:\n        return repr(x) if hasattr(x, \"__origin__\") else x.__class__.__name__\n</code></pre>"},{"location":"API%20Reference/utils/#naff.client.utils.misc_utils.maybe_coroutine","title":"<code>maybe_coroutine(func, *args, **kwargs)</code>  <code>async</code>","text":"<p>Allows running either a coroutine or a function.</p> Source code in <code>naff\\client\\utils\\misc_utils.py</code> <pre><code>async def maybe_coroutine(func: Callable, *args, **kwargs) -&gt; Any:\n\"\"\"Allows running either a coroutine or a function.\"\"\"\n    if inspect.iscoroutinefunction(func):\n        return await func(*args, **kwargs)\n    else:\n        return func(*args, **kwargs)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/","title":"HTTP client","text":"<p>This file handles the interaction with discords http endpoints.</p>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.GlobalLock","title":"<code>GlobalLock</code>","text":"Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>class GlobalLock:\n    def __init__(self) -&gt; None:\n        self._lock = asyncio.Lock()\n        self.max_requests = 45\n        self._calls = self.max_requests\n        self._reset_time = 0\n\n    @property\n    def calls_remaining(self) -&gt; int:\n\"\"\"Returns the amount of calls remaining.\"\"\"\n        return self.max_requests - self._calls\n\n    def reset_calls(self) -&gt; None:\n\"\"\"Resets the calls to the max amount.\"\"\"\n        self._calls = self.max_requests\n        self._reset_time = time.perf_counter() + 1\n\n    def set_reset_time(self, delta: float) -&gt; None:\n\"\"\"\n        Sets the reset time to the current time + delta.\n\n        To be called if a 429 is received.\n        Args:\n            delta: The time to wait before resetting the calls.\n        \"\"\"\n        self._reset_time = time.perf_counter() + delta\n        self._calls = 0\n\n    async def wait(self) -&gt; None:\n\"\"\"Throttles calls to prevent hitting the global rate limit.\"\"\"\n        async with self._lock:\n            if self._reset_time &lt;= time.perf_counter():\n                self.reset_calls()\n            elif self._calls &lt;= 0:\n                await asyncio.sleep(self._reset_time - time.perf_counter())\n                self.reset_calls()\n        self._calls -= 1\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.GlobalLock.calls_remaining","title":"<code>calls_remaining: int</code>  <code>property</code>","text":"<p>Returns the amount of calls remaining.</p>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.GlobalLock.reset_calls","title":"<code>reset_calls()</code>","text":"<p>Resets the calls to the max amount.</p> Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>def reset_calls(self) -&gt; None:\n\"\"\"Resets the calls to the max amount.\"\"\"\n    self._calls = self.max_requests\n    self._reset_time = time.perf_counter() + 1\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.GlobalLock.set_reset_time","title":"<code>set_reset_time(delta)</code>","text":"<p>Sets the reset time to the current time + delta.</p> <p>To be called if a 429 is received.</p> <p>Parameters:</p> Name Type Description Default <code>delta</code> <code>float</code> <p>The time to wait before resetting the calls.</p> required Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>def set_reset_time(self, delta: float) -&gt; None:\n\"\"\"\n    Sets the reset time to the current time + delta.\n\n    To be called if a 429 is received.\n    Args:\n        delta: The time to wait before resetting the calls.\n    \"\"\"\n    self._reset_time = time.perf_counter() + delta\n    self._calls = 0\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.GlobalLock.wait","title":"<code>wait()</code>  <code>async</code>","text":"<p>Throttles calls to prevent hitting the global rate limit.</p> Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>async def wait(self) -&gt; None:\n\"\"\"Throttles calls to prevent hitting the global rate limit.\"\"\"\n    async with self._lock:\n        if self._reset_time &lt;= time.perf_counter():\n            self.reset_calls()\n        elif self._calls &lt;= 0:\n            await asyncio.sleep(self._reset_time - time.perf_counter())\n            self.reset_calls()\n    self._calls -= 1\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.BucketLock","title":"<code>BucketLock</code>","text":"<p>Manages the ratelimit for each bucket</p> Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>class BucketLock:\n\"\"\"Manages the ratelimit for each bucket\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._lock: asyncio.Lock = asyncio.Lock()\n\n        self.unlock_on_exit: bool = True\n\n        self.bucket_hash: str | None = None\n        self.limit: int = -1\n        self.remaining: int = -1\n        self.delta: float = 0.0\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;BucketLock: {self.bucket_hash or 'Generic'}&gt;\"\n\n    @property\n    def locked(self) -&gt; bool:\n\"\"\"Return True if lock is acquired.\"\"\"\n        return self._lock.locked()\n\n    def unlock(self) -&gt; None:\n\"\"\"Unlock this bucket.\"\"\"\n        self._lock.release()\n\n    def ingest_ratelimit_header(self, header: CIMultiDictProxy) -&gt; None:\n\"\"\"\n        Ingests a discord rate limit header to configure this bucket lock.\n\n        Args:\n            header: A header from a http response\n        \"\"\"\n        self.bucket_hash = header.get(\"x-ratelimit-bucket\")\n        self.limit = int(header.get(\"x-ratelimit-limit\") or -1)\n        self.remaining = int(header.get(\"x-ratelimit-remaining\") or -1)\n        self.delta = float(header.get(\"x-ratelimit-reset-after\", 0.0))\n\n    async def blind_defer_unlock(self) -&gt; None:\n\"\"\"Unlocks the BucketLock but doesn't wait for completion.\"\"\"\n        self.unlock_on_exit = False\n        loop = asyncio.get_running_loop()\n        loop.call_later(self.delta, self.unlock)\n\n    async def defer_unlock(self, reset_after: float | None = None) -&gt; None:\n\"\"\"Unlocks the BucketLock after a specified delay.\"\"\"\n        self.unlock_on_exit = False\n        await asyncio.sleep(reset_after or self.delta)\n        self.unlock()\n\n    async def __aenter__(self) -&gt; None:\n        await self._lock.acquire()\n\n    async def __aexit__(self, *args) -&gt; None:\n        if self.unlock_on_exit and self._lock.locked():\n            self.unlock()\n        self.unlock_on_exit = True\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.BucketLock.locked","title":"<code>locked: bool</code>  <code>property</code>","text":"<p>Return True if lock is acquired.</p>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.BucketLock.unlock","title":"<code>unlock()</code>","text":"<p>Unlock this bucket.</p> Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>def unlock(self) -&gt; None:\n\"\"\"Unlock this bucket.\"\"\"\n    self._lock.release()\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.BucketLock.ingest_ratelimit_header","title":"<code>ingest_ratelimit_header(header)</code>","text":"<p>Ingests a discord rate limit header to configure this bucket lock.</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>CIMultiDictProxy</code> <p>A header from a http response</p> required Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>def ingest_ratelimit_header(self, header: CIMultiDictProxy) -&gt; None:\n\"\"\"\n    Ingests a discord rate limit header to configure this bucket lock.\n\n    Args:\n        header: A header from a http response\n    \"\"\"\n    self.bucket_hash = header.get(\"x-ratelimit-bucket\")\n    self.limit = int(header.get(\"x-ratelimit-limit\") or -1)\n    self.remaining = int(header.get(\"x-ratelimit-remaining\") or -1)\n    self.delta = float(header.get(\"x-ratelimit-reset-after\", 0.0))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.BucketLock.blind_defer_unlock","title":"<code>blind_defer_unlock()</code>  <code>async</code>","text":"<p>Unlocks the BucketLock but doesn't wait for completion.</p> Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>async def blind_defer_unlock(self) -&gt; None:\n\"\"\"Unlocks the BucketLock but doesn't wait for completion.\"\"\"\n    self.unlock_on_exit = False\n    loop = asyncio.get_running_loop()\n    loop.call_later(self.delta, self.unlock)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.BucketLock.defer_unlock","title":"<code>defer_unlock(reset_after=None)</code>  <code>async</code>","text":"<p>Unlocks the BucketLock after a specified delay.</p> Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>async def defer_unlock(self, reset_after: float | None = None) -&gt; None:\n\"\"\"Unlocks the BucketLock after a specified delay.\"\"\"\n    self.unlock_on_exit = False\n    await asyncio.sleep(reset_after or self.delta)\n    self.unlock()\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.HTTPClient","title":"<code>HTTPClient</code>","text":"<p>         Bases: <code>BotRequests</code>, <code>ChannelRequests</code>, <code>EmojiRequests</code>, <code>GuildRequests</code>, <code>InteractionRequests</code>, <code>MemberRequests</code>, <code>MessageRequests</code>, <code>ReactionRequests</code>, <code>StickerRequests</code>, <code>ThreadRequests</code>, <code>UserRequests</code>, <code>WebhookRequests</code>, <code>ScheduledEventsRequests</code></p> <p>A http client for sending requests to the Discord API.</p> Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>class HTTPClient(\n    BotRequests,\n    ChannelRequests,\n    EmojiRequests,\n    GuildRequests,\n    InteractionRequests,\n    MemberRequests,\n    MessageRequests,\n    ReactionRequests,\n    StickerRequests,\n    ThreadRequests,\n    UserRequests,\n    WebhookRequests,\n    ScheduledEventsRequests,\n):\n\"\"\"A http client for sending requests to the Discord API.\"\"\"\n\n    def __init__(self, connector: BaseConnector | None = None, logger: Logger = MISSING) -&gt; None:\n        self.connector: BaseConnector | None = connector\n        self.__session: ClientSession | None = None\n        self.token: str | None = None\n        self.global_lock: GlobalLock = GlobalLock()\n        self._max_attempts: int = 3\n\n        self.ratelimit_locks: WeakValueDictionary[str, BucketLock] = WeakValueDictionary()\n        self._endpoints = {}\n\n        self.user_agent: str = (\n            f\"DiscordBot ({__repo_url__} {__version__} Python/{__py_version__}) aiohttp/{aiohttp.__version__}\"\n        )\n\n        if logger is MISSING:\n            logger = constants.get_logger()\n        self.logger = logger\n\n    def get_ratelimit(self, route: Route) -&gt; BucketLock:\n\"\"\"\n        Get a route's rate limit bucket.\n\n        Args:\n            route: The route to fetch the ratelimit bucket for\n\n        Returns:\n            The BucketLock object for this route\n        \"\"\"\n        if bucket_hash := self._endpoints.get(route.rl_bucket):\n            # we have seen this route before, we know which bucket it is associated with\n            lock = self.ratelimit_locks.get(bucket_hash)\n            if lock:\n                # if we have an active lock on this route, it'll still be in the cache\n                # return that lock\n                return lock\n        # if no cached lock exists, return a new lock\n        return BucketLock()\n\n    def ingest_ratelimit(self, route: Route, header: CIMultiDictProxy, bucket_lock: BucketLock) -&gt; None:\n\"\"\"\n        Ingests a ratelimit header from discord to determine ratelimit.\n\n        Args:\n            route: The route we're ingesting ratelimit for\n            header: The rate limit header in question\n            bucket_lock: The rate limit bucket for this route\n        \"\"\"\n        bucket_lock.ingest_ratelimit_header(header)\n\n        if bucket_lock.bucket_hash:\n            # We only ever try and cache the bucket if the bucket hash has been set (ignores unlimited endpoints)\n            self.logger.debug(f\"Caching ingested rate limit data for: {bucket_lock.bucket_hash}\")\n            self._endpoints[route.rl_bucket] = bucket_lock.bucket_hash\n            self.ratelimit_locks[bucket_lock.bucket_hash] = bucket_lock\n\n    @staticmethod\n    def _process_payload(\n        payload: dict | list[dict] | None, files: UPLOADABLE_TYPE | list[UPLOADABLE_TYPE] | None\n    ) -&gt; dict | list[dict] | FormData | None:\n\"\"\"\n        Processes a payload into a format safe for discord. Converts the payload into FormData where required\n\n        Args:\n            payload: The payload of the request\n            files: A list of any files to send\n\n        Returns:\n            Either a dictionary or multipart data form\n        \"\"\"\n        if payload is None:\n            return None\n\n        if isinstance(payload, dict):\n            payload = dict_filter(payload)\n\n            for k, v in payload.items():\n                if isinstance(v, DictSerializationMixin):\n                    payload[k] = v.to_dict()\n                if isinstance(v, (list, tuple, set)):\n                    payload[k] = [i.to_dict() if isinstance(i, DictSerializationMixin) else i for i in v]\n\n        else:\n            payload = [dict_filter(x) if isinstance(x, dict) else x for x in payload]\n\n        if not files:\n            return payload\n\n        if not isinstance(files, list):\n            files = [files]\n\n        form_data = FormData()\n        form_data.add_field(\"payload_json\", OverriddenJson.dumps(payload))\n\n        for index, file in enumerate(files):\n            file_buffer = models.open_file(file)\n            if isinstance(file, models.File):\n                form_data.add_field(f\"files[{index}]\", file_buffer, filename=file.file_name)\n            else:\n                form_data.add_field(f\"files[{index}]\", file_buffer)\n        return form_data\n\n    async def request(\n        self,\n        route: Route,\n        payload: list | dict | None = None,\n        files: list[UPLOADABLE_TYPE] | None = None,\n        reason: str | None = None,\n        params: dict | None = None,\n        **kwargs: dict,\n    ) -&gt; str | dict[str, Any] | None:\n\"\"\"\n        Make a request to discord.\n\n        Args:\n            route: The route to take\n            payload: The payload for this request\n            files: The files to send with this request\n            reason: Attach a reason to this request, used for audit logs\n\n        \"\"\"\n        # Assemble headers\n        kwargs[\"headers\"] = {\"User-Agent\": self.user_agent}\n        if self.token:\n            kwargs[\"headers\"][\"Authorization\"] = f\"Bot {self.token}\"\n        if reason:\n            kwargs[\"headers\"][\"X-Audit-Log-Reason\"] = _uriquote(reason, safe=\"/ \")\n\n        if isinstance(payload, (list, dict)) and not files:\n            kwargs[\"headers\"][\"Content-Type\"] = \"application/json\"\n        if isinstance(params, dict):\n            kwargs[\"params\"] = dict_filter(params)\n\n        lock = self.get_ratelimit(route)\n        # this gets a BucketLock for this route.\n        # If this endpoint has been used before, it will get an existing ratelimit for the respective buckethash\n        # otherwise a brand-new bucket lock will be returned\n\n        for attempt in range(self._max_attempts):\n            async with lock:\n                try:\n                    if self.__session.closed:\n                        await self.login(cast(str, self.token))\n\n                    processed_data = self._process_payload(payload, files)\n                    if isinstance(processed_data, FormData):\n                        kwargs[\"data\"] = processed_data  # pyright: ignore\n                    else:\n                        kwargs[\"json\"] = processed_data  # pyright: ignore\n                    await self.global_lock.wait()\n\n                    async with self.__session.request(route.method, route.url, **kwargs) as response:\n                        result = await response_decode(response)\n                        self.ingest_ratelimit(route, response.headers, lock)\n\n                        if response.status == 429:\n                            # ratelimit exceeded\n                            result = cast(dict[str, str], result)\n                            if result.get(\"global\", False):\n                                # global ratelimit is reached\n                                # if we get a global, that's pretty bad, this would usually happen if the user is hitting the api from 2 clients sharing a token\n                                self.logger.error(\n                                    f\"Bot has exceeded global ratelimit, locking REST API for {result['retry_after']} seconds\"\n                                )\n                                self.global_lock.set_reset_time(float(result[\"retry_after\"]))\n                                continue\n                            elif result.get(\"message\") == \"The resource is being rate limited.\":\n                                # resource ratelimit is reached\n                                self.logger.warning(\n                                    f\"{route.endpoint} The resource is being rate limited! \"\n                                    f\"Reset in {result.get('retry_after')} seconds\"\n                                )\n                                # lock this resource and wait for unlock\n                                await lock.defer_unlock(float(result[\"retry_after\"]))\n                                continue\n                            else:\n                                # endpoint ratelimit is reached\n                                # 429's are unfortunately unavoidable, but we can attempt to avoid them\n                                # so long as these are infrequent we're doing well\n                                self.logger.warning(\n                                    f\"{route.endpoint} Has exceeded it's ratelimit ({lock.limit})! Reset in {lock.delta} seconds\"\n                                )\n                                await lock.defer_unlock()  # lock this route and wait for unlock\n                                continue\n                        elif lock.remaining == 0:\n                            # Last call available in the bucket, lock until reset\n                            self.logger.debug(\n                                f\"{route.endpoint} Has exhausted its ratelimit ({lock.limit})! Locking route for {lock.delta} seconds\"\n                            )\n                            await lock.blind_defer_unlock()  # lock this route, but continue processing the current response\n\n                        elif response.status in {500, 502, 504}:\n                            # Server issues, retry\n                            self.logger.warning(\n                                f\"{route.endpoint} Received {response.status}... retrying in {1 + attempt * 2} seconds\"\n                            )\n                            await asyncio.sleep(1 + attempt * 2)\n                            continue\n\n                        if not 300 &gt; response.status &gt;= 200:\n                            await self._raise_exception(response, route, result)\n\n                        self.logger.debug(\n                            f\"{route.endpoint} Received {response.status} :: [{lock.remaining}/{lock.limit} calls remaining]\"\n                        )\n                        return result\n                except OSError as e:\n                    if attempt &lt; self._max_attempts - 1 and e.errno in (54, 10054):\n                        await asyncio.sleep(1 + attempt * 2)\n                        continue\n                    raise\n\n    async def _raise_exception(self, response, route, result) -&gt; None:\n        self.logger.error(f\"{route.method}::{route.url}: {response.status}\")\n\n        if response.status == 403:\n            raise Forbidden(response, response_data=result, route=route)\n        elif response.status == 404:\n            raise NotFound(response, response_data=result, route=route)\n        elif response.status &gt;= 500:\n            raise DiscordError(response, response_data=result, route=route)\n        else:\n            raise HTTPException(response, response_data=result, route=route)\n\n    async def request_cdn(self, url, asset) -&gt; bytes:  # pyright: ignore [reportGeneralTypeIssues]\n        self.logger.debug(f\"{asset} requests {url} from CDN\")\n        async with self.__session.get(url) as response:\n            if response.status == 200:\n                return await response.read()\n            await self._raise_exception(response, asset, await response_decode(response))\n\n    async def login(self, token: str) -&gt; dict[str, Any]:\n\"\"\"\n        \"Login\" to the gateway, basically validates the token and grabs user data.\n\n        Args:\n            token: the token to use\n\n        Returns:\n            The currently logged in bot's data\n\n        \"\"\"\n        self.__session = ClientSession(\n            connector=self.connector if self.connector else aiohttp.TCPConnector(limit=self.global_lock.max_requests),\n        )\n        self.token = token\n        try:\n            result = await self.request(Route(\"GET\", \"/users/@me\"))\n            return cast(dict[str, Any], result)\n        except HTTPException as e:\n            if e.status == 401:\n                raise LoginError(\"An improper token was passed\") from e\n            raise\n\n    async def close(self) -&gt; None:\n\"\"\"Close the session.\"\"\"\n        if self.__session and not self.__session.closed:\n            await self.__session.close()\n\n    async def get_gateway(self) -&gt; str:\n\"\"\"\n        Gets the gateway url.\n\n        Returns:\n            The gateway url\n\n        \"\"\"\n        try:\n            result = await self.request(Route(\"GET\", \"/gateway\"))\n            result = cast(dict[str, Any], result)\n        except HTTPException as exc:\n            raise GatewayNotFound from exc\n        return \"{0}?encoding={1}&amp;v={2}&amp;compress=zlib-stream\".format(result[\"url\"], \"json\", __api_version__)\n\n    async def get_gateway_bot(self) -&gt; discord_typings.GetGatewayBotData:\n        try:\n            result = await self.request(Route(\"GET\", \"/gateway/bot\"))\n        except HTTPException as exc:\n            raise GatewayNotFound from exc\n        return cast(discord_typings.GetGatewayBotData, result)\n\n    async def websocket_connect(self, url: str) -&gt; ClientWebSocketResponse:\n\"\"\"\n        Connect to the websocket.\n\n        Args:\n            url: the url to connect to\n\n        \"\"\"\n        return await self.__session.ws_connect(\n            url, timeout=30, max_msg_size=0, autoclose=False, headers={\"User-Agent\": self.user_agent}, compress=0\n        )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.HTTPClient.get_ratelimit","title":"<code>get_ratelimit(route)</code>","text":"<p>Get a route's rate limit bucket.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Route</code> <p>The route to fetch the ratelimit bucket for</p> required <p>Returns:</p> Type Description <code>BucketLock</code> <p>The BucketLock object for this route</p> Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>def get_ratelimit(self, route: Route) -&gt; BucketLock:\n\"\"\"\n    Get a route's rate limit bucket.\n\n    Args:\n        route: The route to fetch the ratelimit bucket for\n\n    Returns:\n        The BucketLock object for this route\n    \"\"\"\n    if bucket_hash := self._endpoints.get(route.rl_bucket):\n        # we have seen this route before, we know which bucket it is associated with\n        lock = self.ratelimit_locks.get(bucket_hash)\n        if lock:\n            # if we have an active lock on this route, it'll still be in the cache\n            # return that lock\n            return lock\n    # if no cached lock exists, return a new lock\n    return BucketLock()\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.HTTPClient.ingest_ratelimit","title":"<code>ingest_ratelimit(route, header, bucket_lock)</code>","text":"<p>Ingests a ratelimit header from discord to determine ratelimit.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Route</code> <p>The route we're ingesting ratelimit for</p> required <code>header</code> <code>CIMultiDictProxy</code> <p>The rate limit header in question</p> required <code>bucket_lock</code> <code>BucketLock</code> <p>The rate limit bucket for this route</p> required Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>def ingest_ratelimit(self, route: Route, header: CIMultiDictProxy, bucket_lock: BucketLock) -&gt; None:\n\"\"\"\n    Ingests a ratelimit header from discord to determine ratelimit.\n\n    Args:\n        route: The route we're ingesting ratelimit for\n        header: The rate limit header in question\n        bucket_lock: The rate limit bucket for this route\n    \"\"\"\n    bucket_lock.ingest_ratelimit_header(header)\n\n    if bucket_lock.bucket_hash:\n        # We only ever try and cache the bucket if the bucket hash has been set (ignores unlimited endpoints)\n        self.logger.debug(f\"Caching ingested rate limit data for: {bucket_lock.bucket_hash}\")\n        self._endpoints[route.rl_bucket] = bucket_lock.bucket_hash\n        self.ratelimit_locks[bucket_lock.bucket_hash] = bucket_lock\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.HTTPClient.request","title":"<code>request(route, payload=None, files=None, reason=None, params=None, **kwargs)</code>  <code>async</code>","text":"<p>Make a request to discord.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Route</code> <p>The route to take</p> required <code>payload</code> <code>list | dict | None</code> <p>The payload for this request</p> <code>None</code> <code>files</code> <code>list[UPLOADABLE_TYPE] | None</code> <p>The files to send with this request</p> <code>None</code> <code>reason</code> <code>str | None</code> <p>Attach a reason to this request, used for audit logs</p> <code>None</code> Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>async def request(\n    self,\n    route: Route,\n    payload: list | dict | None = None,\n    files: list[UPLOADABLE_TYPE] | None = None,\n    reason: str | None = None,\n    params: dict | None = None,\n    **kwargs: dict,\n) -&gt; str | dict[str, Any] | None:\n\"\"\"\n    Make a request to discord.\n\n    Args:\n        route: The route to take\n        payload: The payload for this request\n        files: The files to send with this request\n        reason: Attach a reason to this request, used for audit logs\n\n    \"\"\"\n    # Assemble headers\n    kwargs[\"headers\"] = {\"User-Agent\": self.user_agent}\n    if self.token:\n        kwargs[\"headers\"][\"Authorization\"] = f\"Bot {self.token}\"\n    if reason:\n        kwargs[\"headers\"][\"X-Audit-Log-Reason\"] = _uriquote(reason, safe=\"/ \")\n\n    if isinstance(payload, (list, dict)) and not files:\n        kwargs[\"headers\"][\"Content-Type\"] = \"application/json\"\n    if isinstance(params, dict):\n        kwargs[\"params\"] = dict_filter(params)\n\n    lock = self.get_ratelimit(route)\n    # this gets a BucketLock for this route.\n    # If this endpoint has been used before, it will get an existing ratelimit for the respective buckethash\n    # otherwise a brand-new bucket lock will be returned\n\n    for attempt in range(self._max_attempts):\n        async with lock:\n            try:\n                if self.__session.closed:\n                    await self.login(cast(str, self.token))\n\n                processed_data = self._process_payload(payload, files)\n                if isinstance(processed_data, FormData):\n                    kwargs[\"data\"] = processed_data  # pyright: ignore\n                else:\n                    kwargs[\"json\"] = processed_data  # pyright: ignore\n                await self.global_lock.wait()\n\n                async with self.__session.request(route.method, route.url, **kwargs) as response:\n                    result = await response_decode(response)\n                    self.ingest_ratelimit(route, response.headers, lock)\n\n                    if response.status == 429:\n                        # ratelimit exceeded\n                        result = cast(dict[str, str], result)\n                        if result.get(\"global\", False):\n                            # global ratelimit is reached\n                            # if we get a global, that's pretty bad, this would usually happen if the user is hitting the api from 2 clients sharing a token\n                            self.logger.error(\n                                f\"Bot has exceeded global ratelimit, locking REST API for {result['retry_after']} seconds\"\n                            )\n                            self.global_lock.set_reset_time(float(result[\"retry_after\"]))\n                            continue\n                        elif result.get(\"message\") == \"The resource is being rate limited.\":\n                            # resource ratelimit is reached\n                            self.logger.warning(\n                                f\"{route.endpoint} The resource is being rate limited! \"\n                                f\"Reset in {result.get('retry_after')} seconds\"\n                            )\n                            # lock this resource and wait for unlock\n                            await lock.defer_unlock(float(result[\"retry_after\"]))\n                            continue\n                        else:\n                            # endpoint ratelimit is reached\n                            # 429's are unfortunately unavoidable, but we can attempt to avoid them\n                            # so long as these are infrequent we're doing well\n                            self.logger.warning(\n                                f\"{route.endpoint} Has exceeded it's ratelimit ({lock.limit})! Reset in {lock.delta} seconds\"\n                            )\n                            await lock.defer_unlock()  # lock this route and wait for unlock\n                            continue\n                    elif lock.remaining == 0:\n                        # Last call available in the bucket, lock until reset\n                        self.logger.debug(\n                            f\"{route.endpoint} Has exhausted its ratelimit ({lock.limit})! Locking route for {lock.delta} seconds\"\n                        )\n                        await lock.blind_defer_unlock()  # lock this route, but continue processing the current response\n\n                    elif response.status in {500, 502, 504}:\n                        # Server issues, retry\n                        self.logger.warning(\n                            f\"{route.endpoint} Received {response.status}... retrying in {1 + attempt * 2} seconds\"\n                        )\n                        await asyncio.sleep(1 + attempt * 2)\n                        continue\n\n                    if not 300 &gt; response.status &gt;= 200:\n                        await self._raise_exception(response, route, result)\n\n                    self.logger.debug(\n                        f\"{route.endpoint} Received {response.status} :: [{lock.remaining}/{lock.limit} calls remaining]\"\n                    )\n                    return result\n            except OSError as e:\n                if attempt &lt; self._max_attempts - 1 and e.errno in (54, 10054):\n                    await asyncio.sleep(1 + attempt * 2)\n                    continue\n                raise\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.HTTPClient.login","title":"<code>login(token)</code>  <code>async</code>","text":"<p>\"Login\" to the gateway, basically validates the token and grabs user data.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>the token to use</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The currently logged in bot's data</p> Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>async def login(self, token: str) -&gt; dict[str, Any]:\n\"\"\"\n    \"Login\" to the gateway, basically validates the token and grabs user data.\n\n    Args:\n        token: the token to use\n\n    Returns:\n        The currently logged in bot's data\n\n    \"\"\"\n    self.__session = ClientSession(\n        connector=self.connector if self.connector else aiohttp.TCPConnector(limit=self.global_lock.max_requests),\n    )\n    self.token = token\n    try:\n        result = await self.request(Route(\"GET\", \"/users/@me\"))\n        return cast(dict[str, Any], result)\n    except HTTPException as e:\n        if e.status == 401:\n            raise LoginError(\"An improper token was passed\") from e\n        raise\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.HTTPClient.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the session.</p> Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Close the session.\"\"\"\n    if self.__session and not self.__session.closed:\n        await self.__session.close()\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.HTTPClient.get_gateway","title":"<code>get_gateway()</code>  <code>async</code>","text":"<p>Gets the gateway url.</p> <p>Returns:</p> Type Description <code>str</code> <p>The gateway url</p> Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>async def get_gateway(self) -&gt; str:\n\"\"\"\n    Gets the gateway url.\n\n    Returns:\n        The gateway url\n\n    \"\"\"\n    try:\n        result = await self.request(Route(\"GET\", \"/gateway\"))\n        result = cast(dict[str, Any], result)\n    except HTTPException as exc:\n        raise GatewayNotFound from exc\n    return \"{0}?encoding={1}&amp;v={2}&amp;compress=zlib-stream\".format(result[\"url\"], \"json\", __api_version__)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/HTTP_client/#naff.api.http.http_client.HTTPClient.websocket_connect","title":"<code>websocket_connect(url)</code>  <code>async</code>","text":"<p>Connect to the websocket.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>the url to connect to</p> required Source code in <code>naff\\api\\http\\http_client.py</code> <pre><code>async def websocket_connect(self, url: str) -&gt; ClientWebSocketResponse:\n\"\"\"\n    Connect to the websocket.\n\n    Args:\n        url: the url to connect to\n\n    \"\"\"\n    return await self.__session.ws_connect(\n        url, timeout=30, max_msg_size=0, autoclose=False, headers={\"User-Agent\": self.user_agent}, compress=0\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/","title":"Supported Endpoints","text":"<p>This is a list of endpoints that are supported by naff. These methods are organised in sub-files of naff/http_requests according to where they best fit.</p> <p>Note</p> <p>The majority of the time you should never need to interact with these. They\u2019re only documented for people contributing to naff.</p>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.BotRequests","title":"<code>BotRequests</code>","text":"<p>         Bases: <code>CanRequest</code></p> Source code in <code>naff\\api\\http\\http_requests\\bot.py</code> <pre><code>class BotRequests(CanRequest):\n    async def get_current_bot_information(self) -&gt; discord_typings.ApplicationData:\n\"\"\"\n        Gets the bot's application object without flags.\n\n        Returns:\n            application object\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", \"/oauth2/applications/@me\"))\n        return cast(discord_typings.ApplicationData, result)\n\n    async def get_current_authorisation_information(self) -&gt; dict:  # todo typing?\n\"\"\"\n        Gets info about the current authorization.\n\n        Returns:\n            Authorisation information\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", \"/oauth2/@me\"))\n        return cast(dict, result)\n\n    async def list_voice_regions(self) -&gt; list[discord_typings.VoiceRegionData]:\n\"\"\"\n        Gets an array of voice region objects that can be used when setting a voice or stage channel's `rtc_region`.\n\n        Returns:\n            an array of voice region objects\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", \"/voice/regions\"))\n        return cast(list[discord_typings.VoiceRegionData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.bot.BotRequests.get_current_bot_information","title":"<code>get_current_bot_information()</code>  <code>async</code>","text":"<p>Gets the bot's application object without flags.</p> <p>Returns:</p> Type Description <code>discord_typings.ApplicationData</code> <p>application object</p> Source code in <code>naff\\api\\http\\http_requests\\bot.py</code> <pre><code>async def get_current_bot_information(self) -&gt; discord_typings.ApplicationData:\n\"\"\"\n    Gets the bot's application object without flags.\n\n    Returns:\n        application object\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", \"/oauth2/applications/@me\"))\n    return cast(discord_typings.ApplicationData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.bot.BotRequests.get_current_authorisation_information","title":"<code>get_current_authorisation_information()</code>  <code>async</code>","text":"<p>Gets info about the current authorization.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Authorisation information</p> Source code in <code>naff\\api\\http\\http_requests\\bot.py</code> <pre><code>async def get_current_authorisation_information(self) -&gt; dict:  # todo typing?\n\"\"\"\n    Gets info about the current authorization.\n\n    Returns:\n        Authorisation information\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", \"/oauth2/@me\"))\n    return cast(dict, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.bot.BotRequests.list_voice_regions","title":"<code>list_voice_regions()</code>  <code>async</code>","text":"<p>Gets an array of voice region objects that can be used when setting a voice or stage channel's <code>rtc_region</code>.</p> <p>Returns:</p> Type Description <code>list[discord_typings.VoiceRegionData]</code> <p>an array of voice region objects</p> Source code in <code>naff\\api\\http\\http_requests\\bot.py</code> <pre><code>async def list_voice_regions(self) -&gt; list[discord_typings.VoiceRegionData]:\n\"\"\"\n    Gets an array of voice region objects that can be used when setting a voice or stage channel's `rtc_region`.\n\n    Returns:\n        an array of voice region objects\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", \"/voice/regions\"))\n    return cast(list[discord_typings.VoiceRegionData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.UserRequests","title":"<code>UserRequests</code>","text":"Source code in <code>naff\\api\\http\\http_requests\\users.py</code> <pre><code>class UserRequests:\n    request: Any\n\n    async def get_current_user(self) -&gt; discord_typings.UserData:\n\"\"\"\n        Shortcut to get requester's user.\n\n        Returns:\n            The user object.\n\n        \"\"\"\n        return await self.get_user(\"@me\")\n\n    async def get_user(self, user_id: \"Snowflake_Type\") -&gt; discord_typings.UserData:\n\"\"\"\n        Get a user object for a given user ID.\n\n        Args:\n            user_id: The user to get.\n\n        Returns:\n            The user object.\n\n        \"\"\"\n        return await self.request(Route(\"GET\", f\"/users/{user_id}\"))\n\n    async def modify_client_user(self, payload: dict) -&gt; discord_typings.UserData:\n\"\"\"\n        Modify the user account settings.\n\n        Args:\n            payload: The data to send.\n\n        \"\"\"\n        return await self.request(Route(\"PATCH\", \"/users/@me\"), payload=payload)\n\n    async def get_user_guilds(self) -&gt; List[discord_typings.GuildData]:\n\"\"\"\n        Returns a list of partial guild objects the current user is a member of.\n\n        Requires the guilds OAuth2 scope.\n\n        \"\"\"\n        return await self.request(Route(\"GET\", \"/users/@me/guilds\"))\n\n    async def leave_guild(self, guild_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n        Leave a guild. Returns a 204 empty response on success.\n\n        Args:\n            guild_id: The guild to leave from.\n\n        \"\"\"\n        return await self.request(Route(\"DELETE\", f\"/users/@me/guilds/{guild_id}\"))\n\n    async def create_dm(self, recipient_id: \"Snowflake_Type\") -&gt; discord_typings.DMChannelData:\n\"\"\"\n        Create a new DM channel with a user. Returns a DM channel object.\n\n        Args:\n            recipient_id: The recipient to open a DM channel with.\n\n        \"\"\"\n        return await self.request(Route(\"POST\", \"/users/@me/channels\"), payload={\"recipient_id\": recipient_id})\n\n    async def create_group_dm(self, payload: dict) -&gt; discord_typings.GroupDMChannelData:\n\"\"\"\n        Create a new group DM channel with multiple users.\n\n        Args:\n            payload: The data to send.\n\n        \"\"\"\n        return await self.request(Route(\"POST\", \"/users/@me/channels\"), payload=payload)\n\n    async def get_user_connections(self) -&gt; list:\n\"\"\"\n        Returns a list of connection objects.\n\n        Requires the connections OAuth2 scope.\n\n        \"\"\"\n        return await self.request(Route(\"GET\", \"/users/@me/connections\"))\n\n    async def group_dm_add_recipient(\n        self, channel_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\", access_token: str, nick: str = None\n    ) -&gt; None:\n\"\"\"\n        Adds a recipient to a Group DM using their access token.\n\n        Args:\n            channel_id: The ID of the group dm\n            user_id: The ID of the user to add\n            access_token: Access token of a user that has granted your app the gdm.join scope\n            nick: Nickname of the user being added\n\n        \"\"\"\n        return await self.request(\n            Route(\"PUT\", f\"/channels/{channel_id}/recipients/{user_id}\"),\n            payload={\"access_token\": access_token, \"nick\": nick},\n        )\n\n    async def group_dm_remove_recipient(self, channel_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n        Remove a recipient from the group dm.\n\n        Args:\n            channel_id: The ID of the group dm\n            user_id: The ID of the user to remove\n\n        \"\"\"\n        return await self.request(Route(\"DELETE\", f\"/channels/{channel_id}/recipients/{user_id}\"))\n\n    async def modify_current_user_nick(self, guild_id: \"Snowflake_Type\", nickname: str = None) -&gt; None:\n\"\"\"\n        Modifies the nickname of the current user in a guild.\n\n        Args:\n            guild_id: The ID of the guild\n            nickname: The new nickname to use\n\n        \"\"\"\n        return await self.request(Route(\"PATCH\", f\"/guilds/{guild_id}/members/@me/nick\"), payload={\"nick\": nickname})\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.users.UserRequests.get_current_user","title":"<code>get_current_user()</code>  <code>async</code>","text":"<p>Shortcut to get requester's user.</p> <p>Returns:</p> Type Description <code>discord_typings.UserData</code> <p>The user object.</p> Source code in <code>naff\\api\\http\\http_requests\\users.py</code> <pre><code>async def get_current_user(self) -&gt; discord_typings.UserData:\n\"\"\"\n    Shortcut to get requester's user.\n\n    Returns:\n        The user object.\n\n    \"\"\"\n    return await self.get_user(\"@me\")\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.users.UserRequests.get_user","title":"<code>get_user(user_id)</code>  <code>async</code>","text":"<p>Get a user object for a given user ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>Snowflake_Type</code> <p>The user to get.</p> required <p>Returns:</p> Type Description <code>discord_typings.UserData</code> <p>The user object.</p> Source code in <code>naff\\api\\http\\http_requests\\users.py</code> <pre><code>async def get_user(self, user_id: \"Snowflake_Type\") -&gt; discord_typings.UserData:\n\"\"\"\n    Get a user object for a given user ID.\n\n    Args:\n        user_id: The user to get.\n\n    Returns:\n        The user object.\n\n    \"\"\"\n    return await self.request(Route(\"GET\", f\"/users/{user_id}\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.users.UserRequests.modify_client_user","title":"<code>modify_client_user(payload)</code>  <code>async</code>","text":"<p>Modify the user account settings.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>The data to send.</p> required Source code in <code>naff\\api\\http\\http_requests\\users.py</code> <pre><code>async def modify_client_user(self, payload: dict) -&gt; discord_typings.UserData:\n\"\"\"\n    Modify the user account settings.\n\n    Args:\n        payload: The data to send.\n\n    \"\"\"\n    return await self.request(Route(\"PATCH\", \"/users/@me\"), payload=payload)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.users.UserRequests.get_user_guilds","title":"<code>get_user_guilds()</code>  <code>async</code>","text":"<p>Returns a list of partial guild objects the current user is a member of.</p> <p>Requires the guilds OAuth2 scope.</p> Source code in <code>naff\\api\\http\\http_requests\\users.py</code> <pre><code>async def get_user_guilds(self) -&gt; List[discord_typings.GuildData]:\n\"\"\"\n    Returns a list of partial guild objects the current user is a member of.\n\n    Requires the guilds OAuth2 scope.\n\n    \"\"\"\n    return await self.request(Route(\"GET\", \"/users/@me/guilds\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.users.UserRequests.leave_guild","title":"<code>leave_guild(guild_id)</code>  <code>async</code>","text":"<p>Leave a guild. Returns a 204 empty response on success.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The guild to leave from.</p> required Source code in <code>naff\\api\\http\\http_requests\\users.py</code> <pre><code>async def leave_guild(self, guild_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n    Leave a guild. Returns a 204 empty response on success.\n\n    Args:\n        guild_id: The guild to leave from.\n\n    \"\"\"\n    return await self.request(Route(\"DELETE\", f\"/users/@me/guilds/{guild_id}\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.users.UserRequests.create_dm","title":"<code>create_dm(recipient_id)</code>  <code>async</code>","text":"<p>Create a new DM channel with a user. Returns a DM channel object.</p> <p>Parameters:</p> Name Type Description Default <code>recipient_id</code> <code>Snowflake_Type</code> <p>The recipient to open a DM channel with.</p> required Source code in <code>naff\\api\\http\\http_requests\\users.py</code> <pre><code>async def create_dm(self, recipient_id: \"Snowflake_Type\") -&gt; discord_typings.DMChannelData:\n\"\"\"\n    Create a new DM channel with a user. Returns a DM channel object.\n\n    Args:\n        recipient_id: The recipient to open a DM channel with.\n\n    \"\"\"\n    return await self.request(Route(\"POST\", \"/users/@me/channels\"), payload={\"recipient_id\": recipient_id})\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.users.UserRequests.create_group_dm","title":"<code>create_group_dm(payload)</code>  <code>async</code>","text":"<p>Create a new group DM channel with multiple users.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>The data to send.</p> required Source code in <code>naff\\api\\http\\http_requests\\users.py</code> <pre><code>async def create_group_dm(self, payload: dict) -&gt; discord_typings.GroupDMChannelData:\n\"\"\"\n    Create a new group DM channel with multiple users.\n\n    Args:\n        payload: The data to send.\n\n    \"\"\"\n    return await self.request(Route(\"POST\", \"/users/@me/channels\"), payload=payload)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.users.UserRequests.get_user_connections","title":"<code>get_user_connections()</code>  <code>async</code>","text":"<p>Returns a list of connection objects.</p> <p>Requires the connections OAuth2 scope.</p> Source code in <code>naff\\api\\http\\http_requests\\users.py</code> <pre><code>async def get_user_connections(self) -&gt; list:\n\"\"\"\n    Returns a list of connection objects.\n\n    Requires the connections OAuth2 scope.\n\n    \"\"\"\n    return await self.request(Route(\"GET\", \"/users/@me/connections\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.users.UserRequests.group_dm_add_recipient","title":"<code>group_dm_add_recipient(channel_id, user_id, access_token, nick=None)</code>  <code>async</code>","text":"<p>Adds a recipient to a Group DM using their access token.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the group dm</p> required <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the user to add</p> required <code>access_token</code> <code>str</code> <p>Access token of a user that has granted your app the gdm.join scope</p> required <code>nick</code> <code>str</code> <p>Nickname of the user being added</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\users.py</code> <pre><code>async def group_dm_add_recipient(\n    self, channel_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\", access_token: str, nick: str = None\n) -&gt; None:\n\"\"\"\n    Adds a recipient to a Group DM using their access token.\n\n    Args:\n        channel_id: The ID of the group dm\n        user_id: The ID of the user to add\n        access_token: Access token of a user that has granted your app the gdm.join scope\n        nick: Nickname of the user being added\n\n    \"\"\"\n    return await self.request(\n        Route(\"PUT\", f\"/channels/{channel_id}/recipients/{user_id}\"),\n        payload={\"access_token\": access_token, \"nick\": nick},\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.users.UserRequests.group_dm_remove_recipient","title":"<code>group_dm_remove_recipient(channel_id, user_id)</code>  <code>async</code>","text":"<p>Remove a recipient from the group dm.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the group dm</p> required <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the user to remove</p> required Source code in <code>naff\\api\\http\\http_requests\\users.py</code> <pre><code>async def group_dm_remove_recipient(self, channel_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n    Remove a recipient from the group dm.\n\n    Args:\n        channel_id: The ID of the group dm\n        user_id: The ID of the user to remove\n\n    \"\"\"\n    return await self.request(Route(\"DELETE\", f\"/channels/{channel_id}/recipients/{user_id}\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.users.UserRequests.modify_current_user_nick","title":"<code>modify_current_user_nick(guild_id, nickname=None)</code>  <code>async</code>","text":"<p>Modifies the nickname of the current user in a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>nickname</code> <code>str</code> <p>The new nickname to use</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\users.py</code> <pre><code>async def modify_current_user_nick(self, guild_id: \"Snowflake_Type\", nickname: str = None) -&gt; None:\n\"\"\"\n    Modifies the nickname of the current user in a guild.\n\n    Args:\n        guild_id: The ID of the guild\n        nickname: The new nickname to use\n\n    \"\"\"\n    return await self.request(Route(\"PATCH\", f\"/guilds/{guild_id}/members/@me/nick\"), payload={\"nick\": nickname})\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.EmojiRequests","title":"<code>EmojiRequests</code>","text":"<p>         Bases: <code>CanRequest</code></p> Source code in <code>naff\\api\\http\\http_requests\\emojis.py</code> <pre><code>class EmojiRequests(CanRequest):\n    async def get_all_guild_emoji(self, guild_id: \"Snowflake_Type\") -&gt; list[discord_typings.EmojiData]:\n\"\"\"\n        Get all the emoji from a guild.\n\n        Args:\n            guild_id: The ID of the guild to query.\n\n        Returns:\n            List of emoji objects\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/emojis\"))\n        return cast(list[discord_typings.EmojiData], result)\n\n    async def get_guild_emoji(\n        self, guild_id: \"Snowflake_Type\", emoji_id: \"Snowflake_Type\"\n    ) -&gt; discord_typings.EmojiData:\n\"\"\"\n        Get a specific guild emoji object.\n\n        Args:\n            guild_id: The ID of the guild to query\n            emoji_id: The ID of the emoji to get\n\n        Returns:\n            PartialEmoji object\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/emojis/{int(emoji_id)}\"))\n        return cast(discord_typings.EmojiData, result)\n\n    async def create_guild_emoji(\n        self, payload: dict, guild_id: \"Snowflake_Type\", reason: str | None = None\n    ) -&gt; discord_typings.EmojiData:\n\"\"\"\n        Create a guild emoji.\n\n        Args:\n            payload: The emoji's data\n            guild_id: The ID of the guild\n            reason: The reason for this creation\n\n        Returns:\n            The created emoji object\n\n        \"\"\"\n        result = await self.request(Route(\"POST\", f\"/guilds/{int(guild_id)}/emojis\"), payload=payload, reason=reason)\n        return cast(discord_typings.EmojiData, result)\n\n    async def modify_guild_emoji(\n        self, payload: dict, guild_id: \"Snowflake_Type\", emoji_id: \"Snowflake_Type\", reason: str | None = None\n    ) -&gt; discord_typings.EmojiData:\n\"\"\"\n        Modify an existing guild emoji.\n\n        Args:\n            payload: The emoji's data\n            guild_id: The ID of the guild\n            emoji_id: The ID of the emoji to update\n            reason: The reason for this creation\n\n        Returns:\n            The updated emoji object\n\n        \"\"\"\n        result = await self.request(\n            Route(\"PATCH\", f\"/guilds/{int(guild_id)}/emojis/{int(emoji_id)}\"), payload=payload, reason=reason\n        )\n        return cast(discord_typings.EmojiData, result)\n\n    async def delete_guild_emoji(\n        self, guild_id: \"Snowflake_Type\", emoji_id: \"Snowflake_Type\", reason: str | None = None\n    ) -&gt; None:\n\"\"\"\n        Delete a guild emoji.\n\n        Args:\n            guild_id: The ID of the guild\n            emoji_id: The ID of the emoji to update\n            reason: The reason for this deletion\n\n        \"\"\"\n        await self.request(Route(\"DELETE\", f\"/guilds/{int(guild_id)}/emojis/{int(emoji_id)}\"), reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.emojis.EmojiRequests.get_all_guild_emoji","title":"<code>get_all_guild_emoji(guild_id)</code>  <code>async</code>","text":"<p>Get all the emoji from a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to query.</p> required <p>Returns:</p> Type Description <code>list[discord_typings.EmojiData]</code> <p>List of emoji objects</p> Source code in <code>naff\\api\\http\\http_requests\\emojis.py</code> <pre><code>async def get_all_guild_emoji(self, guild_id: \"Snowflake_Type\") -&gt; list[discord_typings.EmojiData]:\n\"\"\"\n    Get all the emoji from a guild.\n\n    Args:\n        guild_id: The ID of the guild to query.\n\n    Returns:\n        List of emoji objects\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/emojis\"))\n    return cast(list[discord_typings.EmojiData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.emojis.EmojiRequests.get_guild_emoji","title":"<code>get_guild_emoji(guild_id, emoji_id)</code>  <code>async</code>","text":"<p>Get a specific guild emoji object.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to query</p> required <code>emoji_id</code> <code>Snowflake_Type</code> <p>The ID of the emoji to get</p> required <p>Returns:</p> Type Description <code>discord_typings.EmojiData</code> <p>PartialEmoji object</p> Source code in <code>naff\\api\\http\\http_requests\\emojis.py</code> <pre><code>async def get_guild_emoji(\n    self, guild_id: \"Snowflake_Type\", emoji_id: \"Snowflake_Type\"\n) -&gt; discord_typings.EmojiData:\n\"\"\"\n    Get a specific guild emoji object.\n\n    Args:\n        guild_id: The ID of the guild to query\n        emoji_id: The ID of the emoji to get\n\n    Returns:\n        PartialEmoji object\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/emojis/{int(emoji_id)}\"))\n    return cast(discord_typings.EmojiData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.emojis.EmojiRequests.create_guild_emoji","title":"<code>create_guild_emoji(payload, guild_id, reason=None)</code>  <code>async</code>","text":"<p>Create a guild emoji.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>The emoji's data</p> required <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>reason</code> <code>str | None</code> <p>The reason for this creation</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.EmojiData</code> <p>The created emoji object</p> Source code in <code>naff\\api\\http\\http_requests\\emojis.py</code> <pre><code>async def create_guild_emoji(\n    self, payload: dict, guild_id: \"Snowflake_Type\", reason: str | None = None\n) -&gt; discord_typings.EmojiData:\n\"\"\"\n    Create a guild emoji.\n\n    Args:\n        payload: The emoji's data\n        guild_id: The ID of the guild\n        reason: The reason for this creation\n\n    Returns:\n        The created emoji object\n\n    \"\"\"\n    result = await self.request(Route(\"POST\", f\"/guilds/{int(guild_id)}/emojis\"), payload=payload, reason=reason)\n    return cast(discord_typings.EmojiData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.emojis.EmojiRequests.modify_guild_emoji","title":"<code>modify_guild_emoji(payload, guild_id, emoji_id, reason=None)</code>  <code>async</code>","text":"<p>Modify an existing guild emoji.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>The emoji's data</p> required <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>emoji_id</code> <code>Snowflake_Type</code> <p>The ID of the emoji to update</p> required <code>reason</code> <code>str | None</code> <p>The reason for this creation</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.EmojiData</code> <p>The updated emoji object</p> Source code in <code>naff\\api\\http\\http_requests\\emojis.py</code> <pre><code>async def modify_guild_emoji(\n    self, payload: dict, guild_id: \"Snowflake_Type\", emoji_id: \"Snowflake_Type\", reason: str | None = None\n) -&gt; discord_typings.EmojiData:\n\"\"\"\n    Modify an existing guild emoji.\n\n    Args:\n        payload: The emoji's data\n        guild_id: The ID of the guild\n        emoji_id: The ID of the emoji to update\n        reason: The reason for this creation\n\n    Returns:\n        The updated emoji object\n\n    \"\"\"\n    result = await self.request(\n        Route(\"PATCH\", f\"/guilds/{int(guild_id)}/emojis/{int(emoji_id)}\"), payload=payload, reason=reason\n    )\n    return cast(discord_typings.EmojiData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.emojis.EmojiRequests.delete_guild_emoji","title":"<code>delete_guild_emoji(guild_id, emoji_id, reason=None)</code>  <code>async</code>","text":"<p>Delete a guild emoji.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>emoji_id</code> <code>Snowflake_Type</code> <p>The ID of the emoji to update</p> required <code>reason</code> <code>str | None</code> <p>The reason for this deletion</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\emojis.py</code> <pre><code>async def delete_guild_emoji(\n    self, guild_id: \"Snowflake_Type\", emoji_id: \"Snowflake_Type\", reason: str | None = None\n) -&gt; None:\n\"\"\"\n    Delete a guild emoji.\n\n    Args:\n        guild_id: The ID of the guild\n        emoji_id: The ID of the emoji to update\n        reason: The reason for this deletion\n\n    \"\"\"\n    await self.request(Route(\"DELETE\", f\"/guilds/{int(guild_id)}/emojis/{int(emoji_id)}\"), reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.ReactionRequests","title":"<code>ReactionRequests</code>","text":"Source code in <code>naff\\api\\http\\http_requests\\reactions.py</code> <pre><code>class ReactionRequests:\n    request: Any\n\n    async def create_reaction(self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\", emoji: str) -&gt; None:\n\"\"\"\n        Create a reaction for a message.\n\n        Args:\n            channel_id: The channel this is taking place in\n            message_id: The message to create a a reaction on\n            emoji: The emoji to use (format: `name:id`)\n\n        \"\"\"\n        return await self.request(\n            Route(\n                \"PUT\",\n                \"/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/@me\",\n                channel_id=channel_id,\n                message_id=message_id,\n                emoji=emoji,\n            )\n        )\n\n    async def remove_self_reaction(\n        self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\", emoji: str\n    ) -&gt; None:\n\"\"\"\n        Remove client's reaction from a message.\n\n        Args:\n            channel_id: The channel this is taking place in.\n            message_id: The message to remove the reaction on.\n            emoji: The emoji to remove. (format: `name:id`)\n\n        \"\"\"\n        return await self.request(\n            Route(\n                \"DELETE\",\n                \"/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/@me\",\n                channel_id=channel_id,\n                message_id=message_id,\n                emoji=emoji,\n            )\n        )\n\n    async def remove_user_reaction(\n        self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\", emoji: str, user_id: \"Snowflake_Type\"\n    ) -&gt; None:\n\"\"\"\n        Remove user's reaction from a message.\n\n        Args:\n            channel_id: The channel this is taking place in\n            message_id: The message to remove the reaction on.\n            emoji: The emoji to remove. (format: `name:id`)\n            user_id: The user to remove reaction of.\n\n        \"\"\"\n        return await self.request(\n            Route(\n                \"DELETE\",\n                \"/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/{user_id}\",\n                channel_id=channel_id,\n                message_id=message_id,\n                emoji=emoji,\n                user_id=user_id,\n            )\n        )\n\n    async def clear_reaction(self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\", emoji: str) -&gt; None:\n\"\"\"\n        Remove specific reaction from a message.\n\n        Args:\n            channel_id: The channel this is taking place in.\n            message_id: The message to remove the reaction on.\n            emoji: The emoji to remove. (format: `name:id`)\n\n        \"\"\"\n        return await self.request(\n            Route(\n                \"DELETE\",\n                \"/channels/{channel_id}/messages/{message_id}/reactions/{emoji}\",\n                channel_id=channel_id,\n                message_id=message_id,\n                emoji=emoji,\n            )\n        )\n\n    async def clear_reactions(self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n        Remove reactions from a message.\n\n        Args:\n            channel_id: The channel this is taking place in.\n            message_id: The message to clear reactions from.\n\n        \"\"\"\n        return await self.request(Route(\"DELETE\", f\"/channels/{channel_id}/messages/{message_id}/reactions\"))\n\n    async def get_reactions(\n        self,\n        channel_id: \"Snowflake_Type\",\n        message_id: \"Snowflake_Type\",\n        emoji: str,\n        limit: Absent[int] = MISSING,\n        after: \"Snowflake_Type\" = MISSING,\n    ) -&gt; List[discord_typings.UserData]:\n\"\"\"\n        Gets specific reaction from a message.\n\n        Args:\n            channel_id: The channel this is taking place in.\n            message_id: The message to get the reaction.\n            emoji: The emoji to get. (format: `name:id`)\n\n        Returns:\n            List of users who reacted with the emoji.\n\n        \"\"\"\n        return await self.request(\n            Route(\n                \"GET\",\n                \"/channels/{channel_id}/messages/{message_id}/reactions/{emoji}\",\n                channel_id=channel_id,\n                message_id=message_id,\n                emoji=emoji,\n            ),\n            params={\"limit\": limit, \"after\": after},\n        )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.reactions.ReactionRequests.create_reaction","title":"<code>create_reaction(channel_id, message_id, emoji)</code>  <code>async</code>","text":"<p>Create a reaction for a message.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The channel this is taking place in</p> required <code>message_id</code> <code>Snowflake_Type</code> <p>The message to create a a reaction on</p> required <code>emoji</code> <code>str</code> <p>The emoji to use (format: <code>name:id</code>)</p> required Source code in <code>naff\\api\\http\\http_requests\\reactions.py</code> <pre><code>async def create_reaction(self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\", emoji: str) -&gt; None:\n\"\"\"\n    Create a reaction for a message.\n\n    Args:\n        channel_id: The channel this is taking place in\n        message_id: The message to create a a reaction on\n        emoji: The emoji to use (format: `name:id`)\n\n    \"\"\"\n    return await self.request(\n        Route(\n            \"PUT\",\n            \"/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/@me\",\n            channel_id=channel_id,\n            message_id=message_id,\n            emoji=emoji,\n        )\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.reactions.ReactionRequests.remove_self_reaction","title":"<code>remove_self_reaction(channel_id, message_id, emoji)</code>  <code>async</code>","text":"<p>Remove client's reaction from a message.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The channel this is taking place in.</p> required <code>message_id</code> <code>Snowflake_Type</code> <p>The message to remove the reaction on.</p> required <code>emoji</code> <code>str</code> <p>The emoji to remove. (format: <code>name:id</code>)</p> required Source code in <code>naff\\api\\http\\http_requests\\reactions.py</code> <pre><code>async def remove_self_reaction(\n    self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\", emoji: str\n) -&gt; None:\n\"\"\"\n    Remove client's reaction from a message.\n\n    Args:\n        channel_id: The channel this is taking place in.\n        message_id: The message to remove the reaction on.\n        emoji: The emoji to remove. (format: `name:id`)\n\n    \"\"\"\n    return await self.request(\n        Route(\n            \"DELETE\",\n            \"/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/@me\",\n            channel_id=channel_id,\n            message_id=message_id,\n            emoji=emoji,\n        )\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.reactions.ReactionRequests.remove_user_reaction","title":"<code>remove_user_reaction(channel_id, message_id, emoji, user_id)</code>  <code>async</code>","text":"<p>Remove user's reaction from a message.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The channel this is taking place in</p> required <code>message_id</code> <code>Snowflake_Type</code> <p>The message to remove the reaction on.</p> required <code>emoji</code> <code>str</code> <p>The emoji to remove. (format: <code>name:id</code>)</p> required <code>user_id</code> <code>Snowflake_Type</code> <p>The user to remove reaction of.</p> required Source code in <code>naff\\api\\http\\http_requests\\reactions.py</code> <pre><code>async def remove_user_reaction(\n    self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\", emoji: str, user_id: \"Snowflake_Type\"\n) -&gt; None:\n\"\"\"\n    Remove user's reaction from a message.\n\n    Args:\n        channel_id: The channel this is taking place in\n        message_id: The message to remove the reaction on.\n        emoji: The emoji to remove. (format: `name:id`)\n        user_id: The user to remove reaction of.\n\n    \"\"\"\n    return await self.request(\n        Route(\n            \"DELETE\",\n            \"/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/{user_id}\",\n            channel_id=channel_id,\n            message_id=message_id,\n            emoji=emoji,\n            user_id=user_id,\n        )\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.reactions.ReactionRequests.clear_reaction","title":"<code>clear_reaction(channel_id, message_id, emoji)</code>  <code>async</code>","text":"<p>Remove specific reaction from a message.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The channel this is taking place in.</p> required <code>message_id</code> <code>Snowflake_Type</code> <p>The message to remove the reaction on.</p> required <code>emoji</code> <code>str</code> <p>The emoji to remove. (format: <code>name:id</code>)</p> required Source code in <code>naff\\api\\http\\http_requests\\reactions.py</code> <pre><code>async def clear_reaction(self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\", emoji: str) -&gt; None:\n\"\"\"\n    Remove specific reaction from a message.\n\n    Args:\n        channel_id: The channel this is taking place in.\n        message_id: The message to remove the reaction on.\n        emoji: The emoji to remove. (format: `name:id`)\n\n    \"\"\"\n    return await self.request(\n        Route(\n            \"DELETE\",\n            \"/channels/{channel_id}/messages/{message_id}/reactions/{emoji}\",\n            channel_id=channel_id,\n            message_id=message_id,\n            emoji=emoji,\n        )\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.reactions.ReactionRequests.clear_reactions","title":"<code>clear_reactions(channel_id, message_id)</code>  <code>async</code>","text":"<p>Remove reactions from a message.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The channel this is taking place in.</p> required <code>message_id</code> <code>Snowflake_Type</code> <p>The message to clear reactions from.</p> required Source code in <code>naff\\api\\http\\http_requests\\reactions.py</code> <pre><code>async def clear_reactions(self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n    Remove reactions from a message.\n\n    Args:\n        channel_id: The channel this is taking place in.\n        message_id: The message to clear reactions from.\n\n    \"\"\"\n    return await self.request(Route(\"DELETE\", f\"/channels/{channel_id}/messages/{message_id}/reactions\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.reactions.ReactionRequests.get_reactions","title":"<code>get_reactions(channel_id, message_id, emoji, limit=MISSING, after=MISSING)</code>  <code>async</code>","text":"<p>Gets specific reaction from a message.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The channel this is taking place in.</p> required <code>message_id</code> <code>Snowflake_Type</code> <p>The message to get the reaction.</p> required <code>emoji</code> <code>str</code> <p>The emoji to get. (format: <code>name:id</code>)</p> required <p>Returns:</p> Type Description <code>List[discord_typings.UserData]</code> <p>List of users who reacted with the emoji.</p> Source code in <code>naff\\api\\http\\http_requests\\reactions.py</code> <pre><code>async def get_reactions(\n    self,\n    channel_id: \"Snowflake_Type\",\n    message_id: \"Snowflake_Type\",\n    emoji: str,\n    limit: Absent[int] = MISSING,\n    after: \"Snowflake_Type\" = MISSING,\n) -&gt; List[discord_typings.UserData]:\n\"\"\"\n    Gets specific reaction from a message.\n\n    Args:\n        channel_id: The channel this is taking place in.\n        message_id: The message to get the reaction.\n        emoji: The emoji to get. (format: `name:id`)\n\n    Returns:\n        List of users who reacted with the emoji.\n\n    \"\"\"\n    return await self.request(\n        Route(\n            \"GET\",\n            \"/channels/{channel_id}/messages/{message_id}/reactions/{emoji}\",\n            channel_id=channel_id,\n            message_id=message_id,\n            emoji=emoji,\n        ),\n        params={\"limit\": limit, \"after\": after},\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.ScheduledEventsRequests","title":"<code>ScheduledEventsRequests</code>","text":"Source code in <code>naff\\api\\http\\http_requests\\scheduled_events.py</code> <pre><code>class ScheduledEventsRequests:\n    request: Any\n\n    async def list_schedules_events(\n        self, guild_id: \"Snowflake_Type\", with_user_count: bool = False\n    ) -&gt; List[discord_typings.GuildScheduledEventData]:\n\"\"\"\n        Get the scheduled events for a guild.\n\n        Args:\n            guild_id: The guild to get scheduled events from\n            with_user_count: Whether to include the user count in the response\n        Returns:\n            List of Scheduled Events or None\n\n        \"\"\"\n        return await self.request(\n            Route(\"GET\", f\"/guilds/{guild_id}/scheduled-events?with_user_count={with_user_count}\")\n        )\n\n    async def get_scheduled_event(\n        self, guild_id: \"Snowflake_Type\", scheduled_event_id: \"Snowflake_Type\", with_user_count: bool = False\n    ) -&gt; discord_typings.GuildScheduledEventData:\n\"\"\"\n        Get a scheduled event for a guild.\n\n        Args:\n            guild_id: The guild to get scheduled event from\n            with_user_count: Whether to include the user count in the response\n\n        Returns:\n            Scheduled Event or None\n\n        \"\"\"\n        return await self.request(\n            Route(\"GET\", f\"/guilds/{guild_id}/scheduled-events/{scheduled_event_id}\"),\n            params={\"with_user_count\": with_user_count},\n        )\n\n    async def create_scheduled_event(\n        self,\n        guild_id: \"Snowflake_Type\",\n        payload: dict,\n        reason: Absent[str] = MISSING,\n    ) -&gt; discord_typings.GuildScheduledEventData:\n\"\"\"\n        Create a scheduled event for a guild.\n\n        Args:\n            guild_id: The guild to create scheduled event from\n            payload: The scheduled event payload\n            reason: The reason to be displayed in audit logs\n\n        Returns:\n            Scheduled Event or None\n\n        \"\"\"\n        return await self.request(Route(\"POST\", f\"/guilds/{guild_id}/scheduled-events\"), payload=payload, reason=reason)\n\n    async def modify_scheduled_event(\n        self,\n        guild_id: \"Snowflake_Type\",\n        scheduled_event_id: \"Snowflake_Type\",\n        payload: dict,\n        reason: Absent[str] = MISSING,\n    ) -&gt; discord_typings.GuildScheduledEventData:\n\"\"\"\n        Modify a scheduled event for a guild.\n\n        Args:\n            guild_id: The guild to modify scheduled event from\n            scheduled_event_id: The scheduled event to modify\n            payload: The payload to modify the scheduled event with\n            reason: The reason to be displayed in audit logs\n\n        Returns:\n            Scheduled Event or None\n\n        \"\"\"\n        return await self.request(\n            Route(\"PATCH\", f\"/guilds/{guild_id}/scheduled-events/{scheduled_event_id}\"), payload=payload, reason=reason\n        )\n\n    async def delete_scheduled_event(\n        self,\n        guild_id: \"Snowflake_Type\",\n        scheduled_event_id: \"Snowflake_Type\",\n        reason: Absent[str] = MISSING,\n    ) -&gt; None:\n\"\"\"\n        Delete a scheduled event for a guild.\n\n        Args:\n            guild_id: The guild to delete scheduled event from\n            scheduled_event_id: The scheduled event to delete\n            reason: The reason to be displayed in audit logs\n\n        \"\"\"\n        return await self.request(\n            Route(\"DELETE\", f\"/guilds/{guild_id}/scheduled-events/{scheduled_event_id}\"), reason=reason\n        )\n\n    async def get_scheduled_event_users(\n        self,\n        guild_id: \"Snowflake_Type\",\n        scheduled_event_id: \"Snowflake_Type\",\n        limit: int = 100,\n        with_member: bool = False,\n        before: \"Snowflake_Type\" = MISSING,\n        after: \"Snowflake_Type\" = MISSING,\n    ) -&gt; List[discord_typings.GuildScheduledEventUserData]:\n\"\"\"\n        Get the users for a scheduled event.\n\n        Args:\n            guild_id: The guild to get scheduled event users from\n            scheduled_event_id: The scheduled event to get users from\n            limit: how many users to receive from the event\n            with_member: include guild member data if it exists\n            before: consider only users before given user id\n            after: consider only users after given user id\n\n        Returns:\n            List of Scheduled Event Users or None\n\n        \"\"\"\n        params = {\"limit\": limit, \"with_member\": with_member, \"before\": before, \"after\": after}\n        return await self.request(\n            Route(\"GET\", f\"/guilds/{guild_id}/scheduled-events/{scheduled_event_id}/users\"),\n            params=params,\n        )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.scheduled_events.ScheduledEventsRequests.list_schedules_events","title":"<code>list_schedules_events(guild_id, with_user_count=False)</code>  <code>async</code>","text":"<p>Get the scheduled events for a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The guild to get scheduled events from</p> required <code>with_user_count</code> <code>bool</code> <p>Whether to include the user count in the response</p> <code>False</code> <p>Returns:</p> Type Description <code>List[discord_typings.GuildScheduledEventData]</code> <p>List of Scheduled Events or None</p> Source code in <code>naff\\api\\http\\http_requests\\scheduled_events.py</code> <pre><code>async def list_schedules_events(\n    self, guild_id: \"Snowflake_Type\", with_user_count: bool = False\n) -&gt; List[discord_typings.GuildScheduledEventData]:\n\"\"\"\n    Get the scheduled events for a guild.\n\n    Args:\n        guild_id: The guild to get scheduled events from\n        with_user_count: Whether to include the user count in the response\n    Returns:\n        List of Scheduled Events or None\n\n    \"\"\"\n    return await self.request(\n        Route(\"GET\", f\"/guilds/{guild_id}/scheduled-events?with_user_count={with_user_count}\")\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.scheduled_events.ScheduledEventsRequests.get_scheduled_event","title":"<code>get_scheduled_event(guild_id, scheduled_event_id, with_user_count=False)</code>  <code>async</code>","text":"<p>Get a scheduled event for a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The guild to get scheduled event from</p> required <code>with_user_count</code> <code>bool</code> <p>Whether to include the user count in the response</p> <code>False</code> <p>Returns:</p> Type Description <code>discord_typings.GuildScheduledEventData</code> <p>Scheduled Event or None</p> Source code in <code>naff\\api\\http\\http_requests\\scheduled_events.py</code> <pre><code>async def get_scheduled_event(\n    self, guild_id: \"Snowflake_Type\", scheduled_event_id: \"Snowflake_Type\", with_user_count: bool = False\n) -&gt; discord_typings.GuildScheduledEventData:\n\"\"\"\n    Get a scheduled event for a guild.\n\n    Args:\n        guild_id: The guild to get scheduled event from\n        with_user_count: Whether to include the user count in the response\n\n    Returns:\n        Scheduled Event or None\n\n    \"\"\"\n    return await self.request(\n        Route(\"GET\", f\"/guilds/{guild_id}/scheduled-events/{scheduled_event_id}\"),\n        params={\"with_user_count\": with_user_count},\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.scheduled_events.ScheduledEventsRequests.create_scheduled_event","title":"<code>create_scheduled_event(guild_id, payload, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a scheduled event for a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The guild to create scheduled event from</p> required <code>payload</code> <code>dict</code> <p>The scheduled event payload</p> required <code>reason</code> <code>Absent[str]</code> <p>The reason to be displayed in audit logs</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>discord_typings.GuildScheduledEventData</code> <p>Scheduled Event or None</p> Source code in <code>naff\\api\\http\\http_requests\\scheduled_events.py</code> <pre><code>async def create_scheduled_event(\n    self,\n    guild_id: \"Snowflake_Type\",\n    payload: dict,\n    reason: Absent[str] = MISSING,\n) -&gt; discord_typings.GuildScheduledEventData:\n\"\"\"\n    Create a scheduled event for a guild.\n\n    Args:\n        guild_id: The guild to create scheduled event from\n        payload: The scheduled event payload\n        reason: The reason to be displayed in audit logs\n\n    Returns:\n        Scheduled Event or None\n\n    \"\"\"\n    return await self.request(Route(\"POST\", f\"/guilds/{guild_id}/scheduled-events\"), payload=payload, reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.scheduled_events.ScheduledEventsRequests.modify_scheduled_event","title":"<code>modify_scheduled_event(guild_id, scheduled_event_id, payload, reason=MISSING)</code>  <code>async</code>","text":"<p>Modify a scheduled event for a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The guild to modify scheduled event from</p> required <code>scheduled_event_id</code> <code>Snowflake_Type</code> <p>The scheduled event to modify</p> required <code>payload</code> <code>dict</code> <p>The payload to modify the scheduled event with</p> required <code>reason</code> <code>Absent[str]</code> <p>The reason to be displayed in audit logs</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>discord_typings.GuildScheduledEventData</code> <p>Scheduled Event or None</p> Source code in <code>naff\\api\\http\\http_requests\\scheduled_events.py</code> <pre><code>async def modify_scheduled_event(\n    self,\n    guild_id: \"Snowflake_Type\",\n    scheduled_event_id: \"Snowflake_Type\",\n    payload: dict,\n    reason: Absent[str] = MISSING,\n) -&gt; discord_typings.GuildScheduledEventData:\n\"\"\"\n    Modify a scheduled event for a guild.\n\n    Args:\n        guild_id: The guild to modify scheduled event from\n        scheduled_event_id: The scheduled event to modify\n        payload: The payload to modify the scheduled event with\n        reason: The reason to be displayed in audit logs\n\n    Returns:\n        Scheduled Event or None\n\n    \"\"\"\n    return await self.request(\n        Route(\"PATCH\", f\"/guilds/{guild_id}/scheduled-events/{scheduled_event_id}\"), payload=payload, reason=reason\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.scheduled_events.ScheduledEventsRequests.delete_scheduled_event","title":"<code>delete_scheduled_event(guild_id, scheduled_event_id, reason=MISSING)</code>  <code>async</code>","text":"<p>Delete a scheduled event for a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The guild to delete scheduled event from</p> required <code>scheduled_event_id</code> <code>Snowflake_Type</code> <p>The scheduled event to delete</p> required <code>reason</code> <code>Absent[str]</code> <p>The reason to be displayed in audit logs</p> <code>MISSING</code> Source code in <code>naff\\api\\http\\http_requests\\scheduled_events.py</code> <pre><code>async def delete_scheduled_event(\n    self,\n    guild_id: \"Snowflake_Type\",\n    scheduled_event_id: \"Snowflake_Type\",\n    reason: Absent[str] = MISSING,\n) -&gt; None:\n\"\"\"\n    Delete a scheduled event for a guild.\n\n    Args:\n        guild_id: The guild to delete scheduled event from\n        scheduled_event_id: The scheduled event to delete\n        reason: The reason to be displayed in audit logs\n\n    \"\"\"\n    return await self.request(\n        Route(\"DELETE\", f\"/guilds/{guild_id}/scheduled-events/{scheduled_event_id}\"), reason=reason\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.scheduled_events.ScheduledEventsRequests.get_scheduled_event_users","title":"<code>get_scheduled_event_users(guild_id, scheduled_event_id, limit=100, with_member=False, before=MISSING, after=MISSING)</code>  <code>async</code>","text":"<p>Get the users for a scheduled event.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The guild to get scheduled event users from</p> required <code>scheduled_event_id</code> <code>Snowflake_Type</code> <p>The scheduled event to get users from</p> required <code>limit</code> <code>int</code> <p>how many users to receive from the event</p> <code>100</code> <code>with_member</code> <code>bool</code> <p>include guild member data if it exists</p> <code>False</code> <code>before</code> <code>Snowflake_Type</code> <p>consider only users before given user id</p> <code>MISSING</code> <code>after</code> <code>Snowflake_Type</code> <p>consider only users after given user id</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>List[discord_typings.GuildScheduledEventUserData]</code> <p>List of Scheduled Event Users or None</p> Source code in <code>naff\\api\\http\\http_requests\\scheduled_events.py</code> <pre><code>async def get_scheduled_event_users(\n    self,\n    guild_id: \"Snowflake_Type\",\n    scheduled_event_id: \"Snowflake_Type\",\n    limit: int = 100,\n    with_member: bool = False,\n    before: \"Snowflake_Type\" = MISSING,\n    after: \"Snowflake_Type\" = MISSING,\n) -&gt; List[discord_typings.GuildScheduledEventUserData]:\n\"\"\"\n    Get the users for a scheduled event.\n\n    Args:\n        guild_id: The guild to get scheduled event users from\n        scheduled_event_id: The scheduled event to get users from\n        limit: how many users to receive from the event\n        with_member: include guild member data if it exists\n        before: consider only users before given user id\n        after: consider only users after given user id\n\n    Returns:\n        List of Scheduled Event Users or None\n\n    \"\"\"\n    params = {\"limit\": limit, \"with_member\": with_member, \"before\": before, \"after\": after}\n    return await self.request(\n        Route(\"GET\", f\"/guilds/{guild_id}/scheduled-events/{scheduled_event_id}/users\"),\n        params=params,\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.MessageRequests","title":"<code>MessageRequests</code>","text":"<p>         Bases: <code>CanRequest</code></p> Source code in <code>naff\\api\\http\\http_requests\\messages.py</code> <pre><code>class MessageRequests(CanRequest):\n    async def create_message(\n        self,\n        payload: dict,\n        channel_id: \"Snowflake_Type\",\n        files: list[\"UPLOADABLE_TYPE\"] | None = None,  # todo type payload\n    ) -&gt; discord_typings.MessageData:\n\"\"\"\n        Send a message to the specified channel.\n\n        Args:\n            payload: The message to send\n            channel_id: id of the channel to send message in\n            files: Any files to send with this message\n\n        Returns:\n            The resulting message object\n\n        \"\"\"\n        result = await self.request(\n            Route(\"POST\", f\"/channels/{int(channel_id)}/messages\"), payload=payload, files=files\n        )\n        return cast(discord_typings.MessageData, result)\n\n    async def delete_message(\n        self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\", reason: str | None = None\n    ) -&gt; None:\n\"\"\"\n        Deletes a message from the specified channel.\n\n        Args:\n            channel_id: The id of the channel to delete the message from\n            message_id: The id of the message to delete\n            reason: The reason for this action\n\n        \"\"\"\n        await self.request(Route(\"DELETE\", f\"/channels/{int(channel_id)}/messages/{int(message_id)}\"), reason=reason)\n\n    async def bulk_delete_messages(\n        self, channel_id: \"Snowflake_Type\", message_ids: list[\"Snowflake_Type\"], reason: str | None = None\n    ) -&gt; None:\n\"\"\"\n        Delete multiple messages in a single request.\n\n        Args:\n            channel_id: The id of the channel these messages are in\n            message_ids: A list of message ids to delete\n            reason: The reason for this action\n\n        \"\"\"\n        payload = {\"messages\": [int(message_id) for message_id in message_ids]}\n\n        await self.request(\n            Route(\"POST\", f\"/channels/{int(channel_id)}/messages/bulk-delete\"), payload=payload, reason=reason\n        )\n\n    async def get_message(\n        self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\"\n    ) -&gt; discord_typings.MessageData:\n\"\"\"\n        Get a specific message in the channel. Returns a message object on success.\n\n        Args:\n            channel_id: the channel this message belongs to\n            message_id: the id of the message\n\n        Returns:\n            message or None\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/channels/{int(channel_id)}/messages/{int(message_id)}\"))\n        return cast(discord_typings.MessageData, result)\n\n    async def pin_message(self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n        Pin a message to a channel.\n\n        Args:\n            channel_id: Channel to pin message to\n            message_id: Message to pin\n\n        \"\"\"\n        await self.request(Route(\"PUT\", f\"/channels/{int(channel_id)}/pins/{int(message_id)}\"))\n\n    async def unpin_message(self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n        Unpin a message to a channel.\n\n        Args:\n            channel_id: Channel to unpin message to\n            message_id: Message to unpin\n\n        \"\"\"\n        await self.request(Route(\"DELETE\", f\"/channels/{int(channel_id)}/pins/{int(message_id)}\"))\n\n    async def edit_message(\n        self,\n        payload: dict,\n        channel_id: \"Snowflake_Type\",\n        message_id: \"Snowflake_Type\",\n        files: list[\"UPLOADABLE_TYPE\"] | None = None,\n    ) -&gt; discord_typings.MessageData:\n\"\"\"\n        Edit an existing message.\n\n        Args:\n            payload:\n            channel_id: Channel of message to edit.\n            message_id: Message to edit.\n            files: Any files to send with this message\n\n        Returns:\n            Message object of edited message\n\n        \"\"\"\n        result = await self.request(\n            Route(\"PATCH\", f\"/channels/{int(channel_id)}/messages/{int(message_id)}\"), payload=payload, files=files\n        )\n        return cast(discord_typings.MessageData, result)\n\n    async def crosspost_message(\n        self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\"\n    ) -&gt; discord_typings.MessageData:\n\"\"\"\n        Crosspost a message in a News Channel to following channels.\n\n        Args:\n            channel_id: Channel the message is in\n            message_id: The id of the message to crosspost\n        Returns:\n            message object\n\n        \"\"\"\n        result = await self.request(Route(\"POST\", f\"/channels/{int(channel_id)}/messages/{int(message_id)}/crosspost\"))\n        return cast(discord_typings.MessageData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.messages.MessageRequests.create_message","title":"<code>create_message(payload, channel_id, files=None)</code>  <code>async</code>","text":"<p>Send a message to the specified channel.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>The message to send</p> required <code>channel_id</code> <code>Snowflake_Type</code> <p>id of the channel to send message in</p> required <code>files</code> <code>list[UPLOADABLE_TYPE] | None</code> <p>Any files to send with this message</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.MessageData</code> <p>The resulting message object</p> Source code in <code>naff\\api\\http\\http_requests\\messages.py</code> <pre><code>async def create_message(\n    self,\n    payload: dict,\n    channel_id: \"Snowflake_Type\",\n    files: list[\"UPLOADABLE_TYPE\"] | None = None,  # todo type payload\n) -&gt; discord_typings.MessageData:\n\"\"\"\n    Send a message to the specified channel.\n\n    Args:\n        payload: The message to send\n        channel_id: id of the channel to send message in\n        files: Any files to send with this message\n\n    Returns:\n        The resulting message object\n\n    \"\"\"\n    result = await self.request(\n        Route(\"POST\", f\"/channels/{int(channel_id)}/messages\"), payload=payload, files=files\n    )\n    return cast(discord_typings.MessageData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.messages.MessageRequests.delete_message","title":"<code>delete_message(channel_id, message_id, reason=None)</code>  <code>async</code>","text":"<p>Deletes a message from the specified channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The id of the channel to delete the message from</p> required <code>message_id</code> <code>Snowflake_Type</code> <p>The id of the message to delete</p> required <code>reason</code> <code>str | None</code> <p>The reason for this action</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\messages.py</code> <pre><code>async def delete_message(\n    self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\", reason: str | None = None\n) -&gt; None:\n\"\"\"\n    Deletes a message from the specified channel.\n\n    Args:\n        channel_id: The id of the channel to delete the message from\n        message_id: The id of the message to delete\n        reason: The reason for this action\n\n    \"\"\"\n    await self.request(Route(\"DELETE\", f\"/channels/{int(channel_id)}/messages/{int(message_id)}\"), reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.messages.MessageRequests.bulk_delete_messages","title":"<code>bulk_delete_messages(channel_id, message_ids, reason=None)</code>  <code>async</code>","text":"<p>Delete multiple messages in a single request.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The id of the channel these messages are in</p> required <code>message_ids</code> <code>list[Snowflake_Type]</code> <p>A list of message ids to delete</p> required <code>reason</code> <code>str | None</code> <p>The reason for this action</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\messages.py</code> <pre><code>async def bulk_delete_messages(\n    self, channel_id: \"Snowflake_Type\", message_ids: list[\"Snowflake_Type\"], reason: str | None = None\n) -&gt; None:\n\"\"\"\n    Delete multiple messages in a single request.\n\n    Args:\n        channel_id: The id of the channel these messages are in\n        message_ids: A list of message ids to delete\n        reason: The reason for this action\n\n    \"\"\"\n    payload = {\"messages\": [int(message_id) for message_id in message_ids]}\n\n    await self.request(\n        Route(\"POST\", f\"/channels/{int(channel_id)}/messages/bulk-delete\"), payload=payload, reason=reason\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.messages.MessageRequests.get_message","title":"<code>get_message(channel_id, message_id)</code>  <code>async</code>","text":"<p>Get a specific message in the channel. Returns a message object on success.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>the channel this message belongs to</p> required <code>message_id</code> <code>Snowflake_Type</code> <p>the id of the message</p> required <p>Returns:</p> Type Description <code>discord_typings.MessageData</code> <p>message or None</p> Source code in <code>naff\\api\\http\\http_requests\\messages.py</code> <pre><code>async def get_message(\n    self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\"\n) -&gt; discord_typings.MessageData:\n\"\"\"\n    Get a specific message in the channel. Returns a message object on success.\n\n    Args:\n        channel_id: the channel this message belongs to\n        message_id: the id of the message\n\n    Returns:\n        message or None\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/channels/{int(channel_id)}/messages/{int(message_id)}\"))\n    return cast(discord_typings.MessageData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.messages.MessageRequests.pin_message","title":"<code>pin_message(channel_id, message_id)</code>  <code>async</code>","text":"<p>Pin a message to a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>Channel to pin message to</p> required <code>message_id</code> <code>Snowflake_Type</code> <p>Message to pin</p> required Source code in <code>naff\\api\\http\\http_requests\\messages.py</code> <pre><code>async def pin_message(self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n    Pin a message to a channel.\n\n    Args:\n        channel_id: Channel to pin message to\n        message_id: Message to pin\n\n    \"\"\"\n    await self.request(Route(\"PUT\", f\"/channels/{int(channel_id)}/pins/{int(message_id)}\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.messages.MessageRequests.unpin_message","title":"<code>unpin_message(channel_id, message_id)</code>  <code>async</code>","text":"<p>Unpin a message to a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>Channel to unpin message to</p> required <code>message_id</code> <code>Snowflake_Type</code> <p>Message to unpin</p> required Source code in <code>naff\\api\\http\\http_requests\\messages.py</code> <pre><code>async def unpin_message(self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n    Unpin a message to a channel.\n\n    Args:\n        channel_id: Channel to unpin message to\n        message_id: Message to unpin\n\n    \"\"\"\n    await self.request(Route(\"DELETE\", f\"/channels/{int(channel_id)}/pins/{int(message_id)}\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.messages.MessageRequests.edit_message","title":"<code>edit_message(payload, channel_id, message_id, files=None)</code>  <code>async</code>","text":"<p>Edit an existing message.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> required <code>channel_id</code> <code>Snowflake_Type</code> <p>Channel of message to edit.</p> required <code>message_id</code> <code>Snowflake_Type</code> <p>Message to edit.</p> required <code>files</code> <code>list[UPLOADABLE_TYPE] | None</code> <p>Any files to send with this message</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.MessageData</code> <p>Message object of edited message</p> Source code in <code>naff\\api\\http\\http_requests\\messages.py</code> <pre><code>async def edit_message(\n    self,\n    payload: dict,\n    channel_id: \"Snowflake_Type\",\n    message_id: \"Snowflake_Type\",\n    files: list[\"UPLOADABLE_TYPE\"] | None = None,\n) -&gt; discord_typings.MessageData:\n\"\"\"\n    Edit an existing message.\n\n    Args:\n        payload:\n        channel_id: Channel of message to edit.\n        message_id: Message to edit.\n        files: Any files to send with this message\n\n    Returns:\n        Message object of edited message\n\n    \"\"\"\n    result = await self.request(\n        Route(\"PATCH\", f\"/channels/{int(channel_id)}/messages/{int(message_id)}\"), payload=payload, files=files\n    )\n    return cast(discord_typings.MessageData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.messages.MessageRequests.crosspost_message","title":"<code>crosspost_message(channel_id, message_id)</code>  <code>async</code>","text":"<p>Crosspost a message in a News Channel to following channels.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>Channel the message is in</p> required <code>message_id</code> <code>Snowflake_Type</code> <p>The id of the message to crosspost</p> required <p>Returns:</p> Type Description <code>discord_typings.MessageData</code> <p>message object</p> Source code in <code>naff\\api\\http\\http_requests\\messages.py</code> <pre><code>async def crosspost_message(\n    self, channel_id: \"Snowflake_Type\", message_id: \"Snowflake_Type\"\n) -&gt; discord_typings.MessageData:\n\"\"\"\n    Crosspost a message in a News Channel to following channels.\n\n    Args:\n        channel_id: Channel the message is in\n        message_id: The id of the message to crosspost\n    Returns:\n        message object\n\n    \"\"\"\n    result = await self.request(Route(\"POST\", f\"/channels/{int(channel_id)}/messages/{int(message_id)}/crosspost\"))\n    return cast(discord_typings.MessageData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.StickerRequests","title":"<code>StickerRequests</code>","text":"Source code in <code>naff\\api\\http\\http_requests\\stickers.py</code> <pre><code>class StickerRequests:\n    request: Any\n\n    async def get_sticker(self, sticker_id: \"Snowflake_Type\") -&gt; discord_typings.StickerData:\n\"\"\"\n        Get a specific sticker.\n\n        Args:\n            sticker_id: The id of the sticker\n\n        Returns:\n            Sticker or None\n\n        \"\"\"\n        return await self.request(Route(\"GET\", f\"/stickers/{sticker_id}\"))\n\n    async def list_nitro_sticker_packs(self) -&gt; List[discord_typings.StickerPackData]:\n\"\"\"\n        Gets the list of sticker packs available to Nitro subscribers.\n\n        Returns:\n            List of sticker packs\n\n        \"\"\"\n        return await self.request(Route(\"GET\", \"/sticker-packs\"))\n\n    async def list_guild_stickers(self, guild_id: \"Snowflake_Type\") -&gt; List[discord_typings.StickerData]:\n\"\"\"\n        Get the stickers for a guild.\n\n        Args:\n            guild_id: The guild to get stickers from\n\n        Returns:\n            List of Stickers or None\n\n        \"\"\"\n        return await self.request(Route(\"GET\", f\"/guilds/{guild_id}/stickers\"))\n\n    async def get_guild_sticker(\n        self, guild_id: \"Snowflake_Type\", sticker_id: \"Snowflake_Type\"\n    ) -&gt; discord_typings.StickerData:\n\"\"\"\n        Get a sticker from a guild.\n\n        Args:\n            guild_id: The guild to get stickers from\n            sticker_id: The sticker to get from the guild\n\n        Returns:\n            Sticker or None\n\n        \"\"\"\n        return await self.request(Route(\"GET\", f\"/guilds/{guild_id}/stickers/{sticker_id}\"))\n\n    async def create_guild_sticker(\n        self, payload: dict, guild_id: \"Snowflake_Type\", file: \"UPLOADABLE_TYPE\", reason: Optional[str] = MISSING\n    ) -&gt; discord_typings.StickerData:\n\"\"\"\n        Create a new sticker for the guild. Requires the MANAGE_EMOJIS_AND_STICKERS permission.\n\n        Args:\n            payload: the payload to send.\n            guild_id: The guild to create sticker at.\n            file: the image to use for the sticker\n            reason: The reason for this action.\n\n        Returns:\n            The new sticker data on success.\n\n        \"\"\"\n        return await self.request(\n            Route(\"POST\", f\"/guild/{guild_id}/stickers\"), payload=payload, files=[file], reason=reason\n        )\n\n    async def modify_guild_sticker(\n        self, payload: dict, guild_id: \"Snowflake_Type\", sticker_id: \"Snowflake_Type\", reason: Optional[str] = MISSING\n    ) -&gt; discord_typings.StickerData:\n\"\"\"\n        Modify the given sticker. Requires the MANAGE_EMOJIS_AND_STICKERS permission.\n\n        Args:\n            payload: the payload to send.\n            guild_id: The guild of the target sticker.\n            sticker_id:  The sticker to modify.\n            reason: The reason for this action.\n\n        Returns:\n            The updated sticker data on success.\n\n        \"\"\"\n        return await self.request(\n            Route(\"PATCH\", f\"/guild/{guild_id}/stickers/{sticker_id}\"), payload=payload, reason=reason\n        )\n\n    async def delete_guild_sticker(\n        self, guild_id: \"Snowflake_Type\", sticker_id: \"Snowflake_Type\", reason: Optional[str] = MISSING\n    ) -&gt; None:\n\"\"\"\n        Delete the given sticker. Requires the MANAGE_EMOJIS_AND_STICKERS permission.\n\n        Args:\n            guild_id: The guild of the target sticker.\n            sticker_id:  The sticker to delete.\n            reason: The reason for this action.\n\n        Returns:\n            Returns 204 No Content on success.\n\n        \"\"\"\n        return await self.request(Route(\"DELETE\", f\"/guild/{guild_id}/stickers/{sticker_id}\"), reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.stickers.StickerRequests.get_sticker","title":"<code>get_sticker(sticker_id)</code>  <code>async</code>","text":"<p>Get a specific sticker.</p> <p>Parameters:</p> Name Type Description Default <code>sticker_id</code> <code>Snowflake_Type</code> <p>The id of the sticker</p> required <p>Returns:</p> Type Description <code>discord_typings.StickerData</code> <p>Sticker or None</p> Source code in <code>naff\\api\\http\\http_requests\\stickers.py</code> <pre><code>async def get_sticker(self, sticker_id: \"Snowflake_Type\") -&gt; discord_typings.StickerData:\n\"\"\"\n    Get a specific sticker.\n\n    Args:\n        sticker_id: The id of the sticker\n\n    Returns:\n        Sticker or None\n\n    \"\"\"\n    return await self.request(Route(\"GET\", f\"/stickers/{sticker_id}\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.stickers.StickerRequests.list_nitro_sticker_packs","title":"<code>list_nitro_sticker_packs()</code>  <code>async</code>","text":"<p>Gets the list of sticker packs available to Nitro subscribers.</p> <p>Returns:</p> Type Description <code>List[discord_typings.StickerPackData]</code> <p>List of sticker packs</p> Source code in <code>naff\\api\\http\\http_requests\\stickers.py</code> <pre><code>async def list_nitro_sticker_packs(self) -&gt; List[discord_typings.StickerPackData]:\n\"\"\"\n    Gets the list of sticker packs available to Nitro subscribers.\n\n    Returns:\n        List of sticker packs\n\n    \"\"\"\n    return await self.request(Route(\"GET\", \"/sticker-packs\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.stickers.StickerRequests.list_guild_stickers","title":"<code>list_guild_stickers(guild_id)</code>  <code>async</code>","text":"<p>Get the stickers for a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The guild to get stickers from</p> required <p>Returns:</p> Type Description <code>List[discord_typings.StickerData]</code> <p>List of Stickers or None</p> Source code in <code>naff\\api\\http\\http_requests\\stickers.py</code> <pre><code>async def list_guild_stickers(self, guild_id: \"Snowflake_Type\") -&gt; List[discord_typings.StickerData]:\n\"\"\"\n    Get the stickers for a guild.\n\n    Args:\n        guild_id: The guild to get stickers from\n\n    Returns:\n        List of Stickers or None\n\n    \"\"\"\n    return await self.request(Route(\"GET\", f\"/guilds/{guild_id}/stickers\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.stickers.StickerRequests.get_guild_sticker","title":"<code>get_guild_sticker(guild_id, sticker_id)</code>  <code>async</code>","text":"<p>Get a sticker from a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The guild to get stickers from</p> required <code>sticker_id</code> <code>Snowflake_Type</code> <p>The sticker to get from the guild</p> required <p>Returns:</p> Type Description <code>discord_typings.StickerData</code> <p>Sticker or None</p> Source code in <code>naff\\api\\http\\http_requests\\stickers.py</code> <pre><code>async def get_guild_sticker(\n    self, guild_id: \"Snowflake_Type\", sticker_id: \"Snowflake_Type\"\n) -&gt; discord_typings.StickerData:\n\"\"\"\n    Get a sticker from a guild.\n\n    Args:\n        guild_id: The guild to get stickers from\n        sticker_id: The sticker to get from the guild\n\n    Returns:\n        Sticker or None\n\n    \"\"\"\n    return await self.request(Route(\"GET\", f\"/guilds/{guild_id}/stickers/{sticker_id}\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.stickers.StickerRequests.create_guild_sticker","title":"<code>create_guild_sticker(payload, guild_id, file, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a new sticker for the guild. Requires the MANAGE_EMOJIS_AND_STICKERS permission.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>the payload to send.</p> required <code>guild_id</code> <code>Snowflake_Type</code> <p>The guild to create sticker at.</p> required <code>file</code> <code>UPLOADABLE_TYPE</code> <p>the image to use for the sticker</p> required <code>reason</code> <code>Optional[str]</code> <p>The reason for this action.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>discord_typings.StickerData</code> <p>The new sticker data on success.</p> Source code in <code>naff\\api\\http\\http_requests\\stickers.py</code> <pre><code>async def create_guild_sticker(\n    self, payload: dict, guild_id: \"Snowflake_Type\", file: \"UPLOADABLE_TYPE\", reason: Optional[str] = MISSING\n) -&gt; discord_typings.StickerData:\n\"\"\"\n    Create a new sticker for the guild. Requires the MANAGE_EMOJIS_AND_STICKERS permission.\n\n    Args:\n        payload: the payload to send.\n        guild_id: The guild to create sticker at.\n        file: the image to use for the sticker\n        reason: The reason for this action.\n\n    Returns:\n        The new sticker data on success.\n\n    \"\"\"\n    return await self.request(\n        Route(\"POST\", f\"/guild/{guild_id}/stickers\"), payload=payload, files=[file], reason=reason\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.stickers.StickerRequests.modify_guild_sticker","title":"<code>modify_guild_sticker(payload, guild_id, sticker_id, reason=MISSING)</code>  <code>async</code>","text":"<p>Modify the given sticker. Requires the MANAGE_EMOJIS_AND_STICKERS permission.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>the payload to send.</p> required <code>guild_id</code> <code>Snowflake_Type</code> <p>The guild of the target sticker.</p> required <code>sticker_id</code> <code>Snowflake_Type</code> <p>The sticker to modify.</p> required <code>reason</code> <code>Optional[str]</code> <p>The reason for this action.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>discord_typings.StickerData</code> <p>The updated sticker data on success.</p> Source code in <code>naff\\api\\http\\http_requests\\stickers.py</code> <pre><code>async def modify_guild_sticker(\n    self, payload: dict, guild_id: \"Snowflake_Type\", sticker_id: \"Snowflake_Type\", reason: Optional[str] = MISSING\n) -&gt; discord_typings.StickerData:\n\"\"\"\n    Modify the given sticker. Requires the MANAGE_EMOJIS_AND_STICKERS permission.\n\n    Args:\n        payload: the payload to send.\n        guild_id: The guild of the target sticker.\n        sticker_id:  The sticker to modify.\n        reason: The reason for this action.\n\n    Returns:\n        The updated sticker data on success.\n\n    \"\"\"\n    return await self.request(\n        Route(\"PATCH\", f\"/guild/{guild_id}/stickers/{sticker_id}\"), payload=payload, reason=reason\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.stickers.StickerRequests.delete_guild_sticker","title":"<code>delete_guild_sticker(guild_id, sticker_id, reason=MISSING)</code>  <code>async</code>","text":"<p>Delete the given sticker. Requires the MANAGE_EMOJIS_AND_STICKERS permission.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The guild of the target sticker.</p> required <code>sticker_id</code> <code>Snowflake_Type</code> <p>The sticker to delete.</p> required <code>reason</code> <code>Optional[str]</code> <p>The reason for this action.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>None</code> <p>Returns 204 No Content on success.</p> Source code in <code>naff\\api\\http\\http_requests\\stickers.py</code> <pre><code>async def delete_guild_sticker(\n    self, guild_id: \"Snowflake_Type\", sticker_id: \"Snowflake_Type\", reason: Optional[str] = MISSING\n) -&gt; None:\n\"\"\"\n    Delete the given sticker. Requires the MANAGE_EMOJIS_AND_STICKERS permission.\n\n    Args:\n        guild_id: The guild of the target sticker.\n        sticker_id:  The sticker to delete.\n        reason: The reason for this action.\n\n    Returns:\n        Returns 204 No Content on success.\n\n    \"\"\"\n    return await self.request(Route(\"DELETE\", f\"/guild/{guild_id}/stickers/{sticker_id}\"), reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.WebhookRequests","title":"<code>WebhookRequests</code>","text":"Source code in <code>naff\\api\\http\\http_requests\\webhooks.py</code> <pre><code>class WebhookRequests:\n    request: Any\n\n    async def create_webhook(\n        self, channel_id: \"Snowflake_Type\", name: str, avatar: Any = None\n    ) -&gt; discord_typings.WebhookData:\n\"\"\"\n        Create a new webhook.\n\n        Args:\n            channel_id: The id of the channel to add this webhook to\n            name: name of the webhook (1-80 characters)\n            avatar: The image for the default webhook avatar\n\n        \"\"\"\n        return await self.request(\n            Route(\"POST\", f\"/channels/{channel_id}/webhooks\"), payload={\"name\": name, \"avatar\": avatar}\n        )\n\n    async def get_channel_webhooks(self, channel_id: \"Snowflake_Type\") -&gt; List[discord_typings.WebhookData]:\n\"\"\"\n        Return a list of channel webhook objects.\n\n        Args:\n            channel_id: The id of the channel to query\n\n        Returns:\n            List of webhook objects\n\n        \"\"\"\n        return await self.request(Route(\"GET\", f\"/channels/{channel_id}/webhooks\"))\n\n    async def get_guild_webhooks(self, guild_id: \"Snowflake_Type\") -&gt; List[discord_typings.WebhookData]:\n\"\"\"\n        Return a list of guild webhook objects.\n\n        Args:\n            guild_id: The id of the guild to query\n\n        Returns:\n            List of webhook objects\n\n        \"\"\"\n        return await self.request(Route(\"GET\", f\"/guilds/{guild_id}/webhooks\"))\n\n    async def get_webhook(self, webhook_id: \"Snowflake_Type\", webhook_token: str = None) -&gt; discord_typings.WebhookData:\n\"\"\"\n        Return the new webhook object for the given id.\n\n        Args:\n            webhook_id: The ID of the webhook to get\n            webhook_token: The token for the webhook\n\n        Returns:\n            Webhook object\n\n        \"\"\"\n        endpoint = f\"/webhooks/{webhook_id}{f'/{webhook_token}' if webhook_token else ''}\"\n\n        return await self.request(Route(\"GET\", endpoint))\n\n    async def modify_webhook(\n        self,\n        webhook_id: \"Snowflake_Type\",\n        name: str,\n        avatar: Any,\n        channel_id: \"Snowflake_Type\",\n        webhook_token: str = None,\n    ) -&gt; discord_typings.WebhookData:\n\"\"\"\n        Modify a webhook.\n\n        Args:\n            name: the default name of the webhook\n            avatar: image for the default webhook avatar\n            channel_id: the new channel id this webhook should be moved to\n            webhook_id: The ID of the webhook to modify\n            webhook_token: The token for the webhook\n\n        \"\"\"\n        endpoint = f\"/webhooks/{webhook_id}{f'/{webhook_token}' if webhook_token else ''}\"\n\n        return await self.request(\n            Route(\"PATCH\", endpoint), payload={\"name\": name, \"avatar\": avatar, \"channel_id\": channel_id}\n        )\n\n    async def delete_webhook(self, webhook_id: \"Snowflake_Type\", webhook_token: str = None) -&gt; None:\n\"\"\"\n        Delete a webhook.\n\n        Args:\n            webhook_id: The ID of the webhook to delete\n            webhook_token: The token for the webhook\n\n        Returns:\n            Webhook object\n\n        \"\"\"\n        endpoint = f\"/webhooks/{webhook_id}{f'/{webhook_token}' if webhook_token else ''}\"\n\n        return await self.request(Route(\"DELETE\", endpoint))\n\n    async def execute_webhook(\n        self,\n        webhook_id: \"Snowflake_Type\",\n        webhook_token: str,\n        payload: dict,\n        wait: bool = False,\n        thread_id: \"Snowflake_Type\" = None,\n        files: list[\"UPLOADABLE_TYPE\"] | None = None,\n    ) -&gt; Optional[discord_typings.MessageData]:\n\"\"\"\n        Execute a webhook. Basically send a message as the webhook.\n\n        Args:\n            webhook_id: The ID of the webhook to delete\n            webhook_token: The token for the webhook\n            payload: The JSON payload for the message\n            wait: Waits for server confirmation of message send before response\n            thread_id: Send a message to the specified thread\n            files: The files to send with this message\n\n        Returns:\n            The sent `message`, if `wait` is True else None\n\n        \"\"\"\n        return await self.request(\n            Route(\"POST\", f\"/webhooks/{webhook_id}/{webhook_token}\"),\n            params=dict_filter_none({\"wait\": \"true\" if wait else \"false\", \"thread_id\": thread_id}),\n            payload=payload,\n            files=files,\n        )\n\n    async def get_webhook_message(\n        self, webhook_id: \"Snowflake_Type\", webhook_token: str, message_id: \"Snowflake_Type\"\n    ) -&gt; discord_typings.MessageData:\n\"\"\"\n        Returns a previously-sent webhook message from the same token. Returns a message object on success.\n\n        Args:\n            webhook_id: The ID of the webhook to delete\n            webhook_token: The token for the webhook\n            message_id: The ID of a message sent by this webhook\n\n        Returns:\n            A message object on success\n\n        \"\"\"\n        return await self.request(Route(\"GET\", f\"/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}\"))\n\n    async def edit_webhook_message(\n        self,\n        webhook_id: \"Snowflake_Type\",\n        webhook_token: str,\n        message_id: \"Snowflake_Type\",\n        payload: dict,\n        files: None | list[\"UPLOADABLE_TYPE\"] = None,\n    ) -&gt; discord_typings.MessageData:\n\"\"\"\n        Edits a previously-sent webhook message from the same token.\n\n        Args:\n            webhook_id: The ID of the webhook to delete\n            webhook_token: The token for the webhook\n            message_id: The ID of a message sent by this webhook\n            payload: The JSON payload for the message\n            files: The files to send in this message\n\n        Returns:\n            The updated message on success\n\n        \"\"\"\n        return await self.request(\n            Route(\"PATCH\", f\"/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}\"),\n            payload=payload,\n            files=files,\n        )\n\n    async def delete_webhook_message(\n        self, webhook_id: \"Snowflake_Type\", webhook_token: str, message_id: \"Snowflake_Type\"\n    ) -&gt; None:\n\"\"\"\n        Delete a message that was created by the same token.\n\n        Args:\n            webhook_id: The ID of the webhook to delete\n            webhook_token: The token for the webhook\n            message_id: The ID of a message sent by this webhook\n\n        \"\"\"\n        return await self.request(Route(\"DELETE\", f\"/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.webhooks.WebhookRequests.create_webhook","title":"<code>create_webhook(channel_id, name, avatar=None)</code>  <code>async</code>","text":"<p>Create a new webhook.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The id of the channel to add this webhook to</p> required <code>name</code> <code>str</code> <p>name of the webhook (1-80 characters)</p> required <code>avatar</code> <code>Any</code> <p>The image for the default webhook avatar</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\webhooks.py</code> <pre><code>async def create_webhook(\n    self, channel_id: \"Snowflake_Type\", name: str, avatar: Any = None\n) -&gt; discord_typings.WebhookData:\n\"\"\"\n    Create a new webhook.\n\n    Args:\n        channel_id: The id of the channel to add this webhook to\n        name: name of the webhook (1-80 characters)\n        avatar: The image for the default webhook avatar\n\n    \"\"\"\n    return await self.request(\n        Route(\"POST\", f\"/channels/{channel_id}/webhooks\"), payload={\"name\": name, \"avatar\": avatar}\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.webhooks.WebhookRequests.get_channel_webhooks","title":"<code>get_channel_webhooks(channel_id)</code>  <code>async</code>","text":"<p>Return a list of channel webhook objects.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The id of the channel to query</p> required <p>Returns:</p> Type Description <code>List[discord_typings.WebhookData]</code> <p>List of webhook objects</p> Source code in <code>naff\\api\\http\\http_requests\\webhooks.py</code> <pre><code>async def get_channel_webhooks(self, channel_id: \"Snowflake_Type\") -&gt; List[discord_typings.WebhookData]:\n\"\"\"\n    Return a list of channel webhook objects.\n\n    Args:\n        channel_id: The id of the channel to query\n\n    Returns:\n        List of webhook objects\n\n    \"\"\"\n    return await self.request(Route(\"GET\", f\"/channels/{channel_id}/webhooks\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.webhooks.WebhookRequests.get_guild_webhooks","title":"<code>get_guild_webhooks(guild_id)</code>  <code>async</code>","text":"<p>Return a list of guild webhook objects.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The id of the guild to query</p> required <p>Returns:</p> Type Description <code>List[discord_typings.WebhookData]</code> <p>List of webhook objects</p> Source code in <code>naff\\api\\http\\http_requests\\webhooks.py</code> <pre><code>async def get_guild_webhooks(self, guild_id: \"Snowflake_Type\") -&gt; List[discord_typings.WebhookData]:\n\"\"\"\n    Return a list of guild webhook objects.\n\n    Args:\n        guild_id: The id of the guild to query\n\n    Returns:\n        List of webhook objects\n\n    \"\"\"\n    return await self.request(Route(\"GET\", f\"/guilds/{guild_id}/webhooks\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.webhooks.WebhookRequests.get_webhook","title":"<code>get_webhook(webhook_id, webhook_token=None)</code>  <code>async</code>","text":"<p>Return the new webhook object for the given id.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>Snowflake_Type</code> <p>The ID of the webhook to get</p> required <code>webhook_token</code> <code>str</code> <p>The token for the webhook</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.WebhookData</code> <p>Webhook object</p> Source code in <code>naff\\api\\http\\http_requests\\webhooks.py</code> <pre><code>async def get_webhook(self, webhook_id: \"Snowflake_Type\", webhook_token: str = None) -&gt; discord_typings.WebhookData:\n\"\"\"\n    Return the new webhook object for the given id.\n\n    Args:\n        webhook_id: The ID of the webhook to get\n        webhook_token: The token for the webhook\n\n    Returns:\n        Webhook object\n\n    \"\"\"\n    endpoint = f\"/webhooks/{webhook_id}{f'/{webhook_token}' if webhook_token else ''}\"\n\n    return await self.request(Route(\"GET\", endpoint))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.webhooks.WebhookRequests.modify_webhook","title":"<code>modify_webhook(webhook_id, name, avatar, channel_id, webhook_token=None)</code>  <code>async</code>","text":"<p>Modify a webhook.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the default name of the webhook</p> required <code>avatar</code> <code>Any</code> <p>image for the default webhook avatar</p> required <code>channel_id</code> <code>Snowflake_Type</code> <p>the new channel id this webhook should be moved to</p> required <code>webhook_id</code> <code>Snowflake_Type</code> <p>The ID of the webhook to modify</p> required <code>webhook_token</code> <code>str</code> <p>The token for the webhook</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\webhooks.py</code> <pre><code>async def modify_webhook(\n    self,\n    webhook_id: \"Snowflake_Type\",\n    name: str,\n    avatar: Any,\n    channel_id: \"Snowflake_Type\",\n    webhook_token: str = None,\n) -&gt; discord_typings.WebhookData:\n\"\"\"\n    Modify a webhook.\n\n    Args:\n        name: the default name of the webhook\n        avatar: image for the default webhook avatar\n        channel_id: the new channel id this webhook should be moved to\n        webhook_id: The ID of the webhook to modify\n        webhook_token: The token for the webhook\n\n    \"\"\"\n    endpoint = f\"/webhooks/{webhook_id}{f'/{webhook_token}' if webhook_token else ''}\"\n\n    return await self.request(\n        Route(\"PATCH\", endpoint), payload={\"name\": name, \"avatar\": avatar, \"channel_id\": channel_id}\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.webhooks.WebhookRequests.delete_webhook","title":"<code>delete_webhook(webhook_id, webhook_token=None)</code>  <code>async</code>","text":"<p>Delete a webhook.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>Snowflake_Type</code> <p>The ID of the webhook to delete</p> required <code>webhook_token</code> <code>str</code> <p>The token for the webhook</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Webhook object</p> Source code in <code>naff\\api\\http\\http_requests\\webhooks.py</code> <pre><code>async def delete_webhook(self, webhook_id: \"Snowflake_Type\", webhook_token: str = None) -&gt; None:\n\"\"\"\n    Delete a webhook.\n\n    Args:\n        webhook_id: The ID of the webhook to delete\n        webhook_token: The token for the webhook\n\n    Returns:\n        Webhook object\n\n    \"\"\"\n    endpoint = f\"/webhooks/{webhook_id}{f'/{webhook_token}' if webhook_token else ''}\"\n\n    return await self.request(Route(\"DELETE\", endpoint))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.webhooks.WebhookRequests.execute_webhook","title":"<code>execute_webhook(webhook_id, webhook_token, payload, wait=False, thread_id=None, files=None)</code>  <code>async</code>","text":"<p>Execute a webhook. Basically send a message as the webhook.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>Snowflake_Type</code> <p>The ID of the webhook to delete</p> required <code>webhook_token</code> <code>str</code> <p>The token for the webhook</p> required <code>payload</code> <code>dict</code> <p>The JSON payload for the message</p> required <code>wait</code> <code>bool</code> <p>Waits for server confirmation of message send before response</p> <code>False</code> <code>thread_id</code> <code>Snowflake_Type</code> <p>Send a message to the specified thread</p> <code>None</code> <code>files</code> <code>list[UPLOADABLE_TYPE] | None</code> <p>The files to send with this message</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[discord_typings.MessageData]</code> <p>The sent <code>message</code>, if <code>wait</code> is True else None</p> Source code in <code>naff\\api\\http\\http_requests\\webhooks.py</code> <pre><code>async def execute_webhook(\n    self,\n    webhook_id: \"Snowflake_Type\",\n    webhook_token: str,\n    payload: dict,\n    wait: bool = False,\n    thread_id: \"Snowflake_Type\" = None,\n    files: list[\"UPLOADABLE_TYPE\"] | None = None,\n) -&gt; Optional[discord_typings.MessageData]:\n\"\"\"\n    Execute a webhook. Basically send a message as the webhook.\n\n    Args:\n        webhook_id: The ID of the webhook to delete\n        webhook_token: The token for the webhook\n        payload: The JSON payload for the message\n        wait: Waits for server confirmation of message send before response\n        thread_id: Send a message to the specified thread\n        files: The files to send with this message\n\n    Returns:\n        The sent `message`, if `wait` is True else None\n\n    \"\"\"\n    return await self.request(\n        Route(\"POST\", f\"/webhooks/{webhook_id}/{webhook_token}\"),\n        params=dict_filter_none({\"wait\": \"true\" if wait else \"false\", \"thread_id\": thread_id}),\n        payload=payload,\n        files=files,\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.webhooks.WebhookRequests.get_webhook_message","title":"<code>get_webhook_message(webhook_id, webhook_token, message_id)</code>  <code>async</code>","text":"<p>Returns a previously-sent webhook message from the same token. Returns a message object on success.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>Snowflake_Type</code> <p>The ID of the webhook to delete</p> required <code>webhook_token</code> <code>str</code> <p>The token for the webhook</p> required <code>message_id</code> <code>Snowflake_Type</code> <p>The ID of a message sent by this webhook</p> required <p>Returns:</p> Type Description <code>discord_typings.MessageData</code> <p>A message object on success</p> Source code in <code>naff\\api\\http\\http_requests\\webhooks.py</code> <pre><code>async def get_webhook_message(\n    self, webhook_id: \"Snowflake_Type\", webhook_token: str, message_id: \"Snowflake_Type\"\n) -&gt; discord_typings.MessageData:\n\"\"\"\n    Returns a previously-sent webhook message from the same token. Returns a message object on success.\n\n    Args:\n        webhook_id: The ID of the webhook to delete\n        webhook_token: The token for the webhook\n        message_id: The ID of a message sent by this webhook\n\n    Returns:\n        A message object on success\n\n    \"\"\"\n    return await self.request(Route(\"GET\", f\"/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.webhooks.WebhookRequests.edit_webhook_message","title":"<code>edit_webhook_message(webhook_id, webhook_token, message_id, payload, files=None)</code>  <code>async</code>","text":"<p>Edits a previously-sent webhook message from the same token.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>Snowflake_Type</code> <p>The ID of the webhook to delete</p> required <code>webhook_token</code> <code>str</code> <p>The token for the webhook</p> required <code>message_id</code> <code>Snowflake_Type</code> <p>The ID of a message sent by this webhook</p> required <code>payload</code> <code>dict</code> <p>The JSON payload for the message</p> required <code>files</code> <code>None | list[UPLOADABLE_TYPE]</code> <p>The files to send in this message</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.MessageData</code> <p>The updated message on success</p> Source code in <code>naff\\api\\http\\http_requests\\webhooks.py</code> <pre><code>async def edit_webhook_message(\n    self,\n    webhook_id: \"Snowflake_Type\",\n    webhook_token: str,\n    message_id: \"Snowflake_Type\",\n    payload: dict,\n    files: None | list[\"UPLOADABLE_TYPE\"] = None,\n) -&gt; discord_typings.MessageData:\n\"\"\"\n    Edits a previously-sent webhook message from the same token.\n\n    Args:\n        webhook_id: The ID of the webhook to delete\n        webhook_token: The token for the webhook\n        message_id: The ID of a message sent by this webhook\n        payload: The JSON payload for the message\n        files: The files to send in this message\n\n    Returns:\n        The updated message on success\n\n    \"\"\"\n    return await self.request(\n        Route(\"PATCH\", f\"/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}\"),\n        payload=payload,\n        files=files,\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.webhooks.WebhookRequests.delete_webhook_message","title":"<code>delete_webhook_message(webhook_id, webhook_token, message_id)</code>  <code>async</code>","text":"<p>Delete a message that was created by the same token.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>Snowflake_Type</code> <p>The ID of the webhook to delete</p> required <code>webhook_token</code> <code>str</code> <p>The token for the webhook</p> required <code>message_id</code> <code>Snowflake_Type</code> <p>The ID of a message sent by this webhook</p> required Source code in <code>naff\\api\\http\\http_requests\\webhooks.py</code> <pre><code>async def delete_webhook_message(\n    self, webhook_id: \"Snowflake_Type\", webhook_token: str, message_id: \"Snowflake_Type\"\n) -&gt; None:\n\"\"\"\n    Delete a message that was created by the same token.\n\n    Args:\n        webhook_id: The ID of the webhook to delete\n        webhook_token: The token for the webhook\n        message_id: The ID of a message sent by this webhook\n\n    \"\"\"\n    return await self.request(Route(\"DELETE\", f\"/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.GuildRequests","title":"<code>GuildRequests</code>","text":"<p>         Bases: <code>CanRequest</code></p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>class GuildRequests(CanRequest):\n    async def get_guilds(\n        self, limit: int = 200, before: \"Snowflake_Type | None\" = None, after: \"Snowflake_Type | None\" = None\n    ) -&gt; list[discord_typings.GuildData]:\n\"\"\"\n        Get a list of partial guild objects the current user is a member of req. `guilds` scope.\n\n        Args:\n            limit: max number of guilds to return (1-200)\n            before: get guilds before this guild ID\n            after: get guilds after this guild ID\n\n        Returns:\n            List of guild objects\n\n        \"\"\"\n        params: PAYLOAD_TYPE = {\n            \"limit\": limit,\n            \"before\": int(before) if before else None,\n            \"after\": int(after) if after else None,\n        }\n        params = dict_filter_none(params)\n\n        result = await self.request(Route(\"GET\", \"/users/@me/guilds\", params=params))\n        return cast(list[discord_typings.GuildData], result)\n\n    async def get_guild(self, guild_id: \"Snowflake_Type\", with_counts: bool = True) -&gt; discord_typings.GuildData:\n\"\"\"\n        Get the guild object for the given ID.\n\n        Args:\n            guild_id: the id of the guild\n            with_counts: when `true`, will return approximate member and presence counts for the guild\n        Returns:\n            a guild object\n\n        \"\"\"\n        params = {\"with_counts\": int(with_counts)}\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}\"), params=params)\n        return cast(discord_typings.GuildData, result)\n\n    async def get_guild_preview(self, guild_id: \"Snowflake_Type\") -&gt; discord_typings.GuildPreviewData:\n\"\"\"\n        Get a guild's preview.\n\n        Args:\n            guild_id: the guilds ID\n\n        Returns:\n            guild preview object\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/preview\"))\n        return cast(discord_typings.GuildPreviewData, result)\n\n    async def get_channels(self, guild_id: \"Snowflake_Type\") -&gt; list[discord_typings.ChannelData]:\n\"\"\"\n        Get a guilds channels.\n\n        Args:\n            guild_id: the id of the guild\n\n        Returns:\n            List of channels\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/channels\"))\n        return cast(list[discord_typings.ChannelData], result)\n\n    async def get_roles(self, guild_id: \"Snowflake_Type\") -&gt; list[discord_typings.RoleData]:\n\"\"\"\n        Get a guild's roles.\n\n        Args:\n            guild_id: The ID of the guild\n\n        Returns:\n            List of roles\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/roles\"))\n        return cast(list[discord_typings.RoleData], result)\n\n    async def modify_guild(\n        self, guild_id: \"Snowflake_Type\", reason: str | None = None, **kwargs: Mapping[str, Any]\n    ) -&gt; None:\n\"\"\"\n        Modify a guild's attributes.\n\n        Args:\n            guild_id: The ID of the guild we want to modify\n            reason: The reason for this change\n            **kwargs: The params to change\n\n        \"\"\"\n        expected = (\n            \"name\",\n            \"region\",\n            \"verification_level\",\n            \"default_message_notifications\",\n            \"explicit_content_filter\",\n            \"afk_channel_id\",\n            \"afk_timeout\",\n            \"icon\",\n            \"owner_id\",\n            \"splash\",\n            \"discovery_splash\",\n            \"banner\",\n            \"system_channel_id\",\n            \"system_channel_flags\",\n            \"rules_channel_id\",\n            \"public_updates_channel_id\",\n            \"preferred_locale\",\n            \"features\",\n            \"description\",\n        )\n        payload = kwargs.copy()\n        for key, value in kwargs.items():\n            if key not in expected or value is None:\n                del payload[key]\n\n        # only do the request if there is something to modify\n        if payload:\n            await self.request(Route(\"PATCH\", f\"/guilds/{int(guild_id)}\"), payload=payload, reason=reason)\n\n    async def delete_guild(self, guild_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n        Delete the guild.\n\n        Args:\n            guild_id: The ID of the guild that we want to delete\n\n        \"\"\"\n        await self.request(Route(\"DELETE\", f\"/guilds/{int(guild_id)}\"))\n\n    async def add_guild_member(\n        self,\n        guild_id: \"Snowflake_Type\",\n        user_id: \"Snowflake_Type\",\n        access_token: str,\n        nick: str | None = None,\n        roles: list[\"Snowflake_Type\"] | None = None,\n        mute: bool = False,\n        deaf: bool = False,\n    ) -&gt; discord_typings.GuildMemberData:\n\"\"\"\n        Add a user to the guild. All parameters to this endpoint except for `access_token`, `guild_id` and `user_id` are optional.\n\n        Args:\n            guild_id: The ID of the guild\n            user_id: The ID of the user to add\n            access_token: The access token of the user\n            nick: value to set users nickname to\n            roles: array of role ids the member is assigned\n            mute: whether the user is muted in voice channels\n            deaf: whether the user is deafened in voice channels\n        Returns:\n            Guild Member Object\n\n        \"\"\"\n        payload = {\n            \"access_token\": access_token,\n            \"nick\": nick,\n            \"roles\": [int(role) for role in roles] if roles else None,\n            \"mute\": mute,\n            \"deaf\": deaf,\n        }\n        payload = dict_filter_none(payload)\n\n        result = await self.request(\n            Route(\"PUT\", f\"/guilds/{int(guild_id)}/members/{int(user_id)}\"),\n            payload=payload,\n        )\n        return cast(discord_typings.GuildMemberData, result)\n\n    async def remove_guild_member(\n        self, guild_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\", reason: str | None = None\n    ) -&gt; None:\n\"\"\"\n        Remove a member from a guild.\n\n        Args:\n            guild_id: The ID of the guild\n            user_id: The ID of the user to remove\n            reason: The reason for this action\n\n        \"\"\"\n        await self.request(Route(\"DELETE\", f\"/guilds/{int(guild_id)}/members/{int(user_id)}\"), reason=reason)\n\n    async def get_guild_bans(\n        self,\n        guild_id: \"Snowflake_Type\",\n        before: \"Snowflake_Type | None\" = None,\n        after: \"Snowflake_Type | None\" = None,\n        limit: int = 1000,\n    ) -&gt; list[discord_typings.BanData]:\n\"\"\"\n        Return a list of ban objects for the users banned from this guild.\n\n        Args:\n            guild_id: The ID of the guild to query\n\n        Returns:\n            List of ban objects\n\n        \"\"\"\n        params: PAYLOAD_TYPE = {\n            \"limit\": limit,\n            \"before\": int(before) if before else None,\n            \"after\": int(after) if after else None,\n        }\n        params = dict_filter_none(params)\n\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/bans\"), params=params)\n        return cast(list[discord_typings.BanData], result)\n\n    async def get_guild_ban(self, guild_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\") -&gt; discord_typings.BanData:\n\"\"\"\n        Returns a ban object for the given user or a 404 not found if the ban cannot be found.\n\n        Args:\n            guild_id: The ID of the guild to query\n            user_id: The ID of the user to query\n\n        Returns:\n            Ban object if exists\n\n        Raises:\n            NotFound: if no ban exists\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/bans/{int(user_id)}\"))\n        return cast(discord_typings.BanData, result)\n\n    async def create_guild_ban(\n        self,\n        guild_id: \"Snowflake_Type\",\n        user_id: \"Snowflake_Type\",\n        delete_message_seconds: int = 0,\n        reason: str | None = None,\n    ) -&gt; None:\n\"\"\"\n        Create a guild ban, and optionally delete previous messages sent by the banned user.\n\n        Args:\n            guild_id: The ID of the guild to create the ban in\n            user_id: The ID of the user to ban\n            delete_message_seconds: number of seconds to delete messages for (0-604800)\n            reason: The reason for this action\n\n        \"\"\"\n        payload = {\"delete_message_seconds\": delete_message_seconds}\n        await self.request(Route(\"PUT\", f\"/guilds/{int(guild_id)}/bans/{int(user_id)}\"), payload=payload, reason=reason)\n\n    async def remove_guild_ban(\n        self, guild_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\", reason: str | None = None\n    ) -&gt; None:\n\"\"\"\n        Remove a guild ban.\n\n        Args:\n            guild_id: The ID of the guild to remove the ban in\n            user_id: The ID of the user to unban\n            reason: The reason for this action\n\n        \"\"\"\n        await self.request(Route(\"DELETE\", f\"/guilds/{int(guild_id)}/bans/{int(user_id)}\"), reason=reason)\n\n    async def get_guild_prune_count(\n        self, guild_id: \"Snowflake_Type\", days: int = 7, include_roles: list[\"Snowflake_Type\"] | None = None\n    ) -&gt; dict:\n\"\"\"\n        Returns an object with one 'pruned' key indicating the number of members that would be removed in a prune operation.\n\n        Args:\n            guild_id: The ID of the guild to query\n            days: number of days to count prune for (1-30)\n            include_roles: role(s) to include\n\n        Returns:\n            {\"pruned\": int}\n\n        \"\"\"\n        params: PAYLOAD_TYPE = {\n            \"days\": days,\n            \"include_roles\": \", \".join(str(int(role)) for role in include_roles) if include_roles else None,\n        }\n        params = dict_filter_none(params)\n\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/prune\"), params=params)\n        return cast(dict, result)  # todo revisit, create TypedDict for pruned\n\n    async def begin_guild_prune(\n        self,\n        guild_id: \"Snowflake_Type\",\n        days: int = 7,\n        include_roles: list[\"Snowflake_Type\"] | None = None,\n        compute_prune_count: bool = True,\n        reason: str | None = None,\n    ) -&gt; dict:\n\"\"\"\n        Begin a prune operation.\n\n        Args:\n            guild_id: The ID of the guild to query\n            days: number of days to count prune for (1-30)\n            include_roles: role(s) to include\n            compute_prune_count: whether 'pruned' is returned, discouraged for large guilds\n            reason: The reason for this action\n\n        Returns:\n            {\"pruned\": Optional[int]}\n\n        \"\"\"\n        payload: PAYLOAD_TYPE = {\n            \"days\": days,\n            \"compute_prune_count\": compute_prune_count,\n            \"include_roles\": \", \".join(str(int(role)) for role in include_roles) if include_roles else None,\n        }\n        payload = dict_filter_none(payload)\n\n        result = await self.request(Route(\"POST\", f\"/guilds/{int(guild_id)}/prune\"), payload=payload, reason=reason)\n        return cast(dict, result)  # todo revisit, create TypedDict for pruned\n\n    async def get_guild_invites(self, guild_id: \"Snowflake_Type\") -&gt; list[discord_typings.InviteData]:\n\"\"\"\n        Returns a list of invite objects (with invite metadata) for the guild.\n\n        Args:\n            guild_id: The ID of the guild to query\n\n        Returns:\n            List of invite objects\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/invites\"))\n        return cast(list[discord_typings.InviteData], result)\n\n    async def create_guild_role(\n        self, guild_id: \"Snowflake_Type\", payload: dict, reason: str | None = None\n    ) -&gt; discord_typings.RoleData:\n\"\"\"\n        Create a new role for the guild.\n\n        Args:\n            guild_id: The ID of the guild\n            payload: A dict representing the role to add\n            reason: The reason for this action\n\n        Returns:\n            Role object\n\n        \"\"\"\n        result = await self.request(Route(\"POST\", f\"/guilds/{int(guild_id)}/roles\"), payload=payload, reason=reason)\n        return cast(discord_typings.RoleData, result)\n\n    async def modify_guild_role_positions(\n        self,\n        guild_id: \"Snowflake_Type\",\n        position_changes: List[dict[\"Snowflake_Type\", int]],\n        reason: str | None = None,\n    ) -&gt; list[discord_typings.RoleData]:\n\"\"\"\n        Modify the position of a role in the guild.\n\n        Args:\n            guild_id: The ID of the guild\n            position_changes: A list of dicts representing the roles to move and their new positions\n\n            ``{\"id\": role_id, \"position\": new_position}``\n            position: The new position of this role in the hierarchy\n            reason: The reason for this action\n\n        Returns:\n            List of guild roles\n\n        \"\"\"\n        payload: PAYLOAD_TYPE = [\n            {\"id\": int(role[\"id\"]), \"position\": int(role[\"position\"])} for role in position_changes\n        ]\n        result = await self.request(Route(\"PATCH\", f\"/guilds/{int(guild_id)}/roles\"), payload=payload, reason=reason)\n        return cast(list[discord_typings.RoleData], result)\n\n    async def modify_guild_role(\n        self, guild_id: \"Snowflake_Type\", role_id: \"Snowflake_Type\", payload: dict, reason: str | None = None\n    ) -&gt; discord_typings.RoleData:\n\"\"\"\n        Modify an existing role for the guild.\n\n        Args:\n            guild_id: The ID of the guild\n            role_id: The ID of the role to move\n            payload: A dict representing the role to add\n            reason: The reason for this action\n\n        Returns:\n            Role object\n\n        \"\"\"\n        result = await self.request(\n            Route(\"PATCH\", f\"/guilds/{int(guild_id)}/roles/{int(role_id)}\"), payload=payload, reason=reason\n        )\n        return cast(discord_typings.RoleData, result)\n\n    async def delete_guild_role(\n        self, guild_id: \"Snowflake_Type\", role_id: \"Snowflake_Type\", reason: str | None = None\n    ) -&gt; None:\n\"\"\"\n        Delete a guild role.\n\n        Args:\n            role_id: The ID of the role to delete\n            reason: The reason for this action\n            guild_id: The ID of the guild\n\n        \"\"\"\n        await self.request(Route(\"DELETE\", f\"/guilds/{int(guild_id)}/roles/{int(role_id)}\"), reason=reason)\n\n    async def get_audit_log(\n        self,\n        guild_id: \"Snowflake_Type\",\n        user_id: \"Snowflake_Type | None\" = None,\n        action_type: \"AuditLogEventType | None\" = None,\n        before: \"Snowflake_Type | None\" = None,\n        after: \"Snowflake_Type | None\" = None,\n        limit: int = 100,\n    ) -&gt; discord_typings.AuditLogData:\n\"\"\"\n        Get the audit log for a guild.\n\n        Args:\n            guild_id: The ID of the guild to query\n            user_id: filter by user ID\n            action_type: filter by action type\n            before: snowflake to get entries before\n            after: snowflake to get entries after\n            limit: max number of entries to get\n\n        Returns:\n            audit log object for the guild\n\n        \"\"\"\n        params: PAYLOAD_TYPE = {\n            \"limit\": limit,\n            \"before\": int(before) if before else None,\n            \"after\": int(after) if after else None,\n            \"user_id\": int(user_id) if user_id else None,\n            \"action_type\": int(action_type) if action_type else None,\n        }\n        params = dict_filter_none(params)\n\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/audit-logs\"), params=params)\n        return cast(discord_typings.AuditLogData, result)\n\n    async def get_guild_voice_regions(self, guild_id: \"Snowflake_Type\") -&gt; list[discord_typings.VoiceRegionData]:\n\"\"\"\n        Returns a list of voice region objects for the guild. Unlike the similar /voice route, this returns VIP servers when the guild is VIP- enabled.\n\n        Args:\n            guild_id: The ID of the guild to query\n\n        Returns:\n            List of voice region objects\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/regions\"))\n        return cast(list[discord_typings.VoiceRegionData], result)\n\n    async def get_guild_integrations(self, guild_id: \"Snowflake_Type\") -&gt; list[discord_typings.IntegrationData]:\n\"\"\"\n        Returns a list of integration objects for the guild.\n\n        Args:\n            guild_id: The ID of the guild to query\n\n        Returns:\n            list of integration objects\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/integrations\"))\n        return cast(list[discord_typings.IntegrationData], result)\n\n    async def delete_guild_integration(\n        self, guild_id: \"Snowflake_Type\", integration_id: \"Snowflake_Type\", reason: str | None = None\n    ) -&gt; None:\n\"\"\"\n        Delete an integration from the guild.\n\n        Args:\n            guild_id: The ID of the guild\n            integration_id: The ID of the integration to remove\n\n        \"\"\"\n        await self.request(\n            Route(\"DELETE\", f\"/guilds/{int(guild_id)}/integrations/{int(integration_id)}\"), reason=reason\n        )\n\n    async def get_guild_widget_settings(self, guild_id: \"Snowflake_Type\") -&gt; discord_typings.GuildWidgetSettingsData:\n\"\"\"\n        Get guild widget settings.\n\n        Args:\n            guild_id: The ID of the guild to query\n\n        Returns:\n            guild widget object\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/widget\"))\n        return cast(discord_typings.GuildWidgetSettingsData, result)\n\n    async def get_guild_widget(self, guild_id: \"Snowflake_Type\") -&gt; discord_typings.GuildWidgetData:\n\"\"\"\n        Returns the widget for the guild.\n\n        Args:\n            guild_id: The ID of the guild to query\n\n        Returns:\n            Guild widget\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/widget.json\"))\n        return cast(discord_typings.GuildWidgetData, result)\n\n    async def get_guild_widget_image(self, guild_id: \"Snowflake_Type\", style: str | None = None) -&gt; str:\n\"\"\"\n        Get a url representing a png image widget for the guild.\n\n        For styles see: https://discord.com/developers/docs/resources/guild#get-guild-widget-image\n\n        Args:\n            guild_id: The guild to query\n            style: The style of widget required.\n\n        Returns:\n            A url pointing to this image\n\n        \"\"\"\n        route = Route(\"GET\", f\"/guilds/{int(guild_id)}/widget.png{f'?style={style}' if style else ''}\")\n        return route.url\n\n    async def get_guild_welcome_screen(self, guild_id: \"Snowflake_Type\") -&gt; discord_typings.WelcomeScreenData:\n\"\"\"\n        Get the welcome screen for this guild.\n\n        Args:\n            guild_id: The ID of the guild to query\n        Returns:\n            Welcome screen object\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/welcome-screen\"))\n        return cast(discord_typings.WelcomeScreenData, result)\n\n    async def get_guild_vanity_url(self, guild_id: \"Snowflake_Type\") -&gt; dict:\n\"\"\"\n        Get a partial invite object for the guilds vanity invite url.\n\n        Args:\n            guild_id: The ID of the guild to query\n\n        Returns:\n            Returns a partial invite object. Code is None if a vanity url for the guild is not set.\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/vanity-url\"))\n        return cast(dict, result)  # todo create typing?\n\n    async def get_guild_channels(\n        self, guild_id: \"Snowflake_Type\"\n    ) -&gt; list[discord_typings.ChannelData]:  # todo narrow down channel types\n\"\"\"\n        Gets a list of guild channel objects.\n\n        Args:\n            guild_id: The ID of the guild\n\n        Returns:\n            A list of channels in this guild. Does not include threads.\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/channels\"))\n        return cast(list[discord_typings.ChannelData], result)\n\n    async def modify_guild_widget(\n        self, guild_id: \"Snowflake_Type\", enabled: bool | None = None, channel_id: \"Snowflake_Type | None\" = None\n    ) -&gt; discord_typings.GuildWidgetData:\n\"\"\"\n        Modify a guild widget.\n\n        Args:\n            guild_id: The ID of the guild to modify.\n            enabled: Should the guild widget be enabled\n            channel_id: The widget's channel ID\n\n        Returns:\n            Updated guild widget.\n\n        \"\"\"\n        payload: PAYLOAD_TYPE = {\n            \"enabled\": enabled,\n            \"channel_id\": int(channel_id) if channel_id else None,\n        }\n        payload = dict_filter_none(payload)\n\n        result = await self.request(Route(\"PATCH\", f\"/guilds/{int(guild_id)}/widget\"), payload=payload)\n        return cast(discord_typings.GuildWidgetData, result)\n\n    async def modify_guild_welcome_screen(\n        self, guild_id: \"Snowflake_Type\", enabled: bool, welcome_channels: list[\"Snowflake_Type\"], description: str\n    ) -&gt; discord_typings.WelcomeScreenData:\n\"\"\"\n        Modify the guild's welcome screen.\n\n        Args:\n            guild_id: The ID of the guild.\n            enabled: Whether the welcome screen is enabled\n            welcome_channels: Channels linked in the welcome screen and their display options\n            description: The server description to show in the welcome screen\n\n        Returns:\n            Updated welcome screen object\n\n        \"\"\"\n        payload: PAYLOAD_TYPE = {\n            \"enabled\": enabled,\n            \"welcome_channels\": [int(channel) for channel in welcome_channels],\n            \"description\": description,\n        }\n        result = await self.request(Route(\"PATCH\", f\"/guilds/{int(guild_id)}/welcome-screen\"), payload=payload)\n        return cast(discord_typings.WelcomeScreenData, result)\n\n    async def modify_current_user_voice_state(\n        self,\n        guild_id: \"Snowflake_Type\",\n        channel_id: \"Snowflake_Type\",\n        suppress: bool | None = None,\n        request_to_speak_timestamp: str | None = None,\n    ) -&gt; None:\n\"\"\"\n        Update the current user voice state.\n\n        Args:\n            guild_id: The ID of the guild to update.\n            channel_id: The id of the channel the user is currently in\n            suppress: Toggle the user's suppress state.\n            request_to_speak_timestamp: Sets the user's request to speak\n\n        \"\"\"\n        payload: PAYLOAD_TYPE = {\n            \"suppress\": suppress,\n            \"request_to_speak_timestamp\": request_to_speak_timestamp,\n            \"channel_id\": int(channel_id) if channel_id else None,\n        }\n        payload = dict_filter_none(payload)\n\n        await self.request(Route(\"PATCH\", f\"/guilds/{int(guild_id)}/voice-states/@me\"), payload=payload)\n\n    async def modify_user_voice_state(\n        self,\n        guild_id: \"Snowflake_Type\",\n        user_id: \"Snowflake_Type\",\n        channel_id: \"Snowflake_Type\",\n        suppress: bool | None = None,\n    ) -&gt; None:\n\"\"\"\n        Modify the voice state of a user.\n\n        Args:\n            guild_id: The ID of the guild.\n            user_id: The ID of the user to modify.\n            channel_id: The ID of the channel the user is currently in.\n            suppress: Toggles the user's suppress state.\n\n        \"\"\"\n        payload: PAYLOAD_TYPE = {\n            \"suppress\": suppress,\n            \"channel_id\": int(channel_id) if channel_id else None,\n        }\n        payload = dict_filter_none(payload)\n\n        await self.request(Route(\"PATCH\", f\"/guilds/{int(guild_id)}/voice-states/{user_id}\"), payload=payload)\n\n    async def create_guild(\n        self,\n        name: str,\n        icon: str | None = None,\n        verification_level: int | None = None,\n        default_message_notifications: int | None = None,\n        explicit_content_filter: int | None = None,\n        roles: list[dict] | None = None,\n        channels: list[dict] | None = None,\n        afk_channel_id: \"Snowflake_Type | None\" = None,\n        afk_timeout: int | None = None,\n        system_channel_id: \"Snowflake_Type | None\" = None,\n        system_channel_flags: int | None = None,\n    ) -&gt; discord_typings.GuildData:\n\n        payload = {\n            \"name\": name,\n            \"icon\": icon,\n            \"verification_level\": verification_level,\n            \"default_message_notifications\": default_message_notifications,\n            \"explicit_content_filter\": explicit_content_filter,\n            \"roles\": roles,\n            \"channels\": channels,\n            \"afk_channel_id\": int(afk_channel_id) if afk_channel_id else None,\n            \"afk_timeout\": afk_timeout,\n            \"system_channel_id\": int(system_channel_id) if system_channel_id else None,\n            \"system_channel_flags\": system_channel_flags,\n        }\n        payload = dict_filter_none(payload)\n\n        result = await self.request(Route(\"POST\", \"/guilds\"), payload=payload)\n        return cast(discord_typings.GuildData, result)\n\n    async def create_guild_from_guild_template(\n        self, template_code: str, name: str, icon: str\n    ) -&gt; discord_typings.GuildData:\n\"\"\"\n        Creates a new guild based on a template.\n\n        !!! note\n            This endpoint can only be used by bots in less than 10 guilds.\n\n        Args:\n            template_code: The code of the template to use.\n            name: The name of the guild (2-100 characters)\n            icon: Data URI scheme\n\n        Returns:\n            The newly created guild object\n\n        \"\"\"\n        payload = {\"name\": name, \"icon\": icon}\n\n        result = await self.request(Route(\"POST\", f\"/guilds/templates/{template_code}\"), payload=payload)\n        return cast(discord_typings.GuildData, result)\n\n    async def get_guild_templates(self, guild_id: \"Snowflake_Type\") -&gt; list[discord_typings.GuildTemplateData]:\n\"\"\"\n        Returns an array of guild templates.\n\n        Args:\n            guild_id: The ID of the guild to query.\n\n        Returns:\n            An array of guild templates\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/templates\"))\n        return cast(list[discord_typings.GuildTemplateData], result)\n\n    async def create_guild_template(\n        self, guild_id: \"Snowflake_Type\", name: str, description: str | None = None\n    ) -&gt; discord_typings.GuildTemplateData:\n\"\"\"\n        Create a guild template for the guild.\n\n        Args:\n            guild_id: The ID of the guild to create a template for.\n            name: The name of the template\n            description: The description of the template\n\n        Returns:\n            The created guild template\n\n        \"\"\"\n        payload = {\"name\": name, \"description\": description}\n        payload = dict_filter_none(payload)\n\n        result = await self.request(Route(\"POST\", f\"/guilds/{int(guild_id)}/templates\"), payload=payload)\n        return cast(discord_typings.GuildTemplateData, result)\n\n    async def sync_guild_template(\n        self, guild_id: \"Snowflake_Type\", template_code: str\n    ) -&gt; discord_typings.GuildTemplateData:\n\"\"\"\n        Sync the template to the guild's current state.\n\n        Args:\n            guild_id: The ID of the guild\n            template_code: The code for the template to sync\n\n        Returns:\n            The updated guild template\n\n        \"\"\"\n        result = await self.request(Route(\"PUT\", f\"/guilds/{int(guild_id)}/templates/{template_code}\"))\n        return cast(discord_typings.GuildTemplateData, result)\n\n    async def modify_guild_template(\n        self,\n        guild_id: \"Snowflake_Type\",\n        template_code: str,\n        name: str | None = None,\n        description: str | None = None,\n    ) -&gt; discord_typings.GuildTemplateData:\n\"\"\"\n        Modifies the template's metadata.\n\n        Args:\n            guild_id: The ID of the guild\n            template_code: The template code\n            name: The name of the template\n            description: The description of the template\n\n        Returns:\n            The updated guild template\n\n        \"\"\"\n        payload: PAYLOAD_TYPE = {\"name\": name, \"description\": description}\n        payload = dict_filter_none(payload)\n\n        result = await self.request(\n            Route(\"PATCH\", f\"/guilds/{int(guild_id)}/templates/{template_code}\"), payload=payload\n        )\n        return cast(discord_typings.GuildTemplateData, result)\n\n    async def delete_guild_template(\n        self, guild_id: \"Snowflake_Type\", template_code: str\n    ) -&gt; discord_typings.GuildTemplateData:\n\"\"\"\n        Delete the guild template.\n\n        Args:\n            guild_id: The ID of the guild\n            template_code: The ID of the template\n\n        Returns:\n            The deleted template object\n\n        \"\"\"\n        # why on earth does this return the deleted template object?\n        result = await self.request(Route(\"DELETE\", f\"/guilds/{int(guild_id)}/templates/{template_code}\"))\n        return cast(discord_typings.GuildTemplateData, result)\n\n    async def get_auto_moderation_rules(\n        self, guild_id: \"Snowflake_Type\"\n    ) -&gt; list[discord_typings.AutoModerationRuleData]:\n\"\"\"\n        Get this guilds auto moderation rules.\n\n        Args:\n            guild_id: The ID of the guild to get\n\n        Returns:\n            A list of auto moderation rules\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/auto-moderation/rules\"))\n        return cast(list[dict], result)\n\n    async def get_auto_moderation_rule(\n        self, guild_id: \"Snowflake_Type\", rule_id: \"Snowflake_Type\"\n    ) -&gt; discord_typings.AutoModerationRuleData:\n\"\"\"\n        Get a specific auto moderation rule.\n\n        Args:\n            guild_id: The ID of the guild\n            rule_id: The ID of the rule to get\n\n        Returns:\n            The auto moderation rule\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/auto-moderation/rules/{int(rule_id)}\"))\n        return cast(dict, result)\n\n    async def create_auto_moderation_rule(\n        self, guild_id: \"Snowflake_Type\", payload: discord_typings.AutoModerationRuleData\n    ) -&gt; discord_typings.AutoModerationRuleData:\n\"\"\"\n        Create an auto moderation rule.\n\n        Args:\n            guild_id: The ID of the guild to create this rule within\n            payload: A dict representing the auto moderation rule\n\n        Returns:\n            The created auto moderation rule\n        \"\"\"\n        result = await self.request(Route(\"POST\", f\"/guilds/{int(guild_id)}/auto-moderation/rules\"), payload=payload)\n        return cast(dict, result)\n\n    async def modify_auto_moderation_rule(\n        self,\n        guild_id: \"Snowflake_Type\",\n        rule_id: \"Snowflake_Type\",\n        name: str | None = None,\n        trigger_type: dict | None = None,\n        trigger_metadata: dict | None = None,\n        actions: list[dict] | None = None,\n        exempt_channels: list[\"Snowflake_Type\"] | None = None,\n        exempt_roles: list[\"Snowflake_Type\"] | None = None,\n        event_type: dict | None = None,\n        enabled: bool | None = None,\n        reason: str | None = None,\n    ) -&gt; dict:\n\"\"\"\n        Modify an existing auto moderation rule.\n\n        Args:\n            guild_id: The ID of the guild the rule belongs to\n            rule_id: The ID of the rule to modify\n            name: The name of the rule\n            trigger_type: The type trigger for this rule\n            trigger_metadata: Metadata for the trigger\n            actions: A list of actions to take upon triggering\n            exempt_roles: Roles that ignore this rule\n            exempt_channels: Channels that ignore this role\n            enabled: Is this rule enabled?\n            event_type: The type of event that triggers this rule\n            reason: The reason for this change\n\n        Returns:\n            The updated rule object\n        \"\"\"\n        payload = {\n            \"name\": name,\n            \"trigger_type\": trigger_type,\n            \"trigger_metadata\": trigger_metadata,\n            \"actions\": actions,\n            \"exempt_roles\": [int(role) for role in exempt_roles] if exempt_roles else None,\n            \"exempt_channels\": [int(channel) for channel in exempt_channels] if exempt_channels else None,\n            \"event_type\": event_type,\n            \"enabled\": enabled,\n        }\n        payload = dict_filter_none(payload)\n\n        result = await self.request(\n            Route(\"PATCH\", f\"/guilds/{int(guild_id)}/auto-moderation/rules/{int(rule_id)}\"),\n            payload=payload,\n            reason=reason,\n        )\n        return cast(dict, result)\n\n    async def delete_auto_moderation_rule(\n        self, guild_id: \"Snowflake_Type\", rule_id: \"Snowflake_Type\", reason: str | None = None\n    ) -&gt; dict:\n\"\"\"\n        Delete an auto moderation rule.\n\n        Args:\n            guild_id: The ID of the guild to delete this rule from\n            rule_id: The ID of the role to delete\n            reason: The reason for deleting this rule\n        \"\"\"\n        result = await self.request(\n            Route(\"DELETE\", f\"/guilds/{int(guild_id)}/auto-moderation/rules/{int(rule_id)}\"), reason=reason\n        )\n        return cast(dict, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guilds","title":"<code>get_guilds(limit=200, before=None, after=None)</code>  <code>async</code>","text":"<p>Get a list of partial guild objects the current user is a member of req. <code>guilds</code> scope.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>max number of guilds to return (1-200)</p> <code>200</code> <code>before</code> <code>Snowflake_Type | None</code> <p>get guilds before this guild ID</p> <code>None</code> <code>after</code> <code>Snowflake_Type | None</code> <p>get guilds after this guild ID</p> <code>None</code> <p>Returns:</p> Type Description <code>list[discord_typings.GuildData]</code> <p>List of guild objects</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guilds(\n    self, limit: int = 200, before: \"Snowflake_Type | None\" = None, after: \"Snowflake_Type | None\" = None\n) -&gt; list[discord_typings.GuildData]:\n\"\"\"\n    Get a list of partial guild objects the current user is a member of req. `guilds` scope.\n\n    Args:\n        limit: max number of guilds to return (1-200)\n        before: get guilds before this guild ID\n        after: get guilds after this guild ID\n\n    Returns:\n        List of guild objects\n\n    \"\"\"\n    params: PAYLOAD_TYPE = {\n        \"limit\": limit,\n        \"before\": int(before) if before else None,\n        \"after\": int(after) if after else None,\n    }\n    params = dict_filter_none(params)\n\n    result = await self.request(Route(\"GET\", \"/users/@me/guilds\", params=params))\n    return cast(list[discord_typings.GuildData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guild","title":"<code>get_guild(guild_id, with_counts=True)</code>  <code>async</code>","text":"<p>Get the guild object for the given ID.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>the id of the guild</p> required <code>with_counts</code> <code>bool</code> <p>when <code>true</code>, will return approximate member and presence counts for the guild</p> <code>True</code> <p>Returns:</p> Type Description <code>discord_typings.GuildData</code> <p>a guild object</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guild(self, guild_id: \"Snowflake_Type\", with_counts: bool = True) -&gt; discord_typings.GuildData:\n\"\"\"\n    Get the guild object for the given ID.\n\n    Args:\n        guild_id: the id of the guild\n        with_counts: when `true`, will return approximate member and presence counts for the guild\n    Returns:\n        a guild object\n\n    \"\"\"\n    params = {\"with_counts\": int(with_counts)}\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}\"), params=params)\n    return cast(discord_typings.GuildData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guild_preview","title":"<code>get_guild_preview(guild_id)</code>  <code>async</code>","text":"<p>Get a guild's preview.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>the guilds ID</p> required <p>Returns:</p> Type Description <code>discord_typings.GuildPreviewData</code> <p>guild preview object</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guild_preview(self, guild_id: \"Snowflake_Type\") -&gt; discord_typings.GuildPreviewData:\n\"\"\"\n    Get a guild's preview.\n\n    Args:\n        guild_id: the guilds ID\n\n    Returns:\n        guild preview object\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/preview\"))\n    return cast(discord_typings.GuildPreviewData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_channels","title":"<code>get_channels(guild_id)</code>  <code>async</code>","text":"<p>Get a guilds channels.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>the id of the guild</p> required <p>Returns:</p> Type Description <code>list[discord_typings.ChannelData]</code> <p>List of channels</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_channels(self, guild_id: \"Snowflake_Type\") -&gt; list[discord_typings.ChannelData]:\n\"\"\"\n    Get a guilds channels.\n\n    Args:\n        guild_id: the id of the guild\n\n    Returns:\n        List of channels\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/channels\"))\n    return cast(list[discord_typings.ChannelData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_roles","title":"<code>get_roles(guild_id)</code>  <code>async</code>","text":"<p>Get a guild's roles.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <p>Returns:</p> Type Description <code>list[discord_typings.RoleData]</code> <p>List of roles</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_roles(self, guild_id: \"Snowflake_Type\") -&gt; list[discord_typings.RoleData]:\n\"\"\"\n    Get a guild's roles.\n\n    Args:\n        guild_id: The ID of the guild\n\n    Returns:\n        List of roles\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/roles\"))\n    return cast(list[discord_typings.RoleData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.modify_guild","title":"<code>modify_guild(guild_id, reason=None, **kwargs)</code>  <code>async</code>","text":"<p>Modify a guild's attributes.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild we want to modify</p> required <code>reason</code> <code>str | None</code> <p>The reason for this change</p> <code>None</code> <code>**kwargs</code> <code>Mapping[str, Any]</code> <p>The params to change</p> <code>{}</code> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def modify_guild(\n    self, guild_id: \"Snowflake_Type\", reason: str | None = None, **kwargs: Mapping[str, Any]\n) -&gt; None:\n\"\"\"\n    Modify a guild's attributes.\n\n    Args:\n        guild_id: The ID of the guild we want to modify\n        reason: The reason for this change\n        **kwargs: The params to change\n\n    \"\"\"\n    expected = (\n        \"name\",\n        \"region\",\n        \"verification_level\",\n        \"default_message_notifications\",\n        \"explicit_content_filter\",\n        \"afk_channel_id\",\n        \"afk_timeout\",\n        \"icon\",\n        \"owner_id\",\n        \"splash\",\n        \"discovery_splash\",\n        \"banner\",\n        \"system_channel_id\",\n        \"system_channel_flags\",\n        \"rules_channel_id\",\n        \"public_updates_channel_id\",\n        \"preferred_locale\",\n        \"features\",\n        \"description\",\n    )\n    payload = kwargs.copy()\n    for key, value in kwargs.items():\n        if key not in expected or value is None:\n            del payload[key]\n\n    # only do the request if there is something to modify\n    if payload:\n        await self.request(Route(\"PATCH\", f\"/guilds/{int(guild_id)}\"), payload=payload, reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.delete_guild","title":"<code>delete_guild(guild_id)</code>  <code>async</code>","text":"<p>Delete the guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild that we want to delete</p> required Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def delete_guild(self, guild_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n    Delete the guild.\n\n    Args:\n        guild_id: The ID of the guild that we want to delete\n\n    \"\"\"\n    await self.request(Route(\"DELETE\", f\"/guilds/{int(guild_id)}\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.add_guild_member","title":"<code>add_guild_member(guild_id, user_id, access_token, nick=None, roles=None, mute=False, deaf=False)</code>  <code>async</code>","text":"<p>Add a user to the guild. All parameters to this endpoint except for <code>access_token</code>, <code>guild_id</code> and <code>user_id</code> are optional.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the user to add</p> required <code>access_token</code> <code>str</code> <p>The access token of the user</p> required <code>nick</code> <code>str | None</code> <p>value to set users nickname to</p> <code>None</code> <code>roles</code> <code>list[Snowflake_Type] | None</code> <p>array of role ids the member is assigned</p> <code>None</code> <code>mute</code> <code>bool</code> <p>whether the user is muted in voice channels</p> <code>False</code> <code>deaf</code> <code>bool</code> <p>whether the user is deafened in voice channels</p> <code>False</code> <p>Returns:</p> Type Description <code>discord_typings.GuildMemberData</code> <p>Guild Member Object</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def add_guild_member(\n    self,\n    guild_id: \"Snowflake_Type\",\n    user_id: \"Snowflake_Type\",\n    access_token: str,\n    nick: str | None = None,\n    roles: list[\"Snowflake_Type\"] | None = None,\n    mute: bool = False,\n    deaf: bool = False,\n) -&gt; discord_typings.GuildMemberData:\n\"\"\"\n    Add a user to the guild. All parameters to this endpoint except for `access_token`, `guild_id` and `user_id` are optional.\n\n    Args:\n        guild_id: The ID of the guild\n        user_id: The ID of the user to add\n        access_token: The access token of the user\n        nick: value to set users nickname to\n        roles: array of role ids the member is assigned\n        mute: whether the user is muted in voice channels\n        deaf: whether the user is deafened in voice channels\n    Returns:\n        Guild Member Object\n\n    \"\"\"\n    payload = {\n        \"access_token\": access_token,\n        \"nick\": nick,\n        \"roles\": [int(role) for role in roles] if roles else None,\n        \"mute\": mute,\n        \"deaf\": deaf,\n    }\n    payload = dict_filter_none(payload)\n\n    result = await self.request(\n        Route(\"PUT\", f\"/guilds/{int(guild_id)}/members/{int(user_id)}\"),\n        payload=payload,\n    )\n    return cast(discord_typings.GuildMemberData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.remove_guild_member","title":"<code>remove_guild_member(guild_id, user_id, reason=None)</code>  <code>async</code>","text":"<p>Remove a member from a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the user to remove</p> required <code>reason</code> <code>str | None</code> <p>The reason for this action</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def remove_guild_member(\n    self, guild_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\", reason: str | None = None\n) -&gt; None:\n\"\"\"\n    Remove a member from a guild.\n\n    Args:\n        guild_id: The ID of the guild\n        user_id: The ID of the user to remove\n        reason: The reason for this action\n\n    \"\"\"\n    await self.request(Route(\"DELETE\", f\"/guilds/{int(guild_id)}/members/{int(user_id)}\"), reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guild_bans","title":"<code>get_guild_bans(guild_id, before=None, after=None, limit=1000)</code>  <code>async</code>","text":"<p>Return a list of ban objects for the users banned from this guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to query</p> required <p>Returns:</p> Type Description <code>list[discord_typings.BanData]</code> <p>List of ban objects</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guild_bans(\n    self,\n    guild_id: \"Snowflake_Type\",\n    before: \"Snowflake_Type | None\" = None,\n    after: \"Snowflake_Type | None\" = None,\n    limit: int = 1000,\n) -&gt; list[discord_typings.BanData]:\n\"\"\"\n    Return a list of ban objects for the users banned from this guild.\n\n    Args:\n        guild_id: The ID of the guild to query\n\n    Returns:\n        List of ban objects\n\n    \"\"\"\n    params: PAYLOAD_TYPE = {\n        \"limit\": limit,\n        \"before\": int(before) if before else None,\n        \"after\": int(after) if after else None,\n    }\n    params = dict_filter_none(params)\n\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/bans\"), params=params)\n    return cast(list[discord_typings.BanData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guild_ban","title":"<code>get_guild_ban(guild_id, user_id)</code>  <code>async</code>","text":"<p>Returns a ban object for the given user or a 404 not found if the ban cannot be found.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to query</p> required <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the user to query</p> required <p>Returns:</p> Type Description <code>discord_typings.BanData</code> <p>Ban object if exists</p> <p>Raises:</p> Type Description <code>NotFound</code> <p>if no ban exists</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guild_ban(self, guild_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\") -&gt; discord_typings.BanData:\n\"\"\"\n    Returns a ban object for the given user or a 404 not found if the ban cannot be found.\n\n    Args:\n        guild_id: The ID of the guild to query\n        user_id: The ID of the user to query\n\n    Returns:\n        Ban object if exists\n\n    Raises:\n        NotFound: if no ban exists\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/bans/{int(user_id)}\"))\n    return cast(discord_typings.BanData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.create_guild_ban","title":"<code>create_guild_ban(guild_id, user_id, delete_message_seconds=0, reason=None)</code>  <code>async</code>","text":"<p>Create a guild ban, and optionally delete previous messages sent by the banned user.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to create the ban in</p> required <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the user to ban</p> required <code>delete_message_seconds</code> <code>int</code> <p>number of seconds to delete messages for (0-604800)</p> <code>0</code> <code>reason</code> <code>str | None</code> <p>The reason for this action</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def create_guild_ban(\n    self,\n    guild_id: \"Snowflake_Type\",\n    user_id: \"Snowflake_Type\",\n    delete_message_seconds: int = 0,\n    reason: str | None = None,\n) -&gt; None:\n\"\"\"\n    Create a guild ban, and optionally delete previous messages sent by the banned user.\n\n    Args:\n        guild_id: The ID of the guild to create the ban in\n        user_id: The ID of the user to ban\n        delete_message_seconds: number of seconds to delete messages for (0-604800)\n        reason: The reason for this action\n\n    \"\"\"\n    payload = {\"delete_message_seconds\": delete_message_seconds}\n    await self.request(Route(\"PUT\", f\"/guilds/{int(guild_id)}/bans/{int(user_id)}\"), payload=payload, reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.remove_guild_ban","title":"<code>remove_guild_ban(guild_id, user_id, reason=None)</code>  <code>async</code>","text":"<p>Remove a guild ban.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to remove the ban in</p> required <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the user to unban</p> required <code>reason</code> <code>str | None</code> <p>The reason for this action</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def remove_guild_ban(\n    self, guild_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\", reason: str | None = None\n) -&gt; None:\n\"\"\"\n    Remove a guild ban.\n\n    Args:\n        guild_id: The ID of the guild to remove the ban in\n        user_id: The ID of the user to unban\n        reason: The reason for this action\n\n    \"\"\"\n    await self.request(Route(\"DELETE\", f\"/guilds/{int(guild_id)}/bans/{int(user_id)}\"), reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guild_prune_count","title":"<code>get_guild_prune_count(guild_id, days=7, include_roles=None)</code>  <code>async</code>","text":"<p>Returns an object with one 'pruned' key indicating the number of members that would be removed in a prune operation.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to query</p> required <code>days</code> <code>int</code> <p>number of days to count prune for (1-30)</p> <code>7</code> <code>include_roles</code> <code>list[Snowflake_Type] | None</code> <p>role(s) to include</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>{\"pruned\": int}</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guild_prune_count(\n    self, guild_id: \"Snowflake_Type\", days: int = 7, include_roles: list[\"Snowflake_Type\"] | None = None\n) -&gt; dict:\n\"\"\"\n    Returns an object with one 'pruned' key indicating the number of members that would be removed in a prune operation.\n\n    Args:\n        guild_id: The ID of the guild to query\n        days: number of days to count prune for (1-30)\n        include_roles: role(s) to include\n\n    Returns:\n        {\"pruned\": int}\n\n    \"\"\"\n    params: PAYLOAD_TYPE = {\n        \"days\": days,\n        \"include_roles\": \", \".join(str(int(role)) for role in include_roles) if include_roles else None,\n    }\n    params = dict_filter_none(params)\n\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/prune\"), params=params)\n    return cast(dict, result)  # todo revisit, create TypedDict for pruned\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.begin_guild_prune","title":"<code>begin_guild_prune(guild_id, days=7, include_roles=None, compute_prune_count=True, reason=None)</code>  <code>async</code>","text":"<p>Begin a prune operation.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to query</p> required <code>days</code> <code>int</code> <p>number of days to count prune for (1-30)</p> <code>7</code> <code>include_roles</code> <code>list[Snowflake_Type] | None</code> <p>role(s) to include</p> <code>None</code> <code>compute_prune_count</code> <code>bool</code> <p>whether 'pruned' is returned, discouraged for large guilds</p> <code>True</code> <code>reason</code> <code>str | None</code> <p>The reason for this action</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>{\"pruned\": Optional[int]}</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def begin_guild_prune(\n    self,\n    guild_id: \"Snowflake_Type\",\n    days: int = 7,\n    include_roles: list[\"Snowflake_Type\"] | None = None,\n    compute_prune_count: bool = True,\n    reason: str | None = None,\n) -&gt; dict:\n\"\"\"\n    Begin a prune operation.\n\n    Args:\n        guild_id: The ID of the guild to query\n        days: number of days to count prune for (1-30)\n        include_roles: role(s) to include\n        compute_prune_count: whether 'pruned' is returned, discouraged for large guilds\n        reason: The reason for this action\n\n    Returns:\n        {\"pruned\": Optional[int]}\n\n    \"\"\"\n    payload: PAYLOAD_TYPE = {\n        \"days\": days,\n        \"compute_prune_count\": compute_prune_count,\n        \"include_roles\": \", \".join(str(int(role)) for role in include_roles) if include_roles else None,\n    }\n    payload = dict_filter_none(payload)\n\n    result = await self.request(Route(\"POST\", f\"/guilds/{int(guild_id)}/prune\"), payload=payload, reason=reason)\n    return cast(dict, result)  # todo revisit, create TypedDict for pruned\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guild_invites","title":"<code>get_guild_invites(guild_id)</code>  <code>async</code>","text":"<p>Returns a list of invite objects (with invite metadata) for the guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to query</p> required <p>Returns:</p> Type Description <code>list[discord_typings.InviteData]</code> <p>List of invite objects</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guild_invites(self, guild_id: \"Snowflake_Type\") -&gt; list[discord_typings.InviteData]:\n\"\"\"\n    Returns a list of invite objects (with invite metadata) for the guild.\n\n    Args:\n        guild_id: The ID of the guild to query\n\n    Returns:\n        List of invite objects\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/invites\"))\n    return cast(list[discord_typings.InviteData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.create_guild_role","title":"<code>create_guild_role(guild_id, payload, reason=None)</code>  <code>async</code>","text":"<p>Create a new role for the guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>payload</code> <code>dict</code> <p>A dict representing the role to add</p> required <code>reason</code> <code>str | None</code> <p>The reason for this action</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.RoleData</code> <p>Role object</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def create_guild_role(\n    self, guild_id: \"Snowflake_Type\", payload: dict, reason: str | None = None\n) -&gt; discord_typings.RoleData:\n\"\"\"\n    Create a new role for the guild.\n\n    Args:\n        guild_id: The ID of the guild\n        payload: A dict representing the role to add\n        reason: The reason for this action\n\n    Returns:\n        Role object\n\n    \"\"\"\n    result = await self.request(Route(\"POST\", f\"/guilds/{int(guild_id)}/roles\"), payload=payload, reason=reason)\n    return cast(discord_typings.RoleData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.modify_guild_role_positions","title":"<code>modify_guild_role_positions(guild_id, position_changes, reason=None)</code>  <code>async</code>","text":"<p>Modify the position of a role in the guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>position_changes</code> <code>List[dict[Snowflake_Type, int]]</code> <p>A list of dicts representing the roles to move and their new positions</p> required <code>``{\"id\"</code> <p>role_id, \"position\": new_position}``</p> required <code>position</code> <p>The new position of this role in the hierarchy</p> required <code>reason</code> <code>str | None</code> <p>The reason for this action</p> <code>None</code> <p>Returns:</p> Type Description <code>list[discord_typings.RoleData]</code> <p>List of guild roles</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def modify_guild_role_positions(\n    self,\n    guild_id: \"Snowflake_Type\",\n    position_changes: List[dict[\"Snowflake_Type\", int]],\n    reason: str | None = None,\n) -&gt; list[discord_typings.RoleData]:\n\"\"\"\n    Modify the position of a role in the guild.\n\n    Args:\n        guild_id: The ID of the guild\n        position_changes: A list of dicts representing the roles to move and their new positions\n\n        ``{\"id\": role_id, \"position\": new_position}``\n        position: The new position of this role in the hierarchy\n        reason: The reason for this action\n\n    Returns:\n        List of guild roles\n\n    \"\"\"\n    payload: PAYLOAD_TYPE = [\n        {\"id\": int(role[\"id\"]), \"position\": int(role[\"position\"])} for role in position_changes\n    ]\n    result = await self.request(Route(\"PATCH\", f\"/guilds/{int(guild_id)}/roles\"), payload=payload, reason=reason)\n    return cast(list[discord_typings.RoleData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.modify_guild_role","title":"<code>modify_guild_role(guild_id, role_id, payload, reason=None)</code>  <code>async</code>","text":"<p>Modify an existing role for the guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>role_id</code> <code>Snowflake_Type</code> <p>The ID of the role to move</p> required <code>payload</code> <code>dict</code> <p>A dict representing the role to add</p> required <code>reason</code> <code>str | None</code> <p>The reason for this action</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.RoleData</code> <p>Role object</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def modify_guild_role(\n    self, guild_id: \"Snowflake_Type\", role_id: \"Snowflake_Type\", payload: dict, reason: str | None = None\n) -&gt; discord_typings.RoleData:\n\"\"\"\n    Modify an existing role for the guild.\n\n    Args:\n        guild_id: The ID of the guild\n        role_id: The ID of the role to move\n        payload: A dict representing the role to add\n        reason: The reason for this action\n\n    Returns:\n        Role object\n\n    \"\"\"\n    result = await self.request(\n        Route(\"PATCH\", f\"/guilds/{int(guild_id)}/roles/{int(role_id)}\"), payload=payload, reason=reason\n    )\n    return cast(discord_typings.RoleData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.delete_guild_role","title":"<code>delete_guild_role(guild_id, role_id, reason=None)</code>  <code>async</code>","text":"<p>Delete a guild role.</p> <p>Parameters:</p> Name Type Description Default <code>role_id</code> <code>Snowflake_Type</code> <p>The ID of the role to delete</p> required <code>reason</code> <code>str | None</code> <p>The reason for this action</p> <code>None</code> <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def delete_guild_role(\n    self, guild_id: \"Snowflake_Type\", role_id: \"Snowflake_Type\", reason: str | None = None\n) -&gt; None:\n\"\"\"\n    Delete a guild role.\n\n    Args:\n        role_id: The ID of the role to delete\n        reason: The reason for this action\n        guild_id: The ID of the guild\n\n    \"\"\"\n    await self.request(Route(\"DELETE\", f\"/guilds/{int(guild_id)}/roles/{int(role_id)}\"), reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_audit_log","title":"<code>get_audit_log(guild_id, user_id=None, action_type=None, before=None, after=None, limit=100)</code>  <code>async</code>","text":"<p>Get the audit log for a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to query</p> required <code>user_id</code> <code>Snowflake_Type | None</code> <p>filter by user ID</p> <code>None</code> <code>action_type</code> <code>AuditLogEventType | None</code> <p>filter by action type</p> <code>None</code> <code>before</code> <code>Snowflake_Type | None</code> <p>snowflake to get entries before</p> <code>None</code> <code>after</code> <code>Snowflake_Type | None</code> <p>snowflake to get entries after</p> <code>None</code> <code>limit</code> <code>int</code> <p>max number of entries to get</p> <code>100</code> <p>Returns:</p> Type Description <code>discord_typings.AuditLogData</code> <p>audit log object for the guild</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_audit_log(\n    self,\n    guild_id: \"Snowflake_Type\",\n    user_id: \"Snowflake_Type | None\" = None,\n    action_type: \"AuditLogEventType | None\" = None,\n    before: \"Snowflake_Type | None\" = None,\n    after: \"Snowflake_Type | None\" = None,\n    limit: int = 100,\n) -&gt; discord_typings.AuditLogData:\n\"\"\"\n    Get the audit log for a guild.\n\n    Args:\n        guild_id: The ID of the guild to query\n        user_id: filter by user ID\n        action_type: filter by action type\n        before: snowflake to get entries before\n        after: snowflake to get entries after\n        limit: max number of entries to get\n\n    Returns:\n        audit log object for the guild\n\n    \"\"\"\n    params: PAYLOAD_TYPE = {\n        \"limit\": limit,\n        \"before\": int(before) if before else None,\n        \"after\": int(after) if after else None,\n        \"user_id\": int(user_id) if user_id else None,\n        \"action_type\": int(action_type) if action_type else None,\n    }\n    params = dict_filter_none(params)\n\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/audit-logs\"), params=params)\n    return cast(discord_typings.AuditLogData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guild_voice_regions","title":"<code>get_guild_voice_regions(guild_id)</code>  <code>async</code>","text":"<p>Returns a list of voice region objects for the guild. Unlike the similar /voice route, this returns VIP servers when the guild is VIP- enabled.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to query</p> required <p>Returns:</p> Type Description <code>list[discord_typings.VoiceRegionData]</code> <p>List of voice region objects</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guild_voice_regions(self, guild_id: \"Snowflake_Type\") -&gt; list[discord_typings.VoiceRegionData]:\n\"\"\"\n    Returns a list of voice region objects for the guild. Unlike the similar /voice route, this returns VIP servers when the guild is VIP- enabled.\n\n    Args:\n        guild_id: The ID of the guild to query\n\n    Returns:\n        List of voice region objects\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/regions\"))\n    return cast(list[discord_typings.VoiceRegionData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guild_integrations","title":"<code>get_guild_integrations(guild_id)</code>  <code>async</code>","text":"<p>Returns a list of integration objects for the guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to query</p> required <p>Returns:</p> Type Description <code>list[discord_typings.IntegrationData]</code> <p>list of integration objects</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guild_integrations(self, guild_id: \"Snowflake_Type\") -&gt; list[discord_typings.IntegrationData]:\n\"\"\"\n    Returns a list of integration objects for the guild.\n\n    Args:\n        guild_id: The ID of the guild to query\n\n    Returns:\n        list of integration objects\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/integrations\"))\n    return cast(list[discord_typings.IntegrationData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.delete_guild_integration","title":"<code>delete_guild_integration(guild_id, integration_id, reason=None)</code>  <code>async</code>","text":"<p>Delete an integration from the guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>integration_id</code> <code>Snowflake_Type</code> <p>The ID of the integration to remove</p> required Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def delete_guild_integration(\n    self, guild_id: \"Snowflake_Type\", integration_id: \"Snowflake_Type\", reason: str | None = None\n) -&gt; None:\n\"\"\"\n    Delete an integration from the guild.\n\n    Args:\n        guild_id: The ID of the guild\n        integration_id: The ID of the integration to remove\n\n    \"\"\"\n    await self.request(\n        Route(\"DELETE\", f\"/guilds/{int(guild_id)}/integrations/{int(integration_id)}\"), reason=reason\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guild_widget_settings","title":"<code>get_guild_widget_settings(guild_id)</code>  <code>async</code>","text":"<p>Get guild widget settings.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to query</p> required <p>Returns:</p> Type Description <code>discord_typings.GuildWidgetSettingsData</code> <p>guild widget object</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guild_widget_settings(self, guild_id: \"Snowflake_Type\") -&gt; discord_typings.GuildWidgetSettingsData:\n\"\"\"\n    Get guild widget settings.\n\n    Args:\n        guild_id: The ID of the guild to query\n\n    Returns:\n        guild widget object\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/widget\"))\n    return cast(discord_typings.GuildWidgetSettingsData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guild_widget","title":"<code>get_guild_widget(guild_id)</code>  <code>async</code>","text":"<p>Returns the widget for the guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to query</p> required <p>Returns:</p> Type Description <code>discord_typings.GuildWidgetData</code> <p>Guild widget</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guild_widget(self, guild_id: \"Snowflake_Type\") -&gt; discord_typings.GuildWidgetData:\n\"\"\"\n    Returns the widget for the guild.\n\n    Args:\n        guild_id: The ID of the guild to query\n\n    Returns:\n        Guild widget\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/widget.json\"))\n    return cast(discord_typings.GuildWidgetData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guild_widget_image","title":"<code>get_guild_widget_image(guild_id, style=None)</code>  <code>async</code>","text":"<p>Get a url representing a png image widget for the guild.</p> <p>For styles see: https://discord.com/developers/docs/resources/guild#get-guild-widget-image</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The guild to query</p> required <code>style</code> <code>str | None</code> <p>The style of widget required.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A url pointing to this image</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guild_widget_image(self, guild_id: \"Snowflake_Type\", style: str | None = None) -&gt; str:\n\"\"\"\n    Get a url representing a png image widget for the guild.\n\n    For styles see: https://discord.com/developers/docs/resources/guild#get-guild-widget-image\n\n    Args:\n        guild_id: The guild to query\n        style: The style of widget required.\n\n    Returns:\n        A url pointing to this image\n\n    \"\"\"\n    route = Route(\"GET\", f\"/guilds/{int(guild_id)}/widget.png{f'?style={style}' if style else ''}\")\n    return route.url\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guild_welcome_screen","title":"<code>get_guild_welcome_screen(guild_id)</code>  <code>async</code>","text":"<p>Get the welcome screen for this guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to query</p> required <p>Returns:</p> Type Description <code>discord_typings.WelcomeScreenData</code> <p>Welcome screen object</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guild_welcome_screen(self, guild_id: \"Snowflake_Type\") -&gt; discord_typings.WelcomeScreenData:\n\"\"\"\n    Get the welcome screen for this guild.\n\n    Args:\n        guild_id: The ID of the guild to query\n    Returns:\n        Welcome screen object\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/welcome-screen\"))\n    return cast(discord_typings.WelcomeScreenData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guild_vanity_url","title":"<code>get_guild_vanity_url(guild_id)</code>  <code>async</code>","text":"<p>Get a partial invite object for the guilds vanity invite url.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to query</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Returns a partial invite object. Code is None if a vanity url for the guild is not set.</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guild_vanity_url(self, guild_id: \"Snowflake_Type\") -&gt; dict:\n\"\"\"\n    Get a partial invite object for the guilds vanity invite url.\n\n    Args:\n        guild_id: The ID of the guild to query\n\n    Returns:\n        Returns a partial invite object. Code is None if a vanity url for the guild is not set.\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/vanity-url\"))\n    return cast(dict, result)  # todo create typing?\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guild_channels","title":"<code>get_guild_channels(guild_id)</code>  <code>async</code>","text":"<p>Gets a list of guild channel objects.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <p>Returns:</p> Type Description <code>list[discord_typings.ChannelData]</code> <p>A list of channels in this guild. Does not include threads.</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guild_channels(\n    self, guild_id: \"Snowflake_Type\"\n) -&gt; list[discord_typings.ChannelData]:  # todo narrow down channel types\n\"\"\"\n    Gets a list of guild channel objects.\n\n    Args:\n        guild_id: The ID of the guild\n\n    Returns:\n        A list of channels in this guild. Does not include threads.\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/channels\"))\n    return cast(list[discord_typings.ChannelData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.modify_guild_widget","title":"<code>modify_guild_widget(guild_id, enabled=None, channel_id=None)</code>  <code>async</code>","text":"<p>Modify a guild widget.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to modify.</p> required <code>enabled</code> <code>bool | None</code> <p>Should the guild widget be enabled</p> <code>None</code> <code>channel_id</code> <code>Snowflake_Type | None</code> <p>The widget's channel ID</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.GuildWidgetData</code> <p>Updated guild widget.</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def modify_guild_widget(\n    self, guild_id: \"Snowflake_Type\", enabled: bool | None = None, channel_id: \"Snowflake_Type | None\" = None\n) -&gt; discord_typings.GuildWidgetData:\n\"\"\"\n    Modify a guild widget.\n\n    Args:\n        guild_id: The ID of the guild to modify.\n        enabled: Should the guild widget be enabled\n        channel_id: The widget's channel ID\n\n    Returns:\n        Updated guild widget.\n\n    \"\"\"\n    payload: PAYLOAD_TYPE = {\n        \"enabled\": enabled,\n        \"channel_id\": int(channel_id) if channel_id else None,\n    }\n    payload = dict_filter_none(payload)\n\n    result = await self.request(Route(\"PATCH\", f\"/guilds/{int(guild_id)}/widget\"), payload=payload)\n    return cast(discord_typings.GuildWidgetData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.modify_guild_welcome_screen","title":"<code>modify_guild_welcome_screen(guild_id, enabled, welcome_channels, description)</code>  <code>async</code>","text":"<p>Modify the guild's welcome screen.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild.</p> required <code>enabled</code> <code>bool</code> <p>Whether the welcome screen is enabled</p> required <code>welcome_channels</code> <code>list[Snowflake_Type]</code> <p>Channels linked in the welcome screen and their display options</p> required <code>description</code> <code>str</code> <p>The server description to show in the welcome screen</p> required <p>Returns:</p> Type Description <code>discord_typings.WelcomeScreenData</code> <p>Updated welcome screen object</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def modify_guild_welcome_screen(\n    self, guild_id: \"Snowflake_Type\", enabled: bool, welcome_channels: list[\"Snowflake_Type\"], description: str\n) -&gt; discord_typings.WelcomeScreenData:\n\"\"\"\n    Modify the guild's welcome screen.\n\n    Args:\n        guild_id: The ID of the guild.\n        enabled: Whether the welcome screen is enabled\n        welcome_channels: Channels linked in the welcome screen and their display options\n        description: The server description to show in the welcome screen\n\n    Returns:\n        Updated welcome screen object\n\n    \"\"\"\n    payload: PAYLOAD_TYPE = {\n        \"enabled\": enabled,\n        \"welcome_channels\": [int(channel) for channel in welcome_channels],\n        \"description\": description,\n    }\n    result = await self.request(Route(\"PATCH\", f\"/guilds/{int(guild_id)}/welcome-screen\"), payload=payload)\n    return cast(discord_typings.WelcomeScreenData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.modify_current_user_voice_state","title":"<code>modify_current_user_voice_state(guild_id, channel_id, suppress=None, request_to_speak_timestamp=None)</code>  <code>async</code>","text":"<p>Update the current user voice state.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to update.</p> required <code>channel_id</code> <code>Snowflake_Type</code> <p>The id of the channel the user is currently in</p> required <code>suppress</code> <code>bool | None</code> <p>Toggle the user's suppress state.</p> <code>None</code> <code>request_to_speak_timestamp</code> <code>str | None</code> <p>Sets the user's request to speak</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def modify_current_user_voice_state(\n    self,\n    guild_id: \"Snowflake_Type\",\n    channel_id: \"Snowflake_Type\",\n    suppress: bool | None = None,\n    request_to_speak_timestamp: str | None = None,\n) -&gt; None:\n\"\"\"\n    Update the current user voice state.\n\n    Args:\n        guild_id: The ID of the guild to update.\n        channel_id: The id of the channel the user is currently in\n        suppress: Toggle the user's suppress state.\n        request_to_speak_timestamp: Sets the user's request to speak\n\n    \"\"\"\n    payload: PAYLOAD_TYPE = {\n        \"suppress\": suppress,\n        \"request_to_speak_timestamp\": request_to_speak_timestamp,\n        \"channel_id\": int(channel_id) if channel_id else None,\n    }\n    payload = dict_filter_none(payload)\n\n    await self.request(Route(\"PATCH\", f\"/guilds/{int(guild_id)}/voice-states/@me\"), payload=payload)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.modify_user_voice_state","title":"<code>modify_user_voice_state(guild_id, user_id, channel_id, suppress=None)</code>  <code>async</code>","text":"<p>Modify the voice state of a user.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild.</p> required <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the user to modify.</p> required <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel the user is currently in.</p> required <code>suppress</code> <code>bool | None</code> <p>Toggles the user's suppress state.</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def modify_user_voice_state(\n    self,\n    guild_id: \"Snowflake_Type\",\n    user_id: \"Snowflake_Type\",\n    channel_id: \"Snowflake_Type\",\n    suppress: bool | None = None,\n) -&gt; None:\n\"\"\"\n    Modify the voice state of a user.\n\n    Args:\n        guild_id: The ID of the guild.\n        user_id: The ID of the user to modify.\n        channel_id: The ID of the channel the user is currently in.\n        suppress: Toggles the user's suppress state.\n\n    \"\"\"\n    payload: PAYLOAD_TYPE = {\n        \"suppress\": suppress,\n        \"channel_id\": int(channel_id) if channel_id else None,\n    }\n    payload = dict_filter_none(payload)\n\n    await self.request(Route(\"PATCH\", f\"/guilds/{int(guild_id)}/voice-states/{user_id}\"), payload=payload)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.create_guild_from_guild_template","title":"<code>create_guild_from_guild_template(template_code, name, icon)</code>  <code>async</code>","text":"<p>Creates a new guild based on a template.</p> <p>Note</p> <p>This endpoint can only be used by bots in less than 10 guilds.</p> <p>Parameters:</p> Name Type Description Default <code>template_code</code> <code>str</code> <p>The code of the template to use.</p> required <code>name</code> <code>str</code> <p>The name of the guild (2-100 characters)</p> required <code>icon</code> <code>str</code> <p>Data URI scheme</p> required <p>Returns:</p> Type Description <code>discord_typings.GuildData</code> <p>The newly created guild object</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def create_guild_from_guild_template(\n    self, template_code: str, name: str, icon: str\n) -&gt; discord_typings.GuildData:\n\"\"\"\n    Creates a new guild based on a template.\n\n    !!! note\n        This endpoint can only be used by bots in less than 10 guilds.\n\n    Args:\n        template_code: The code of the template to use.\n        name: The name of the guild (2-100 characters)\n        icon: Data URI scheme\n\n    Returns:\n        The newly created guild object\n\n    \"\"\"\n    payload = {\"name\": name, \"icon\": icon}\n\n    result = await self.request(Route(\"POST\", f\"/guilds/templates/{template_code}\"), payload=payload)\n    return cast(discord_typings.GuildData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_guild_templates","title":"<code>get_guild_templates(guild_id)</code>  <code>async</code>","text":"<p>Returns an array of guild templates.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to query.</p> required <p>Returns:</p> Type Description <code>list[discord_typings.GuildTemplateData]</code> <p>An array of guild templates</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_guild_templates(self, guild_id: \"Snowflake_Type\") -&gt; list[discord_typings.GuildTemplateData]:\n\"\"\"\n    Returns an array of guild templates.\n\n    Args:\n        guild_id: The ID of the guild to query.\n\n    Returns:\n        An array of guild templates\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/templates\"))\n    return cast(list[discord_typings.GuildTemplateData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.create_guild_template","title":"<code>create_guild_template(guild_id, name, description=None)</code>  <code>async</code>","text":"<p>Create a guild template for the guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to create a template for.</p> required <code>name</code> <code>str</code> <p>The name of the template</p> required <code>description</code> <code>str | None</code> <p>The description of the template</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.GuildTemplateData</code> <p>The created guild template</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def create_guild_template(\n    self, guild_id: \"Snowflake_Type\", name: str, description: str | None = None\n) -&gt; discord_typings.GuildTemplateData:\n\"\"\"\n    Create a guild template for the guild.\n\n    Args:\n        guild_id: The ID of the guild to create a template for.\n        name: The name of the template\n        description: The description of the template\n\n    Returns:\n        The created guild template\n\n    \"\"\"\n    payload = {\"name\": name, \"description\": description}\n    payload = dict_filter_none(payload)\n\n    result = await self.request(Route(\"POST\", f\"/guilds/{int(guild_id)}/templates\"), payload=payload)\n    return cast(discord_typings.GuildTemplateData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.sync_guild_template","title":"<code>sync_guild_template(guild_id, template_code)</code>  <code>async</code>","text":"<p>Sync the template to the guild's current state.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>template_code</code> <code>str</code> <p>The code for the template to sync</p> required <p>Returns:</p> Type Description <code>discord_typings.GuildTemplateData</code> <p>The updated guild template</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def sync_guild_template(\n    self, guild_id: \"Snowflake_Type\", template_code: str\n) -&gt; discord_typings.GuildTemplateData:\n\"\"\"\n    Sync the template to the guild's current state.\n\n    Args:\n        guild_id: The ID of the guild\n        template_code: The code for the template to sync\n\n    Returns:\n        The updated guild template\n\n    \"\"\"\n    result = await self.request(Route(\"PUT\", f\"/guilds/{int(guild_id)}/templates/{template_code}\"))\n    return cast(discord_typings.GuildTemplateData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.modify_guild_template","title":"<code>modify_guild_template(guild_id, template_code, name=None, description=None)</code>  <code>async</code>","text":"<p>Modifies the template's metadata.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>template_code</code> <code>str</code> <p>The template code</p> required <code>name</code> <code>str | None</code> <p>The name of the template</p> <code>None</code> <code>description</code> <code>str | None</code> <p>The description of the template</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.GuildTemplateData</code> <p>The updated guild template</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def modify_guild_template(\n    self,\n    guild_id: \"Snowflake_Type\",\n    template_code: str,\n    name: str | None = None,\n    description: str | None = None,\n) -&gt; discord_typings.GuildTemplateData:\n\"\"\"\n    Modifies the template's metadata.\n\n    Args:\n        guild_id: The ID of the guild\n        template_code: The template code\n        name: The name of the template\n        description: The description of the template\n\n    Returns:\n        The updated guild template\n\n    \"\"\"\n    payload: PAYLOAD_TYPE = {\"name\": name, \"description\": description}\n    payload = dict_filter_none(payload)\n\n    result = await self.request(\n        Route(\"PATCH\", f\"/guilds/{int(guild_id)}/templates/{template_code}\"), payload=payload\n    )\n    return cast(discord_typings.GuildTemplateData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.delete_guild_template","title":"<code>delete_guild_template(guild_id, template_code)</code>  <code>async</code>","text":"<p>Delete the guild template.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>template_code</code> <code>str</code> <p>The ID of the template</p> required <p>Returns:</p> Type Description <code>discord_typings.GuildTemplateData</code> <p>The deleted template object</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def delete_guild_template(\n    self, guild_id: \"Snowflake_Type\", template_code: str\n) -&gt; discord_typings.GuildTemplateData:\n\"\"\"\n    Delete the guild template.\n\n    Args:\n        guild_id: The ID of the guild\n        template_code: The ID of the template\n\n    Returns:\n        The deleted template object\n\n    \"\"\"\n    # why on earth does this return the deleted template object?\n    result = await self.request(Route(\"DELETE\", f\"/guilds/{int(guild_id)}/templates/{template_code}\"))\n    return cast(discord_typings.GuildTemplateData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_auto_moderation_rules","title":"<code>get_auto_moderation_rules(guild_id)</code>  <code>async</code>","text":"<p>Get this guilds auto moderation rules.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to get</p> required <p>Returns:</p> Type Description <code>list[discord_typings.AutoModerationRuleData]</code> <p>A list of auto moderation rules</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_auto_moderation_rules(\n    self, guild_id: \"Snowflake_Type\"\n) -&gt; list[discord_typings.AutoModerationRuleData]:\n\"\"\"\n    Get this guilds auto moderation rules.\n\n    Args:\n        guild_id: The ID of the guild to get\n\n    Returns:\n        A list of auto moderation rules\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/auto-moderation/rules\"))\n    return cast(list[dict], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.get_auto_moderation_rule","title":"<code>get_auto_moderation_rule(guild_id, rule_id)</code>  <code>async</code>","text":"<p>Get a specific auto moderation rule.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>rule_id</code> <code>Snowflake_Type</code> <p>The ID of the rule to get</p> required <p>Returns:</p> Type Description <code>discord_typings.AutoModerationRuleData</code> <p>The auto moderation rule</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def get_auto_moderation_rule(\n    self, guild_id: \"Snowflake_Type\", rule_id: \"Snowflake_Type\"\n) -&gt; discord_typings.AutoModerationRuleData:\n\"\"\"\n    Get a specific auto moderation rule.\n\n    Args:\n        guild_id: The ID of the guild\n        rule_id: The ID of the rule to get\n\n    Returns:\n        The auto moderation rule\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/auto-moderation/rules/{int(rule_id)}\"))\n    return cast(dict, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.create_auto_moderation_rule","title":"<code>create_auto_moderation_rule(guild_id, payload)</code>  <code>async</code>","text":"<p>Create an auto moderation rule.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to create this rule within</p> required <code>payload</code> <code>discord_typings.AutoModerationRuleData</code> <p>A dict representing the auto moderation rule</p> required <p>Returns:</p> Type Description <code>discord_typings.AutoModerationRuleData</code> <p>The created auto moderation rule</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def create_auto_moderation_rule(\n    self, guild_id: \"Snowflake_Type\", payload: discord_typings.AutoModerationRuleData\n) -&gt; discord_typings.AutoModerationRuleData:\n\"\"\"\n    Create an auto moderation rule.\n\n    Args:\n        guild_id: The ID of the guild to create this rule within\n        payload: A dict representing the auto moderation rule\n\n    Returns:\n        The created auto moderation rule\n    \"\"\"\n    result = await self.request(Route(\"POST\", f\"/guilds/{int(guild_id)}/auto-moderation/rules\"), payload=payload)\n    return cast(dict, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.modify_auto_moderation_rule","title":"<code>modify_auto_moderation_rule(guild_id, rule_id, name=None, trigger_type=None, trigger_metadata=None, actions=None, exempt_channels=None, exempt_roles=None, event_type=None, enabled=None, reason=None)</code>  <code>async</code>","text":"<p>Modify an existing auto moderation rule.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild the rule belongs to</p> required <code>rule_id</code> <code>Snowflake_Type</code> <p>The ID of the rule to modify</p> required <code>name</code> <code>str | None</code> <p>The name of the rule</p> <code>None</code> <code>trigger_type</code> <code>dict | None</code> <p>The type trigger for this rule</p> <code>None</code> <code>trigger_metadata</code> <code>dict | None</code> <p>Metadata for the trigger</p> <code>None</code> <code>actions</code> <code>list[dict] | None</code> <p>A list of actions to take upon triggering</p> <code>None</code> <code>exempt_roles</code> <code>list[Snowflake_Type] | None</code> <p>Roles that ignore this rule</p> <code>None</code> <code>exempt_channels</code> <code>list[Snowflake_Type] | None</code> <p>Channels that ignore this role</p> <code>None</code> <code>enabled</code> <code>bool | None</code> <p>Is this rule enabled?</p> <code>None</code> <code>event_type</code> <code>dict | None</code> <p>The type of event that triggers this rule</p> <code>None</code> <code>reason</code> <code>str | None</code> <p>The reason for this change</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>The updated rule object</p> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def modify_auto_moderation_rule(\n    self,\n    guild_id: \"Snowflake_Type\",\n    rule_id: \"Snowflake_Type\",\n    name: str | None = None,\n    trigger_type: dict | None = None,\n    trigger_metadata: dict | None = None,\n    actions: list[dict] | None = None,\n    exempt_channels: list[\"Snowflake_Type\"] | None = None,\n    exempt_roles: list[\"Snowflake_Type\"] | None = None,\n    event_type: dict | None = None,\n    enabled: bool | None = None,\n    reason: str | None = None,\n) -&gt; dict:\n\"\"\"\n    Modify an existing auto moderation rule.\n\n    Args:\n        guild_id: The ID of the guild the rule belongs to\n        rule_id: The ID of the rule to modify\n        name: The name of the rule\n        trigger_type: The type trigger for this rule\n        trigger_metadata: Metadata for the trigger\n        actions: A list of actions to take upon triggering\n        exempt_roles: Roles that ignore this rule\n        exempt_channels: Channels that ignore this role\n        enabled: Is this rule enabled?\n        event_type: The type of event that triggers this rule\n        reason: The reason for this change\n\n    Returns:\n        The updated rule object\n    \"\"\"\n    payload = {\n        \"name\": name,\n        \"trigger_type\": trigger_type,\n        \"trigger_metadata\": trigger_metadata,\n        \"actions\": actions,\n        \"exempt_roles\": [int(role) for role in exempt_roles] if exempt_roles else None,\n        \"exempt_channels\": [int(channel) for channel in exempt_channels] if exempt_channels else None,\n        \"event_type\": event_type,\n        \"enabled\": enabled,\n    }\n    payload = dict_filter_none(payload)\n\n    result = await self.request(\n        Route(\"PATCH\", f\"/guilds/{int(guild_id)}/auto-moderation/rules/{int(rule_id)}\"),\n        payload=payload,\n        reason=reason,\n    )\n    return cast(dict, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.guild.GuildRequests.delete_auto_moderation_rule","title":"<code>delete_auto_moderation_rule(guild_id, rule_id, reason=None)</code>  <code>async</code>","text":"<p>Delete an auto moderation rule.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to delete this rule from</p> required <code>rule_id</code> <code>Snowflake_Type</code> <p>The ID of the role to delete</p> required <code>reason</code> <code>str | None</code> <p>The reason for deleting this rule</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\guild.py</code> <pre><code>async def delete_auto_moderation_rule(\n    self, guild_id: \"Snowflake_Type\", rule_id: \"Snowflake_Type\", reason: str | None = None\n) -&gt; dict:\n\"\"\"\n    Delete an auto moderation rule.\n\n    Args:\n        guild_id: The ID of the guild to delete this rule from\n        rule_id: The ID of the role to delete\n        reason: The reason for deleting this rule\n    \"\"\"\n    result = await self.request(\n        Route(\"DELETE\", f\"/guilds/{int(guild_id)}/auto-moderation/rules/{int(rule_id)}\"), reason=reason\n    )\n    return cast(dict, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.InteractionRequests","title":"<code>InteractionRequests</code>","text":"<p>         Bases: <code>CanRequest</code></p> Source code in <code>naff\\api\\http\\http_requests\\interactions.py</code> <pre><code>class InteractionRequests(CanRequest):\n    async def delete_application_command(\n        self, application_id: \"Snowflake_Type\", guild_id: \"Snowflake_Type\", command_id: \"Snowflake_Type\"\n    ) -&gt; None:\n\"\"\"\n        Delete an existing application command for this application.\n\n        Args:\n            application_id: the what application to delete for\n            guild_id: specify a guild to delete commands from\n            command_id: the command to delete\n\n        \"\"\"\n        if guild_id == GLOBAL_SCOPE:\n            await self.request(Route(\"DELETE\", f\"/applications/{int(application_id)}/commands/{int(command_id)}\"))\n        else:\n            await self.request(\n                Route(\n                    \"DELETE\", f\"/applications/{int(application_id)}/guilds/{int(guild_id)}/commands/{int(command_id)}\"\n                )\n            )\n\n    async def get_application_commands(\n        self, application_id: \"Snowflake_Type\", guild_id: \"Snowflake_Type\", with_localisations: bool = True\n    ) -&gt; list[discord_typings.ApplicationCommandData]:\n\"\"\"\n        Get all application commands for this application from discord.\n\n        Args:\n            application_id: the what application to query\n            guild_id: specify a guild to get commands from\n            with_localisations: whether to include all localisations in the response\n\n        Returns:\n            Application command data\n\n        \"\"\"\n        if guild_id == GLOBAL_SCOPE:\n            return await self.request(\n                Route(\"GET\", f\"/applications/{application_id}/commands\"),\n                params={\"with_localizations\": int(with_localisations)},\n            )\n        return await self.request(\n            Route(\"GET\", f\"/applications/{application_id}/guilds/{guild_id}/commands\"),\n            params={\"with_localizations\": int(with_localisations)},\n        )\n\n    async def overwrite_application_commands(\n        self, app_id: \"Snowflake_Type\", data: list[dict], guild_id: \"Snowflake_Type\"\n    ) -&gt; list[discord_typings.ApplicationCommandData]:  # todo type \"data\"\n\"\"\"\n        Take a list of commands and overwrite the existing command list within the given scope\n\n        Args:\n            app_id: The application ID of this bot\n            guild_id: The ID of the guild this command is for, if this is a guild command\n            data: List of your interaction data\n\n        \"\"\"\n        if guild_id == GLOBAL_SCOPE:\n            result = await self.request(Route(\"PUT\", f\"/applications/{app_id}/commands\"), payload=data)\n        else:\n            result = await self.request(\n                Route(\"PUT\", f\"/applications/{app_id}/guilds/{int(guild_id)}/commands\"), payload=data\n            )\n        return cast(list[discord_typings.ApplicationCommandData], result)\n\n    async def create_application_command(\n        self, app_id: \"Snowflake_Type\", command: dict, guild_id: \"Snowflake_Type\"\n    ) -&gt; discord_typings.ApplicationCommandData:\n\"\"\"\n        Add a given command to scope.\n\n        Args:\n            app_id: The application ID of this bot\n            command: A dictionary representing a command to be created\n            guild_id: The ID of the guild this command is for, if this is a guild command\n\n        Returns:\n            An application command object\n        \"\"\"\n        if guild_id == GLOBAL_SCOPE:\n            result = await self.request(Route(\"POST\", f\"/applications/{app_id}/commands\"), payload=command)\n        else:\n            result = await self.request(\n                Route(\"POST\", f\"/applications/{app_id}/guilds/{int(guild_id)}/commands\"), payload=command\n            )\n        return cast(discord_typings.ApplicationCommandData, result)\n\n    async def post_initial_response(\n        self, payload: dict, interaction_id: str, token: str, files: list[\"UPLOADABLE_TYPE\"] | None = None\n    ) -&gt; None:\n\"\"\"\n        Post an initial response to an interaction.\n\n        Args:\n            payload: the payload to send\n            interaction_id: the id of the interaction\n            token: the token of the interaction\n            files: The files to send in this message\n\n        \"\"\"\n        return await self.request(\n            Route(\"POST\", f\"/interactions/{interaction_id}/{token}/callback\"), payload=payload, files=files\n        )\n\n    async def post_followup(\n        self, payload: dict, application_id: \"Snowflake_Type\", token: str, files: list[\"UPLOADABLE_TYPE\"] | None = None\n    ) -&gt; None:\n\"\"\"\n        Send a followup to an interaction.\n\n        Args:\n            payload: the payload to send\n            application_id: the id of the application\n            token: the token of the interaction\n            files: The files to send with this interaction\n\n        \"\"\"\n        return await self.request(\n            Route(\"POST\", f\"/webhooks/{int(application_id)}/{token}\"), payload=payload, files=files\n        )\n\n    async def edit_interaction_message(\n        self,\n        payload: dict,\n        application_id: \"Snowflake_Type\",\n        token: str,\n        message_id: \"str|Snowflake_Type\" = \"@original\",\n        files: list[\"UPLOADABLE_TYPE\"] | None = None,\n    ) -&gt; discord_typings.MessageData:\n\"\"\"\n        Edits an existing interaction message.\n\n        Args:\n            payload: The payload to send.\n            application_id: The id of the application.\n            token: The token of the interaction.\n            message_id: The target message to edit. Defaults to @original which represents the initial response message.\n            files: The files to send with this interaction\n\n        Returns:\n            The edited message data.\n\n        \"\"\"\n        result = await self.request(\n            Route(\"PATCH\", f\"/webhooks/{int(application_id)}/{token}/messages/{message_id}\"),\n            payload=payload,\n            files=files,\n        )\n        return cast(discord_typings.MessageData, result)\n\n    async def delete_interaction_message(\n        self, application_id: \"Snowflake_Type\", token: str, message_id: \"str | Snowflake_Type\" = \"@original\"\n    ) -&gt; None:\n\"\"\"\n        Deletes an existing interaction message.\n\n        Args:\n            application_id: The id of the application.\n            token: The token of the interaction.\n            message_id: The target message to delete. Defaults to @original which represents the initial response message.\n\n        \"\"\"\n        return await self.request(Route(\"DELETE\", f\"/webhooks/{int(application_id)}/{token}/messages/{message_id}\"))\n\n    async def get_interaction_message(\n        self, application_id: \"Snowflake_Type\", token: str, message_id: str = \"@original\"\n    ) -&gt; discord_typings.MessageData:\n\"\"\"\n        Gets an existing interaction message.\n\n        Args:\n            application_id: The id of the application.\n            token: The token of the interaction.\n            message_id: The target message to get. Defaults to @original which represents the initial response message.\n\n        Returns:\n            The message data.\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/webhooks/{int(application_id)}/{token}/messages/{message_id}\"))\n        return cast(discord_typings.MessageData, result)\n\n    async def edit_application_command_permissions(\n        self,\n        application_id: \"Snowflake_Type\",\n        scope: \"Snowflake_Type\",\n        command_id: \"Snowflake_Type\",\n        permissions: list[dict],  # todo better typing\n    ) -&gt; discord_typings.ApplicationCommandPermissionsData:\n\"\"\"\n        Edits command permissions for a specific command.\n\n        Args:\n            application_id: the id of the application\n            scope: The scope this command is in\n            command_id: The command id to edit\n            permissions: The permissions to set to this command\n\n        Returns:\n            Guild Application Command Permissions\n\n        \"\"\"\n        result = await self.request(\n            Route(\n                \"PUT\", f\"/applications/{int(application_id)}/guilds/{int(scope)}/commands/{int(command_id)}/permissions\"\n            ),\n            payload=permissions,\n        )\n        return cast(discord_typings.ApplicationCommandPermissionsData, result)\n\n    async def get_application_command_permissions(\n        self, application_id: \"Snowflake_Type\", scope: \"Snowflake_Type\", command_id: \"Snowflake_Type\"\n    ) -&gt; list[discord_typings.ApplicationCommandPermissionsData]:\n\"\"\"\n        Get permission data for a command.\n\n        Args:\n            application_id: the id of the application\n            scope: The scope this command is in\n            command_id: The command id to edit\n\n        Returns:\n            guild application command permissions\n\n        \"\"\"\n        result = await self.request(\n            Route(\n                \"GET\", f\"/applications/{int(application_id)}/guilds/{int(scope)}/commands/{int(command_id)}/permissions\"\n            )\n        )\n        return cast(list[discord_typings.ApplicationCommandPermissionsData], result)\n\n    async def batch_get_application_command_permissions(\n        self, application_id: \"Snowflake_Type\", scope: \"Snowflake_Type\"\n    ) -&gt; list[discord_typings.ApplicationCommandPermissionsData]:\n\"\"\"\n        Get permission data for all commands in a scope.\n\n        Args:\n            application_id: the id of the application\n            scope: The scope this command is in\n\n        Returns:\n            list of guild application command permissions\n\n        \"\"\"\n        result = await self.request(\n            Route(\"GET\", f\"/applications/{int(application_id)}/guilds/{int(scope)}/commands/permissions\")\n        )\n        return cast(list[discord_typings.ApplicationCommandPermissionsData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.interactions.InteractionRequests.delete_application_command","title":"<code>delete_application_command(application_id, guild_id, command_id)</code>  <code>async</code>","text":"<p>Delete an existing application command for this application.</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>Snowflake_Type</code> <p>the what application to delete for</p> required <code>guild_id</code> <code>Snowflake_Type</code> <p>specify a guild to delete commands from</p> required <code>command_id</code> <code>Snowflake_Type</code> <p>the command to delete</p> required Source code in <code>naff\\api\\http\\http_requests\\interactions.py</code> <pre><code>async def delete_application_command(\n    self, application_id: \"Snowflake_Type\", guild_id: \"Snowflake_Type\", command_id: \"Snowflake_Type\"\n) -&gt; None:\n\"\"\"\n    Delete an existing application command for this application.\n\n    Args:\n        application_id: the what application to delete for\n        guild_id: specify a guild to delete commands from\n        command_id: the command to delete\n\n    \"\"\"\n    if guild_id == GLOBAL_SCOPE:\n        await self.request(Route(\"DELETE\", f\"/applications/{int(application_id)}/commands/{int(command_id)}\"))\n    else:\n        await self.request(\n            Route(\n                \"DELETE\", f\"/applications/{int(application_id)}/guilds/{int(guild_id)}/commands/{int(command_id)}\"\n            )\n        )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.interactions.InteractionRequests.get_application_commands","title":"<code>get_application_commands(application_id, guild_id, with_localisations=True)</code>  <code>async</code>","text":"<p>Get all application commands for this application from discord.</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>Snowflake_Type</code> <p>the what application to query</p> required <code>guild_id</code> <code>Snowflake_Type</code> <p>specify a guild to get commands from</p> required <code>with_localisations</code> <code>bool</code> <p>whether to include all localisations in the response</p> <code>True</code> <p>Returns:</p> Type Description <code>list[discord_typings.ApplicationCommandData]</code> <p>Application command data</p> Source code in <code>naff\\api\\http\\http_requests\\interactions.py</code> <pre><code>async def get_application_commands(\n    self, application_id: \"Snowflake_Type\", guild_id: \"Snowflake_Type\", with_localisations: bool = True\n) -&gt; list[discord_typings.ApplicationCommandData]:\n\"\"\"\n    Get all application commands for this application from discord.\n\n    Args:\n        application_id: the what application to query\n        guild_id: specify a guild to get commands from\n        with_localisations: whether to include all localisations in the response\n\n    Returns:\n        Application command data\n\n    \"\"\"\n    if guild_id == GLOBAL_SCOPE:\n        return await self.request(\n            Route(\"GET\", f\"/applications/{application_id}/commands\"),\n            params={\"with_localizations\": int(with_localisations)},\n        )\n    return await self.request(\n        Route(\"GET\", f\"/applications/{application_id}/guilds/{guild_id}/commands\"),\n        params={\"with_localizations\": int(with_localisations)},\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.interactions.InteractionRequests.overwrite_application_commands","title":"<code>overwrite_application_commands(app_id, data, guild_id)</code>  <code>async</code>","text":"<p>Take a list of commands and overwrite the existing command list within the given scope</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>Snowflake_Type</code> <p>The application ID of this bot</p> required <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild this command is for, if this is a guild command</p> required <code>data</code> <code>list[dict]</code> <p>List of your interaction data</p> required Source code in <code>naff\\api\\http\\http_requests\\interactions.py</code> <pre><code>async def overwrite_application_commands(\n    self, app_id: \"Snowflake_Type\", data: list[dict], guild_id: \"Snowflake_Type\"\n) -&gt; list[discord_typings.ApplicationCommandData]:  # todo type \"data\"\n\"\"\"\n    Take a list of commands and overwrite the existing command list within the given scope\n\n    Args:\n        app_id: The application ID of this bot\n        guild_id: The ID of the guild this command is for, if this is a guild command\n        data: List of your interaction data\n\n    \"\"\"\n    if guild_id == GLOBAL_SCOPE:\n        result = await self.request(Route(\"PUT\", f\"/applications/{app_id}/commands\"), payload=data)\n    else:\n        result = await self.request(\n            Route(\"PUT\", f\"/applications/{app_id}/guilds/{int(guild_id)}/commands\"), payload=data\n        )\n    return cast(list[discord_typings.ApplicationCommandData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.interactions.InteractionRequests.create_application_command","title":"<code>create_application_command(app_id, command, guild_id)</code>  <code>async</code>","text":"<p>Add a given command to scope.</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>Snowflake_Type</code> <p>The application ID of this bot</p> required <code>command</code> <code>dict</code> <p>A dictionary representing a command to be created</p> required <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild this command is for, if this is a guild command</p> required <p>Returns:</p> Type Description <code>discord_typings.ApplicationCommandData</code> <p>An application command object</p> Source code in <code>naff\\api\\http\\http_requests\\interactions.py</code> <pre><code>async def create_application_command(\n    self, app_id: \"Snowflake_Type\", command: dict, guild_id: \"Snowflake_Type\"\n) -&gt; discord_typings.ApplicationCommandData:\n\"\"\"\n    Add a given command to scope.\n\n    Args:\n        app_id: The application ID of this bot\n        command: A dictionary representing a command to be created\n        guild_id: The ID of the guild this command is for, if this is a guild command\n\n    Returns:\n        An application command object\n    \"\"\"\n    if guild_id == GLOBAL_SCOPE:\n        result = await self.request(Route(\"POST\", f\"/applications/{app_id}/commands\"), payload=command)\n    else:\n        result = await self.request(\n            Route(\"POST\", f\"/applications/{app_id}/guilds/{int(guild_id)}/commands\"), payload=command\n        )\n    return cast(discord_typings.ApplicationCommandData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.interactions.InteractionRequests.post_initial_response","title":"<code>post_initial_response(payload, interaction_id, token, files=None)</code>  <code>async</code>","text":"<p>Post an initial response to an interaction.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>the payload to send</p> required <code>interaction_id</code> <code>str</code> <p>the id of the interaction</p> required <code>token</code> <code>str</code> <p>the token of the interaction</p> required <code>files</code> <code>list[UPLOADABLE_TYPE] | None</code> <p>The files to send in this message</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\interactions.py</code> <pre><code>async def post_initial_response(\n    self, payload: dict, interaction_id: str, token: str, files: list[\"UPLOADABLE_TYPE\"] | None = None\n) -&gt; None:\n\"\"\"\n    Post an initial response to an interaction.\n\n    Args:\n        payload: the payload to send\n        interaction_id: the id of the interaction\n        token: the token of the interaction\n        files: The files to send in this message\n\n    \"\"\"\n    return await self.request(\n        Route(\"POST\", f\"/interactions/{interaction_id}/{token}/callback\"), payload=payload, files=files\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.interactions.InteractionRequests.post_followup","title":"<code>post_followup(payload, application_id, token, files=None)</code>  <code>async</code>","text":"<p>Send a followup to an interaction.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>the payload to send</p> required <code>application_id</code> <code>Snowflake_Type</code> <p>the id of the application</p> required <code>token</code> <code>str</code> <p>the token of the interaction</p> required <code>files</code> <code>list[UPLOADABLE_TYPE] | None</code> <p>The files to send with this interaction</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\interactions.py</code> <pre><code>async def post_followup(\n    self, payload: dict, application_id: \"Snowflake_Type\", token: str, files: list[\"UPLOADABLE_TYPE\"] | None = None\n) -&gt; None:\n\"\"\"\n    Send a followup to an interaction.\n\n    Args:\n        payload: the payload to send\n        application_id: the id of the application\n        token: the token of the interaction\n        files: The files to send with this interaction\n\n    \"\"\"\n    return await self.request(\n        Route(\"POST\", f\"/webhooks/{int(application_id)}/{token}\"), payload=payload, files=files\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.interactions.InteractionRequests.edit_interaction_message","title":"<code>edit_interaction_message(payload, application_id, token, message_id='@original', files=None)</code>  <code>async</code>","text":"<p>Edits an existing interaction message.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>The payload to send.</p> required <code>application_id</code> <code>Snowflake_Type</code> <p>The id of the application.</p> required <code>token</code> <code>str</code> <p>The token of the interaction.</p> required <code>message_id</code> <code>str|Snowflake_Type</code> <p>The target message to edit. Defaults to @original which represents the initial response message.</p> <code>'@original'</code> <code>files</code> <code>list[UPLOADABLE_TYPE] | None</code> <p>The files to send with this interaction</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.MessageData</code> <p>The edited message data.</p> Source code in <code>naff\\api\\http\\http_requests\\interactions.py</code> <pre><code>async def edit_interaction_message(\n    self,\n    payload: dict,\n    application_id: \"Snowflake_Type\",\n    token: str,\n    message_id: \"str|Snowflake_Type\" = \"@original\",\n    files: list[\"UPLOADABLE_TYPE\"] | None = None,\n) -&gt; discord_typings.MessageData:\n\"\"\"\n    Edits an existing interaction message.\n\n    Args:\n        payload: The payload to send.\n        application_id: The id of the application.\n        token: The token of the interaction.\n        message_id: The target message to edit. Defaults to @original which represents the initial response message.\n        files: The files to send with this interaction\n\n    Returns:\n        The edited message data.\n\n    \"\"\"\n    result = await self.request(\n        Route(\"PATCH\", f\"/webhooks/{int(application_id)}/{token}/messages/{message_id}\"),\n        payload=payload,\n        files=files,\n    )\n    return cast(discord_typings.MessageData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.interactions.InteractionRequests.delete_interaction_message","title":"<code>delete_interaction_message(application_id, token, message_id='@original')</code>  <code>async</code>","text":"<p>Deletes an existing interaction message.</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>Snowflake_Type</code> <p>The id of the application.</p> required <code>token</code> <code>str</code> <p>The token of the interaction.</p> required <code>message_id</code> <code>str | Snowflake_Type</code> <p>The target message to delete. Defaults to @original which represents the initial response message.</p> <code>'@original'</code> Source code in <code>naff\\api\\http\\http_requests\\interactions.py</code> <pre><code>async def delete_interaction_message(\n    self, application_id: \"Snowflake_Type\", token: str, message_id: \"str | Snowflake_Type\" = \"@original\"\n) -&gt; None:\n\"\"\"\n    Deletes an existing interaction message.\n\n    Args:\n        application_id: The id of the application.\n        token: The token of the interaction.\n        message_id: The target message to delete. Defaults to @original which represents the initial response message.\n\n    \"\"\"\n    return await self.request(Route(\"DELETE\", f\"/webhooks/{int(application_id)}/{token}/messages/{message_id}\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.interactions.InteractionRequests.get_interaction_message","title":"<code>get_interaction_message(application_id, token, message_id='@original')</code>  <code>async</code>","text":"<p>Gets an existing interaction message.</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>Snowflake_Type</code> <p>The id of the application.</p> required <code>token</code> <code>str</code> <p>The token of the interaction.</p> required <code>message_id</code> <code>str</code> <p>The target message to get. Defaults to @original which represents the initial response message.</p> <code>'@original'</code> <p>Returns:</p> Type Description <code>discord_typings.MessageData</code> <p>The message data.</p> Source code in <code>naff\\api\\http\\http_requests\\interactions.py</code> <pre><code>async def get_interaction_message(\n    self, application_id: \"Snowflake_Type\", token: str, message_id: str = \"@original\"\n) -&gt; discord_typings.MessageData:\n\"\"\"\n    Gets an existing interaction message.\n\n    Args:\n        application_id: The id of the application.\n        token: The token of the interaction.\n        message_id: The target message to get. Defaults to @original which represents the initial response message.\n\n    Returns:\n        The message data.\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/webhooks/{int(application_id)}/{token}/messages/{message_id}\"))\n    return cast(discord_typings.MessageData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.interactions.InteractionRequests.edit_application_command_permissions","title":"<code>edit_application_command_permissions(application_id, scope, command_id, permissions)</code>  <code>async</code>","text":"<p>Edits command permissions for a specific command.</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>Snowflake_Type</code> <p>the id of the application</p> required <code>scope</code> <code>Snowflake_Type</code> <p>The scope this command is in</p> required <code>command_id</code> <code>Snowflake_Type</code> <p>The command id to edit</p> required <code>permissions</code> <code>list[dict]</code> <p>The permissions to set to this command</p> required <p>Returns:</p> Type Description <code>discord_typings.ApplicationCommandPermissionsData</code> <p>Guild Application Command Permissions</p> Source code in <code>naff\\api\\http\\http_requests\\interactions.py</code> <pre><code>async def edit_application_command_permissions(\n    self,\n    application_id: \"Snowflake_Type\",\n    scope: \"Snowflake_Type\",\n    command_id: \"Snowflake_Type\",\n    permissions: list[dict],  # todo better typing\n) -&gt; discord_typings.ApplicationCommandPermissionsData:\n\"\"\"\n    Edits command permissions for a specific command.\n\n    Args:\n        application_id: the id of the application\n        scope: The scope this command is in\n        command_id: The command id to edit\n        permissions: The permissions to set to this command\n\n    Returns:\n        Guild Application Command Permissions\n\n    \"\"\"\n    result = await self.request(\n        Route(\n            \"PUT\", f\"/applications/{int(application_id)}/guilds/{int(scope)}/commands/{int(command_id)}/permissions\"\n        ),\n        payload=permissions,\n    )\n    return cast(discord_typings.ApplicationCommandPermissionsData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.interactions.InteractionRequests.get_application_command_permissions","title":"<code>get_application_command_permissions(application_id, scope, command_id)</code>  <code>async</code>","text":"<p>Get permission data for a command.</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>Snowflake_Type</code> <p>the id of the application</p> required <code>scope</code> <code>Snowflake_Type</code> <p>The scope this command is in</p> required <code>command_id</code> <code>Snowflake_Type</code> <p>The command id to edit</p> required <p>Returns:</p> Type Description <code>list[discord_typings.ApplicationCommandPermissionsData]</code> <p>guild application command permissions</p> Source code in <code>naff\\api\\http\\http_requests\\interactions.py</code> <pre><code>async def get_application_command_permissions(\n    self, application_id: \"Snowflake_Type\", scope: \"Snowflake_Type\", command_id: \"Snowflake_Type\"\n) -&gt; list[discord_typings.ApplicationCommandPermissionsData]:\n\"\"\"\n    Get permission data for a command.\n\n    Args:\n        application_id: the id of the application\n        scope: The scope this command is in\n        command_id: The command id to edit\n\n    Returns:\n        guild application command permissions\n\n    \"\"\"\n    result = await self.request(\n        Route(\n            \"GET\", f\"/applications/{int(application_id)}/guilds/{int(scope)}/commands/{int(command_id)}/permissions\"\n        )\n    )\n    return cast(list[discord_typings.ApplicationCommandPermissionsData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.interactions.InteractionRequests.batch_get_application_command_permissions","title":"<code>batch_get_application_command_permissions(application_id, scope)</code>  <code>async</code>","text":"<p>Get permission data for all commands in a scope.</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>Snowflake_Type</code> <p>the id of the application</p> required <code>scope</code> <code>Snowflake_Type</code> <p>The scope this command is in</p> required <p>Returns:</p> Type Description <code>list[discord_typings.ApplicationCommandPermissionsData]</code> <p>list of guild application command permissions</p> Source code in <code>naff\\api\\http\\http_requests\\interactions.py</code> <pre><code>async def batch_get_application_command_permissions(\n    self, application_id: \"Snowflake_Type\", scope: \"Snowflake_Type\"\n) -&gt; list[discord_typings.ApplicationCommandPermissionsData]:\n\"\"\"\n    Get permission data for all commands in a scope.\n\n    Args:\n        application_id: the id of the application\n        scope: The scope this command is in\n\n    Returns:\n        list of guild application command permissions\n\n    \"\"\"\n    result = await self.request(\n        Route(\"GET\", f\"/applications/{int(application_id)}/guilds/{int(scope)}/commands/permissions\")\n    )\n    return cast(list[discord_typings.ApplicationCommandPermissionsData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.ChannelRequests","title":"<code>ChannelRequests</code>","text":"<p>         Bases: <code>CanRequest</code></p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>class ChannelRequests(CanRequest):\n    async def get_channel(self, channel_id: \"Snowflake_Type\") -&gt; discord_typings.ChannelData:\n\"\"\"\n        Get a channel by ID. Returns a channel object. If the channel is a thread, a thread member object is included.\n\n        Args:\n            channel_id: The id of the channel\n\n        Returns:\n            channel\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/channels/{int(channel_id)}\"))\n        return cast(discord_typings.ChannelData, result)\n\n    @overload\n    async def get_channel_messages(\n        self,\n        channel_id: \"Snowflake_Type\",\n        limit: int = 50,\n    ) -&gt; list[discord_typings.MessageData]:\n        ...\n\n    @overload\n    async def get_channel_messages(\n        self,\n        channel_id: \"Snowflake_Type\",\n        limit: int = 50,\n        *,\n        around: \"Snowflake_Type | None\" = None,\n    ) -&gt; list[discord_typings.MessageData]:\n        ...\n\n    @overload\n    async def get_channel_messages(\n        self,\n        channel_id: \"Snowflake_Type\",\n        limit: int = 50,\n        *,\n        before: \"Snowflake_Type | None\" = None,\n    ) -&gt; list[discord_typings.MessageData]:\n        ...\n\n    @overload\n    async def get_channel_messages(\n        self,\n        channel_id: \"Snowflake_Type\",\n        limit: int = 50,\n        *,\n        after: \"Snowflake_Type | None\" = None,\n    ) -&gt; list[discord_typings.MessageData]:\n        ...\n\n    async def get_channel_messages(\n        self,\n        channel_id: \"Snowflake_Type\",\n        limit: int = 50,\n        *,\n        around: \"Snowflake_Type | None\" = None,\n        before: \"Snowflake_Type | None\" = None,\n        after: \"Snowflake_Type | None\" = None,\n    ) -&gt; list[discord_typings.MessageData]:\n\"\"\"\n        Get the messages for a channel.\n\n        Args:\n            channel_id: The channel to get messages from\n            limit: How many messages to get (default 50, max 100)\n            around: Get messages around this snowflake\n            before: Get messages before this snowflake\n            after: Get messages after this snowflake\n\n        Returns:\n            List of message dicts\n\n        \"\"\"\n        params_count = sum(bool(param) for param in (before, after, around))\n        if params_count &gt; 1:\n            raise ValueError(\"`before` `after` and `around` are mutually exclusive, only one may be passed at a time.\")\n\n        params: PAYLOAD_TYPE = {\n            \"limit\": limit,\n            \"before\": int(before) if before else None,\n            \"after\": int(after) if after else None,\n            \"around\": int(around) if around else None,\n        }\n        params = dict_filter_none(params)\n\n        result = await self.request(Route(\"GET\", f\"/channels/{int(channel_id)}/messages\"), params=params)\n        return cast(list[discord_typings.MessageData], result)\n\n    async def create_guild_channel(\n        self,\n        guild_id: \"Snowflake_Type\",\n        name: str,\n        channel_type: \"ChannelTypes | int\",\n        topic: str | None = None,\n        position: int | None = None,\n        permission_overwrites: Sequence[\"PermissionOverwrite | dict\"] | None = None,\n        parent_id: \"Snowflake_Type | None\" = None,\n        nsfw: bool = False,\n        bitrate: int = 64000,\n        user_limit: int = 0,\n        rate_limit_per_user: int = 0,\n        reason: str | None = None,\n    ) -&gt; discord_typings.ChannelData:\n\"\"\"\n        Create a channel in a guild.\n\n        Args:\n            guild_id: The ID of the guild to create the channel in\n            name: The name of the channel\n            channel_type: The type of channel to create\n            topic: The topic of the channel\n            position: The position of the channel in the channel list\n            permission_overwrites: Permission overwrites to apply to the channel\n            parent_id: The category this channel should be within\n            nsfw: Should this channel be marked nsfw\n            bitrate: The bitrate of this channel, only for voice\n            user_limit: The max users that can be in this channel, only for voice\n            rate_limit_per_user: The time users must wait between sending messages\n            reason: The reason for creating this channel\n\n        Returns:\n            The created channel object\n\n        \"\"\"\n        payload: PAYLOAD_TYPE = {\n            \"name\": name,\n            \"type\": channel_type,\n            \"topic\": topic,\n            \"position\": position,\n            \"rate_limit_per_user\": rate_limit_per_user,\n            \"nsfw\": nsfw,\n            \"parent_id\": int(parent_id) if parent_id else None,\n            \"permission_overwrites\": list(permission_overwrites) if permission_overwrites else None,\n        }\n        if channel_type in (ChannelTypes.GUILD_VOICE, ChannelTypes.GUILD_STAGE_VOICE):\n            payload.update(\n                bitrate=bitrate,\n                user_limit=user_limit,\n            )\n        payload = dict_filter_none(payload)\n\n        result = await self.request(Route(\"POST\", f\"/guilds/{int(guild_id)}/channels\"), payload=payload, reason=reason)\n        return cast(discord_typings.ChannelData, result)\n\n    async def move_channel(\n        self,\n        guild_id: \"Snowflake_Type\",\n        channel_id: \"Snowflake_Type\",\n        new_pos: int,\n        parent_id: \"Snowflake_Type | None\" = None,\n        lock_perms: bool = False,\n        reason: str | None = None,\n    ) -&gt; None:\n\"\"\"\n        Move a channel.\n\n        Args:\n            guild_id: The ID of the guild this affects\n            channel_id: The ID of the channel to move\n            new_pos: The new position of this channel\n            parent_id: The parent ID if needed\n            lock_perms: Sync permissions with the new parent\n            reason: An optional reason for the audit log\n\n        \"\"\"\n        payload: PAYLOAD_TYPE = {\n            \"id\": int(channel_id),\n            \"position\": new_pos,\n            \"parent_id\": int(parent_id) if parent_id else None,\n            \"lock_permissions\": lock_perms,\n        }\n        payload = dict_filter_none(payload)\n\n        await self.request(Route(\"PATCH\", f\"/guilds/{int(guild_id)}/channels\"), payload=payload, reason=reason)\n\n    async def modify_channel(\n        self, channel_id: \"Snowflake_Type\", data: dict, reason: str | None = None\n    ) -&gt; discord_typings.ChannelData:\n\"\"\"\n        Update a channel's settings, returns the updated channel object on success.\n\n        Args:\n            channel_id: The ID of the channel to update\n            data: The data to update with\n            reason: An optional reason for the audit log\n\n        Returns:\n            Channel object on success\n\n        \"\"\"\n        result = await self.request(Route(\"PATCH\", f\"/channels/{int(channel_id)}\"), payload=data, reason=reason)\n        return cast(discord_typings.ChannelData, result)\n\n    async def delete_channel(self, channel_id: \"Snowflake_Type\", reason: str | None = None) -&gt; None:\n\"\"\"\n        Delete the channel.\n\n        Args:\n            channel_id: The ID of the channel to delete\n            reason: An optional reason for the audit log\n\n        \"\"\"\n        await self.request(Route(\"DELETE\", f\"/channels/{int(channel_id)}\"), reason=reason)\n\n    async def get_channel_invites(self, channel_id: \"Snowflake_Type\") -&gt; list[discord_typings.InviteData]:\n\"\"\"\n        Get the invites for the channel.\n\n        Args:\n            channel_id: The ID of the channel to retrieve from\n\n        Returns:\n            List of invite objects\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/channels/{int(channel_id)}/invites\"))\n        return cast(list[discord_typings.InviteData], result)\n\n    @overload\n    async def create_channel_invite(\n        self,\n        channel_id: \"Snowflake_Type\",\n        max_age: int = 86400,\n        max_uses: int = 0,\n        temporary: bool = False,\n        unique: bool = False,\n        *,\n        reason: str | None = None,\n    ) -&gt; discord_typings.InviteData:\n        ...\n\n    @overload\n    async def create_channel_invite(\n        self,\n        channel_id: \"Snowflake_Type\",\n        max_age: int = 86400,\n        max_uses: int = 0,\n        temporary: bool = False,\n        unique: bool = False,\n        *,\n        target_user_id: \"Snowflake_Type | None\" = None,\n        reason: str | None = None,\n    ) -&gt; discord_typings.InviteData:\n        ...\n\n    @overload\n    async def create_channel_invite(\n        self,\n        channel_id: \"Snowflake_Type\",\n        max_age: int = 86400,\n        max_uses: int = 0,\n        temporary: bool = False,\n        unique: bool = False,\n        *,\n        target_application_id: \"Snowflake_Type | None\" = None,\n        reason: str | None = None,\n    ) -&gt; discord_typings.InviteData:\n        ...\n\n    async def create_channel_invite(\n        self,\n        channel_id: \"Snowflake_Type\",\n        max_age: int = 86400,\n        max_uses: int = 0,\n        temporary: bool = False,\n        unique: bool = False,\n        *,\n        target_user_id: \"Snowflake_Type | None\" = None,\n        target_application_id: \"Snowflake_Type | None\" = None,\n        reason: str | None = None,\n    ) -&gt; discord_typings.InviteData:\n\"\"\"\n        Create an invite for the given channel.\n\n        Args:\n            channel_id: The ID of the channel to create an invite for\n            max_age: duration of invite in seconds before expiry, or 0 for never. between 0 and 604800 (7 days) (default 24 hours)\n            max_uses: max number of uses or 0 for unlimited. between 0 and 100\n            temporary: whether this invite only grants temporary membership\n            unique: if true, don't try to reuse a similar invite (useful for creating many unique one time use invites)\n            target_user_id: the id of the user whose stream to display for this invite, the user must be streaming in the channel\n            target_application_id: the id of the embedded application to open for this invite, the application must have the EMBEDDED flag\n            reason: An optional reason for the audit log\n\n        Returns:\n            an invite object\n\n        \"\"\"\n        params_count = sum(bool(param) for param in (target_user_id, target_application_id))\n        if params_count &gt; 1:\n            raise ValueError(\n                \"`target_type` and `target_user_id` are mutually exclusive, only one may be passed at a time.\"\n            )\n\n        payload: PAYLOAD_TYPE = {\n            \"max_age\": max_age,\n            \"max_uses\": max_uses,\n            \"temporary\": temporary,\n            \"unique\": unique,\n        }\n        if target_user_id:\n            payload[\"target_type\"] = 1\n            payload[\"target_user_id\"] = int(target_user_id)\n        if target_application_id:\n            payload[\"target_type\"] = 2\n            payload[\"target_application_id\"] = int(target_application_id)\n        payload = dict_filter_none(payload)\n\n        result = await self.request(\n            Route(\"POST\", f\"/channels/{int(channel_id)}/invites\"), payload=payload, reason=reason\n        )\n        return cast(discord_typings.InviteData, result)\n\n    async def get_invite(\n        self,\n        invite_code: str,\n        with_counts: bool = False,\n        with_expiration: bool = True,\n        scheduled_event_id: \"Snowflake_Type | None\" = None,\n    ) -&gt; discord_typings.InviteData:\n\"\"\"\n        Get an invite object for a given code.\n\n        Args:\n            invite_code: The code of the invite\n            with_counts: whether the invite should contain approximate member counts\n            with_expiration: whether the invite should contain the expiration date\n            scheduled_event_id: the guild scheduled event to include with the invite\n\n        Returns:\n            an invite object\n\n        \"\"\"\n        params: PAYLOAD_TYPE = {\n            \"with_counts\": with_counts,\n            \"with_expiration\": with_expiration,\n            \"guild_scheduled_event_id\": int(scheduled_event_id) if scheduled_event_id else None,\n        }\n        params = dict_filter_none(params)\n\n        result = await self.request(Route(\"GET\", f\"/invites/{invite_code}\", params=params))\n        return cast(discord_typings.InviteData, result)\n\n    async def delete_invite(self, invite_code: str, reason: str | None = None) -&gt; discord_typings.InviteData:\n\"\"\"\n        Delete an invite.\n\n        Args:\n            invite_code: The code of the invite to delete\n            reason: The reason to delete the invite\n\n        Returns:\n            The deleted invite object\n\n        \"\"\"\n        result = await self.request(Route(\"DELETE\", f\"/invites/{invite_code}\"), reason=reason)\n        return cast(discord_typings.InviteData, result)\n\n    async def edit_channel_permission(\n        self,\n        channel_id: \"Snowflake_Type\",\n        overwrite_id: \"Snowflake_Type\",\n        perm_type: \"OverwriteTypes | int\",\n        allow: \"Permissions | int\" = 0,\n        deny: \"Permissions | int\" = 0,\n        reason: str | None = None,\n    ) -&gt; None:\n\"\"\"\n        Edit the channel permission overwrites for a user or role in a channel.\n\n        Args:\n            channel_id: The id of the channel\n            overwrite_id: The id of the object to override\n            allow: the bitwise value of all allowed permissions\n            deny: the bitwise value of all disallowed permissions\n            perm_type: 0 for a role or 1 for a member\n            reason: The reason for this action\n\n        \"\"\"\n        payload: PAYLOAD_TYPE = {\"allow\": allow, \"deny\": deny, \"type\": perm_type}\n\n        await self.request(\n            Route(\"PUT\", f\"/channels/{int(channel_id)}/permissions/{int(overwrite_id)}\"),\n            payload=payload,\n            reason=reason,\n        )\n\n    async def delete_channel_permission(\n        self, channel_id: \"Snowflake_Type\", overwrite_id: \"Snowflake_Type\", reason: str | None = None\n    ) -&gt; None:\n\"\"\"\n        Delete a channel permission overwrite for a user or role in a channel.\n\n        Args:\n            channel_id: The ID of the channel.\n            overwrite_id: The ID of the overwrite\n            reason: An optional reason for the audit log\n\n        \"\"\"\n        await self.request(Route(\"DELETE\", f\"/channels/{int(channel_id)}/{int(overwrite_id)}\"), reason=reason)\n\n    async def follow_news_channel(\n        self, channel_id: \"Snowflake_Type\", webhook_channel_id: \"Snowflake_Type\"\n    ) -&gt; discord_typings.FollowedChannelData:\n\"\"\"\n        Follow a news channel to send messages to the target channel.\n\n        Args:\n            channel_id: The channel to follow\n            webhook_channel_id: ID of the target channel\n\n        Returns:\n            Followed channel object\n\n        \"\"\"\n        payload = {\"webhook_channel_id\": int(webhook_channel_id)}\n\n        result = await self.request(Route(\"POST\", f\"/channels/{int(channel_id)}/followers\"), payload=payload)\n        return cast(discord_typings.FollowedChannelData, result)\n\n    async def trigger_typing_indicator(self, channel_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n        Post a typing indicator for the specified channel. Generally bots should not implement this route.\n\n        Args:\n            channel_id: The id of the channel to \"type\" in\n\n        \"\"\"\n        await self.request(Route(\"POST\", f\"/channels/{int(channel_id)}/typing\"))\n\n    async def get_pinned_messages(self, channel_id: \"Snowflake_Type\") -&gt; list[discord_typings.MessageData]:\n\"\"\"\n        Get all pinned messages from a channel.\n\n        Args:\n            channel_id: The ID of the channel to get pins from\n\n        Returns:\n            A list of pinned message objects\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/channels/{int(channel_id)}/pins\"))\n        return cast(list[discord_typings.MessageData], result)\n\n    async def create_stage_instance(\n        self,\n        channel_id: \"Snowflake_Type\",\n        topic: str,\n        privacy_level: StagePrivacyLevel | int = StagePrivacyLevel.PUBLIC,\n        reason: str | None = None,\n    ) -&gt; discord_typings.StageInstanceData:\n\"\"\"\n        Create a new stage instance.\n\n        Args:\n            channel_id: The ID of the stage channel\n            topic: The topic of the stage instance (1-120 characters)\n            privacy_level: Them privacy_level of the stage instance (default guild only)\n            reason: The reason for the creating the stage instance\n\n        Returns:\n            The stage instance\n\n        \"\"\"\n        payload: PAYLOAD_TYPE = {\n            \"channel_id\": int(channel_id),\n            \"topic\": topic,\n            \"privacy_level\": StagePrivacyLevel(privacy_level),\n        }\n\n        result = await self.request(Route(\"POST\", \"/stage-instances\"), payload=payload, reason=reason)\n        return cast(discord_typings.StageInstanceData, result)\n\n    async def get_stage_instance(self, channel_id: \"Snowflake_Type\") -&gt; discord_typings.StageInstanceData:\n\"\"\"\n        Get the stage instance associated with a given channel, if it exists.\n\n        Args:\n            channel_id: The ID of the channel to retrieve the instance for.\n\n        Returns:\n            A stage instance.\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/stage-instances/{int(channel_id)}\"))\n        return cast(discord_typings.StageInstanceData, result)\n\n    async def modify_stage_instance(\n        self,\n        channel_id: \"Snowflake_Type\",\n        topic: str | None = None,\n        privacy_level: int | None = None,\n        reason: str | None = None,\n    ) -&gt; discord_typings.StageInstanceData:\n\"\"\"\n        Update the fields of a given stage instance.\n\n        Args:\n            channel_id: The id of the stage channel.\n            topic: The new topic for the stage instance\n            privacy_level: The privacy level for the stage instance\n            reason: The reason for the change\n\n        Returns:\n            The updated stage instance.\n\n        \"\"\"\n        payload: PAYLOAD_TYPE = {\"topic\": topic, \"privacy_level\": privacy_level}\n        payload = dict_filter_none(payload)\n        result = await self.request(\n            Route(\"PATCH\", f\"/stage-instances/{int(channel_id)}\"), payload=payload, reason=reason\n        )\n        return cast(discord_typings.StageInstanceData, result)\n\n    async def delete_stage_instance(self, channel_id: \"Snowflake_Type\", reason: str | None = None) -&gt; None:\n\"\"\"\n        Delete a stage instance.\n\n        Args:\n            channel_id: The ID of the channel to delete the stage instance for.\n            reason: The reason for the deletion\n\n        \"\"\"\n        await self.request(Route(\"DELETE\", f\"/stage-instances/{int(channel_id)}\"), reason=reason)\n\n    async def create_tag(\n        self,\n        channel_id: \"Snowflake_Type\",\n        name: str,\n        emoji_id: Optional[\"Snowflake_Type\"] = None,\n        emoji_name: Optional[str] = None,\n    ) -&gt; discord_typings.ChannelData:\n\"\"\"\n        Create a new tag.\n\n        Args:\n            channel_id: The ID of the forum channel to create tag for.\n            name: The name of the tag\n            emoji_id: The ID of the emoji to use for the tag\n            emoji_name: The name of the emoji to use for the tag\n\n        !!! note\n            Can either have an `emoji_id` or an `emoji_name`, but not both.\n            `emoji_id` is meant for custom emojis, `emoji_name` is meant for unicode emojis.\n        \"\"\"\n        payload: PAYLOAD_TYPE = {\n            \"name\": name,\n            \"emoji_id\": int(emoji_id) if emoji_id else None,\n            \"emoji_name\": emoji_name if emoji_name else None,\n        }\n        payload = dict_filter_none(payload)\n\n        result = await self.request(Route(\"POST\", f\"/channels/{int(channel_id)}/tags\"), payload=payload)\n        return cast(discord_typings.ChannelData, result)\n\n    async def edit_tag(\n        self,\n        channel_id: \"Snowflake_Type\",\n        tag_id: \"Snowflake_Type\",\n        name: str,\n        emoji_id: \"Snowflake_Type | None\" = None,\n        emoji_name: str | None = None,\n    ) -&gt; discord_typings.ChannelData:\n\"\"\"\n        Update a tag.\n\n        Args:\n            channel_id: The ID of the forum channel to edit tag it.\n            tag_id: The ID of the tag to update\n            name: The new name of the tag\n            emoji_id: The ID of the emoji to use for the tag\n            emoji_name: The name of the emoji to use for the tag\n\n        !!! note\n            Can either have an `emoji_id` or an `emoji_name`, but not both.\n            emoji`_id is meant for custom emojis, `emoji_name` is meant for unicode emojis.\n        \"\"\"\n        payload: PAYLOAD_TYPE = {\n            \"name\": name,\n            \"emoji_id\": int(emoji_id) if emoji_id else None,\n            \"emoji_name\": emoji_name,\n        }\n        payload = dict_filter_none(payload)\n\n        result = await self.request(Route(\"PUT\", f\"/channels/{int(channel_id)}/tags/{int(tag_id)}\"), payload=payload)\n        return cast(discord_typings.ChannelData, result)\n\n    async def delete_tag(self, channel_id: \"Snowflake_Type\", tag_id: \"Snowflake_Type\") -&gt; discord_typings.ChannelData:\n\"\"\"\n        Delete a forum tag.\n\n        Args:\n            channel_id: The ID of the forum channel to delete tag it.\n            tag_id: The ID of the tag to delete\n        \"\"\"\n        result = await self.request(Route(\"DELETE\", f\"/channels/{int(channel_id)}/tags/{int(tag_id)}\"))\n        return cast(discord_typings.ChannelData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.get_channel","title":"<code>get_channel(channel_id)</code>  <code>async</code>","text":"<p>Get a channel by ID. Returns a channel object. If the channel is a thread, a thread member object is included.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The id of the channel</p> required <p>Returns:</p> Type Description <code>discord_typings.ChannelData</code> <p>channel</p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def get_channel(self, channel_id: \"Snowflake_Type\") -&gt; discord_typings.ChannelData:\n\"\"\"\n    Get a channel by ID. Returns a channel object. If the channel is a thread, a thread member object is included.\n\n    Args:\n        channel_id: The id of the channel\n\n    Returns:\n        channel\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/channels/{int(channel_id)}\"))\n    return cast(discord_typings.ChannelData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.get_channel_messages","title":"<code>get_channel_messages(channel_id, limit=50, *, around=None, before=None, after=None)</code>  <code>async</code>","text":"<p>Get the messages for a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The channel to get messages from</p> required <code>limit</code> <code>int</code> <p>How many messages to get (default 50, max 100)</p> <code>50</code> <code>around</code> <code>Snowflake_Type | None</code> <p>Get messages around this snowflake</p> <code>None</code> <code>before</code> <code>Snowflake_Type | None</code> <p>Get messages before this snowflake</p> <code>None</code> <code>after</code> <code>Snowflake_Type | None</code> <p>Get messages after this snowflake</p> <code>None</code> <p>Returns:</p> Type Description <code>list[discord_typings.MessageData]</code> <p>List of message dicts</p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def get_channel_messages(\n    self,\n    channel_id: \"Snowflake_Type\",\n    limit: int = 50,\n    *,\n    around: \"Snowflake_Type | None\" = None,\n    before: \"Snowflake_Type | None\" = None,\n    after: \"Snowflake_Type | None\" = None,\n) -&gt; list[discord_typings.MessageData]:\n\"\"\"\n    Get the messages for a channel.\n\n    Args:\n        channel_id: The channel to get messages from\n        limit: How many messages to get (default 50, max 100)\n        around: Get messages around this snowflake\n        before: Get messages before this snowflake\n        after: Get messages after this snowflake\n\n    Returns:\n        List of message dicts\n\n    \"\"\"\n    params_count = sum(bool(param) for param in (before, after, around))\n    if params_count &gt; 1:\n        raise ValueError(\"`before` `after` and `around` are mutually exclusive, only one may be passed at a time.\")\n\n    params: PAYLOAD_TYPE = {\n        \"limit\": limit,\n        \"before\": int(before) if before else None,\n        \"after\": int(after) if after else None,\n        \"around\": int(around) if around else None,\n    }\n    params = dict_filter_none(params)\n\n    result = await self.request(Route(\"GET\", f\"/channels/{int(channel_id)}/messages\"), params=params)\n    return cast(list[discord_typings.MessageData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.create_guild_channel","title":"<code>create_guild_channel(guild_id, name, channel_type, topic=None, position=None, permission_overwrites=None, parent_id=None, nsfw=False, bitrate=64000, user_limit=0, rate_limit_per_user=0, reason=None)</code>  <code>async</code>","text":"<p>Create a channel in a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to create the channel in</p> required <code>name</code> <code>str</code> <p>The name of the channel</p> required <code>channel_type</code> <code>ChannelTypes | int</code> <p>The type of channel to create</p> required <code>topic</code> <code>str | None</code> <p>The topic of the channel</p> <code>None</code> <code>position</code> <code>int | None</code> <p>The position of the channel in the channel list</p> <code>None</code> <code>permission_overwrites</code> <code>Sequence[PermissionOverwrite | dict] | None</code> <p>Permission overwrites to apply to the channel</p> <code>None</code> <code>parent_id</code> <code>Snowflake_Type | None</code> <p>The category this channel should be within</p> <code>None</code> <code>nsfw</code> <code>bool</code> <p>Should this channel be marked nsfw</p> <code>False</code> <code>bitrate</code> <code>int</code> <p>The bitrate of this channel, only for voice</p> <code>64000</code> <code>user_limit</code> <code>int</code> <p>The max users that can be in this channel, only for voice</p> <code>0</code> <code>rate_limit_per_user</code> <code>int</code> <p>The time users must wait between sending messages</p> <code>0</code> <code>reason</code> <code>str | None</code> <p>The reason for creating this channel</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.ChannelData</code> <p>The created channel object</p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def create_guild_channel(\n    self,\n    guild_id: \"Snowflake_Type\",\n    name: str,\n    channel_type: \"ChannelTypes | int\",\n    topic: str | None = None,\n    position: int | None = None,\n    permission_overwrites: Sequence[\"PermissionOverwrite | dict\"] | None = None,\n    parent_id: \"Snowflake_Type | None\" = None,\n    nsfw: bool = False,\n    bitrate: int = 64000,\n    user_limit: int = 0,\n    rate_limit_per_user: int = 0,\n    reason: str | None = None,\n) -&gt; discord_typings.ChannelData:\n\"\"\"\n    Create a channel in a guild.\n\n    Args:\n        guild_id: The ID of the guild to create the channel in\n        name: The name of the channel\n        channel_type: The type of channel to create\n        topic: The topic of the channel\n        position: The position of the channel in the channel list\n        permission_overwrites: Permission overwrites to apply to the channel\n        parent_id: The category this channel should be within\n        nsfw: Should this channel be marked nsfw\n        bitrate: The bitrate of this channel, only for voice\n        user_limit: The max users that can be in this channel, only for voice\n        rate_limit_per_user: The time users must wait between sending messages\n        reason: The reason for creating this channel\n\n    Returns:\n        The created channel object\n\n    \"\"\"\n    payload: PAYLOAD_TYPE = {\n        \"name\": name,\n        \"type\": channel_type,\n        \"topic\": topic,\n        \"position\": position,\n        \"rate_limit_per_user\": rate_limit_per_user,\n        \"nsfw\": nsfw,\n        \"parent_id\": int(parent_id) if parent_id else None,\n        \"permission_overwrites\": list(permission_overwrites) if permission_overwrites else None,\n    }\n    if channel_type in (ChannelTypes.GUILD_VOICE, ChannelTypes.GUILD_STAGE_VOICE):\n        payload.update(\n            bitrate=bitrate,\n            user_limit=user_limit,\n        )\n    payload = dict_filter_none(payload)\n\n    result = await self.request(Route(\"POST\", f\"/guilds/{int(guild_id)}/channels\"), payload=payload, reason=reason)\n    return cast(discord_typings.ChannelData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.move_channel","title":"<code>move_channel(guild_id, channel_id, new_pos, parent_id=None, lock_perms=False, reason=None)</code>  <code>async</code>","text":"<p>Move a channel.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild this affects</p> required <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel to move</p> required <code>new_pos</code> <code>int</code> <p>The new position of this channel</p> required <code>parent_id</code> <code>Snowflake_Type | None</code> <p>The parent ID if needed</p> <code>None</code> <code>lock_perms</code> <code>bool</code> <p>Sync permissions with the new parent</p> <code>False</code> <code>reason</code> <code>str | None</code> <p>An optional reason for the audit log</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def move_channel(\n    self,\n    guild_id: \"Snowflake_Type\",\n    channel_id: \"Snowflake_Type\",\n    new_pos: int,\n    parent_id: \"Snowflake_Type | None\" = None,\n    lock_perms: bool = False,\n    reason: str | None = None,\n) -&gt; None:\n\"\"\"\n    Move a channel.\n\n    Args:\n        guild_id: The ID of the guild this affects\n        channel_id: The ID of the channel to move\n        new_pos: The new position of this channel\n        parent_id: The parent ID if needed\n        lock_perms: Sync permissions with the new parent\n        reason: An optional reason for the audit log\n\n    \"\"\"\n    payload: PAYLOAD_TYPE = {\n        \"id\": int(channel_id),\n        \"position\": new_pos,\n        \"parent_id\": int(parent_id) if parent_id else None,\n        \"lock_permissions\": lock_perms,\n    }\n    payload = dict_filter_none(payload)\n\n    await self.request(Route(\"PATCH\", f\"/guilds/{int(guild_id)}/channels\"), payload=payload, reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.modify_channel","title":"<code>modify_channel(channel_id, data, reason=None)</code>  <code>async</code>","text":"<p>Update a channel's settings, returns the updated channel object on success.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel to update</p> required <code>data</code> <code>dict</code> <p>The data to update with</p> required <code>reason</code> <code>str | None</code> <p>An optional reason for the audit log</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.ChannelData</code> <p>Channel object on success</p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def modify_channel(\n    self, channel_id: \"Snowflake_Type\", data: dict, reason: str | None = None\n) -&gt; discord_typings.ChannelData:\n\"\"\"\n    Update a channel's settings, returns the updated channel object on success.\n\n    Args:\n        channel_id: The ID of the channel to update\n        data: The data to update with\n        reason: An optional reason for the audit log\n\n    Returns:\n        Channel object on success\n\n    \"\"\"\n    result = await self.request(Route(\"PATCH\", f\"/channels/{int(channel_id)}\"), payload=data, reason=reason)\n    return cast(discord_typings.ChannelData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.delete_channel","title":"<code>delete_channel(channel_id, reason=None)</code>  <code>async</code>","text":"<p>Delete the channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel to delete</p> required <code>reason</code> <code>str | None</code> <p>An optional reason for the audit log</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def delete_channel(self, channel_id: \"Snowflake_Type\", reason: str | None = None) -&gt; None:\n\"\"\"\n    Delete the channel.\n\n    Args:\n        channel_id: The ID of the channel to delete\n        reason: An optional reason for the audit log\n\n    \"\"\"\n    await self.request(Route(\"DELETE\", f\"/channels/{int(channel_id)}\"), reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.get_channel_invites","title":"<code>get_channel_invites(channel_id)</code>  <code>async</code>","text":"<p>Get the invites for the channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel to retrieve from</p> required <p>Returns:</p> Type Description <code>list[discord_typings.InviteData]</code> <p>List of invite objects</p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def get_channel_invites(self, channel_id: \"Snowflake_Type\") -&gt; list[discord_typings.InviteData]:\n\"\"\"\n    Get the invites for the channel.\n\n    Args:\n        channel_id: The ID of the channel to retrieve from\n\n    Returns:\n        List of invite objects\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/channels/{int(channel_id)}/invites\"))\n    return cast(list[discord_typings.InviteData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.create_channel_invite","title":"<code>create_channel_invite(channel_id, max_age=86400, max_uses=0, temporary=False, unique=False, *, target_user_id=None, target_application_id=None, reason=None)</code>  <code>async</code>","text":"<p>Create an invite for the given channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel to create an invite for</p> required <code>max_age</code> <code>int</code> <p>duration of invite in seconds before expiry, or 0 for never. between 0 and 604800 (7 days) (default 24 hours)</p> <code>86400</code> <code>max_uses</code> <code>int</code> <p>max number of uses or 0 for unlimited. between 0 and 100</p> <code>0</code> <code>temporary</code> <code>bool</code> <p>whether this invite only grants temporary membership</p> <code>False</code> <code>unique</code> <code>bool</code> <p>if true, don't try to reuse a similar invite (useful for creating many unique one time use invites)</p> <code>False</code> <code>target_user_id</code> <code>Snowflake_Type | None</code> <p>the id of the user whose stream to display for this invite, the user must be streaming in the channel</p> <code>None</code> <code>target_application_id</code> <code>Snowflake_Type | None</code> <p>the id of the embedded application to open for this invite, the application must have the EMBEDDED flag</p> <code>None</code> <code>reason</code> <code>str | None</code> <p>An optional reason for the audit log</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.InviteData</code> <p>an invite object</p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def create_channel_invite(\n    self,\n    channel_id: \"Snowflake_Type\",\n    max_age: int = 86400,\n    max_uses: int = 0,\n    temporary: bool = False,\n    unique: bool = False,\n    *,\n    target_user_id: \"Snowflake_Type | None\" = None,\n    target_application_id: \"Snowflake_Type | None\" = None,\n    reason: str | None = None,\n) -&gt; discord_typings.InviteData:\n\"\"\"\n    Create an invite for the given channel.\n\n    Args:\n        channel_id: The ID of the channel to create an invite for\n        max_age: duration of invite in seconds before expiry, or 0 for never. between 0 and 604800 (7 days) (default 24 hours)\n        max_uses: max number of uses or 0 for unlimited. between 0 and 100\n        temporary: whether this invite only grants temporary membership\n        unique: if true, don't try to reuse a similar invite (useful for creating many unique one time use invites)\n        target_user_id: the id of the user whose stream to display for this invite, the user must be streaming in the channel\n        target_application_id: the id of the embedded application to open for this invite, the application must have the EMBEDDED flag\n        reason: An optional reason for the audit log\n\n    Returns:\n        an invite object\n\n    \"\"\"\n    params_count = sum(bool(param) for param in (target_user_id, target_application_id))\n    if params_count &gt; 1:\n        raise ValueError(\n            \"`target_type` and `target_user_id` are mutually exclusive, only one may be passed at a time.\"\n        )\n\n    payload: PAYLOAD_TYPE = {\n        \"max_age\": max_age,\n        \"max_uses\": max_uses,\n        \"temporary\": temporary,\n        \"unique\": unique,\n    }\n    if target_user_id:\n        payload[\"target_type\"] = 1\n        payload[\"target_user_id\"] = int(target_user_id)\n    if target_application_id:\n        payload[\"target_type\"] = 2\n        payload[\"target_application_id\"] = int(target_application_id)\n    payload = dict_filter_none(payload)\n\n    result = await self.request(\n        Route(\"POST\", f\"/channels/{int(channel_id)}/invites\"), payload=payload, reason=reason\n    )\n    return cast(discord_typings.InviteData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.get_invite","title":"<code>get_invite(invite_code, with_counts=False, with_expiration=True, scheduled_event_id=None)</code>  <code>async</code>","text":"<p>Get an invite object for a given code.</p> <p>Parameters:</p> Name Type Description Default <code>invite_code</code> <code>str</code> <p>The code of the invite</p> required <code>with_counts</code> <code>bool</code> <p>whether the invite should contain approximate member counts</p> <code>False</code> <code>with_expiration</code> <code>bool</code> <p>whether the invite should contain the expiration date</p> <code>True</code> <code>scheduled_event_id</code> <code>Snowflake_Type | None</code> <p>the guild scheduled event to include with the invite</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.InviteData</code> <p>an invite object</p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def get_invite(\n    self,\n    invite_code: str,\n    with_counts: bool = False,\n    with_expiration: bool = True,\n    scheduled_event_id: \"Snowflake_Type | None\" = None,\n) -&gt; discord_typings.InviteData:\n\"\"\"\n    Get an invite object for a given code.\n\n    Args:\n        invite_code: The code of the invite\n        with_counts: whether the invite should contain approximate member counts\n        with_expiration: whether the invite should contain the expiration date\n        scheduled_event_id: the guild scheduled event to include with the invite\n\n    Returns:\n        an invite object\n\n    \"\"\"\n    params: PAYLOAD_TYPE = {\n        \"with_counts\": with_counts,\n        \"with_expiration\": with_expiration,\n        \"guild_scheduled_event_id\": int(scheduled_event_id) if scheduled_event_id else None,\n    }\n    params = dict_filter_none(params)\n\n    result = await self.request(Route(\"GET\", f\"/invites/{invite_code}\", params=params))\n    return cast(discord_typings.InviteData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.delete_invite","title":"<code>delete_invite(invite_code, reason=None)</code>  <code>async</code>","text":"<p>Delete an invite.</p> <p>Parameters:</p> Name Type Description Default <code>invite_code</code> <code>str</code> <p>The code of the invite to delete</p> required <code>reason</code> <code>str | None</code> <p>The reason to delete the invite</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.InviteData</code> <p>The deleted invite object</p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def delete_invite(self, invite_code: str, reason: str | None = None) -&gt; discord_typings.InviteData:\n\"\"\"\n    Delete an invite.\n\n    Args:\n        invite_code: The code of the invite to delete\n        reason: The reason to delete the invite\n\n    Returns:\n        The deleted invite object\n\n    \"\"\"\n    result = await self.request(Route(\"DELETE\", f\"/invites/{invite_code}\"), reason=reason)\n    return cast(discord_typings.InviteData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.edit_channel_permission","title":"<code>edit_channel_permission(channel_id, overwrite_id, perm_type, allow=0, deny=0, reason=None)</code>  <code>async</code>","text":"<p>Edit the channel permission overwrites for a user or role in a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The id of the channel</p> required <code>overwrite_id</code> <code>Snowflake_Type</code> <p>The id of the object to override</p> required <code>allow</code> <code>Permissions | int</code> <p>the bitwise value of all allowed permissions</p> <code>0</code> <code>deny</code> <code>Permissions | int</code> <p>the bitwise value of all disallowed permissions</p> <code>0</code> <code>perm_type</code> <code>OverwriteTypes | int</code> <p>0 for a role or 1 for a member</p> required <code>reason</code> <code>str | None</code> <p>The reason for this action</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def edit_channel_permission(\n    self,\n    channel_id: \"Snowflake_Type\",\n    overwrite_id: \"Snowflake_Type\",\n    perm_type: \"OverwriteTypes | int\",\n    allow: \"Permissions | int\" = 0,\n    deny: \"Permissions | int\" = 0,\n    reason: str | None = None,\n) -&gt; None:\n\"\"\"\n    Edit the channel permission overwrites for a user or role in a channel.\n\n    Args:\n        channel_id: The id of the channel\n        overwrite_id: The id of the object to override\n        allow: the bitwise value of all allowed permissions\n        deny: the bitwise value of all disallowed permissions\n        perm_type: 0 for a role or 1 for a member\n        reason: The reason for this action\n\n    \"\"\"\n    payload: PAYLOAD_TYPE = {\"allow\": allow, \"deny\": deny, \"type\": perm_type}\n\n    await self.request(\n        Route(\"PUT\", f\"/channels/{int(channel_id)}/permissions/{int(overwrite_id)}\"),\n        payload=payload,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.delete_channel_permission","title":"<code>delete_channel_permission(channel_id, overwrite_id, reason=None)</code>  <code>async</code>","text":"<p>Delete a channel permission overwrite for a user or role in a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel.</p> required <code>overwrite_id</code> <code>Snowflake_Type</code> <p>The ID of the overwrite</p> required <code>reason</code> <code>str | None</code> <p>An optional reason for the audit log</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def delete_channel_permission(\n    self, channel_id: \"Snowflake_Type\", overwrite_id: \"Snowflake_Type\", reason: str | None = None\n) -&gt; None:\n\"\"\"\n    Delete a channel permission overwrite for a user or role in a channel.\n\n    Args:\n        channel_id: The ID of the channel.\n        overwrite_id: The ID of the overwrite\n        reason: An optional reason for the audit log\n\n    \"\"\"\n    await self.request(Route(\"DELETE\", f\"/channels/{int(channel_id)}/{int(overwrite_id)}\"), reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.follow_news_channel","title":"<code>follow_news_channel(channel_id, webhook_channel_id)</code>  <code>async</code>","text":"<p>Follow a news channel to send messages to the target channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The channel to follow</p> required <code>webhook_channel_id</code> <code>Snowflake_Type</code> <p>ID of the target channel</p> required <p>Returns:</p> Type Description <code>discord_typings.FollowedChannelData</code> <p>Followed channel object</p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def follow_news_channel(\n    self, channel_id: \"Snowflake_Type\", webhook_channel_id: \"Snowflake_Type\"\n) -&gt; discord_typings.FollowedChannelData:\n\"\"\"\n    Follow a news channel to send messages to the target channel.\n\n    Args:\n        channel_id: The channel to follow\n        webhook_channel_id: ID of the target channel\n\n    Returns:\n        Followed channel object\n\n    \"\"\"\n    payload = {\"webhook_channel_id\": int(webhook_channel_id)}\n\n    result = await self.request(Route(\"POST\", f\"/channels/{int(channel_id)}/followers\"), payload=payload)\n    return cast(discord_typings.FollowedChannelData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.trigger_typing_indicator","title":"<code>trigger_typing_indicator(channel_id)</code>  <code>async</code>","text":"<p>Post a typing indicator for the specified channel. Generally bots should not implement this route.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The id of the channel to \"type\" in</p> required Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def trigger_typing_indicator(self, channel_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n    Post a typing indicator for the specified channel. Generally bots should not implement this route.\n\n    Args:\n        channel_id: The id of the channel to \"type\" in\n\n    \"\"\"\n    await self.request(Route(\"POST\", f\"/channels/{int(channel_id)}/typing\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.get_pinned_messages","title":"<code>get_pinned_messages(channel_id)</code>  <code>async</code>","text":"<p>Get all pinned messages from a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel to get pins from</p> required <p>Returns:</p> Type Description <code>list[discord_typings.MessageData]</code> <p>A list of pinned message objects</p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def get_pinned_messages(self, channel_id: \"Snowflake_Type\") -&gt; list[discord_typings.MessageData]:\n\"\"\"\n    Get all pinned messages from a channel.\n\n    Args:\n        channel_id: The ID of the channel to get pins from\n\n    Returns:\n        A list of pinned message objects\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/channels/{int(channel_id)}/pins\"))\n    return cast(list[discord_typings.MessageData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.create_stage_instance","title":"<code>create_stage_instance(channel_id, topic, privacy_level=StagePrivacyLevel.PUBLIC, reason=None)</code>  <code>async</code>","text":"<p>Create a new stage instance.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the stage channel</p> required <code>topic</code> <code>str</code> <p>The topic of the stage instance (1-120 characters)</p> required <code>privacy_level</code> <code>StagePrivacyLevel | int</code> <p>Them privacy_level of the stage instance (default guild only)</p> <code>StagePrivacyLevel.PUBLIC</code> <code>reason</code> <code>str | None</code> <p>The reason for the creating the stage instance</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.StageInstanceData</code> <p>The stage instance</p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def create_stage_instance(\n    self,\n    channel_id: \"Snowflake_Type\",\n    topic: str,\n    privacy_level: StagePrivacyLevel | int = StagePrivacyLevel.PUBLIC,\n    reason: str | None = None,\n) -&gt; discord_typings.StageInstanceData:\n\"\"\"\n    Create a new stage instance.\n\n    Args:\n        channel_id: The ID of the stage channel\n        topic: The topic of the stage instance (1-120 characters)\n        privacy_level: Them privacy_level of the stage instance (default guild only)\n        reason: The reason for the creating the stage instance\n\n    Returns:\n        The stage instance\n\n    \"\"\"\n    payload: PAYLOAD_TYPE = {\n        \"channel_id\": int(channel_id),\n        \"topic\": topic,\n        \"privacy_level\": StagePrivacyLevel(privacy_level),\n    }\n\n    result = await self.request(Route(\"POST\", \"/stage-instances\"), payload=payload, reason=reason)\n    return cast(discord_typings.StageInstanceData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.get_stage_instance","title":"<code>get_stage_instance(channel_id)</code>  <code>async</code>","text":"<p>Get the stage instance associated with a given channel, if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel to retrieve the instance for.</p> required <p>Returns:</p> Type Description <code>discord_typings.StageInstanceData</code> <p>A stage instance.</p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def get_stage_instance(self, channel_id: \"Snowflake_Type\") -&gt; discord_typings.StageInstanceData:\n\"\"\"\n    Get the stage instance associated with a given channel, if it exists.\n\n    Args:\n        channel_id: The ID of the channel to retrieve the instance for.\n\n    Returns:\n        A stage instance.\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/stage-instances/{int(channel_id)}\"))\n    return cast(discord_typings.StageInstanceData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.modify_stage_instance","title":"<code>modify_stage_instance(channel_id, topic=None, privacy_level=None, reason=None)</code>  <code>async</code>","text":"<p>Update the fields of a given stage instance.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The id of the stage channel.</p> required <code>topic</code> <code>str | None</code> <p>The new topic for the stage instance</p> <code>None</code> <code>privacy_level</code> <code>int | None</code> <p>The privacy level for the stage instance</p> <code>None</code> <code>reason</code> <code>str | None</code> <p>The reason for the change</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.StageInstanceData</code> <p>The updated stage instance.</p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def modify_stage_instance(\n    self,\n    channel_id: \"Snowflake_Type\",\n    topic: str | None = None,\n    privacy_level: int | None = None,\n    reason: str | None = None,\n) -&gt; discord_typings.StageInstanceData:\n\"\"\"\n    Update the fields of a given stage instance.\n\n    Args:\n        channel_id: The id of the stage channel.\n        topic: The new topic for the stage instance\n        privacy_level: The privacy level for the stage instance\n        reason: The reason for the change\n\n    Returns:\n        The updated stage instance.\n\n    \"\"\"\n    payload: PAYLOAD_TYPE = {\"topic\": topic, \"privacy_level\": privacy_level}\n    payload = dict_filter_none(payload)\n    result = await self.request(\n        Route(\"PATCH\", f\"/stage-instances/{int(channel_id)}\"), payload=payload, reason=reason\n    )\n    return cast(discord_typings.StageInstanceData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.delete_stage_instance","title":"<code>delete_stage_instance(channel_id, reason=None)</code>  <code>async</code>","text":"<p>Delete a stage instance.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel to delete the stage instance for.</p> required <code>reason</code> <code>str | None</code> <p>The reason for the deletion</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def delete_stage_instance(self, channel_id: \"Snowflake_Type\", reason: str | None = None) -&gt; None:\n\"\"\"\n    Delete a stage instance.\n\n    Args:\n        channel_id: The ID of the channel to delete the stage instance for.\n        reason: The reason for the deletion\n\n    \"\"\"\n    await self.request(Route(\"DELETE\", f\"/stage-instances/{int(channel_id)}\"), reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.create_tag","title":"<code>create_tag(channel_id, name, emoji_id=None, emoji_name=None)</code>  <code>async</code>","text":"<p>Create a new tag.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the forum channel to create tag for.</p> required <code>name</code> <code>str</code> <p>The name of the tag</p> required <code>emoji_id</code> <code>Optional[Snowflake_Type]</code> <p>The ID of the emoji to use for the tag</p> <code>None</code> <code>emoji_name</code> <code>Optional[str]</code> <p>The name of the emoji to use for the tag</p> <code>None</code> <p>Note</p> <p>Can either have an <code>emoji_id</code> or an <code>emoji_name</code>, but not both. <code>emoji_id</code> is meant for custom emojis, <code>emoji_name</code> is meant for unicode emojis.</p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def create_tag(\n    self,\n    channel_id: \"Snowflake_Type\",\n    name: str,\n    emoji_id: Optional[\"Snowflake_Type\"] = None,\n    emoji_name: Optional[str] = None,\n) -&gt; discord_typings.ChannelData:\n\"\"\"\n    Create a new tag.\n\n    Args:\n        channel_id: The ID of the forum channel to create tag for.\n        name: The name of the tag\n        emoji_id: The ID of the emoji to use for the tag\n        emoji_name: The name of the emoji to use for the tag\n\n    !!! note\n        Can either have an `emoji_id` or an `emoji_name`, but not both.\n        `emoji_id` is meant for custom emojis, `emoji_name` is meant for unicode emojis.\n    \"\"\"\n    payload: PAYLOAD_TYPE = {\n        \"name\": name,\n        \"emoji_id\": int(emoji_id) if emoji_id else None,\n        \"emoji_name\": emoji_name if emoji_name else None,\n    }\n    payload = dict_filter_none(payload)\n\n    result = await self.request(Route(\"POST\", f\"/channels/{int(channel_id)}/tags\"), payload=payload)\n    return cast(discord_typings.ChannelData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.edit_tag","title":"<code>edit_tag(channel_id, tag_id, name, emoji_id=None, emoji_name=None)</code>  <code>async</code>","text":"<p>Update a tag.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the forum channel to edit tag it.</p> required <code>tag_id</code> <code>Snowflake_Type</code> <p>The ID of the tag to update</p> required <code>name</code> <code>str</code> <p>The new name of the tag</p> required <code>emoji_id</code> <code>Snowflake_Type | None</code> <p>The ID of the emoji to use for the tag</p> <code>None</code> <code>emoji_name</code> <code>str | None</code> <p>The name of the emoji to use for the tag</p> <code>None</code> <p>Note</p> <p>Can either have an <code>emoji_id</code> or an <code>emoji_name</code>, but not both. emoji<code>_id is meant for custom emojis,</code>emoji_name` is meant for unicode emojis.</p> Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def edit_tag(\n    self,\n    channel_id: \"Snowflake_Type\",\n    tag_id: \"Snowflake_Type\",\n    name: str,\n    emoji_id: \"Snowflake_Type | None\" = None,\n    emoji_name: str | None = None,\n) -&gt; discord_typings.ChannelData:\n\"\"\"\n    Update a tag.\n\n    Args:\n        channel_id: The ID of the forum channel to edit tag it.\n        tag_id: The ID of the tag to update\n        name: The new name of the tag\n        emoji_id: The ID of the emoji to use for the tag\n        emoji_name: The name of the emoji to use for the tag\n\n    !!! note\n        Can either have an `emoji_id` or an `emoji_name`, but not both.\n        emoji`_id is meant for custom emojis, `emoji_name` is meant for unicode emojis.\n    \"\"\"\n    payload: PAYLOAD_TYPE = {\n        \"name\": name,\n        \"emoji_id\": int(emoji_id) if emoji_id else None,\n        \"emoji_name\": emoji_name,\n    }\n    payload = dict_filter_none(payload)\n\n    result = await self.request(Route(\"PUT\", f\"/channels/{int(channel_id)}/tags/{int(tag_id)}\"), payload=payload)\n    return cast(discord_typings.ChannelData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.channels.ChannelRequests.delete_tag","title":"<code>delete_tag(channel_id, tag_id)</code>  <code>async</code>","text":"<p>Delete a forum tag.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the forum channel to delete tag it.</p> required <code>tag_id</code> <code>Snowflake_Type</code> <p>The ID of the tag to delete</p> required Source code in <code>naff\\api\\http\\http_requests\\channels.py</code> <pre><code>async def delete_tag(self, channel_id: \"Snowflake_Type\", tag_id: \"Snowflake_Type\") -&gt; discord_typings.ChannelData:\n\"\"\"\n    Delete a forum tag.\n\n    Args:\n        channel_id: The ID of the forum channel to delete tag it.\n        tag_id: The ID of the tag to delete\n    \"\"\"\n    result = await self.request(Route(\"DELETE\", f\"/channels/{int(channel_id)}/tags/{int(tag_id)}\"))\n    return cast(discord_typings.ChannelData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.MemberRequests","title":"<code>MemberRequests</code>","text":"<p>         Bases: <code>CanRequest</code></p> Source code in <code>naff\\api\\http\\http_requests\\members.py</code> <pre><code>class MemberRequests(CanRequest):\n    async def get_member(\n        self, guild_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\"\n    ) -&gt; discord_typings.GuildMemberData:\n\"\"\"\n        Get a member of a guild by ID.\n\n        Args:\n            guild_id: The id of the guild\n            user_id: The user id to grab\n\n        \"\"\"\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/members/{int(user_id)}\"))\n        return cast(discord_typings.GuildMemberData, result)\n\n    async def list_members(\n        self, guild_id: \"Snowflake_Type\", limit: int = 1, after: \"Snowflake_Type | None\" = None\n    ) -&gt; list[discord_typings.GuildMemberData]:\n\"\"\"\n        List the members of a guild.\n\n        Args:\n            guild_id: The ID of the guild\n            limit: How many members to get (max 1000)\n            after: Get IDs after this snowflake\n\n        \"\"\"\n        payload: PAYLOAD_TYPE = {\n            \"limit\": limit,\n            \"after\": int(after) if after else None,\n        }\n        payload = dict_filter_none(payload)\n\n        result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/members\"), params=payload)\n        return cast(list[discord_typings.GuildMemberData], result)\n\n    async def search_guild_members(\n        self, guild_id: \"Snowflake_Type\", query: str, limit: int = 1\n    ) -&gt; list[discord_typings.GuildMemberData]:\n\"\"\"\n        Search a guild for members who's username or nickname starts with provided string.\n\n        Args:\n            guild_id: The ID of the guild to search\n            query: The string to search for\n            limit: The number of members to return\n\n        \"\"\"\n        result = await self.request(\n            Route(\"GET\", f\"/guilds/{int(guild_id)}/members/search\"), params={\"query\": query, \"limit\": limit}\n        )\n        return cast(list[discord_typings.GuildMemberData], result)\n\n    async def modify_guild_member(\n        self,\n        guild_id: \"Snowflake_Type\",\n        user_id: \"Snowflake_Type\",\n        nickname: str | None | Missing = MISSING,\n        roles: list[\"Snowflake_Type\"] | None = None,\n        mute: bool | None = None,\n        deaf: bool | None = None,\n        channel_id: \"Snowflake_Type | None\" = None,\n        communication_disabled_until: str | datetime | Timestamp | None | Missing = MISSING,\n        reason: str | None = None,\n    ) -&gt; discord_typings.GuildMemberData:\n\"\"\"\n        Modify attributes of a guild member.\n\n        Args:\n            guild_id: The ID of the guild\n            user_id: The ID of the user we're modifying\n            nickname: Value to set users nickname to\n            roles: Array of role ids the member is assigned\n            mute: Whether the user is muted in voice channels. Will throw a 400 if the user is not in a voice channel\n            deaf: Whether the user is deafened in voice channels\n            channel_id: id of channel to move user to (if they are connected to voice)\n            communication_disabled_until: \twhen the user's timeout will expire and the user will be able to communicate in the guild again\n            reason: An optional reason for the audit log\n\n        Returns:\n            The updated member object\n\n        \"\"\"\n        if isinstance(communication_disabled_until, datetime):\n            communication_disabled_until = communication_disabled_until.isoformat()\n\n        payload: PAYLOAD_TYPE = {\n            \"roles\": roles,\n            \"mute\": mute,\n            \"deaf\": deaf,\n            \"channel_id\": int(channel_id) if channel_id else None,\n        }\n        payload = dict_filter_none(payload)\n\n        if not isinstance(nickname, Missing):\n            payload[\"nick\"] = nickname\n        if not isinstance(communication_disabled_until, Missing):\n            payload[\"communication_disabled_until\"] = communication_disabled_until\n\n        result = await self.request(\n            Route(\"PATCH\", f\"/guilds/{int(guild_id)}/members/{int(user_id)}\"),\n            payload=payload,\n            reason=reason,\n        )\n        return cast(discord_typings.GuildMemberData, result)\n\n    async def modify_current_member(\n        self,\n        guild_id: \"Snowflake_Type\",\n        nickname: str | None | Missing = MISSING,\n        reason: str | None = None,\n    ) -&gt; None:\n\"\"\"\n        Modify attributes of the user\n\n        Args:\n            guild_id: The ID of the guild to modify current member in\n            nickname: The new nickname to apply\n            reason: An optional reason for the audit log\n\n        \"\"\"\n        payload: PAYLOAD_TYPE = {\"nick\": nickname if not isinstance(nickname, Missing) else None}\n        await self.request(\n            Route(\"PATCH\", f\"/guilds/{int(guild_id)}/members/@me\"),\n            payload=payload,\n            reason=reason,\n        )\n\n    async def add_guild_member_role(\n        self,\n        guild_id: \"Snowflake_Type\",\n        user_id: \"Snowflake_Type\",\n        role_id: \"Snowflake_Type\",\n        reason: str | None = None,\n    ) -&gt; None:\n\"\"\"\n        Adds a role to a guild member.\n\n        Args:\n            guild_id: The ID of the guild\n            user_id: The ID of the user\n            role_id: The ID of the role to add\n            reason: The reason for this action\n\n        \"\"\"\n        await self.request(\n            Route(\"PUT\", f\"/guilds/{int(guild_id)}/members/{int(user_id)}/roles/{int(role_id)}\"), reason=reason\n        )\n\n    async def remove_guild_member_role(\n        self,\n        guild_id: \"Snowflake_Type\",\n        user_id: \"Snowflake_Type\",\n        role_id: \"Snowflake_Type\",\n        reason: str | None = None,\n    ) -&gt; None:\n\"\"\"\n        Remove a role from a guild member.\n\n        Args:\n            guild_id: The ID of the guild\n            user_id: The ID of the user\n            role_id: The ID of the role to remove\n            reason: The reason for this action\n\n        \"\"\"\n        await self.request(\n            Route(\"DELETE\", f\"/guilds/{int(guild_id)}/members/{int(user_id)}/roles/{int(role_id)}\"), reason=reason\n        )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.members.MemberRequests.get_member","title":"<code>get_member(guild_id, user_id)</code>  <code>async</code>","text":"<p>Get a member of a guild by ID.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The id of the guild</p> required <code>user_id</code> <code>Snowflake_Type</code> <p>The user id to grab</p> required Source code in <code>naff\\api\\http\\http_requests\\members.py</code> <pre><code>async def get_member(\n    self, guild_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\"\n) -&gt; discord_typings.GuildMemberData:\n\"\"\"\n    Get a member of a guild by ID.\n\n    Args:\n        guild_id: The id of the guild\n        user_id: The user id to grab\n\n    \"\"\"\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/members/{int(user_id)}\"))\n    return cast(discord_typings.GuildMemberData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.members.MemberRequests.list_members","title":"<code>list_members(guild_id, limit=1, after=None)</code>  <code>async</code>","text":"<p>List the members of a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>limit</code> <code>int</code> <p>How many members to get (max 1000)</p> <code>1</code> <code>after</code> <code>Snowflake_Type | None</code> <p>Get IDs after this snowflake</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\members.py</code> <pre><code>async def list_members(\n    self, guild_id: \"Snowflake_Type\", limit: int = 1, after: \"Snowflake_Type | None\" = None\n) -&gt; list[discord_typings.GuildMemberData]:\n\"\"\"\n    List the members of a guild.\n\n    Args:\n        guild_id: The ID of the guild\n        limit: How many members to get (max 1000)\n        after: Get IDs after this snowflake\n\n    \"\"\"\n    payload: PAYLOAD_TYPE = {\n        \"limit\": limit,\n        \"after\": int(after) if after else None,\n    }\n    payload = dict_filter_none(payload)\n\n    result = await self.request(Route(\"GET\", f\"/guilds/{int(guild_id)}/members\"), params=payload)\n    return cast(list[discord_typings.GuildMemberData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.members.MemberRequests.search_guild_members","title":"<code>search_guild_members(guild_id, query, limit=1)</code>  <code>async</code>","text":"<p>Search a guild for members who's username or nickname starts with provided string.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to search</p> required <code>query</code> <code>str</code> <p>The string to search for</p> required <code>limit</code> <code>int</code> <p>The number of members to return</p> <code>1</code> Source code in <code>naff\\api\\http\\http_requests\\members.py</code> <pre><code>async def search_guild_members(\n    self, guild_id: \"Snowflake_Type\", query: str, limit: int = 1\n) -&gt; list[discord_typings.GuildMemberData]:\n\"\"\"\n    Search a guild for members who's username or nickname starts with provided string.\n\n    Args:\n        guild_id: The ID of the guild to search\n        query: The string to search for\n        limit: The number of members to return\n\n    \"\"\"\n    result = await self.request(\n        Route(\"GET\", f\"/guilds/{int(guild_id)}/members/search\"), params={\"query\": query, \"limit\": limit}\n    )\n    return cast(list[discord_typings.GuildMemberData], result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.members.MemberRequests.modify_guild_member","title":"<code>modify_guild_member(guild_id, user_id, nickname=MISSING, roles=None, mute=None, deaf=None, channel_id=None, communication_disabled_until=MISSING, reason=None)</code>  <code>async</code>","text":"<p>Modify attributes of a guild member.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the user we're modifying</p> required <code>nickname</code> <code>str | None | Missing</code> <p>Value to set users nickname to</p> <code>MISSING</code> <code>roles</code> <code>list[Snowflake_Type] | None</code> <p>Array of role ids the member is assigned</p> <code>None</code> <code>mute</code> <code>bool | None</code> <p>Whether the user is muted in voice channels. Will throw a 400 if the user is not in a voice channel</p> <code>None</code> <code>deaf</code> <code>bool | None</code> <p>Whether the user is deafened in voice channels</p> <code>None</code> <code>channel_id</code> <code>Snowflake_Type | None</code> <p>id of channel to move user to (if they are connected to voice)</p> <code>None</code> <code>communication_disabled_until</code> <code>str | datetime | Timestamp | None | Missing</code> <p>when the user's timeout will expire and the user will be able to communicate in the guild again</p> <code>MISSING</code> <code>reason</code> <code>str | None</code> <p>An optional reason for the audit log</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.GuildMemberData</code> <p>The updated member object</p> Source code in <code>naff\\api\\http\\http_requests\\members.py</code> <pre><code>async def modify_guild_member(\n    self,\n    guild_id: \"Snowflake_Type\",\n    user_id: \"Snowflake_Type\",\n    nickname: str | None | Missing = MISSING,\n    roles: list[\"Snowflake_Type\"] | None = None,\n    mute: bool | None = None,\n    deaf: bool | None = None,\n    channel_id: \"Snowflake_Type | None\" = None,\n    communication_disabled_until: str | datetime | Timestamp | None | Missing = MISSING,\n    reason: str | None = None,\n) -&gt; discord_typings.GuildMemberData:\n\"\"\"\n    Modify attributes of a guild member.\n\n    Args:\n        guild_id: The ID of the guild\n        user_id: The ID of the user we're modifying\n        nickname: Value to set users nickname to\n        roles: Array of role ids the member is assigned\n        mute: Whether the user is muted in voice channels. Will throw a 400 if the user is not in a voice channel\n        deaf: Whether the user is deafened in voice channels\n        channel_id: id of channel to move user to (if they are connected to voice)\n        communication_disabled_until: \twhen the user's timeout will expire and the user will be able to communicate in the guild again\n        reason: An optional reason for the audit log\n\n    Returns:\n        The updated member object\n\n    \"\"\"\n    if isinstance(communication_disabled_until, datetime):\n        communication_disabled_until = communication_disabled_until.isoformat()\n\n    payload: PAYLOAD_TYPE = {\n        \"roles\": roles,\n        \"mute\": mute,\n        \"deaf\": deaf,\n        \"channel_id\": int(channel_id) if channel_id else None,\n    }\n    payload = dict_filter_none(payload)\n\n    if not isinstance(nickname, Missing):\n        payload[\"nick\"] = nickname\n    if not isinstance(communication_disabled_until, Missing):\n        payload[\"communication_disabled_until\"] = communication_disabled_until\n\n    result = await self.request(\n        Route(\"PATCH\", f\"/guilds/{int(guild_id)}/members/{int(user_id)}\"),\n        payload=payload,\n        reason=reason,\n    )\n    return cast(discord_typings.GuildMemberData, result)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.members.MemberRequests.modify_current_member","title":"<code>modify_current_member(guild_id, nickname=MISSING, reason=None)</code>  <code>async</code>","text":"<p>Modify attributes of the user</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild to modify current member in</p> required <code>nickname</code> <code>str | None | Missing</code> <p>The new nickname to apply</p> <code>MISSING</code> <code>reason</code> <code>str | None</code> <p>An optional reason for the audit log</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\members.py</code> <pre><code>async def modify_current_member(\n    self,\n    guild_id: \"Snowflake_Type\",\n    nickname: str | None | Missing = MISSING,\n    reason: str | None = None,\n) -&gt; None:\n\"\"\"\n    Modify attributes of the user\n\n    Args:\n        guild_id: The ID of the guild to modify current member in\n        nickname: The new nickname to apply\n        reason: An optional reason for the audit log\n\n    \"\"\"\n    payload: PAYLOAD_TYPE = {\"nick\": nickname if not isinstance(nickname, Missing) else None}\n    await self.request(\n        Route(\"PATCH\", f\"/guilds/{int(guild_id)}/members/@me\"),\n        payload=payload,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.members.MemberRequests.add_guild_member_role","title":"<code>add_guild_member_role(guild_id, user_id, role_id, reason=None)</code>  <code>async</code>","text":"<p>Adds a role to a guild member.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the user</p> required <code>role_id</code> <code>Snowflake_Type</code> <p>The ID of the role to add</p> required <code>reason</code> <code>str | None</code> <p>The reason for this action</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\members.py</code> <pre><code>async def add_guild_member_role(\n    self,\n    guild_id: \"Snowflake_Type\",\n    user_id: \"Snowflake_Type\",\n    role_id: \"Snowflake_Type\",\n    reason: str | None = None,\n) -&gt; None:\n\"\"\"\n    Adds a role to a guild member.\n\n    Args:\n        guild_id: The ID of the guild\n        user_id: The ID of the user\n        role_id: The ID of the role to add\n        reason: The reason for this action\n\n    \"\"\"\n    await self.request(\n        Route(\"PUT\", f\"/guilds/{int(guild_id)}/members/{int(user_id)}/roles/{int(role_id)}\"), reason=reason\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.members.MemberRequests.remove_guild_member_role","title":"<code>remove_guild_member_role(guild_id, user_id, role_id, reason=None)</code>  <code>async</code>","text":"<p>Remove a role from a guild member.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The ID of the guild</p> required <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the user</p> required <code>role_id</code> <code>Snowflake_Type</code> <p>The ID of the role to remove</p> required <code>reason</code> <code>str | None</code> <p>The reason for this action</p> <code>None</code> Source code in <code>naff\\api\\http\\http_requests\\members.py</code> <pre><code>async def remove_guild_member_role(\n    self,\n    guild_id: \"Snowflake_Type\",\n    user_id: \"Snowflake_Type\",\n    role_id: \"Snowflake_Type\",\n    reason: str | None = None,\n) -&gt; None:\n\"\"\"\n    Remove a role from a guild member.\n\n    Args:\n        guild_id: The ID of the guild\n        user_id: The ID of the user\n        role_id: The ID of the role to remove\n        reason: The reason for this action\n\n    \"\"\"\n    await self.request(\n        Route(\"DELETE\", f\"/guilds/{int(guild_id)}/members/{int(user_id)}/roles/{int(role_id)}\"), reason=reason\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.ThreadRequests","title":"<code>ThreadRequests</code>","text":"Source code in <code>naff\\api\\http\\http_requests\\threads.py</code> <pre><code>class ThreadRequests:\n    request: Any\n\n    async def join_thread(self, thread_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n        Join a thread.\n\n        Args:\n            thread_id: The thread to join.\n\n        \"\"\"\n        return await self.request(Route(\"PUT\", f\"/channels/{thread_id}/thread-members/@me\"))\n\n    async def leave_thread(self, thread_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n        Leave a thread.\n\n        Args:\n            thread_id: The thread to leave.\n\n        \"\"\"\n        return await self.request(Route(\"DELETE\", f\"/channels/{thread_id}/thread-members/@me\"))\n\n    async def add_thread_member(self, thread_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n        Add another user to a thread.\n\n        Args:\n            thread_id: The ID of the thread\n            user_id: The ID of the user to add\n\n        \"\"\"\n        return await self.request(Route(\"PUT\", f\"/channels/{thread_id}/thread-members/{user_id}\"))\n\n    async def remove_thread_member(self, thread_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n        Remove another user from a thread.\n\n        Args:\n            thread_id: The ID of the thread\n            user_id: The ID of the user to remove\n\n        \"\"\"\n        return await self.request(Route(\"DELETE\", f\"/channels/{thread_id}/thread-members/{user_id}\"))\n\n    async def list_thread_members(self, thread_id: \"Snowflake_Type\") -&gt; List[discord_typings.ThreadMemberData]:\n\"\"\"\n        Get a list of members in the thread.\n\n        Args:\n            thread_id: the id of the thread\n\n        Returns:\n            a list of member objects\n\n        \"\"\"\n        return await self.request(Route(\"GET\", f\"/channels/{thread_id}/thread-members\"))\n\n    async def list_public_archived_threads(\n        self, channel_id: \"Snowflake_Type\", limit: int = None, before: Optional[\"Snowflake_Type\"] = None\n    ) -&gt; discord_typings.ListThreadsData:\n\"\"\"\n        Get a list of archived public threads in a channel.\n\n        Args:\n            channel_id: The channel to get threads from\n            limit: Optional limit of threads to\n            before: Get threads before this snowflake\n\n        Returns:\n            a list of threads\n\n        \"\"\"\n        payload = {}\n        if limit:\n            payload[\"limit\"] = limit\n        if before:\n            payload[\"before\"] = Timestamp.from_snowflake(before).isoformat()\n        return await self.request(Route(\"GET\", f\"/channels/{channel_id}/threads/archived/public\"), params=payload)\n\n    async def list_private_archived_threads(\n        self, channel_id: \"Snowflake_Type\", limit: int = None, before: Optional[\"Snowflake_Type\"] = None\n    ) -&gt; discord_typings.ListThreadsData:\n\"\"\"\n        Get a list of archived private threads in a channel.\n\n        Args:\n            channel_id: The channel to get threads from\n            limit: Optional limit of threads to\n            before: Get threads before this snowflake\n\n        Returns:\n            a list of threads\n\n        \"\"\"\n        payload = {}\n        if limit:\n            payload[\"limit\"] = limit\n        if before:\n            payload[\"before\"] = Timestamp.from_snowflake(before).isoformat()\n        return await self.request(Route(\"GET\", f\"/channels/{channel_id}/threads/archived/private\"), params=payload)\n\n    async def list_joined_private_archived_threads(\n        self, channel_id: \"Snowflake_Type\", limit: int = None, before: Optional[\"Snowflake_Type\"] = None\n    ) -&gt; discord_typings.ListThreadsData:\n\"\"\"\n        Get a list of archived private threads in a channel that you have joined.\n\n        Args:\n            channel_id: The channel to get threads from\n            limit: Optional limit of threads to\n            before: Get threads before this snowflake\n\n        Returns:\n            a list of threads\n\n        \"\"\"\n        payload = {}\n        if limit:\n            payload[\"limit\"] = limit\n        if before:\n            payload[\"before\"] = before\n        return await self.request(\n            Route(\"GET\", f\"/channels/{channel_id}/users/@me/threads/archived/private\"), params=payload\n        )\n\n    async def list_active_threads(self, guild_id: \"Snowflake_Type\") -&gt; discord_typings.ListThreadsData:\n\"\"\"\n        List active threads within a guild.\n\n        Args:\n            guild_id: the guild id to get threads from\n\n        Returns:\n            A list of active threads\n\n        \"\"\"\n        return await self.request(Route(\"GET\", f\"/guilds/{guild_id}/threads/active\"))\n\n    async def create_thread(\n        self,\n        channel_id: \"Snowflake_Type\",\n        name: str,\n        auto_archive_duration: int,\n        thread_type: Absent[int] = MISSING,\n        invitable: Absent[bool] = MISSING,\n        message_id: Absent[\"Snowflake_Type\"] = MISSING,\n        reason: Absent[str] = MISSING,\n    ) -&gt; discord_typings.ThreadChannelData:\n\"\"\"\n        Create a thread in the given channel. Can either create a thread with or without a message.\n\n        Args:\n            channel_id: The ID of the channel to create this thread in\n            name: The name of the thread\n            auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\n            thread_type: The type of thread, defaults to public. ignored if creating thread from a message\n            invitable:\n            message_id: An optional message to create a thread from.\n            reason: An optional reason for the audit log\n\n        Returns:\n            The created thread\n\n        \"\"\"\n        payload = {\"name\": name, \"auto_archive_duration\": auto_archive_duration}\n        if message_id:\n            return await self.request(\n                Route(\"POST\", f\"/channels/{channel_id}/messages/{message_id}/threads\"), payload=payload, reason=reason\n            )\n        else:\n            payload[\"type\"] = thread_type or ChannelTypes.GUILD_PUBLIC_THREAD\n            payload[\"invitable\"] = invitable\n            return await self.request(Route(\"POST\", f\"/channels/{channel_id}/threads\"), payload=payload, reason=reason)\n\n    async def create_forum_thread(\n        self,\n        channel_id: \"Snowflake_Type\",\n        name: str,\n        auto_archive_duration: int,\n        message: dict | FormData,\n        applied_tags: List[str] = None,\n        rate_limit_per_user: Absent[int] = MISSING,\n        files: Absent[\"UPLOADABLE_TYPE\"] = MISSING,\n        reason: Absent[str] = MISSING,\n    ) -&gt; dict:\n\"\"\"\n        Create a thread within a forum channel.\n\n        Args:\n            channel_id: The id of the forum channel\n            name: The name of the thread\n            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.\n            message: The message-content for the post/thread\n            applied_tags: The tags to apply to the thread\n            rate_limit_per_user: The time users must wait between sending messages\n            files: The files to upload\n            reason: The reason for creating this thread\n\n        Returns:\n            The created thread object\n        \"\"\"\n        return await self.request(\n            Route(\"POST\", f\"/channels/{channel_id}/threads\"),\n            payload={\n                \"name\": name,\n                \"auto_archive_duration\": auto_archive_duration,\n                \"rate_limit_per_user\": rate_limit_per_user,\n                \"message\": message,\n                \"applied_tags\": applied_tags,\n            },\n            files=files,\n            reason=reason,\n        )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.threads.ThreadRequests.join_thread","title":"<code>join_thread(thread_id)</code>  <code>async</code>","text":"<p>Join a thread.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>Snowflake_Type</code> <p>The thread to join.</p> required Source code in <code>naff\\api\\http\\http_requests\\threads.py</code> <pre><code>async def join_thread(self, thread_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n    Join a thread.\n\n    Args:\n        thread_id: The thread to join.\n\n    \"\"\"\n    return await self.request(Route(\"PUT\", f\"/channels/{thread_id}/thread-members/@me\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.threads.ThreadRequests.leave_thread","title":"<code>leave_thread(thread_id)</code>  <code>async</code>","text":"<p>Leave a thread.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>Snowflake_Type</code> <p>The thread to leave.</p> required Source code in <code>naff\\api\\http\\http_requests\\threads.py</code> <pre><code>async def leave_thread(self, thread_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n    Leave a thread.\n\n    Args:\n        thread_id: The thread to leave.\n\n    \"\"\"\n    return await self.request(Route(\"DELETE\", f\"/channels/{thread_id}/thread-members/@me\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.threads.ThreadRequests.add_thread_member","title":"<code>add_thread_member(thread_id, user_id)</code>  <code>async</code>","text":"<p>Add another user to a thread.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>Snowflake_Type</code> <p>The ID of the thread</p> required <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the user to add</p> required Source code in <code>naff\\api\\http\\http_requests\\threads.py</code> <pre><code>async def add_thread_member(self, thread_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n    Add another user to a thread.\n\n    Args:\n        thread_id: The ID of the thread\n        user_id: The ID of the user to add\n\n    \"\"\"\n    return await self.request(Route(\"PUT\", f\"/channels/{thread_id}/thread-members/{user_id}\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.threads.ThreadRequests.remove_thread_member","title":"<code>remove_thread_member(thread_id, user_id)</code>  <code>async</code>","text":"<p>Remove another user from a thread.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>Snowflake_Type</code> <p>The ID of the thread</p> required <code>user_id</code> <code>Snowflake_Type</code> <p>The ID of the user to remove</p> required Source code in <code>naff\\api\\http\\http_requests\\threads.py</code> <pre><code>async def remove_thread_member(self, thread_id: \"Snowflake_Type\", user_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n    Remove another user from a thread.\n\n    Args:\n        thread_id: The ID of the thread\n        user_id: The ID of the user to remove\n\n    \"\"\"\n    return await self.request(Route(\"DELETE\", f\"/channels/{thread_id}/thread-members/{user_id}\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.threads.ThreadRequests.list_thread_members","title":"<code>list_thread_members(thread_id)</code>  <code>async</code>","text":"<p>Get a list of members in the thread.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>Snowflake_Type</code> <p>the id of the thread</p> required <p>Returns:</p> Type Description <code>List[discord_typings.ThreadMemberData]</code> <p>a list of member objects</p> Source code in <code>naff\\api\\http\\http_requests\\threads.py</code> <pre><code>async def list_thread_members(self, thread_id: \"Snowflake_Type\") -&gt; List[discord_typings.ThreadMemberData]:\n\"\"\"\n    Get a list of members in the thread.\n\n    Args:\n        thread_id: the id of the thread\n\n    Returns:\n        a list of member objects\n\n    \"\"\"\n    return await self.request(Route(\"GET\", f\"/channels/{thread_id}/thread-members\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.threads.ThreadRequests.list_public_archived_threads","title":"<code>list_public_archived_threads(channel_id, limit=None, before=None)</code>  <code>async</code>","text":"<p>Get a list of archived public threads in a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The channel to get threads from</p> required <code>limit</code> <code>int</code> <p>Optional limit of threads to</p> <code>None</code> <code>before</code> <code>Optional[Snowflake_Type]</code> <p>Get threads before this snowflake</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.ListThreadsData</code> <p>a list of threads</p> Source code in <code>naff\\api\\http\\http_requests\\threads.py</code> <pre><code>async def list_public_archived_threads(\n    self, channel_id: \"Snowflake_Type\", limit: int = None, before: Optional[\"Snowflake_Type\"] = None\n) -&gt; discord_typings.ListThreadsData:\n\"\"\"\n    Get a list of archived public threads in a channel.\n\n    Args:\n        channel_id: The channel to get threads from\n        limit: Optional limit of threads to\n        before: Get threads before this snowflake\n\n    Returns:\n        a list of threads\n\n    \"\"\"\n    payload = {}\n    if limit:\n        payload[\"limit\"] = limit\n    if before:\n        payload[\"before\"] = Timestamp.from_snowflake(before).isoformat()\n    return await self.request(Route(\"GET\", f\"/channels/{channel_id}/threads/archived/public\"), params=payload)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.threads.ThreadRequests.list_private_archived_threads","title":"<code>list_private_archived_threads(channel_id, limit=None, before=None)</code>  <code>async</code>","text":"<p>Get a list of archived private threads in a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The channel to get threads from</p> required <code>limit</code> <code>int</code> <p>Optional limit of threads to</p> <code>None</code> <code>before</code> <code>Optional[Snowflake_Type]</code> <p>Get threads before this snowflake</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.ListThreadsData</code> <p>a list of threads</p> Source code in <code>naff\\api\\http\\http_requests\\threads.py</code> <pre><code>async def list_private_archived_threads(\n    self, channel_id: \"Snowflake_Type\", limit: int = None, before: Optional[\"Snowflake_Type\"] = None\n) -&gt; discord_typings.ListThreadsData:\n\"\"\"\n    Get a list of archived private threads in a channel.\n\n    Args:\n        channel_id: The channel to get threads from\n        limit: Optional limit of threads to\n        before: Get threads before this snowflake\n\n    Returns:\n        a list of threads\n\n    \"\"\"\n    payload = {}\n    if limit:\n        payload[\"limit\"] = limit\n    if before:\n        payload[\"before\"] = Timestamp.from_snowflake(before).isoformat()\n    return await self.request(Route(\"GET\", f\"/channels/{channel_id}/threads/archived/private\"), params=payload)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.threads.ThreadRequests.list_joined_private_archived_threads","title":"<code>list_joined_private_archived_threads(channel_id, limit=None, before=None)</code>  <code>async</code>","text":"<p>Get a list of archived private threads in a channel that you have joined.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The channel to get threads from</p> required <code>limit</code> <code>int</code> <p>Optional limit of threads to</p> <code>None</code> <code>before</code> <code>Optional[Snowflake_Type]</code> <p>Get threads before this snowflake</p> <code>None</code> <p>Returns:</p> Type Description <code>discord_typings.ListThreadsData</code> <p>a list of threads</p> Source code in <code>naff\\api\\http\\http_requests\\threads.py</code> <pre><code>async def list_joined_private_archived_threads(\n    self, channel_id: \"Snowflake_Type\", limit: int = None, before: Optional[\"Snowflake_Type\"] = None\n) -&gt; discord_typings.ListThreadsData:\n\"\"\"\n    Get a list of archived private threads in a channel that you have joined.\n\n    Args:\n        channel_id: The channel to get threads from\n        limit: Optional limit of threads to\n        before: Get threads before this snowflake\n\n    Returns:\n        a list of threads\n\n    \"\"\"\n    payload = {}\n    if limit:\n        payload[\"limit\"] = limit\n    if before:\n        payload[\"before\"] = before\n    return await self.request(\n        Route(\"GET\", f\"/channels/{channel_id}/users/@me/threads/archived/private\"), params=payload\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.threads.ThreadRequests.list_active_threads","title":"<code>list_active_threads(guild_id)</code>  <code>async</code>","text":"<p>List active threads within a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>the guild id to get threads from</p> required <p>Returns:</p> Type Description <code>discord_typings.ListThreadsData</code> <p>A list of active threads</p> Source code in <code>naff\\api\\http\\http_requests\\threads.py</code> <pre><code>async def list_active_threads(self, guild_id: \"Snowflake_Type\") -&gt; discord_typings.ListThreadsData:\n\"\"\"\n    List active threads within a guild.\n\n    Args:\n        guild_id: the guild id to get threads from\n\n    Returns:\n        A list of active threads\n\n    \"\"\"\n    return await self.request(Route(\"GET\", f\"/guilds/{guild_id}/threads/active\"))\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.threads.ThreadRequests.create_thread","title":"<code>create_thread(channel_id, name, auto_archive_duration, thread_type=MISSING, invitable=MISSING, message_id=MISSING, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a thread in the given channel. Can either create a thread with or without a message.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel to create this thread in</p> required <code>name</code> <code>str</code> <p>The name of the thread</p> required <code>auto_archive_duration</code> <code>int</code> <p>duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080</p> required <code>thread_type</code> <code>Absent[int]</code> <p>The type of thread, defaults to public. ignored if creating thread from a message</p> <code>MISSING</code> <code>invitable</code> <code>Absent[bool]</code> <code>MISSING</code> <code>message_id</code> <code>Absent[Snowflake_Type]</code> <p>An optional message to create a thread from.</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>An optional reason for the audit log</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>discord_typings.ThreadChannelData</code> <p>The created thread</p> Source code in <code>naff\\api\\http\\http_requests\\threads.py</code> <pre><code>async def create_thread(\n    self,\n    channel_id: \"Snowflake_Type\",\n    name: str,\n    auto_archive_duration: int,\n    thread_type: Absent[int] = MISSING,\n    invitable: Absent[bool] = MISSING,\n    message_id: Absent[\"Snowflake_Type\"] = MISSING,\n    reason: Absent[str] = MISSING,\n) -&gt; discord_typings.ThreadChannelData:\n\"\"\"\n    Create a thread in the given channel. Can either create a thread with or without a message.\n\n    Args:\n        channel_id: The ID of the channel to create this thread in\n        name: The name of the thread\n        auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\n        thread_type: The type of thread, defaults to public. ignored if creating thread from a message\n        invitable:\n        message_id: An optional message to create a thread from.\n        reason: An optional reason for the audit log\n\n    Returns:\n        The created thread\n\n    \"\"\"\n    payload = {\"name\": name, \"auto_archive_duration\": auto_archive_duration}\n    if message_id:\n        return await self.request(\n            Route(\"POST\", f\"/channels/{channel_id}/messages/{message_id}/threads\"), payload=payload, reason=reason\n        )\n    else:\n        payload[\"type\"] = thread_type or ChannelTypes.GUILD_PUBLIC_THREAD\n        payload[\"invitable\"] = invitable\n        return await self.request(Route(\"POST\", f\"/channels/{channel_id}/threads\"), payload=payload, reason=reason)\n</code></pre>"},{"location":"API%20Reference/API_Communication/HTTP/Supported_Endpoints/#naff.api.http.http_requests.threads.ThreadRequests.create_forum_thread","title":"<code>create_forum_thread(channel_id, name, auto_archive_duration, message, applied_tags=None, rate_limit_per_user=MISSING, files=MISSING, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a thread within a forum channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The id of the forum channel</p> required <code>name</code> <code>str</code> <p>The name of the thread</p> required <code>auto_archive_duration</code> <code>int</code> <p>Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.</p> required <code>message</code> <code>dict | FormData</code> <p>The message-content for the post/thread</p> required <code>applied_tags</code> <code>List[str]</code> <p>The tags to apply to the thread</p> <code>None</code> <code>rate_limit_per_user</code> <code>Absent[int]</code> <p>The time users must wait between sending messages</p> <code>MISSING</code> <code>files</code> <code>Absent[UPLOADABLE_TYPE]</code> <p>The files to upload</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for creating this thread</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>dict</code> <p>The created thread object</p> Source code in <code>naff\\api\\http\\http_requests\\threads.py</code> <pre><code>async def create_forum_thread(\n    self,\n    channel_id: \"Snowflake_Type\",\n    name: str,\n    auto_archive_duration: int,\n    message: dict | FormData,\n    applied_tags: List[str] = None,\n    rate_limit_per_user: Absent[int] = MISSING,\n    files: Absent[\"UPLOADABLE_TYPE\"] = MISSING,\n    reason: Absent[str] = MISSING,\n) -&gt; dict:\n\"\"\"\n    Create a thread within a forum channel.\n\n    Args:\n        channel_id: The id of the forum channel\n        name: The name of the thread\n        auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.\n        message: The message-content for the post/thread\n        applied_tags: The tags to apply to the thread\n        rate_limit_per_user: The time users must wait between sending messages\n        files: The files to upload\n        reason: The reason for creating this thread\n\n    Returns:\n        The created thread object\n    \"\"\"\n    return await self.request(\n        Route(\"POST\", f\"/channels/{channel_id}/threads\"),\n        payload={\n            \"name\": name,\n            \"auto_archive_duration\": auto_archive_duration,\n            \"rate_limit_per_user\": rate_limit_per_user,\n            \"message\": message,\n            \"applied_tags\": applied_tags,\n        },\n        files=files,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/","title":"Connection state","text":""},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState","title":"<code>ConnectionState</code>","text":"Source code in <code>naff\\api\\gateway\\state.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ConnectionState:\n    client: \"Client\"\n\"\"\"The bot's client\"\"\"\n    intents: Intents\n\"\"\"The event intents in use\"\"\"\n    shard_id: int\n\"\"\"The shard ID of this state\"\"\"\n    _shard_ready: asyncio.Event = attrs.field(repr=False, default=None)\n\"\"\"Indicates that this state is now ready\"\"\"\n\n    gateway: Absent[GatewayClient] = MISSING\n\"\"\"The websocket connection for the Discord Gateway.\"\"\"\n\n    start_time: Absent[datetime] = MISSING\n\"\"\"The DateTime the bot started at\"\"\"\n\n    gateway_url: str = MISSING\n\"\"\"The URL that the gateway should connect to.\"\"\"\n\n    gateway_started: asyncio.Event = asyncio.Event()\n\"\"\"Event to check if the gateway has been started.\"\"\"\n\n    _shard_task: asyncio.Task | None = None\n\n    logger: Logger = attrs.field(repr=False, init=False, factory=get_logger)\n\n    def __attrs_post_init__(self, *args, **kwargs) -&gt; None:\n        self._shard_ready = asyncio.Event()\n\n    @property\n    def latency(self) -&gt; float:\n\"\"\"Returns the latency of the websocket connection.\"\"\"\n        return self.gateway.average_latency\n\n    @property\n    def average_latency(self) -&gt; float:\n\"\"\"Returns the average latency of the websocket connection.\"\"\"\n        return self.gateway.average_latency\n\n    @property\n    def presence(self) -&gt; dict:\n\"\"\"Returns the presence of the bot.\"\"\"\n        return {\n            \"status\": self.client._status,\n            \"activities\": [self.client._activity.to_dict()] if self.client._activity else [],\n        }\n\n    async def start(self) -&gt; None:\n\"\"\"Connect to the Discord Gateway.\"\"\"\n        self.gateway_url = await self.client.http.get_gateway()\n\n        self.logger.debug(f\"Starting Shard ID {self.shard_id}\")\n        self.start_time = datetime.now()\n        self._shard_task = asyncio.create_task(self._ws_connect())\n\n        self.gateway_started.set()\n\n        # Historically this method didn't return until the connection closed\n        # so we need to wait for the task to exit.\n        await self._shard_task\n\n    async def stop(self) -&gt; None:\n\"\"\"Disconnect from the Discord Gateway.\"\"\"\n        self.logger.debug(f\"Shutting down shard ID {self.shard_id}\")\n        if self.gateway is not None:\n            self.gateway.close()\n            self.gateway = None\n\n        if self._shard_task is not None:\n            await self._shard_task\n            self._shard_task = None\n\n        self.gateway_started.clear()\n\n    def clear_ready(self) -&gt; None:\n\"\"\"Clear the ready event.\"\"\"\n        self._shard_ready.clear()\n        self.client._ready.clear()  # noinspection PyProtectedMember\n\n    async def _ws_connect(self) -&gt; None:\n\"\"\"Connect to the Discord Gateway.\"\"\"\n        self.logger.info(f\"Shard {self.shard_id} is attempting to connect to gateway...\")\n        try:\n            async with GatewayClient(self, (self.shard_id, self.client.total_shards)) as self.gateway:\n                try:\n                    await self.gateway.run()\n                finally:\n                    self._shard_ready.clear()\n                    if self.client.total_shards == 1:\n                        self.client.dispatch(events.Disconnect())\n                    else:\n                        self.client.dispatch(events.ShardDisconnect(self.shard_id))\n\n        except WebSocketClosed as ex:\n            if ex.code == 4011:\n                raise NaffException(\"Your bot is too large, you must use shards\") from None\n            elif ex.code == 4013:\n                raise NaffException(f\"Invalid Intents have been passed: {self.intents}\") from None\n            elif ex.code == 4014:\n                raise NaffException(\n                    \"You have requested privileged intents that have not been enabled or approved. Check the developer dashboard\"\n                ) from None\n            raise\n\n        except Exception as e:\n            self.client.dispatch(events.Disconnect())\n            self.logger.error(\"\".join(traceback.format_exception(type(e), e, e.__traceback__)))\n\n    async def change_presence(\n        self, status: Optional[Union[str, Status]] = Status.ONLINE, activity: Absent[Union[Activity, str]] = MISSING\n    ) -&gt; None:\n\"\"\"\n        Change the bots presence.\n\n        Args:\n            status: The status for the bot to be. i.e. online, afk, etc.\n            activity: The activity for the bot to be displayed as doing.\n\n        !!! note\n            Bots may only be `playing` `streaming` `listening` `watching` or `competing`, other activity types are likely to fail.\n\n        \"\"\"\n        if activity is not MISSING:\n            if activity is None:\n                activity = []\n            else:\n                if not isinstance(activity, Activity):\n                    # squash whatever the user passed into an activity\n                    activity = Activity.create(name=str(activity))\n\n                if activity.type == ActivityType.STREAMING:\n                    if not activity.url:\n                        self.logger.warning(\"Streaming activity cannot be set without a valid URL attribute\")\n                elif activity.type not in [\n                    ActivityType.GAME,\n                    ActivityType.STREAMING,\n                    ActivityType.LISTENING,\n                    ActivityType.WATCHING,\n                    ActivityType.COMPETING,\n                ]:\n                    self.logger.warning(\n                        f\"Activity type `{ActivityType(activity.type).name}` may not be enabled for bots\"\n                    )\n        else:\n            activity = self.client.activity\n\n        if status:\n            if not isinstance(status, Status):\n                try:\n                    status = Status[status.upper()]\n                except KeyError:\n                    raise ValueError(f\"`{status}` is not a valid status type. Please use the Status enum\") from None\n        else:\n            # in case the user set status to None\n            if self.client.status:\n                status = self.client.status\n            else:\n                self.logger.warning(\"Status must be set to a valid status type, defaulting to online\")\n                status = Status.ONLINE\n\n        self.client._status = status\n        self.client._activity = activity\n        await self.gateway.change_presence(activity.to_dict() if activity else None, status)\n\n    def get_voice_state(self, guild_id: \"Snowflake_Type\") -&gt; Optional[\"naff.ActiveVoiceState\"]:\n\"\"\"\n        Get the bot's voice state for a guild.\n\n        Args:\n            guild_id: The target guild's id.\n\n        Returns:\n            The bot's voice state for the guild if connected, otherwise None.\n\n        \"\"\"\n        return self.client.cache.get_bot_voice_state(guild_id)\n\n    async def voice_connect(\n        self, guild_id: \"Snowflake_Type\", channel_id: \"Snowflake_Type\", muted: bool = False, deafened: bool = False\n    ) -&gt; \"naff.ActiveVoiceState\":\n\"\"\"\n        Connect to a voice channel.\n\n        Args:\n            guild_id: id of the guild the voice channel is in.\n            channel_id: id of the voice channel client wants to join.\n            muted: Whether the bot should be muted when connected.\n            deafened: Whether the bot should be deafened when connected.\n\n        Returns:\n            The new active voice state on successfully connection.\n\n        \"\"\"\n        voice_state = naff.ActiveVoiceState(\n            client=self.client, guild_id=guild_id, channel_id=channel_id, self_mute=muted, self_deaf=deafened\n        )\n        await voice_state.connect()\n        self.client.cache.place_bot_voice_state(voice_state)\n        return voice_state\n</code></pre>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.client","title":"<code>client: Client</code>  <code>class-attribute</code>","text":"<p>The bot's client</p>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.intents","title":"<code>intents: Intents</code>  <code>class-attribute</code>","text":"<p>The event intents in use</p>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.shard_id","title":"<code>shard_id: int</code>  <code>class-attribute</code>","text":"<p>The shard ID of this state</p>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.gateway","title":"<code>gateway: Absent[GatewayClient] = MISSING</code>  <code>class-attribute</code>","text":"<p>The websocket connection for the Discord Gateway.</p>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.start_time","title":"<code>start_time: Absent[datetime] = MISSING</code>  <code>class-attribute</code>","text":"<p>The DateTime the bot started at</p>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.gateway_url","title":"<code>gateway_url: str = MISSING</code>  <code>class-attribute</code>","text":"<p>The URL that the gateway should connect to.</p>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.gateway_started","title":"<code>gateway_started: asyncio.Event = asyncio.Event()</code>  <code>class-attribute</code>","text":"<p>Event to check if the gateway has been started.</p>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.latency","title":"<code>latency: float</code>  <code>property</code>","text":"<p>Returns the latency of the websocket connection.</p>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.average_latency","title":"<code>average_latency: float</code>  <code>property</code>","text":"<p>Returns the average latency of the websocket connection.</p>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.presence","title":"<code>presence: dict</code>  <code>property</code>","text":"<p>Returns the presence of the bot.</p>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Connect to the Discord Gateway.</p> Source code in <code>naff\\api\\gateway\\state.py</code> <pre><code>async def start(self) -&gt; None:\n\"\"\"Connect to the Discord Gateway.\"\"\"\n    self.gateway_url = await self.client.http.get_gateway()\n\n    self.logger.debug(f\"Starting Shard ID {self.shard_id}\")\n    self.start_time = datetime.now()\n    self._shard_task = asyncio.create_task(self._ws_connect())\n\n    self.gateway_started.set()\n\n    # Historically this method didn't return until the connection closed\n    # so we need to wait for the task to exit.\n    await self._shard_task\n</code></pre>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Disconnect from the Discord Gateway.</p> Source code in <code>naff\\api\\gateway\\state.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Disconnect from the Discord Gateway.\"\"\"\n    self.logger.debug(f\"Shutting down shard ID {self.shard_id}\")\n    if self.gateway is not None:\n        self.gateway.close()\n        self.gateway = None\n\n    if self._shard_task is not None:\n        await self._shard_task\n        self._shard_task = None\n\n    self.gateway_started.clear()\n</code></pre>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.clear_ready","title":"<code>clear_ready()</code>","text":"<p>Clear the ready event.</p> Source code in <code>naff\\api\\gateway\\state.py</code> <pre><code>def clear_ready(self) -&gt; None:\n\"\"\"Clear the ready event.\"\"\"\n    self._shard_ready.clear()\n    self.client._ready.clear()  # noinspection PyProtectedMember\n</code></pre>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.change_presence","title":"<code>change_presence(status=Status.ONLINE, activity=MISSING)</code>  <code>async</code>","text":"<p>Change the bots presence.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Optional[Union[str, Status]]</code> <p>The status for the bot to be. i.e. online, afk, etc.</p> <code>Status.ONLINE</code> <code>activity</code> <code>Absent[Union[Activity, str]]</code> <p>The activity for the bot to be displayed as doing.</p> <code>MISSING</code> <p>Note</p> <p>Bots may only be <code>playing</code> <code>streaming</code> <code>listening</code> <code>watching</code> or <code>competing</code>, other activity types are likely to fail.</p> Source code in <code>naff\\api\\gateway\\state.py</code> <pre><code>async def change_presence(\n    self, status: Optional[Union[str, Status]] = Status.ONLINE, activity: Absent[Union[Activity, str]] = MISSING\n) -&gt; None:\n\"\"\"\n    Change the bots presence.\n\n    Args:\n        status: The status for the bot to be. i.e. online, afk, etc.\n        activity: The activity for the bot to be displayed as doing.\n\n    !!! note\n        Bots may only be `playing` `streaming` `listening` `watching` or `competing`, other activity types are likely to fail.\n\n    \"\"\"\n    if activity is not MISSING:\n        if activity is None:\n            activity = []\n        else:\n            if not isinstance(activity, Activity):\n                # squash whatever the user passed into an activity\n                activity = Activity.create(name=str(activity))\n\n            if activity.type == ActivityType.STREAMING:\n                if not activity.url:\n                    self.logger.warning(\"Streaming activity cannot be set without a valid URL attribute\")\n            elif activity.type not in [\n                ActivityType.GAME,\n                ActivityType.STREAMING,\n                ActivityType.LISTENING,\n                ActivityType.WATCHING,\n                ActivityType.COMPETING,\n            ]:\n                self.logger.warning(\n                    f\"Activity type `{ActivityType(activity.type).name}` may not be enabled for bots\"\n                )\n    else:\n        activity = self.client.activity\n\n    if status:\n        if not isinstance(status, Status):\n            try:\n                status = Status[status.upper()]\n            except KeyError:\n                raise ValueError(f\"`{status}` is not a valid status type. Please use the Status enum\") from None\n    else:\n        # in case the user set status to None\n        if self.client.status:\n            status = self.client.status\n        else:\n            self.logger.warning(\"Status must be set to a valid status type, defaulting to online\")\n            status = Status.ONLINE\n\n    self.client._status = status\n    self.client._activity = activity\n    await self.gateway.change_presence(activity.to_dict() if activity else None, status)\n</code></pre>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.get_voice_state","title":"<code>get_voice_state(guild_id)</code>","text":"<p>Get the bot's voice state for a guild.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>The target guild's id.</p> required <p>Returns:</p> Type Description <code>Optional[ActiveVoiceState]</code> <p>The bot's voice state for the guild if connected, otherwise None.</p> Source code in <code>naff\\api\\gateway\\state.py</code> <pre><code>def get_voice_state(self, guild_id: \"Snowflake_Type\") -&gt; Optional[\"naff.ActiveVoiceState\"]:\n\"\"\"\n    Get the bot's voice state for a guild.\n\n    Args:\n        guild_id: The target guild's id.\n\n    Returns:\n        The bot's voice state for the guild if connected, otherwise None.\n\n    \"\"\"\n    return self.client.cache.get_bot_voice_state(guild_id)\n</code></pre>"},{"location":"API%20Reference/API_Communication/gateway/connection_state/#naff.api.gateway.state.ConnectionState.voice_connect","title":"<code>voice_connect(guild_id, channel_id, muted=False, deafened=False)</code>  <code>async</code>","text":"<p>Connect to a voice channel.</p> <p>Parameters:</p> Name Type Description Default <code>guild_id</code> <code>Snowflake_Type</code> <p>id of the guild the voice channel is in.</p> required <code>channel_id</code> <code>Snowflake_Type</code> <p>id of the voice channel client wants to join.</p> required <code>muted</code> <code>bool</code> <p>Whether the bot should be muted when connected.</p> <code>False</code> <code>deafened</code> <code>bool</code> <p>Whether the bot should be deafened when connected.</p> <code>False</code> <p>Returns:</p> Type Description <code>ActiveVoiceState</code> <p>The new active voice state on successfully connection.</p> Source code in <code>naff\\api\\gateway\\state.py</code> <pre><code>async def voice_connect(\n    self, guild_id: \"Snowflake_Type\", channel_id: \"Snowflake_Type\", muted: bool = False, deafened: bool = False\n) -&gt; \"naff.ActiveVoiceState\":\n\"\"\"\n    Connect to a voice channel.\n\n    Args:\n        guild_id: id of the guild the voice channel is in.\n        channel_id: id of the voice channel client wants to join.\n        muted: Whether the bot should be muted when connected.\n        deafened: Whether the bot should be deafened when connected.\n\n    Returns:\n        The new active voice state on successfully connection.\n\n    \"\"\"\n    voice_state = naff.ActiveVoiceState(\n        client=self.client, guild_id=guild_id, channel_id=channel_id, self_mute=muted, self_deaf=deafened\n    )\n    await voice_state.connect()\n    self.client.cache.place_bot_voice_state(voice_state)\n    return voice_state\n</code></pre>"},{"location":"API%20Reference/API_Communication/gateway/gateway/","title":"Gateway","text":"<p>This file outlines the interaction between naff and Discord's Gateway API.</p>"},{"location":"API%20Reference/API_Communication/gateway/gateway/#naff.api.gateway.gateway.GatewayClient","title":"<code>GatewayClient</code>","text":"<p>         Bases: <code>WebsocketClient</code></p> <p>Abstraction over one gateway connection.</p> <p>Multiple <code>WebsocketClient</code> instances can be used to implement same-process sharding.</p> <p>Attributes:</p> Name Type Description <code>sequence</code> <p>The sequence of this connection</p> <code>session_id</code> <p>The session ID of this connection</p> Source code in <code>naff\\api\\gateway\\gateway.py</code> <pre><code>class GatewayClient(WebsocketClient):\n\"\"\"\n    Abstraction over one gateway connection.\n\n    Multiple `WebsocketClient` instances can be used to implement same-process sharding.\n\n    Attributes:\n        sequence: The sequence of this connection\n        session_id: The session ID of this connection\n\n    \"\"\"\n\n    def __init__(self, state: \"ConnectionState\", shard: tuple[int, int]) -&gt; None:\n        super().__init__(state)\n\n        self.shard = shard\n\n        self.chunk_cache = {}\n\n        self._trace = []\n        self.sequence = None\n        self.session_id = None\n\n        self.ws_url = state.gateway_url\n        self.ws_resume_url = MISSING\n\n        # This lock needs to be held to send something over the gateway, but is also held when\n        # reconnecting. That way there's no race conditions between sending and reconnecting.\n        self._race_lock = asyncio.Lock()\n        # Then this event is used so that receive() can wait for the reconnecting to complete.\n        self._closed = asyncio.Event()\n\n        self._keep_alive = None\n        self._kill_bee_gees = asyncio.Event()\n        self._last_heartbeat = 0\n        self._acknowledged = asyncio.Event()\n        self._acknowledged.set()  # Initialize it as set\n\n        self._ready = asyncio.Event()\n        self._close_gateway = asyncio.Event()\n\n        # Sanity check, it is extremely important that an instance isn't reused.\n        self._entered = False\n\n    async def __aenter__(self: SELF) -&gt; SELF:\n        if self._entered:\n            raise RuntimeError(\"An instance of 'WebsocketClient' cannot be re-used!\")\n\n        self._entered = True\n        self._zlib = zlib.decompressobj()\n\n        self.ws = await self.state.client.http.websocket_connect(self.state.gateway_url)\n\n        hello = await self.receive(force=True)\n        self.heartbeat_interval = hello[\"d\"][\"heartbeat_interval\"] / 1000\n        self._closed.set()\n\n        self._keep_alive = asyncio.create_task(self.run_bee_gees())\n\n        await self._identify()\n\n        return self\n\n    async def __aexit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, traceback: TracebackType | None\n    ) -&gt; None:\n        # Technically should not be possible in any way, but might as well be safe worst-case.\n        self._close_gateway.set()\n\n        try:\n            if self._keep_alive is not None:\n                self._kill_bee_gees.set()\n                try:\n                    # Even if we get cancelled that is fine, because then the keep-alive\n                    # handler will also be cancelled since we're waiting on it.\n                    await self._keep_alive  # Wait for the keep-alive handler to finish\n                finally:\n                    self._keep_alive = None\n        finally:\n            if self.ws is not None:\n                # We could be cancelled here, it is extremely important that we close the\n                # WebSocket either way, hence the try/except.\n                try:\n                    await self.ws.close(code=1000)\n                finally:\n                    self.ws = None\n\n    @property\n    def average_latency(self) -&gt; float:\n\"\"\"Get the average latency of the connection.\"\"\"\n        if self.latency:\n            return sum(self.latency) / len(self.latency)\n        else:\n            return float(\"inf\")\n\n    async def run(self) -&gt; None:\n\"\"\"Start receiving events from the websocket.\"\"\"\n        while True:\n            if self._stopping is None:\n                self._stopping = asyncio.create_task(self._close_gateway.wait())\n            receiving = asyncio.create_task(self.receive())\n            done, _ = await asyncio.wait({self._stopping, receiving}, return_when=asyncio.FIRST_COMPLETED)\n\n            if receiving in done:\n                # Note that we check for a received message first, because if both completed at\n                # the same time, we don't want to discard that message.\n                msg = await receiving\n            else:\n                # This has to be the stopping task, which we join into the current task (even\n                # though that doesn't give any meaningful value in the return).\n                await self._stopping\n                receiving.cancel()\n                return\n\n            op = msg.get(\"op\")\n            data = msg.get(\"d\")\n            seq = msg.get(\"s\")\n            event = msg.get(\"t\")\n\n            if seq:\n                self.sequence = seq\n\n            if op == OPCODE.DISPATCH:\n                asyncio.create_task(self.dispatch_event(data, seq, event))\n                continue\n\n            # This may try to reconnect the connection so it is best to wait\n            # for it to complete before receiving more - that way there's less\n            # possible race conditions to consider.\n            await self.dispatch_opcode(data, op)\n\n    async def dispatch_opcode(self, data, op: OPCODE) -&gt; None:\n        match op:\n\n            case OPCODE.HEARTBEAT:\n                self.logger.debug(\"Received heartbeat request from gateway\")\n                return await self.send_heartbeat()\n\n            case OPCODE.HEARTBEAT_ACK:\n                self.latency.append(time.perf_counter() - self._last_heartbeat)\n\n                if self._last_heartbeat != 0 and self.latency[-1] &gt;= 15:\n                    self.logger.warning(\n                        f\"High Latency! shard ID {self.shard[0]} heartbeat took {self.latency[-1]:.1f}s to be acknowledged!\"\n                    )\n                else:\n                    self.logger.debug(f\"\u2764 Heartbeat acknowledged after {self.latency[-1]:.5f} seconds\")\n\n                return self._acknowledged.set()\n\n            case OPCODE.RECONNECT:\n                self.logger.debug(\"Gateway requested reconnect. Reconnecting...\")\n                return await self.reconnect(resume=True, url=self.ws_resume_url)\n\n            case OPCODE.INVALIDATE_SESSION:\n                self.logger.warning(\"Gateway has invalidated session! Reconnecting...\")\n                return await self.reconnect()\n\n            case _:\n                return self.logger.debug(f\"Unhandled OPCODE: {op} = {OPCODE(op).name}\")\n\n    async def dispatch_event(self, data, seq, event) -&gt; None:\n        match event:\n            case \"READY\":\n                self._ready.set()\n                self._trace = data.get(\"_trace\", [])\n                self.sequence = seq\n                self.session_id = data[\"session_id\"]\n                self.ws_resume_url = (\n                    f\"{data['resume_gateway_url']}?encoding=json&amp;v={__api_version__}&amp;compress=zlib-stream\"\n                )\n                self.logger.info(f\"Shard {self.shard[0]} has connected to gateway!\")\n                self.logger.debug(f\"Session ID: {self.session_id} Trace: {self._trace}\")\n                return self.state.client.dispatch(events.WebsocketReady(data))\n\n            case \"RESUMED\":\n                self.logger.info(f\"Successfully resumed connection! Session_ID: {self.session_id}\")\n                self.state.client.dispatch(events.Resume())\n                return\n\n            case \"GUILD_MEMBERS_CHUNK\":\n                asyncio.create_task(self._process_member_chunk(data.copy()))\n\n            case _:\n                # the above events are \"special\", and are handled by the gateway itself, the rest can be dispatched\n                event_name = f\"raw_{event.lower()}\"\n                processor = self.state.client.processors.get(event_name)\n                if processor:\n                    try:\n                        asyncio.create_task(processor(events.RawGatewayEvent(data.copy(), override_name=event_name)))\n                    except Exception as ex:\n                        self.logger.error(f\"Failed to run event processor for {event_name}: {ex}\")\n                else:\n                    self.logger.debug(f\"No processor for `{event_name}`\")\n\n        self.state.client.dispatch(events.RawGatewayEvent(data.copy(), override_name=\"raw_gateway_event\"))\n        self.state.client.dispatch(events.RawGatewayEvent(data.copy(), override_name=f\"raw_{event.lower()}\"))\n\n    def close(self) -&gt; None:\n\"\"\"Shutdown the websocket connection.\"\"\"\n        self._close_gateway.set()\n\n    async def _identify(self) -&gt; None:\n\"\"\"Send an identify payload to the gateway.\"\"\"\n        if self.ws is None:\n            raise RuntimeError\n        payload = {\n            \"op\": OPCODE.IDENTIFY,\n            \"d\": {\n                \"token\": self.state.client.http.token,\n                \"intents\": self.state.intents,\n                \"shard\": self.shard,\n                \"large_threshold\": 250,\n                \"properties\": {\"os\": sys.platform, \"browser\": \"naff\", \"device\": \"naff\"},\n                \"presence\": self.state.presence,\n            },\n            \"compress\": True,\n        }\n\n        serialized = OverriddenJson.dumps(payload)\n        await self.ws.send_str(serialized)\n\n        self.logger.debug(\n            f\"Shard ID {self.shard[0]} has identified itself to Gateway, requesting intents: {self.state.intents}!\"\n        )\n\n    async def reconnect(self, *, resume: bool = False, code: int = 1012, url: str | None = None) -&gt; None:\n        self.state.clear_ready()\n        self._ready.clear()\n        await super().reconnect(resume=resume, code=code, url=url)\n\n    async def _resume_connection(self) -&gt; None:\n\"\"\"Send a resume payload to the gateway.\"\"\"\n        if self.ws is None:\n            raise RuntimeError\n\n        payload = {\n            \"op\": OPCODE.RESUME,\n            \"d\": {\"token\": self.state.client.http.token, \"seq\": self.sequence, \"session_id\": self.session_id},\n        }\n\n        serialized = OverriddenJson.dumps(payload)\n        await self.ws.send_str(serialized)\n\n        self.logger.debug(f\"{self.shard[0]} is attempting to resume a connection\")\n\n    async def send_heartbeat(self) -&gt; None:\n        await self.send_json({\"op\": OPCODE.HEARTBEAT, \"d\": self.sequence}, bypass=True)\n        self.logger.debug(f\"\u2764 Shard {self.shard[0]} is sending a Heartbeat\")\n\n    async def change_presence(self, activity=None, status: Status = Status.ONLINE, since=None) -&gt; None:\n\"\"\"Update the bot's presence status.\"\"\"\n        payload = dict_filter_none(\n            {\n                \"since\": int(since if since else time.time() * 1000),\n                \"activities\": [activity] if activity else [],\n                \"status\": status,\n                \"afk\": False,\n            }\n        )\n        await self.send_json({\"op\": OPCODE.PRESENCE, \"d\": payload})\n\n    async def request_member_chunks(\n        self,\n        guild_id: \"Snowflake_Type\",\n        query=\"\",\n        *,\n        limit,\n        user_ids=None,\n        presences=False,\n        nonce=None,\n    ) -&gt; None:\n        payload = {\n            \"op\": OPCODE.REQUEST_MEMBERS,\n            \"d\": dict_filter_none(\n                {\n                    \"guild_id\": guild_id,\n                    \"presences\": presences,\n                    \"limit\": limit,\n                    \"nonce\": nonce,\n                    \"user_ids\": user_ids,\n                    \"query\": query,\n                }\n            ),\n        }\n        await self.send_json(payload)\n\n    async def _process_member_chunk(self, chunk: dict) -&gt; None:\n\n        guild = self.state.client.cache.get_guild(to_snowflake(chunk.get(\"guild_id\")))\n        if guild:\n            return asyncio.create_task(guild.process_member_chunk(chunk))\n        raise ValueError(f\"No guild exists for {chunk.get('guild_id')}\")\n\n    async def voice_state_update(\n        self, guild_id: \"Snowflake_Type\", channel_id: \"Snowflake_Type\", muted: bool = False, deafened: bool = False\n    ) -&gt; None:\n\"\"\"Update the bot's voice state.\"\"\"\n        payload = {\n            \"op\": OPCODE.VOICE_STATE,\n            \"d\": {\"guild_id\": guild_id, \"channel_id\": channel_id, \"self_mute\": muted, \"self_deaf\": deafened},\n        }\n        await self.send_json(payload)\n</code></pre>"},{"location":"API%20Reference/API_Communication/gateway/gateway/#naff.api.gateway.gateway.GatewayClient.average_latency","title":"<code>average_latency: float</code>  <code>property</code>","text":"<p>Get the average latency of the connection.</p>"},{"location":"API%20Reference/API_Communication/gateway/gateway/#naff.api.gateway.gateway.GatewayClient.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Start receiving events from the websocket.</p> Source code in <code>naff\\api\\gateway\\gateway.py</code> <pre><code>async def run(self) -&gt; None:\n\"\"\"Start receiving events from the websocket.\"\"\"\n    while True:\n        if self._stopping is None:\n            self._stopping = asyncio.create_task(self._close_gateway.wait())\n        receiving = asyncio.create_task(self.receive())\n        done, _ = await asyncio.wait({self._stopping, receiving}, return_when=asyncio.FIRST_COMPLETED)\n\n        if receiving in done:\n            # Note that we check for a received message first, because if both completed at\n            # the same time, we don't want to discard that message.\n            msg = await receiving\n        else:\n            # This has to be the stopping task, which we join into the current task (even\n            # though that doesn't give any meaningful value in the return).\n            await self._stopping\n            receiving.cancel()\n            return\n\n        op = msg.get(\"op\")\n        data = msg.get(\"d\")\n        seq = msg.get(\"s\")\n        event = msg.get(\"t\")\n\n        if seq:\n            self.sequence = seq\n\n        if op == OPCODE.DISPATCH:\n            asyncio.create_task(self.dispatch_event(data, seq, event))\n            continue\n\n        # This may try to reconnect the connection so it is best to wait\n        # for it to complete before receiving more - that way there's less\n        # possible race conditions to consider.\n        await self.dispatch_opcode(data, op)\n</code></pre>"},{"location":"API%20Reference/API_Communication/gateway/gateway/#naff.api.gateway.gateway.GatewayClient.close","title":"<code>close()</code>","text":"<p>Shutdown the websocket connection.</p> Source code in <code>naff\\api\\gateway\\gateway.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Shutdown the websocket connection.\"\"\"\n    self._close_gateway.set()\n</code></pre>"},{"location":"API%20Reference/API_Communication/gateway/gateway/#naff.api.gateway.gateway.GatewayClient.change_presence","title":"<code>change_presence(activity=None, status=Status.ONLINE, since=None)</code>  <code>async</code>","text":"<p>Update the bot's presence status.</p> Source code in <code>naff\\api\\gateway\\gateway.py</code> <pre><code>async def change_presence(self, activity=None, status: Status = Status.ONLINE, since=None) -&gt; None:\n\"\"\"Update the bot's presence status.\"\"\"\n    payload = dict_filter_none(\n        {\n            \"since\": int(since if since else time.time() * 1000),\n            \"activities\": [activity] if activity else [],\n            \"status\": status,\n            \"afk\": False,\n        }\n    )\n    await self.send_json({\"op\": OPCODE.PRESENCE, \"d\": payload})\n</code></pre>"},{"location":"API%20Reference/API_Communication/gateway/gateway/#naff.api.gateway.gateway.GatewayClient.voice_state_update","title":"<code>voice_state_update(guild_id, channel_id, muted=False, deafened=False)</code>  <code>async</code>","text":"<p>Update the bot's voice state.</p> Source code in <code>naff\\api\\gateway\\gateway.py</code> <pre><code>async def voice_state_update(\n    self, guild_id: \"Snowflake_Type\", channel_id: \"Snowflake_Type\", muted: bool = False, deafened: bool = False\n) -&gt; None:\n\"\"\"Update the bot's voice state.\"\"\"\n    payload = {\n        \"op\": OPCODE.VOICE_STATE,\n        \"d\": {\"guild_id\": guild_id, \"channel_id\": channel_id, \"self_mute\": muted, \"self_deaf\": deafened},\n    }\n    await self.send_json(payload)\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/audio/","title":"Audio","text":""},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.AudioBuffer","title":"<code>AudioBuffer</code>","text":"Source code in <code>naff\\api\\voice\\audio.py</code> <pre><code>class AudioBuffer:\n    def __init__(self) -&gt; None:\n        self._buffer = bytearray()\n        self._lock = threading.Lock()\n        self.initialised = threading.Event()\n\n    def __len__(self) -&gt; int:\n        return len(self._buffer)\n\n    def extend(self, data: bytes) -&gt; None:\n\"\"\"\n        Extend the buffer with additional data.\n\n        Args:\n            data: The data to add\n        \"\"\"\n        with self._lock:\n            self._buffer.extend(data)\n\n    def read(self, total_bytes: int) -&gt; bytearray:\n\"\"\"\n        Read `total_bytes` bytes of audio from the buffer.\n\n        Args:\n            total_bytes: Amount of bytes to read.\n\n        Returns:\n            Desired amount of bytes\n        \"\"\"\n        with self._lock:\n            view = memoryview(self._buffer)\n            self._buffer = bytearray(view[total_bytes:])\n            data = bytearray(view[:total_bytes])\n            if 0 &lt; len(data) &lt; total_bytes:\n                # pad incomplete frames with 0's\n                data.extend(b\"\\0\" * (total_bytes - len(data)))\n            return data\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.AudioBuffer.extend","title":"<code>extend(data)</code>","text":"<p>Extend the buffer with additional data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The data to add</p> required Source code in <code>naff\\api\\voice\\audio.py</code> <pre><code>def extend(self, data: bytes) -&gt; None:\n\"\"\"\n    Extend the buffer with additional data.\n\n    Args:\n        data: The data to add\n    \"\"\"\n    with self._lock:\n        self._buffer.extend(data)\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.AudioBuffer.read","title":"<code>read(total_bytes)</code>","text":"<p>Read <code>total_bytes</code> bytes of audio from the buffer.</p> <p>Parameters:</p> Name Type Description Default <code>total_bytes</code> <code>int</code> <p>Amount of bytes to read.</p> required <p>Returns:</p> Type Description <code>bytearray</code> <p>Desired amount of bytes</p> Source code in <code>naff\\api\\voice\\audio.py</code> <pre><code>def read(self, total_bytes: int) -&gt; bytearray:\n\"\"\"\n    Read `total_bytes` bytes of audio from the buffer.\n\n    Args:\n        total_bytes: Amount of bytes to read.\n\n    Returns:\n        Desired amount of bytes\n    \"\"\"\n    with self._lock:\n        view = memoryview(self._buffer)\n        self._buffer = bytearray(view[total_bytes:])\n        data = bytearray(view[:total_bytes])\n        if 0 &lt; len(data) &lt; total_bytes:\n            # pad incomplete frames with 0's\n            data.extend(b\"\\0\" * (total_bytes - len(data)))\n        return data\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.BaseAudio","title":"<code>BaseAudio</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Base structure of the audio.</p> Source code in <code>naff\\api\\voice\\audio.py</code> <pre><code>class BaseAudio(ABC):\n\"\"\"Base structure of the audio.\"\"\"\n\n    locked_stream: bool\n\"\"\"Prevents the audio task from closing automatically when no data is received.\"\"\"\n    needs_encode: bool\n\"\"\"Does this audio data need encoding with opus?\"\"\"\n    bitrate: Optional[int]\n\"\"\"Optionally specify a specific bitrate to encode this audio data with\"\"\"\n\n    def __del__(self) -&gt; None:\n        self.cleanup()\n\n    @abstractmethod\n    def cleanup(self) -&gt; None:\n\"\"\"A method to optionally cleanup after this object is no longer required.\"\"\"\n        ...\n\n    @property\n    def audio_complete(self) -&gt; bool:\n\"\"\"A property to tell the player if more audio is expected.\"\"\"\n        return False\n\n    @abstractmethod\n    def read(self, frame_size: int) -&gt; bytes:\n\"\"\"\n        Reads frame_size ms of audio from source.\n\n        returns:\n            bytes of audio\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.BaseAudio.locked_stream","title":"<code>locked_stream: bool</code>  <code>class-attribute</code>","text":"<p>Prevents the audio task from closing automatically when no data is received.</p>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.BaseAudio.needs_encode","title":"<code>needs_encode: bool</code>  <code>class-attribute</code>","text":"<p>Does this audio data need encoding with opus?</p>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.BaseAudio.bitrate","title":"<code>bitrate: Optional[int]</code>  <code>class-attribute</code>","text":"<p>Optionally specify a specific bitrate to encode this audio data with</p>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.BaseAudio.cleanup","title":"<code>cleanup()</code>  <code>abstractmethod</code>","text":"<p>A method to optionally cleanup after this object is no longer required.</p> Source code in <code>naff\\api\\voice\\audio.py</code> <pre><code>@abstractmethod\ndef cleanup(self) -&gt; None:\n\"\"\"A method to optionally cleanup after this object is no longer required.\"\"\"\n    ...\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.BaseAudio.audio_complete","title":"<code>audio_complete: bool</code>  <code>property</code>","text":"<p>A property to tell the player if more audio is expected.</p>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.BaseAudio.read","title":"<code>read(frame_size)</code>  <code>abstractmethod</code>","text":"<p>Reads frame_size ms of audio from source.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>bytes of audio</p> Source code in <code>naff\\api\\voice\\audio.py</code> <pre><code>@abstractmethod\ndef read(self, frame_size: int) -&gt; bytes:\n\"\"\"\n    Reads frame_size ms of audio from source.\n\n    returns:\n        bytes of audio\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.Audio","title":"<code>Audio</code>","text":"<p>         Bases: <code>BaseAudio</code></p> <p>Audio for playing from file or URL.</p> Source code in <code>naff\\api\\voice\\audio.py</code> <pre><code>class Audio(BaseAudio):\n\"\"\"Audio for playing from file or URL.\"\"\"\n\n    source: str\n\"\"\"The source ffmpeg should use to play the audio\"\"\"\n    process: subprocess.Popen\n\"\"\"The ffmpeg process to use\"\"\"\n    buffer: AudioBuffer\n\"\"\"The audio objects buffer to prevent stuttering\"\"\"\n    buffer_seconds: int\n\"\"\"How many seconds of audio should be buffered\"\"\"\n    read_ahead_task: threading.Thread\n\"\"\"A thread that reads ahead to create the buffer\"\"\"\n    ffmpeg_args: str | list[str]\n\"\"\"Args to pass to ffmpeg\"\"\"\n    ffmpeg_before_args: str | list[str]\n\"\"\"Args to pass to ffmpeg before the source\"\"\"\n\n    def __init__(self, src: Union[str, Path]) -&gt; None:\n        self.source = src\n        self.needs_encode = True\n        self.locked_stream = False\n        self.process: Optional[subprocess.Popen] = None\n\n        self.buffer = AudioBuffer()\n\n        self.buffer_seconds = 3\n        self.read_ahead_task = threading.Thread(target=self._read_ahead, daemon=True)\n\n        self.ffmpeg_before_args = \"\"\n        self.ffmpeg_args = \"\"\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{type(self).__name__}: {self.source}&gt;\"\n\n    @property\n    def _max_buffer_size(self) -&gt; int:\n        # 1ms of audio * (buffer seconds * 1000)\n        return 192 * (self.buffer_seconds * 1000)\n\n    @property\n    def audio_complete(self) -&gt; bool:\n\"\"\"Uses the state of the subprocess to determine if more audio is coming\"\"\"\n        if self.process:\n            if self.process.poll() is None:\n                return False\n        return True\n\n    def _create_process(self, *, block: bool = True) -&gt; None:\n        before = (\n            self.ffmpeg_before_args if isinstance(self.ffmpeg_before_args, list) else self.ffmpeg_before_args.split()\n        )\n        after = self.ffmpeg_args if isinstance(self.ffmpeg_args, list) else self.ffmpeg_args.split()\n        cmd = [\n            \"ffmpeg\",\n            \"-i\",\n            self.source,\n            \"-f\",\n            \"s16le\",\n            \"-ar\",\n            \"48000\",\n            \"-ac\",\n            \"2\",\n            \"-loglevel\",\n            \"warning\",\n            \"pipe:1\",\n            \"-vn\",\n        ]\n        cmd[1:1] = before\n        cmd.extend(after)\n\n        self.process = subprocess.Popen(  # noqa: S603\n            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.DEVNULL\n        )\n        self.read_ahead_task.start()\n\n        if block:\n            # block until some data is in the buffer\n            self.buffer.initialised.wait()\n\n    def _read_ahead(self) -&gt; None:\n        while self.process:\n            if self.process.poll() is not None:\n                # ffmpeg has exited, stop reading ahead\n                if not self.buffer.initialised.is_set():\n                    # assume this is a small file and initialise the buffer\n                    self.buffer.initialised.set()\n\n                return\n            if not len(self.buffer) &gt;= self._max_buffer_size:\n                self.buffer.extend(self.process.stdout.read(3840))\n            else:\n                if not self.buffer.initialised.is_set():\n                    self.buffer.initialised.set()\n                time.sleep(0.1)\n\n    def pre_buffer(self, duration: None | float = None) -&gt; None:\n\"\"\"\n        Start pre-buffering the audio.\n\n        Args:\n            duration: The duration of audio to pre-buffer.\n        \"\"\"\n        if duration:\n            self.buffer_seconds = duration\n\n        if self.process and self.process.poll() is None:\n            raise RuntimeError(\"Cannot pre-buffer an already running process\")\n        # sanity value enforcement to prevent audio weirdness\n        self.buffer = AudioBuffer()\n        self.buffer.initialised.clear()\n\n        self._create_process(block=False)\n\n    def read(self, frame_size: int) -&gt; bytes:\n\"\"\"\n        Reads frame_size bytes of audio from the buffer.\n\n        returns:\n            bytes of audio\n        \"\"\"\n        if not self.process:\n            self._create_process()\n        if not self.buffer.initialised.is_set():\n            # we cannot start playing until the buffer is initialised\n            self.buffer.initialised.wait()\n\n        data = self.buffer.read(frame_size)\n\n        if len(data) != frame_size:\n            data = b\"\"\n\n        return bytes(data)\n\n    def cleanup(self) -&gt; None:\n\"\"\"Cleans up after this audio object.\"\"\"\n        if self.process and self.process.poll() is None:\n            self.process.kill()\n            self.process.wait()\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.Audio.audio_complete","title":"<code>audio_complete: bool</code>  <code>property</code>","text":"<p>Uses the state of the subprocess to determine if more audio is coming</p>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.Audio.pre_buffer","title":"<code>pre_buffer(duration=None)</code>","text":"<p>Start pre-buffering the audio.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>None | float</code> <p>The duration of audio to pre-buffer.</p> <code>None</code> Source code in <code>naff\\api\\voice\\audio.py</code> <pre><code>def pre_buffer(self, duration: None | float = None) -&gt; None:\n\"\"\"\n    Start pre-buffering the audio.\n\n    Args:\n        duration: The duration of audio to pre-buffer.\n    \"\"\"\n    if duration:\n        self.buffer_seconds = duration\n\n    if self.process and self.process.poll() is None:\n        raise RuntimeError(\"Cannot pre-buffer an already running process\")\n    # sanity value enforcement to prevent audio weirdness\n    self.buffer = AudioBuffer()\n    self.buffer.initialised.clear()\n\n    self._create_process(block=False)\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.Audio.read","title":"<code>read(frame_size)</code>","text":"<p>Reads frame_size bytes of audio from the buffer.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>bytes of audio</p> Source code in <code>naff\\api\\voice\\audio.py</code> <pre><code>def read(self, frame_size: int) -&gt; bytes:\n\"\"\"\n    Reads frame_size bytes of audio from the buffer.\n\n    returns:\n        bytes of audio\n    \"\"\"\n    if not self.process:\n        self._create_process()\n    if not self.buffer.initialised.is_set():\n        # we cannot start playing until the buffer is initialised\n        self.buffer.initialised.wait()\n\n    data = self.buffer.read(frame_size)\n\n    if len(data) != frame_size:\n        data = b\"\"\n\n    return bytes(data)\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.Audio.cleanup","title":"<code>cleanup()</code>","text":"<p>Cleans up after this audio object.</p> Source code in <code>naff\\api\\voice\\audio.py</code> <pre><code>def cleanup(self) -&gt; None:\n\"\"\"Cleans up after this audio object.\"\"\"\n    if self.process and self.process.poll() is None:\n        self.process.kill()\n        self.process.wait()\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.AudioVolume","title":"<code>AudioVolume</code>","text":"<p>         Bases: <code>Audio</code></p> <p>An audio object with volume control</p> Source code in <code>naff\\api\\voice\\audio.py</code> <pre><code>class AudioVolume(Audio):\n\"\"\"An audio object with volume control\"\"\"\n\n    _volume: float\n\"\"\"The internal volume level of the audio\"\"\"\n\n    def __init__(self, src: Union[str, Path]) -&gt; None:\n        super().__init__(src)\n        self._volume = 0.5\n\n    @property\n    def volume(self) -&gt; float:\n\"\"\"The volume of the audio\"\"\"\n        return self._volume\n\n    @volume.setter\n    def volume(self, value: float) -&gt; None:\n\"\"\"Sets the volume of the audio. Volume cannot be negative.\"\"\"\n        self._volume = max(value, 0.0)\n\n    def read(self, frame_size: int) -&gt; bytes:\n\"\"\"\n        Reads frame_size ms of audio from source.\n\n        returns:\n            bytes of audio\n        \"\"\"\n        data = super().read(frame_size)\n        return audioop.mul(data, 2, self._volume)\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.AudioVolume.volume","title":"<code>volume: float</code>  <code>property</code> <code>writable</code>","text":"<p>The volume of the audio</p>"},{"location":"API%20Reference/API_Communication/voice/audio/#naff.api.voice.audio.AudioVolume.read","title":"<code>read(frame_size)</code>","text":"<p>Reads frame_size ms of audio from source.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>bytes of audio</p> Source code in <code>naff\\api\\voice\\audio.py</code> <pre><code>def read(self, frame_size: int) -&gt; bytes:\n\"\"\"\n    Reads frame_size ms of audio from source.\n\n    returns:\n        bytes of audio\n    \"\"\"\n    data = super().read(frame_size)\n    return audioop.mul(data, 2, self._volume)\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/player/","title":"Player","text":""},{"location":"API%20Reference/API_Communication/voice/player/#naff.api.voice.player.Player","title":"<code>Player</code>","text":"<p>         Bases: <code>threading.Thread</code></p> Source code in <code>naff\\api\\voice\\player.py</code> <pre><code>class Player(threading.Thread):\n    def __init__(self, audio, v_state, loop) -&gt; None:\n        super().__init__()\n        self.daemon = True\n\n        self.current_audio: Optional[BaseAudio] = audio\n        self.state: \"ActiveVoiceState\" = v_state\n        self.loop: AbstractEventLoop = loop\n        self.logger: Logger = self.state.ws.logger\n\n        self._encoder: Encoder = Encoder()\n\n        self._resume: threading.Event = threading.Event()\n\n        self._stop_event: threading.Event = threading.Event()\n        self._stopped: asyncio.Event = asyncio.Event()\n\n        self._sent_payloads: int = 0\n\n        self._cond = threading.Condition()\n\n        if not shutil.which(\"ffmpeg\"):\n            raise RuntimeError(\n                \"Unable to start player. FFmpeg was not found. Please add it to your project directory or PATH. (https://ffmpeg.org/)\"\n            )\n\n    def __enter__(self) -&gt; \"Player\":\n        self.state.ws.cond = self._cond\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        try:\n            self.state.ws.cond = None\n        except AttributeError:\n            pass\n\n    def stop(self) -&gt; None:\n\"\"\"Stop playing completely.\"\"\"\n        self._stop_event.set()\n        with self._cond:\n            self._cond.notify()\n\n    def resume(self) -&gt; None:\n\"\"\"Resume playing.\"\"\"\n        self._resume.set()\n        with self._cond:\n            self._cond.notify()\n\n    @property\n    def paused(self) -&gt; bool:\n\"\"\"Is the player paused\"\"\"\n        return not self._resume.is_set()\n\n    def pause(self) -&gt; None:\n\"\"\"Pause the player.\"\"\"\n        self._resume.clear()\n\n    @property\n    def stopped(self) -&gt; bool:\n\"\"\"Is the player currently stopped?\"\"\"\n        return self._stopped.is_set()\n\n    @property\n    def elapsed_time(self) -&gt; float:\n\"\"\"How many seconds of audio the player has sent.\"\"\"\n        return self._sent_payloads * self._encoder.delay\n\n    def play(self) -&gt; None:\n\"\"\"Start playing.\"\"\"\n        self._stop_event.clear()\n        self._resume.set()\n        self.start()\n\n    def run(self) -&gt; None:\n\"\"\"The main player loop to send audio to the voice websocket.\"\"\"\n        loops = 0\n\n        if isinstance(self.current_audio, AudioVolume):\n            # noinspection PyProtectedMember\n            self.current_audio.volume = self.state._volume\n\n        self._encoder.set_bitrate(getattr(self.current_audio, \"bitrate\", self.state.channel.bitrate))\n\n        self._stopped.clear()\n\n        asyncio.run_coroutine_threadsafe(self.state.ws.speaking(True), self.loop)\n        self.logger.debug(f\"Now playing {self.current_audio!r}\")\n        start = None\n\n        try:\n            while not self._stop_event.is_set():\n                if not self.state.ws.ready.is_set() or not self._resume.is_set():\n                    run_coroutine_threadsafe(self.state.ws.speaking(False), self.loop)\n                    self.logger.debug(\"Voice playback has been suspended!\")\n\n                    wait_for = []\n\n                    if not self.state.ws.ready.is_set():\n                        wait_for.append(self.state.ws.ready)\n                    if not self._resume.is_set():\n                        wait_for.append(self._resume)\n\n                    with self._cond:\n                        while not (self._stop_event.is_set() or all(x.is_set() for x in wait_for)):\n                            self._cond.wait()\n                    if self._stop_event.is_set():\n                        continue\n\n                    run_coroutine_threadsafe(self.state.ws.speaking(), self.loop)\n                    self.logger.debug(\"Voice playback has been resumed!\")\n                    start = None\n                    loops = 0\n\n                if data := self.current_audio.read(self._encoder.frame_size):\n                    self.state.ws.send_packet(data, self._encoder, needs_encode=self.current_audio.needs_encode)\n                else:\n                    if self.current_audio.locked_stream or not self.current_audio.audio_complete:\n                        # if more audio is expected\n                        self.state.ws.send_packet(b\"\\xF8\\xFF\\xFE\", self._encoder, needs_encode=False)\n                    else:\n                        break\n\n                if not start:\n                    start = perf_counter()\n\n                loops += 1\n                self._sent_payloads += 1  # used for duration calc\n                sleep(max(0.0, start + (self._encoder.delay * loops) - perf_counter()))\n        finally:\n            asyncio.run_coroutine_threadsafe(self.state.ws.speaking(False), self.loop)\n            self.current_audio.cleanup()\n            self.loop.call_soon_threadsafe(self._stopped.set)\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/player/#naff.api.voice.player.Player.stop","title":"<code>stop()</code>","text":"<p>Stop playing completely.</p> Source code in <code>naff\\api\\voice\\player.py</code> <pre><code>def stop(self) -&gt; None:\n\"\"\"Stop playing completely.\"\"\"\n    self._stop_event.set()\n    with self._cond:\n        self._cond.notify()\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/player/#naff.api.voice.player.Player.resume","title":"<code>resume()</code>","text":"<p>Resume playing.</p> Source code in <code>naff\\api\\voice\\player.py</code> <pre><code>def resume(self) -&gt; None:\n\"\"\"Resume playing.\"\"\"\n    self._resume.set()\n    with self._cond:\n        self._cond.notify()\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/player/#naff.api.voice.player.Player.paused","title":"<code>paused: bool</code>  <code>property</code>","text":"<p>Is the player paused</p>"},{"location":"API%20Reference/API_Communication/voice/player/#naff.api.voice.player.Player.pause","title":"<code>pause()</code>","text":"<p>Pause the player.</p> Source code in <code>naff\\api\\voice\\player.py</code> <pre><code>def pause(self) -&gt; None:\n\"\"\"Pause the player.\"\"\"\n    self._resume.clear()\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/player/#naff.api.voice.player.Player.stopped","title":"<code>stopped: bool</code>  <code>property</code>","text":"<p>Is the player currently stopped?</p>"},{"location":"API%20Reference/API_Communication/voice/player/#naff.api.voice.player.Player.elapsed_time","title":"<code>elapsed_time: float</code>  <code>property</code>","text":"<p>How many seconds of audio the player has sent.</p>"},{"location":"API%20Reference/API_Communication/voice/player/#naff.api.voice.player.Player.play","title":"<code>play()</code>","text":"<p>Start playing.</p> Source code in <code>naff\\api\\voice\\player.py</code> <pre><code>def play(self) -&gt; None:\n\"\"\"Start playing.\"\"\"\n    self._stop_event.clear()\n    self._resume.set()\n    self.start()\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/player/#naff.api.voice.player.Player.run","title":"<code>run()</code>","text":"<p>The main player loop to send audio to the voice websocket.</p> Source code in <code>naff\\api\\voice\\player.py</code> <pre><code>def run(self) -&gt; None:\n\"\"\"The main player loop to send audio to the voice websocket.\"\"\"\n    loops = 0\n\n    if isinstance(self.current_audio, AudioVolume):\n        # noinspection PyProtectedMember\n        self.current_audio.volume = self.state._volume\n\n    self._encoder.set_bitrate(getattr(self.current_audio, \"bitrate\", self.state.channel.bitrate))\n\n    self._stopped.clear()\n\n    asyncio.run_coroutine_threadsafe(self.state.ws.speaking(True), self.loop)\n    self.logger.debug(f\"Now playing {self.current_audio!r}\")\n    start = None\n\n    try:\n        while not self._stop_event.is_set():\n            if not self.state.ws.ready.is_set() or not self._resume.is_set():\n                run_coroutine_threadsafe(self.state.ws.speaking(False), self.loop)\n                self.logger.debug(\"Voice playback has been suspended!\")\n\n                wait_for = []\n\n                if not self.state.ws.ready.is_set():\n                    wait_for.append(self.state.ws.ready)\n                if not self._resume.is_set():\n                    wait_for.append(self._resume)\n\n                with self._cond:\n                    while not (self._stop_event.is_set() or all(x.is_set() for x in wait_for)):\n                        self._cond.wait()\n                if self._stop_event.is_set():\n                    continue\n\n                run_coroutine_threadsafe(self.state.ws.speaking(), self.loop)\n                self.logger.debug(\"Voice playback has been resumed!\")\n                start = None\n                loops = 0\n\n            if data := self.current_audio.read(self._encoder.frame_size):\n                self.state.ws.send_packet(data, self._encoder, needs_encode=self.current_audio.needs_encode)\n            else:\n                if self.current_audio.locked_stream or not self.current_audio.audio_complete:\n                    # if more audio is expected\n                    self.state.ws.send_packet(b\"\\xF8\\xFF\\xFE\", self._encoder, needs_encode=False)\n                else:\n                    break\n\n            if not start:\n                start = perf_counter()\n\n            loops += 1\n            self._sent_payloads += 1  # used for duration calc\n            sleep(max(0.0, start + (self._encoder.delay * loops) - perf_counter()))\n    finally:\n        asyncio.run_coroutine_threadsafe(self.state.ws.speaking(False), self.loop)\n        self.current_audio.cleanup()\n        self.loop.call_soon_threadsafe(self._stopped.set)\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/voice_gateway/","title":"Voice gateway","text":""},{"location":"API%20Reference/API_Communication/voice/voice_gateway/#naff.api.voice.voice_gateway.VoiceGateway","title":"<code>VoiceGateway</code>","text":"<p>         Bases: <code>WebsocketClient</code></p> Source code in <code>naff\\api\\voice\\voice_gateway.py</code> <pre><code>class VoiceGateway(WebsocketClient):\n    guild_id: str\n    heartbeat_interval: int\n    session_id: str\n    token: str\n    encryptor: Encryption\n\n    ssrc: int\n    me_ip: str\n    me_port: int\n    voice_ip: str\n    voice_port: int\n    voice_modes: list[str]\n    selected_mode: str\n    socket: socket.socket\n    ready: Event\n\n    def __init__(self, state, voice_state: dict, voice_server: dict) -&gt; None:\n        super().__init__(state)\n\n        self._voice_server_update = asyncio.Event()\n        self.ws_url = f\"wss://{voice_server['endpoint']}?v=4\"\n        self.session_id = voice_state[\"session_id\"]\n        self.token = voice_server[\"token\"]\n        self.guild_id = voice_server[\"guild_id\"]\n\n        self.sock_sequence = 0\n        self.timestamp = 0\n        self.ready = Event()\n        self.cond = None\n\n    async def wait_until_ready(self) -&gt; None:\n        await asyncio.to_thread(self.ready.wait)\n\n    async def run(self) -&gt; None:\n\"\"\"Start receiving events from the websocket.\"\"\"\n        while True:\n            if self._stopping is None:\n                self._stopping = asyncio.create_task(self._close_gateway.wait())\n            receiving = asyncio.create_task(self.receive())\n            done, _ = await asyncio.wait({self._stopping, receiving}, return_when=asyncio.FIRST_COMPLETED)\n\n            if receiving in done:\n                # Note that we check for a received message first, because if both completed at\n                # the same time, we don't want to discard that message.\n                msg = await receiving\n            else:\n                # This has to be the stopping task, which we join into the current task (even\n                # though that doesn't give any meaningful value in the return).\n                await self._stopping\n                receiving.cancel()\n                return\n\n            op = msg.get(\"op\")\n            data = msg.get(\"d\")\n            seq = msg.get(\"s\")\n\n            if seq:\n                self.sequence = seq\n\n            # This may try to reconnect the connection so it is best to wait\n            # for it to complete before receiving more - that way there's less\n            # possible race conditions to consider.\n            await self.dispatch_opcode(data, op)\n\n    async def receive(self, force=False) -&gt; str:\n        buffer = bytearray()\n\n        while True:\n            if not force:\n                await self._closed.wait()\n\n            resp = await self.ws.receive()\n\n            if resp.type == WSMsgType.CLOSE:\n                self.logger.debug(f\"Disconnecting from voice gateway! Reason: {resp.data}::{resp.extra}\")\n                if resp.data in (4006, 4009, 4014, 4015):\n                    # these are all recoverable close codes, anything else means we're foobared\n                    # codes: session expired, session timeout, disconnected, server crash\n                    self.ready.clear()\n                    # docs state only resume on 4015\n                    await self.reconnect(resume=resp.data == 4015)\n                    continue\n                raise VoiceWebSocketClosed(resp.data)\n\n            elif resp.type is WSMsgType.CLOSED:\n                if force:\n                    raise RuntimeError(\"Discord unexpectedly closed the underlying socket during force receive!\")\n\n                if not self._closed.is_set():\n                    # Because we are waiting for the even before we receive, this shouldn't be\n                    # possible - the CLOSING message should be returned instead. Either way, if this\n                    # is possible after all we can just wait for the event to be set.\n                    await self._closed.wait()\n                else:\n                    # This is an odd corner-case where the underlying socket connection was closed\n                    # unexpectedly without communicating the WebSocket closing handshake. We'll have\n                    # to reconnect ourselves.\n                    await self.reconnect(resume=True)\n\n            elif resp.type is WSMsgType.CLOSING:\n                if force:\n                    raise RuntimeError(\"WebSocket is unexpectedly closing during force receive!\")\n\n                # This happens when the keep-alive handler is reconnecting the connection even\n                # though we waited for the event before hand, because it got to run while we waited\n                # for data to come in. We can just wait for the event again.\n                await self._closed.wait()\n                continue\n\n            if resp.data is None:\n                continue\n\n            if isinstance(resp.data, bytes):\n                buffer.extend(resp.data)\n\n                if len(resp.data) &lt; 4 or resp.data[-4:] != b\"\\x00\\x00\\xff\\xff\":\n                    # message isn't complete yet, wait\n                    continue\n\n                msg = self._zlib.decompress(buffer)\n                msg = msg.decode(\"utf-8\")\n            else:\n                msg = resp.data\n\n            try:\n                msg = OverriddenJson.loads(msg)\n            except Exception as e:\n                self.logger.error(e)\n\n            return msg\n\n    async def dispatch_opcode(self, data, op) -&gt; None:\n        match op:\n            case OP.HEARTBEAT_ACK:\n                self.latency.append(time.perf_counter() - self._last_heartbeat)\n\n                if self._last_heartbeat != 0 and self.latency[-1] &gt;= 15:\n                    self.logger.warning(\n                        f\"High Latency! Voice heartbeat took {self.latency[-1]:.1f}s to be acknowledged!\"\n                    )\n                else:\n                    self.logger.debug(f\"\u2764 Heartbeat acknowledged after {self.latency[-1]:.5f} seconds\")\n\n                return self._acknowledged.set()\n\n            case OP.READY:\n                self.logger.debug(\"Discord send VC Ready! Establishing a socket connection...\")\n                self.voice_ip = data[\"ip\"]\n                self.voice_port = data[\"port\"]\n                self.ssrc = data[\"ssrc\"]\n                self.voice_modes = [mode for mode in data[\"modes\"] if mode in Encryption.SUPPORTED]\n\n                if len(self.voice_modes) == 0:\n                    self.logger.critical(\"NO VOICE ENCRYPTION MODES SHARED WITH GATEWAY!\")\n\n                await self.establish_voice_socket()\n\n            case OP.SESSION_DESCRIPTION:\n                self.logger.info(f\"Voice connection established; using {data['mode']}\")\n                self.encryptor = Encryption(data[\"secret_key\"])\n                self.ready.set()\n                if self.cond:\n                    with self.cond:\n                        self.cond.notify()\n\n            case _:\n                return self.logger.debug(f\"Unhandled OPCODE: {op} = {data = }\")\n\n    async def reconnect(self, *, resume: bool = False, code: int = 1012) -&gt; None:\n        async with self._race_lock:\n            self._closed.clear()\n\n            if self.ws is not None:\n                await self.ws.close(code=code)\n\n            self.ws = None\n\n            if not resume:\n                self.logger.debug(\"Waiting for updated server information...\")\n                try:\n                    await asyncio.wait_for(self._voice_server_update.wait(), timeout=5)\n                except asyncio.TimeoutError:\n                    self._kill_bee_gees.set()\n                    self.close()\n                    self.logger.debug(\"Terminating VoiceGateway due to disconnection\")\n                    return\n\n                self._voice_server_update.clear()\n\n            self.ws = await self.state.client.http.websocket_connect(self.ws_url)\n\n            try:\n                hello = await self.receive(force=True)\n                self.heartbeat_interval = hello[\"d\"][\"heartbeat_interval\"] / 1000\n            except RuntimeError:\n                # sometimes the initial connection fails with voice gateways, handle that\n                return await self.reconnect(resume=resume, code=code)\n\n            if not resume:\n                await self._identify()\n            else:\n                await self._resume_connection()\n\n            self._closed.set()\n            self._acknowledged.set()\n\n    async def _resume_connection(self) -&gt; None:\n        if self.ws is None:\n            raise RuntimeError\n\n        payload = {\n            \"op\": OP.RESUME,\n            \"d\": {\"server_id\": self.guild_id, \"session_id\": self.session_id, \"token\": self.token},\n        }\n        await self.ws.send_json(payload)\n\n    async def establish_voice_socket(self) -&gt; None:\n\"\"\"Establish the socket connection to discord\"\"\"\n        self.logger.debug(\"IP Discovery in progress...\")\n\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.socket.setblocking(False)\n\n        packet = bytearray(74)\n        struct.pack_into(\"&gt;H\", packet, 0, 1)  # 1 = Send\n        struct.pack_into(\"&gt;H\", packet, 2, 70)  # 70 = Length\n        struct.pack_into(\"&gt;I\", packet, 4, self.ssrc)\n\n        self.socket.sendto(packet, (self.voice_ip, self.voice_port))\n        resp = await self.loop.sock_recv(self.socket, 74)\n        self.logger.debug(f\"Voice Initial Response Received: {resp}\")\n\n        ip_start = 8\n        ip_end = resp.index(0, ip_start)\n        self.me_ip = resp[ip_start:ip_end].decode(\"ascii\")\n\n        self.me_port = struct.unpack_from(\"&gt;H\", resp, len(resp) - 2)[0]\n        self.logger.debug(f\"IP Discovered: {self.me_ip} #{self.me_port}\")\n\n        await self._select_protocol()\n\n    def generate_packet(self, data: bytes) -&gt; bytes:\n\"\"\"Generate a packet to be sent to the voice socket.\"\"\"\n        header = bytearray(12)\n        header[0] = 0x80\n        header[1] = 0x78\n\n        struct.pack_into(\"&gt;H\", header, 2, self.sock_sequence)\n        struct.pack_into(\"&gt;I\", header, 4, self.timestamp)\n        struct.pack_into(\"&gt;I\", header, 8, self.ssrc)\n\n        return self.encryptor.encrypt(self.voice_modes[0], header, data)\n\n    def send_packet(self, data: bytes, encoder, needs_encode=True) -&gt; None:\n\"\"\"Send a packet to the voice socket\"\"\"\n        self.sock_sequence += 1\n        if self.sock_sequence &gt; 0xFFFF:\n            self.sock_sequence = 0\n\n        if self.timestamp &gt; 0xFFFFFFFF:\n            self.timestamp = 0\n\n        if needs_encode:\n            data = encoder.encode(data)\n        packet = self.generate_packet(data)\n\n        self.socket.sendto(packet, (self.voice_ip, self.voice_port))\n        self.timestamp += encoder.samples_per_frame\n\n    async def send_heartbeat(self) -&gt; None:\n        await self.send_json({\"op\": OP.HEARTBEAT, \"d\": random.uniform(0.0, 1.0)})\n        self.logger.debug(\"\u2764 Voice Connection is sending Heartbeat\")\n\n    async def _identify(self) -&gt; None:\n\"\"\"Send an identify payload to the voice gateway.\"\"\"\n        payload = {\n            \"op\": OP.IDENTIFY,\n            \"d\": {\n                \"server_id\": self.guild_id,\n                \"user_id\": self.state.client.user.id,\n                \"session_id\": self.session_id,\n                \"token\": self.token,\n            },\n        }\n        serialized = OverriddenJson.dumps(payload)\n        await self.ws.send_str(serialized)\n\n        self.logger.debug(\"Voice Connection has identified itself to Voice Gateway\")\n\n    async def _select_protocol(self) -&gt; None:\n\"\"\"Inform Discord of our chosen protocol.\"\"\"\n        payload = {\n            \"op\": OP.SELECT_PROTOCOL,\n            \"d\": {\n                \"protocol\": \"udp\",\n                \"data\": {\"address\": self.me_ip, \"port\": self.me_port, \"mode\": self.voice_modes[0]},\n            },\n        }\n        await self.send_json(payload)\n\n    async def speaking(self, is_speaking: bool = True) -&gt; None:\n\"\"\"\n        Tell the gateway if we're sending audio or not.\n\n        Args:\n            is_speaking: If we're sending audio or not\n\n        \"\"\"\n        payload = {\n            \"op\": OP.SPEAKING,\n            \"d\": {\n                \"speaking\": 1 &lt;&lt; 0 if is_speaking else 0,\n                \"delay\": 0,\n                \"ssrc\": self.ssrc,\n            },\n        }\n        await self.ws.send_json(payload)\n\n    def set_new_voice_server(self, payload: dict) -&gt; None:\n\"\"\"\n        Set a new voice server to connect to.\n\n        Args:\n            payload: New voice server connection data\n\n        \"\"\"\n        self.ws_url = f\"wss://{payload['endpoint']}?v=4\"\n        self.token = payload[\"token\"]\n        self.guild_id = payload[\"guild_id\"]\n        self._voice_server_update.set()\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/voice_gateway/#naff.api.voice.voice_gateway.VoiceGateway.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Start receiving events from the websocket.</p> Source code in <code>naff\\api\\voice\\voice_gateway.py</code> <pre><code>async def run(self) -&gt; None:\n\"\"\"Start receiving events from the websocket.\"\"\"\n    while True:\n        if self._stopping is None:\n            self._stopping = asyncio.create_task(self._close_gateway.wait())\n        receiving = asyncio.create_task(self.receive())\n        done, _ = await asyncio.wait({self._stopping, receiving}, return_when=asyncio.FIRST_COMPLETED)\n\n        if receiving in done:\n            # Note that we check for a received message first, because if both completed at\n            # the same time, we don't want to discard that message.\n            msg = await receiving\n        else:\n            # This has to be the stopping task, which we join into the current task (even\n            # though that doesn't give any meaningful value in the return).\n            await self._stopping\n            receiving.cancel()\n            return\n\n        op = msg.get(\"op\")\n        data = msg.get(\"d\")\n        seq = msg.get(\"s\")\n\n        if seq:\n            self.sequence = seq\n\n        # This may try to reconnect the connection so it is best to wait\n        # for it to complete before receiving more - that way there's less\n        # possible race conditions to consider.\n        await self.dispatch_opcode(data, op)\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/voice_gateway/#naff.api.voice.voice_gateway.VoiceGateway.establish_voice_socket","title":"<code>establish_voice_socket()</code>  <code>async</code>","text":"<p>Establish the socket connection to discord</p> Source code in <code>naff\\api\\voice\\voice_gateway.py</code> <pre><code>async def establish_voice_socket(self) -&gt; None:\n\"\"\"Establish the socket connection to discord\"\"\"\n    self.logger.debug(\"IP Discovery in progress...\")\n\n    self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    self.socket.setblocking(False)\n\n    packet = bytearray(74)\n    struct.pack_into(\"&gt;H\", packet, 0, 1)  # 1 = Send\n    struct.pack_into(\"&gt;H\", packet, 2, 70)  # 70 = Length\n    struct.pack_into(\"&gt;I\", packet, 4, self.ssrc)\n\n    self.socket.sendto(packet, (self.voice_ip, self.voice_port))\n    resp = await self.loop.sock_recv(self.socket, 74)\n    self.logger.debug(f\"Voice Initial Response Received: {resp}\")\n\n    ip_start = 8\n    ip_end = resp.index(0, ip_start)\n    self.me_ip = resp[ip_start:ip_end].decode(\"ascii\")\n\n    self.me_port = struct.unpack_from(\"&gt;H\", resp, len(resp) - 2)[0]\n    self.logger.debug(f\"IP Discovered: {self.me_ip} #{self.me_port}\")\n\n    await self._select_protocol()\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/voice_gateway/#naff.api.voice.voice_gateway.VoiceGateway.generate_packet","title":"<code>generate_packet(data)</code>","text":"<p>Generate a packet to be sent to the voice socket.</p> Source code in <code>naff\\api\\voice\\voice_gateway.py</code> <pre><code>def generate_packet(self, data: bytes) -&gt; bytes:\n\"\"\"Generate a packet to be sent to the voice socket.\"\"\"\n    header = bytearray(12)\n    header[0] = 0x80\n    header[1] = 0x78\n\n    struct.pack_into(\"&gt;H\", header, 2, self.sock_sequence)\n    struct.pack_into(\"&gt;I\", header, 4, self.timestamp)\n    struct.pack_into(\"&gt;I\", header, 8, self.ssrc)\n\n    return self.encryptor.encrypt(self.voice_modes[0], header, data)\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/voice_gateway/#naff.api.voice.voice_gateway.VoiceGateway.send_packet","title":"<code>send_packet(data, encoder, needs_encode=True)</code>","text":"<p>Send a packet to the voice socket</p> Source code in <code>naff\\api\\voice\\voice_gateway.py</code> <pre><code>def send_packet(self, data: bytes, encoder, needs_encode=True) -&gt; None:\n\"\"\"Send a packet to the voice socket\"\"\"\n    self.sock_sequence += 1\n    if self.sock_sequence &gt; 0xFFFF:\n        self.sock_sequence = 0\n\n    if self.timestamp &gt; 0xFFFFFFFF:\n        self.timestamp = 0\n\n    if needs_encode:\n        data = encoder.encode(data)\n    packet = self.generate_packet(data)\n\n    self.socket.sendto(packet, (self.voice_ip, self.voice_port))\n    self.timestamp += encoder.samples_per_frame\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/voice_gateway/#naff.api.voice.voice_gateway.VoiceGateway.speaking","title":"<code>speaking(is_speaking=True)</code>  <code>async</code>","text":"<p>Tell the gateway if we're sending audio or not.</p> <p>Parameters:</p> Name Type Description Default <code>is_speaking</code> <code>bool</code> <p>If we're sending audio or not</p> <code>True</code> Source code in <code>naff\\api\\voice\\voice_gateway.py</code> <pre><code>async def speaking(self, is_speaking: bool = True) -&gt; None:\n\"\"\"\n    Tell the gateway if we're sending audio or not.\n\n    Args:\n        is_speaking: If we're sending audio or not\n\n    \"\"\"\n    payload = {\n        \"op\": OP.SPEAKING,\n        \"d\": {\n            \"speaking\": 1 &lt;&lt; 0 if is_speaking else 0,\n            \"delay\": 0,\n            \"ssrc\": self.ssrc,\n        },\n    }\n    await self.ws.send_json(payload)\n</code></pre>"},{"location":"API%20Reference/API_Communication/voice/voice_gateway/#naff.api.voice.voice_gateway.VoiceGateway.set_new_voice_server","title":"<code>set_new_voice_server(payload)</code>","text":"<p>Set a new voice server to connect to.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>New voice server connection data</p> required Source code in <code>naff\\api\\voice\\voice_gateway.py</code> <pre><code>def set_new_voice_server(self, payload: dict) -&gt; None:\n\"\"\"\n    Set a new voice server to connect to.\n\n    Args:\n        payload: New voice server connection data\n\n    \"\"\"\n    self.ws_url = f\"wss://{payload['endpoint']}?v=4\"\n    self.token = payload[\"token\"]\n    self.guild_id = payload[\"guild_id\"]\n    self._voice_server_update.set()\n</code></pre>"},{"location":"API%20Reference/events/discord/","title":"Discord","text":"<p>These are events dispatched by Discord. This is intended as a reference so you know what data to expect for each event.</p> Example Usage: <p>The event classes outlined here are in <code>CamelCase</code> to comply with Class naming convention, however the event names are actually in <code>lower_case_with_underscores</code> so your listeners should be named as following:</p> <pre><code>@listen()\ndef on_ready():\n    # ready events pass no data, so dont have params\n    print(\"Im ready!\")\n\n@listen()\ndef on_guild_join(event):\n    # guild_create events pass a guild object, expect a single param\n    print(f\"{event.guild.name} created\")\n</code></pre> <p>Warning</p> <p>While all of these events are documented, not all of them are used, currently.</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.AutoModExec","title":"<code>AutoModExec</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when an auto modation action is executed</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass AutoModExec(BaseEvent):\n\"\"\"Dispatched when an auto modation action is executed\"\"\"\n\n    execution: \"AutoModerationAction\" = attrs.field(repr=False, metadata=docs(\"The executed auto mod action\"))\n    channel: \"BaseChannel\" = attrs.field(repr=False, metadata=docs(\"The channel the action was executed in\"))\n    guild: \"Guild\" = attrs.field(repr=False, metadata=docs(\"The guild the action was executed in\"))\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.AutoModUpdated","title":"<code>AutoModUpdated</code>","text":"<p>         Bases: <code>AutoModCreated</code></p> <p>Dispatched when an auto mod rule is modified</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass AutoModUpdated(AutoModCreated):\n\"\"\"Dispatched when an auto mod rule is modified\"\"\"\n\n    ...\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.AutoModDeleted","title":"<code>AutoModDeleted</code>","text":"<p>         Bases: <code>AutoModCreated</code></p> <p>Dispatched when an auto mod rule is deleted</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass AutoModDeleted(AutoModCreated):\n\"\"\"Dispatched when an auto mod rule is deleted\"\"\"\n\n    ...\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ChannelCreate","title":"<code>ChannelCreate</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a channel is created.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ChannelCreate(BaseEvent):\n\"\"\"Dispatched when a channel is created.\"\"\"\n\n    channel: \"BaseChannel\" = attrs.field(repr=False, metadata=docs(\"The channel this event is dispatched from\"))\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ChannelUpdate","title":"<code>ChannelUpdate</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a channel is updated.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ChannelUpdate(BaseEvent):\n\"\"\"Dispatched when a channel is updated.\"\"\"\n\n    before: \"BaseChannel\" = attrs.field(\n        repr=False,\n    )\n\"\"\"Channel before this event. MISSING if it was not cached before\"\"\"\n    after: \"BaseChannel\" = attrs.field(\n        repr=False,\n    )\n\"\"\"Channel after this event\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ChannelUpdate.before","title":"<code>before: BaseChannel = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>Channel before this event. MISSING if it was not cached before</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ChannelUpdate.after","title":"<code>after: BaseChannel = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>Channel after this event</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ChannelDelete","title":"<code>ChannelDelete</code>","text":"<p>         Bases: <code>ChannelCreate</code></p> <p>Dispatched when a channel is deleted.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ChannelDelete(ChannelCreate):\n\"\"\"Dispatched when a channel is deleted.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ChannelPinsUpdate","title":"<code>ChannelPinsUpdate</code>","text":"<p>         Bases: <code>ChannelCreate</code></p> <p>Dispatched when a channel's pins are updated.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ChannelPinsUpdate(ChannelCreate):\n\"\"\"Dispatched when a channel's pins are updated.\"\"\"\n\n    last_pin_timestamp: \"Timestamp\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The time at which the most recent pinned message was pinned\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ChannelPinsUpdate.last_pin_timestamp","title":"<code>last_pin_timestamp: Timestamp = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The time at which the most recent pinned message was pinned</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ThreadCreate","title":"<code>ThreadCreate</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a thread is created, or a thread is new to the client</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ThreadCreate(BaseEvent):\n\"\"\"Dispatched when a thread is created, or a thread is new to the client\"\"\"\n\n    thread: \"TYPE_THREAD_CHANNEL\" = attrs.field(repr=False, metadata=docs(\"The thread this event is dispatched from\"))\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.NewThreadCreate","title":"<code>NewThreadCreate</code>","text":"<p>         Bases: <code>ThreadCreate</code></p> <p>Dispatched when a thread is newly created.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass NewThreadCreate(ThreadCreate):\n\"\"\"Dispatched when a thread is newly created.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ThreadUpdate","title":"<code>ThreadUpdate</code>","text":"<p>         Bases: <code>ThreadCreate</code></p> <p>Dispatched when a thread is updated.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ThreadUpdate(ThreadCreate):\n\"\"\"Dispatched when a thread is updated.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ThreadDelete","title":"<code>ThreadDelete</code>","text":"<p>         Bases: <code>ThreadCreate</code></p> <p>Dispatched when a thread is deleted.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ThreadDelete(ThreadCreate):\n\"\"\"Dispatched when a thread is deleted.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ThreadListSync","title":"<code>ThreadListSync</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when gaining access to a channel, contains all active threads in that channel.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ThreadListSync(BaseEvent):\n\"\"\"Dispatched when gaining access to a channel, contains all active threads in that channel.\"\"\"\n\n    channel_ids: Sequence[\"Snowflake_Type\"] = attrs.field(\n        repr=False,\n    )\n\"\"\"The parent channel ids whose threads are being synced. If omitted, then threads were synced for the entire guild. This array may contain channel_ids that have no active threads as well, so you know to clear that data.\"\"\"\n    threads: List[\"BaseChannel\"] = attrs.field(\n        repr=False,\n    )\n\"\"\"all active threads in the given channels that the current user can access\"\"\"\n    members: List[\"Member\"] = attrs.field(\n        repr=False,\n    )\n\"\"\"all thread member objects from the synced threads for the current user, indicating which threads the current user has been added to\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ThreadListSync.channel_ids","title":"<code>channel_ids: Sequence[Snowflake_Type] = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The parent channel ids whose threads are being synced. If omitted, then threads were synced for the entire guild. This array may contain channel_ids that have no active threads as well, so you know to clear that data.</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ThreadListSync.threads","title":"<code>threads: List[BaseChannel] = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>all active threads in the given channels that the current user can access</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ThreadListSync.members","title":"<code>members: List[Member] = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>all thread member objects from the synced threads for the current user, indicating which threads the current user has been added to</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ThreadMemberUpdate","title":"<code>ThreadMemberUpdate</code>","text":"<p>         Bases: <code>ThreadCreate</code></p> <p>Dispatched when the thread member object for the current user is updated.</p> <p>??? info \"Note from Discord\"     This event is documented for completeness, but unlikely to be used by most bots. For bots, this event largely is just a signal that you are a member of the thread</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ThreadMemberUpdate(ThreadCreate):\n\"\"\"\n    Dispatched when the thread member object for the current user is updated.\n\n    ??? info \"Note from Discord\"     This event is documented for\n    completeness, but unlikely to be used by most bots. For bots, this\n    event largely is just a signal that you are a member of the thread\n\n    \"\"\"\n\n    member: \"Member\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The member who was added\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ThreadMemberUpdate.member","title":"<code>member: Member = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The member who was added</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ThreadMembersUpdate","title":"<code>ThreadMembersUpdate</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when anyone is added or removed from a thread.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ThreadMembersUpdate(BaseEvent):\n\"\"\"Dispatched when anyone is added or removed from a thread.\"\"\"\n\n    id: \"Snowflake_Type\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The ID of the thread\"\"\"\n    member_count: int = attrs.field(repr=False, default=50)\n\"\"\"the approximate number of members in the thread, capped at 50\"\"\"\n    added_members: List[\"Member\"] = attrs.field(repr=False, factory=list)\n\"\"\"Users added to the thread\"\"\"\n    removed_member_ids: List[\"Snowflake_Type\"] = attrs.field(repr=False, factory=list)\n\"\"\"Users removed from the thread\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ThreadMembersUpdate.id","title":"<code>id: Snowflake_Type = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The ID of the thread</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ThreadMembersUpdate.member_count","title":"<code>member_count: int = attrs.field(repr=False, default=50)</code>  <code>class-attribute</code>","text":"<p>the approximate number of members in the thread, capped at 50</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ThreadMembersUpdate.added_members","title":"<code>added_members: List[Member] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>Users added to the thread</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.ThreadMembersUpdate.removed_member_ids","title":"<code>removed_member_ids: List[Snowflake_Type] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>Users removed from the thread</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildJoin","title":"<code>GuildJoin</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Dispatched when a guild is joined, created, or becomes available.</p> <p>Note</p> <p>This is called multiple times during startup, check the bot is ready before responding to this.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass GuildJoin(GuildEvent):\n\"\"\"\n    Dispatched when a guild is joined, created, or becomes available.\n\n    !!! note\n        This is called multiple times during startup, check the bot is ready before responding to this.\n\n    \"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildUpdate","title":"<code>GuildUpdate</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a guild is updated.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass GuildUpdate(BaseEvent):\n\"\"\"Dispatched when a guild is updated.\"\"\"\n\n    before: \"Guild\" = attrs.field(\n        repr=False,\n    )\n\"\"\"Guild before this event\"\"\"\n    after: \"Guild\" = attrs.field(\n        repr=False,\n    )\n\"\"\"Guild after this event\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildUpdate.before","title":"<code>before: Guild = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>Guild before this event</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildUpdate.after","title":"<code>after: Guild = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>Guild after this event</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildLeft","title":"<code>GuildLeft</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a guild is left.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass GuildLeft(BaseEvent):\n\"\"\"Dispatched when a guild is left.\"\"\"\n\n    guild: \"Guild\" = attrs.field(repr=True)\n\"\"\"The guild this event is dispatched from\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildLeft.guild","title":"<code>guild: Guild = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>The guild this event is dispatched from</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildAvailable","title":"<code>GuildAvailable</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Dispatched when a guild becomes available.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass GuildAvailable(GuildEvent):\n\"\"\"Dispatched when a guild becomes available.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildUnavailable","title":"<code>GuildUnavailable</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Dispatched when a guild is not available.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass GuildUnavailable(GuildEvent):\n\"\"\"Dispatched when a guild is not available.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.BanCreate","title":"<code>BanCreate</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Dispatched when someone was banned from a guild.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass BanCreate(GuildEvent):\n\"\"\"Dispatched when someone was banned from a guild.\"\"\"\n\n    user: \"BaseUser\" = attrs.field(repr=False, metadata=docs(\"The user\"))\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.BanRemove","title":"<code>BanRemove</code>","text":"<p>         Bases: <code>BanCreate</code></p> <p>Dispatched when a users ban is removed.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass BanRemove(BanCreate):\n\"\"\"Dispatched when a users ban is removed.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildEmojisUpdate","title":"<code>GuildEmojisUpdate</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Dispatched when a guild's emojis are updated.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass GuildEmojisUpdate(GuildEvent):\n\"\"\"Dispatched when a guild's emojis are updated.\"\"\"\n\n    before: List[\"CustomEmoji\"] = attrs.field(repr=False, factory=list)\n\"\"\"List of emoji before this event. Only includes emojis that were cached. To enable the emoji cache (and this field), start your bot with `Client(enable_emoji_cache=True)`\"\"\"\n    after: List[\"CustomEmoji\"] = attrs.field(repr=False, factory=list)\n\"\"\"List of emoji after this event\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildEmojisUpdate.before","title":"<code>before: List[CustomEmoji] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>List of emoji before this event. Only includes emojis that were cached. To enable the emoji cache (and this field), start your bot with <code>Client(enable_emoji_cache=True)</code></p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildEmojisUpdate.after","title":"<code>after: List[CustomEmoji] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>List of emoji after this event</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildStickersUpdate","title":"<code>GuildStickersUpdate</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Dispatched when a guild's stickers are updated.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass GuildStickersUpdate(GuildEvent):\n\"\"\"Dispatched when a guild's stickers are updated.\"\"\"\n\n    stickers: List[\"Sticker\"] = attrs.field(repr=False, factory=list)\n\"\"\"List of stickers from after this event\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildStickersUpdate.stickers","title":"<code>stickers: List[Sticker] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>List of stickers from after this event</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MemberAdd","title":"<code>MemberAdd</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Dispatched when a member is added to a guild.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass MemberAdd(GuildEvent):\n\"\"\"Dispatched when a member is added to a guild.\"\"\"\n\n    member: \"Member\" = attrs.field(repr=False, metadata=docs(\"The member who was added\"))\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MemberRemove","title":"<code>MemberRemove</code>","text":"<p>         Bases: <code>MemberAdd</code></p> <p>Dispatched when a member is removed from a guild.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass MemberRemove(MemberAdd):\n\"\"\"Dispatched when a member is removed from a guild.\"\"\"\n\n    member: Union[\"Member\", \"User\"] = attrs.field(\n        repr=False, metadata=docs(\"The member who was added, can be user if the member is not cached\")\n    )\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MemberUpdate","title":"<code>MemberUpdate</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Dispatched when a member is updated.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass MemberUpdate(GuildEvent):\n\"\"\"Dispatched when a member is updated.\"\"\"\n\n    before: \"Member\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The state of the member before this event\"\"\"\n    after: \"Member\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The state of the member after this event\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MemberUpdate.before","title":"<code>before: Member = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The state of the member before this event</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MemberUpdate.after","title":"<code>after: Member = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The state of the member after this event</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.RoleCreate","title":"<code>RoleCreate</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Dispatched when a role is created.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass RoleCreate(GuildEvent):\n\"\"\"Dispatched when a role is created.\"\"\"\n\n    role: \"Role\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The created role\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.RoleCreate.role","title":"<code>role: Role = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The created role</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.RoleUpdate","title":"<code>RoleUpdate</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Dispatched when a role is updated.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass RoleUpdate(GuildEvent):\n\"\"\"Dispatched when a role is updated.\"\"\"\n\n    before: Absent[\"Role\"] = attrs.field(\n        repr=False,\n    )\n\"\"\"The role before this event\"\"\"\n    after: \"Role\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The role after this event\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.RoleUpdate.before","title":"<code>before: Absent[Role] = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The role before this event</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.RoleUpdate.after","title":"<code>after: Role = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The role after this event</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.RoleDelete","title":"<code>RoleDelete</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Dispatched when a guild role is deleted.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass RoleDelete(GuildEvent):\n\"\"\"Dispatched when a guild role is deleted.\"\"\"\n\n    id: \"Snowflake_Type\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The ID of the deleted role\"\"\"\n    role: Absent[\"Role\"] = attrs.field(\n        repr=False,\n    )\n\"\"\"The deleted role\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.RoleDelete.id","title":"<code>id: Snowflake_Type = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The ID of the deleted role</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.RoleDelete.role","title":"<code>role: Absent[Role] = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The deleted role</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildMembersChunk","title":"<code>GuildMembersChunk</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Sent in response to Guild Request Members.</p> <p>You can use the <code>chunk_index</code> and <code>chunk_count</code> to calculate how many chunks are left for your request.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass GuildMembersChunk(GuildEvent):\n\"\"\"\n    Sent in response to Guild Request Members.\n\n    You can use the `chunk_index` and `chunk_count` to calculate how\n    many chunks are left for your request.\n\n    \"\"\"\n\n    chunk_index: int = attrs.field(\n        repr=False,\n    )\n\"\"\"The chunk index in the expected chunks for this response (0 &lt;= chunk_index &lt; chunk_count)\"\"\"\n    chunk_count: int = attrs.field(\n        repr=False,\n    )\n\"\"\"the total number of expected chunks for this response\"\"\"\n    presences: List = attrs.field(\n        repr=False,\n    )\n\"\"\"if passing true to `REQUEST_GUILD_MEMBERS`, presences of the returned members will be here\"\"\"\n    nonce: str = attrs.field(\n        repr=False,\n    )\n\"\"\"The nonce used in the request, if any\"\"\"\n    members: List[\"Member\"] = attrs.field(repr=False, factory=list)\n\"\"\"A list of members\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildMembersChunk.chunk_index","title":"<code>chunk_index: int = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The chunk index in the expected chunks for this response (0 &lt;= chunk_index &lt; chunk_count)</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildMembersChunk.chunk_count","title":"<code>chunk_count: int = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>the total number of expected chunks for this response</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildMembersChunk.presences","title":"<code>presences: List = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>if passing true to <code>REQUEST_GUILD_MEMBERS</code>, presences of the returned members will be here</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildMembersChunk.nonce","title":"<code>nonce: str = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The nonce used in the request, if any</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.GuildMembersChunk.members","title":"<code>members: List[Member] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>A list of members</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.IntegrationCreate","title":"<code>IntegrationCreate</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a guild integration is created.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass IntegrationCreate(BaseEvent):\n\"\"\"Dispatched when a guild integration is created.\"\"\"\n\n    integration: \"GuildIntegration\" = attrs.field(\n        repr=False,\n    )\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.IntegrationUpdate","title":"<code>IntegrationUpdate</code>","text":"<p>         Bases: <code>IntegrationCreate</code></p> <p>Dispatched when a guild integration is updated.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass IntegrationUpdate(IntegrationCreate):\n\"\"\"Dispatched when a guild integration is updated.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.IntegrationDelete","title":"<code>IntegrationDelete</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Dispatched when a guild integration is deleted.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass IntegrationDelete(GuildEvent):\n\"\"\"Dispatched when a guild integration is deleted.\"\"\"\n\n    id: \"Snowflake_Type\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The ID of the integration\"\"\"\n    application_id: \"Snowflake_Type\" = attrs.field(repr=False, default=None)\n\"\"\"The ID of the bot/application for this integration\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.IntegrationDelete.id","title":"<code>id: Snowflake_Type = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The ID of the integration</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.IntegrationDelete.application_id","title":"<code>application_id: Snowflake_Type = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The ID of the bot/application for this integration</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.InviteCreate","title":"<code>InviteCreate</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a guild invite is created.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass InviteCreate(BaseEvent):\n\"\"\"Dispatched when a guild invite is created.\"\"\"\n\n    invite: naff.models.Invite = attrs.field(\n        repr=False,\n    )\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.InviteDelete","title":"<code>InviteDelete</code>","text":"<p>         Bases: <code>InviteCreate</code></p> <p>Dispatched when an invite is deleted.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass InviteDelete(InviteCreate):\n\"\"\"Dispatched when an invite is deleted.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MessageCreate","title":"<code>MessageCreate</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a message is created.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass MessageCreate(BaseEvent):\n\"\"\"Dispatched when a message is created.\"\"\"\n\n    message: \"Message\" = attrs.field(\n        repr=False,\n    )\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MessageUpdate","title":"<code>MessageUpdate</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a message is edited.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass MessageUpdate(BaseEvent):\n\"\"\"Dispatched when a message is edited.\"\"\"\n\n    before: \"Message\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The message before this event was created\"\"\"\n    after: \"Message\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The message after this event was created\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MessageUpdate.before","title":"<code>before: Message = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The message before this event was created</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MessageUpdate.after","title":"<code>after: Message = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The message after this event was created</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MessageDelete","title":"<code>MessageDelete</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a message is deleted.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass MessageDelete(BaseEvent):\n\"\"\"Dispatched when a message is deleted.\"\"\"\n\n    message: \"Message\" = attrs.field(\n        repr=False,\n    )\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MessageDeleteBulk","title":"<code>MessageDeleteBulk</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Dispatched when multiple messages are deleted at once.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass MessageDeleteBulk(GuildEvent):\n\"\"\"Dispatched when multiple messages are deleted at once.\"\"\"\n\n    channel_id: \"Snowflake_Type\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The ID of the channel these were deleted in\"\"\"\n    ids: List[\"Snowflake_Type\"] = attrs.field(repr=False, factory=list)\n\"\"\"A list of message snowflakes\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MessageDeleteBulk.channel_id","title":"<code>channel_id: Snowflake_Type = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The ID of the channel these were deleted in</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MessageDeleteBulk.ids","title":"<code>ids: List[Snowflake_Type] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>A list of message snowflakes</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MessageReactionAdd","title":"<code>MessageReactionAdd</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a reaction is added to a message.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass MessageReactionAdd(BaseEvent):\n\"\"\"Dispatched when a reaction is added to a message.\"\"\"\n\n    message: \"Message\" = attrs.field(repr=False, metadata=docs(\"The message that was reacted to\"))\n    emoji: \"PartialEmoji\" = attrs.field(repr=False, metadata=docs(\"The emoji that was added to the message\"))\n    author: Union[\"Member\", \"User\"] = attrs.field(repr=False, metadata=docs(\"The user who added the reaction\"))\n    # reaction can be None when the message is not in the cache, and it was the last reaction, and it was deleted in the event\n    reaction: Optional[\"Reaction\"] = attrs.field(\n        repr=False, default=None, metadata=docs(\"The reaction object corresponding to the emoji\")\n    )\n\n    @property\n    def reaction_count(self) -&gt; int:\n\"\"\"Times the emoji in the event has been used to react\"\"\"\n        if self.reaction is None:\n            return 0\n        return self.reaction.count\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MessageReactionAdd.reaction_count","title":"<code>reaction_count: int</code>  <code>property</code>","text":"<p>Times the emoji in the event has been used to react</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MessageReactionRemove","title":"<code>MessageReactionRemove</code>","text":"<p>         Bases: <code>MessageReactionAdd</code></p> <p>Dispatched when a reaction is removed.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass MessageReactionRemove(MessageReactionAdd):\n\"\"\"Dispatched when a reaction is removed.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MessageReactionRemoveAll","title":"<code>MessageReactionRemoveAll</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Dispatched when all reactions are removed from a message.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass MessageReactionRemoveAll(GuildEvent):\n\"\"\"Dispatched when all reactions are removed from a message.\"\"\"\n\n    message: \"Message\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The message that was reacted to\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.MessageReactionRemoveAll.message","title":"<code>message: Message = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The message that was reacted to</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.PresenceUpdate","title":"<code>PresenceUpdate</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>A user's presence has changed.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass PresenceUpdate(BaseEvent):\n\"\"\"A user's presence has changed.\"\"\"\n\n    user: \"User\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The user in question\"\"\"\n    status: str = attrs.field(\n        repr=False,\n    )\n\"\"\"'Either `idle`, `dnd`, `online`, or `offline`'\"\"\"\n    activities: List[\"Activity\"] = attrs.field(\n        repr=False,\n    )\n\"\"\"The users current activities\"\"\"\n    client_status: dict = attrs.field(\n        repr=False,\n    )\n\"\"\"What platform the user is reported as being on\"\"\"\n    guild_id: \"Snowflake_Type\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The guild this presence update was dispatched from\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.PresenceUpdate.user","title":"<code>user: User = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The user in question</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.PresenceUpdate.status","title":"<code>status: str = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>'Either <code>idle</code>, <code>dnd</code>, <code>online</code>, or <code>offline</code>'</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.PresenceUpdate.activities","title":"<code>activities: List[Activity] = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The users current activities</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.PresenceUpdate.client_status","title":"<code>client_status: dict = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>What platform the user is reported as being on</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.PresenceUpdate.guild_id","title":"<code>guild_id: Snowflake_Type = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The guild this presence update was dispatched from</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.StageInstanceCreate","title":"<code>StageInstanceCreate</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a stage instance is created.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass StageInstanceCreate(BaseEvent):\n\"\"\"Dispatched when a stage instance is created.\"\"\"\n\n    stage_instance: \"StageInstance\" = attrs.field(repr=False, metadata=docs(\"The stage instance\"))\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.StageInstanceDelete","title":"<code>StageInstanceDelete</code>","text":"<p>         Bases: <code>StageInstanceCreate</code></p> <p>Dispatched when a stage instance is deleted.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass StageInstanceDelete(StageInstanceCreate):\n\"\"\"Dispatched when a stage instance is deleted.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.StageInstanceUpdate","title":"<code>StageInstanceUpdate</code>","text":"<p>         Bases: <code>StageInstanceCreate</code></p> <p>Dispatched when a stage instance is updated.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass StageInstanceUpdate(StageInstanceCreate):\n\"\"\"Dispatched when a stage instance is updated.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.TypingStart","title":"<code>TypingStart</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a user starts typing.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass TypingStart(BaseEvent):\n\"\"\"Dispatched when a user starts typing.\"\"\"\n\n    author: Union[\"User\", \"Member\"] = attrs.field(\n        repr=False,\n    )\n\"\"\"The user who started typing\"\"\"\n    channel: \"BaseChannel\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The channel typing is in\"\"\"\n    guild: \"Guild\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The ID of the guild this typing is in\"\"\"\n    timestamp: \"Timestamp\" = attrs.field(\n        repr=False,\n    )\n\"\"\"unix time (in seconds) of when the user started typing\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.TypingStart.author","title":"<code>author: Union[User, Member] = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The user who started typing</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.TypingStart.channel","title":"<code>channel: BaseChannel = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The channel typing is in</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.TypingStart.guild","title":"<code>guild: Guild = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The ID of the guild this typing is in</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.TypingStart.timestamp","title":"<code>timestamp: Timestamp = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>unix time (in seconds) of when the user started typing</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.WebhooksUpdate","title":"<code>WebhooksUpdate</code>","text":"<p>         Bases: <code>GuildEvent</code></p> <p>Dispatched when a guild channel webhook is created, updated, or deleted.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass WebhooksUpdate(GuildEvent):\n\"\"\"Dispatched when a guild channel webhook is created, updated, or deleted.\"\"\"\n\n    # Discord doesnt sent the webhook object for this event, for some reason\n    channel_id: \"Snowflake_Type\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The ID of the webhook was updated\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.WebhooksUpdate.channel_id","title":"<code>channel_id: Snowflake_Type = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The ID of the webhook was updated</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.InteractionCreate","title":"<code>InteractionCreate</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a user uses an Application Command.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass InteractionCreate(BaseEvent):\n\"\"\"Dispatched when a user uses an Application Command.\"\"\"\n\n    interaction: dict = attrs.field(\n        repr=False,\n    )\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceStateUpdate","title":"<code>VoiceStateUpdate</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a user's voice state changes.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass VoiceStateUpdate(BaseEvent):\n\"\"\"Dispatched when a user's voice state changes.\"\"\"\n\n    before: Optional[\"VoiceState\"] = attrs.field(\n        repr=False,\n    )\n\"\"\"The voice state before this event was created or None if the user was not in a voice channel\"\"\"\n    after: Optional[\"VoiceState\"] = attrs.field(\n        repr=False,\n    )\n\"\"\"The voice state after this event was created or None if the user is no longer in a voice channel\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceStateUpdate.before","title":"<code>before: Optional[VoiceState] = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The voice state before this event was created or None if the user was not in a voice channel</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceStateUpdate.after","title":"<code>after: Optional[VoiceState] = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The voice state after this event was created or None if the user is no longer in a voice channel</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.BaseVoiceEvent","title":"<code>BaseVoiceEvent</code>","text":"<p>         Bases: <code>BaseEvent</code></p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass BaseVoiceEvent(BaseEvent):\n    state: \"VoiceState\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The current voice state of the user\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.BaseVoiceEvent.state","title":"<code>state: VoiceState = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The current voice state of the user</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserMove","title":"<code>VoiceUserMove</code>","text":"<p>         Bases: <code>BaseVoiceEvent</code></p> <p>Dispatched when a user moves voice channels.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass VoiceUserMove(BaseVoiceEvent):\n\"\"\"Dispatched when a user moves voice channels.\"\"\"\n\n    author: Union[\"User\", \"Member\"] = attrs.field(\n        repr=False,\n    )\n\n    previous_channel: \"VoiceChannel\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The previous voice channel the user was in\"\"\"\n    new_channel: \"VoiceChannel\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The new voice channel the user is in\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserMove.previous_channel","title":"<code>previous_channel: VoiceChannel = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The previous voice channel the user was in</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserMove.new_channel","title":"<code>new_channel: VoiceChannel = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The new voice channel the user is in</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserMute","title":"<code>VoiceUserMute</code>","text":"<p>         Bases: <code>BaseVoiceEvent</code></p> <p>Dispatched when a user is muted or unmuted.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass VoiceUserMute(BaseVoiceEvent):\n\"\"\"Dispatched when a user is muted or unmuted.\"\"\"\n\n    author: Union[\"User\", \"Member\"] = attrs.field(\n        repr=False,\n    )\n\"\"\"The user who was muted or unmuted\"\"\"\n    channel: \"VoiceChannel\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The voice channel the user was muted or unmuted in\"\"\"\n    mute: bool = attrs.field(\n        repr=False,\n    )\n\"\"\"The new mute state of the user\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserMute.author","title":"<code>author: Union[User, Member] = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The user who was muted or unmuted</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserMute.channel","title":"<code>channel: VoiceChannel = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The voice channel the user was muted or unmuted in</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserMute.mute","title":"<code>mute: bool = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The new mute state of the user</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserDeafen","title":"<code>VoiceUserDeafen</code>","text":"<p>         Bases: <code>BaseVoiceEvent</code></p> <p>Dispatched when a user is deafened or undeafened.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass VoiceUserDeafen(BaseVoiceEvent):\n\"\"\"Dispatched when a user is deafened or undeafened.\"\"\"\n\n    author: Union[\"User\", \"Member\"] = attrs.field(\n        repr=False,\n    )\n\"\"\"The user who was deafened or undeafened\"\"\"\n    channel: \"VoiceChannel\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The voice channel the user was deafened or undeafened in\"\"\"\n    deaf: bool = attrs.field(\n        repr=False,\n    )\n\"\"\"The new deaf state of the user\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserDeafen.author","title":"<code>author: Union[User, Member] = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The user who was deafened or undeafened</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserDeafen.channel","title":"<code>channel: VoiceChannel = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The voice channel the user was deafened or undeafened in</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserDeafen.deaf","title":"<code>deaf: bool = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The new deaf state of the user</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserJoin","title":"<code>VoiceUserJoin</code>","text":"<p>         Bases: <code>BaseVoiceEvent</code></p> <p>Dispatched when a user joins a voice channel.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass VoiceUserJoin(BaseVoiceEvent):\n\"\"\"Dispatched when a user joins a voice channel.\"\"\"\n\n    author: Union[\"User\", \"Member\"] = attrs.field(\n        repr=False,\n    )\n\"\"\"The user who joined the voice channel\"\"\"\n    channel: \"VoiceChannel\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The voice channel the user joined\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserJoin.author","title":"<code>author: Union[User, Member] = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The user who joined the voice channel</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserJoin.channel","title":"<code>channel: VoiceChannel = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The voice channel the user joined</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserLeave","title":"<code>VoiceUserLeave</code>","text":"<p>         Bases: <code>BaseVoiceEvent</code></p> <p>Dispatched when a user leaves a voice channel.</p> Source code in <code>naff\\api\\events\\discord.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass VoiceUserLeave(BaseVoiceEvent):\n\"\"\"Dispatched when a user leaves a voice channel.\"\"\"\n\n    author: Union[\"User\", \"Member\"] = attrs.field(\n        repr=False,\n    )\n\"\"\"The user who left the voice channel\"\"\"\n    channel: \"VoiceChannel\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The voice channel the user left\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserLeave.author","title":"<code>author: Union[User, Member] = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The user who left the voice channel</p>"},{"location":"API%20Reference/events/discord/#naff.api.events.discord.VoiceUserLeave.channel","title":"<code>channel: VoiceChannel = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The voice channel the user left</p>"},{"location":"API%20Reference/events/internal/","title":"Internal","text":"<p>These are events dispatched by the client. This is intended as a reference so you know what data to expect for each event.</p> Example Usage: <p>The event classes outlined here are in <code>CamelCase</code> to comply with Class naming convention, however the event names are actually in <code>lower_case_with_underscores</code> so your listeners should be named as following:</p> <pre><code>@listen()\ndef on_ready():\n    # ready events pass no data, so dont have params\n    print(\"Im ready!\")\n\n@listen()\ndef on_guild_join(event):\n    # guild_create events pass a guild object, expect a single param\n    print(f\"{event.guild.name} created\")\n</code></pre> <p>Warning</p> <p>While all of these events are documented, not all of them are used, currently.</p>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.Login","title":"<code>Login</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>The bot has just logged in.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Login(BaseEvent):\n\"\"\"The bot has just logged in.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.Connect","title":"<code>Connect</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>The bot is now connected to the discord Gateway.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Connect(BaseEvent):\n\"\"\"The bot is now connected to the discord Gateway.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.Resume","title":"<code>Resume</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>The bot has resumed its connection to the discord Gateway.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Resume(BaseEvent):\n\"\"\"The bot has resumed its connection to the discord Gateway.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.Disconnect","title":"<code>Disconnect</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>The bot has just disconnected.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Disconnect(BaseEvent):\n\"\"\"The bot has just disconnected.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.ShardConnect","title":"<code>ShardConnect</code>","text":"<p>         Bases: <code>Connect</code></p> <p>A shard just connected to the discord Gateway.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ShardConnect(Connect):\n\"\"\"A shard just connected to the discord Gateway.\"\"\"\n\n    shard_id: int = attrs.field(repr=False, metadata=docs(\"The ID of the shard\"))\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.ShardDisconnect","title":"<code>ShardDisconnect</code>","text":"<p>         Bases: <code>Disconnect</code></p> <p>A shard just disconnected.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ShardDisconnect(Disconnect):\n\"\"\"A shard just disconnected.\"\"\"\n\n    shard_id: int = attrs.field(repr=False, metadata=docs(\"The ID of the shard\"))\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.Startup","title":"<code>Startup</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>The client is now ready for the first time.</p> <p>Use this for tasks you want to do upon login, instead of ready, as this will only be called once.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Startup(BaseEvent):\n\"\"\"\n    The client is now ready for the first time.\n\n    Use this for tasks you want to do upon login, instead of ready, as\n    this will only be called once.\n\n    \"\"\"\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.Ready","title":"<code>Ready</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>The client is now ready.</p> <p>Note</p> <p>Don't use this event for things that must only happen once, on startup, as this event may be called multiple times. Instead, use the <code>Startup</code> event</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Ready(BaseEvent):\n\"\"\"\n    The client is now ready.\n\n    !!! note\n        Don't use this event for things that must only happen once, on startup, as this event may be called multiple times.\n        Instead, use the `Startup` event\n\n    \"\"\"\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.WebsocketReady","title":"<code>WebsocketReady</code>","text":"<p>         Bases: <code>RawGatewayEvent</code></p> <p>The gateway has reported that it is ready.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass WebsocketReady(RawGatewayEvent):\n\"\"\"The gateway has reported that it is ready.\"\"\"\n\n    data: dict = attrs.field(repr=False, metadata=docs(\"The data from the ready event\"))\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.Component","title":"<code>Component</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched when a user uses a Component.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Component(BaseEvent):\n\"\"\"Dispatched when a user uses a Component.\"\"\"\n\n    ctx: \"ComponentContext\" = attrs.field(repr=False, metadata=docs(\"The context of the interaction\"))\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.ButtonPressed","title":"<code>ButtonPressed</code>","text":"<p>         Bases: <code>Component</code></p> <p>Dispatched when a user uses a Button.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ButtonPressed(Component):\n\"\"\"Dispatched when a user uses a Button.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.Select","title":"<code>Select</code>","text":"<p>         Bases: <code>Component</code></p> <p>Dispatched when a user uses a Select.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Select(Component):\n\"\"\"Dispatched when a user uses a Select.\"\"\"\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.CommandCompletion","title":"<code>CommandCompletion</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched after the library ran any command callback.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass CommandCompletion(BaseEvent):\n\"\"\"Dispatched after the library ran any command callback.\"\"\"\n\n    ctx: \"InteractionContext | PrefixedContext | HybridContext\" = attrs.field(\n        repr=False, metadata=docs(\"The command context\")\n    )\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.ComponentCompletion","title":"<code>ComponentCompletion</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched after the library ran any component callback.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ComponentCompletion(BaseEvent):\n\"\"\"Dispatched after the library ran any component callback.\"\"\"\n\n    ctx: \"ComponentContext\" = attrs.field(repr=False, metadata=docs(\"The component context\"))\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.AutocompleteCompletion","title":"<code>AutocompleteCompletion</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched after the library ran any autocomplete callback.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass AutocompleteCompletion(BaseEvent):\n\"\"\"Dispatched after the library ran any autocomplete callback.\"\"\"\n\n    ctx: \"AutocompleteContext\" = attrs.field(repr=False, metadata=docs(\"The autocomplete context\"))\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.ModalCompletion","title":"<code>ModalCompletion</code>","text":"<p>         Bases: <code>BaseEvent</code></p> <p>Dispatched after the library ran any modal callback.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ModalCompletion(BaseEvent):\n\"\"\"Dispatched after the library ran any modal callback.\"\"\"\n\n    ctx: \"ModalContext\" = attrs.field(repr=False, metadata=docs(\"The modal context\"))\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.Error","title":"<code>Error</code>","text":"<p>         Bases: <code>_Error</code></p> <p>Dispatched when the library encounters an error.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass Error(_Error):\n\"\"\"Dispatched when the library encounters an error.\"\"\"\n\n    source: str = attrs.field(repr=False, metadata=docs(\"The source of the error\"))\n    ctx: Optional[\"Context\"] = attrs.field(repr=False, default=None, metadata=docs(\"The Context, if one was active\"))\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.CommandError","title":"<code>CommandError</code>","text":"<p>         Bases: <code>_Error</code></p> <p>Dispatched when the library encounters an error in a command.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass CommandError(_Error):\n\"\"\"Dispatched when the library encounters an error in a command.\"\"\"\n\n    ctx: \"InteractionContext | PrefixedContext | HybridContext\" = attrs.field(\n        repr=False, metadata=docs(\"The command context\")\n    )\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.ComponentError","title":"<code>ComponentError</code>","text":"<p>         Bases: <code>_Error</code></p> <p>Dispatched when the library encounters an error in a component.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ComponentError(_Error):\n\"\"\"Dispatched when the library encounters an error in a component.\"\"\"\n\n    ctx: \"ComponentContext\" = attrs.field(repr=False, metadata=docs(\"The component context\"))\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.AutocompleteError","title":"<code>AutocompleteError</code>","text":"<p>         Bases: <code>_Error</code></p> <p>Dispatched when the library encounters an error in an autocomplete.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass AutocompleteError(_Error):\n\"\"\"Dispatched when the library encounters an error in an autocomplete.\"\"\"\n\n    ctx: \"AutocompleteContext\" = attrs.field(repr=False, metadata=docs(\"The autocomplete context\"))\n</code></pre>"},{"location":"API%20Reference/events/internal/#naff.api.events.internal.ModalError","title":"<code>ModalError</code>","text":"<p>         Bases: <code>_Error</code></p> <p>Dispatched when the library encounters an error in a modal.</p> Source code in <code>naff\\api\\events\\internal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ModalError(_Error):\n\"\"\"Dispatched when the library encounters an error in a modal.\"\"\"\n\n    ctx: \"ModalContext\" = attrs.field(repr=False, metadata=docs(\"The modal context\"))\n</code></pre>"},{"location":"API%20Reference/ext/","title":"Ext Index","text":"<p>These files contain useful features that help you develop a bot</p> <ul> <li> <p>Debug Extension</p> <ul> <li>An extension preloaded with a load of debugging utilities to help you find and fix bugs</li> </ul> </li> <li> <p>Jurigged</p> <ul> <li>An extension to enable live code patching for faster development</li> </ul> </li> <li> <p>Paginators</p> <ul> <li>An automatic message paginator to help you get a lot of information across</li> </ul> </li> <li> <p>Prefixed Help Command</p> <ul> <li>An easy-to-use help command for prefixed commands</li> </ul> </li> </ul>"},{"location":"API%20Reference/ext/debug_ext/","title":"Debug ext","text":""},{"location":"API%20Reference/ext/jurigged/","title":"Jurigged","text":""},{"location":"API%20Reference/ext/jurigged/#naff.ext.jurigged.get_all_commands","title":"<code>get_all_commands(module)</code>","text":"<p>Get all SlashCommands from a specified module.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>ModuleType</code> <p>Module to extract commands from</p> required Source code in <code>naff\\ext\\jurigged.py</code> <pre><code>def get_all_commands(module: ModuleType) -&gt; Dict[str, Callable]:\n\"\"\"\n    Get all SlashCommands from a specified module.\n\n    Args:\n        module: Module to extract commands from\n    \"\"\"\n    commands = {}\n\n    def is_extension(e) -&gt; bool:\n\"\"\"Check that an object is an extension.\"\"\"\n        return inspect.isclass(e) and issubclass(e, Extension) and e is not Extension\n\n    def is_slashcommand(e) -&gt; bool:\n\"\"\"Check that an object is a slash command.\"\"\"\n        return isinstance(e, SlashCommand)\n\n    for _name, item in inspect.getmembers(module, is_extension):\n        inspect_result = inspect.getmembers(item, is_slashcommand)\n        exts = []\n        for _, val in inspect_result:\n            exts.append(val)\n        commands[f\"{module.__name__}\"] = exts\n\n    return {k: v for k, v in commands.items() if v is not None}\n</code></pre>"},{"location":"API%20Reference/ext/jurigged/#naff.ext.jurigged.Jurigged","title":"<code>Jurigged</code>","text":"<p>         Bases: <code>Extension</code></p> Source code in <code>naff\\ext\\jurigged.py</code> <pre><code>class Jurigged(Extension):\n    @listen(event_name=\"on_startup\")\n    async def jurigged_startup(self) -&gt; None:\n\"\"\"Jurigged starting utility.\"\"\"\n        self.command_cache = {}\n        self.bot.logger.warning(\"Setting sync_ext to True by default for syncing changes\")\n        self.bot.sync_ext = True\n\n        self.bot.logger.info(\"Loading jurigged\")\n        path = Path().resolve()\n        self.watcher = watch(f\"{path}/[!.]*.py\", logger=self.jurigged_log)\n        self.watcher.prerun.register(self.jurigged_prerun)\n        self.watcher.postrun.register(self.jurigged_postrun)\n\n    def jurigged_log(self, event: WatchOperation | AddOperation | DeleteOperation | UpdateOperation) -&gt; None:\n\"\"\"\n        Log a jurigged event\n\n        Args:\n            event: jurigged event\n        \"\"\"\n        if isinstance(event, WatchOperation):\n            self.bot.logger.debug(f\"Watch {event.filename}\")\n        elif isinstance(event, (Exception, SyntaxError)):\n            self.bot.logger.exception(\"Jurigged encountered an error\", exc_info=True)\n        else:\n            event_str = \"{action} {dotpath}:{lineno}{extra}\"\n            action = None\n            lineno = event.defn.stashed.lineno\n            dotpath = event.defn.dotpath()\n            extra = \"\"\n\n            if isinstance(event.defn, LineDefinition):\n                dotpath = event.defn.parent.dotpath()\n                extra = f\" | {event.defn.text}\"\n\n            if isinstance(event, AddOperation):\n                action = \"Add\"\n                if isinstance(event.defn, LineDefinition):\n                    action = \"Run\"\n            elif isinstance(event, UpdateOperation):\n                action = \"Update\"\n            elif isinstance(event, DeleteOperation):\n                action = \"Delete\"\n            if not action:\n                self.bot.logger.debug(event)\n            else:\n                self.bot.logger.debug(event_str.format(action=action, dotpath=dotpath, lineno=lineno, extra=extra))\n\n    def jurigged_prerun(self, _path: str, cf: CodeFile) -&gt; None:\n\"\"\"\n        Jurigged prerun event.\n\n        Args:\n            path: Path to file\n            cf: File information\n        \"\"\"\n        if self.bot.get_ext(cf.module_name):\n            self.bot.logger.debug(f\"Caching {cf.module_name}\")\n            self.command_cache = get_all_commands(cf.module)\n\n    def jurigged_postrun(self, _path: str, cf: CodeFile) -&gt; None:\n\"\"\"\n        Jurigged postrun event.\n\n        Args:\n            path: Path to file\n            cf: File information\n        \"\"\"\n        if self.bot.get_ext(cf.module_name):\n            self.bot.logger.debug(f\"Checking {cf.module_name}\")\n            commands = get_all_commands(cf.module)\n\n            self.bot.logger.debug(\"Checking for changes\")\n            for module, cmds in commands.items():\n                # Check if a module was removed\n                if module not in commands:\n                    self.bot.logger.debug(f\"Module {module} removed\")\n                    self.bot.unload_extension(module)\n\n                # Check if a module is new\n                elif module not in self.command_cache:\n                    self.bot.logger.debug(f\"Module {module} added\")\n                    try:\n                        self.bot.load_extension(module)\n                    except ExtensionLoadException:\n                        self.bot.logger.warning(f\"Failed to load new module {module}\")\n\n                # Check if a module has more/less commands\n                elif len(self.command_cache[module]) != len(cmds):\n                    self.bot.logger.debug(\"Number of commands changed, reloading\")\n                    try:\n                        self.bot.reload_extension(module)\n                    except ExtensionNotFound:\n                        try:\n                            self.bot.load_extension(module)\n                        except ExtensionLoadException:\n                            self.bot.logger.warning(f\"Failed to update module {module}\")\n                    except ExtensionLoadException:\n                        self.bot.logger.warning(f\"Failed to update module {module}\")\n\n                # Check each command for differences\n                else:\n                    for cmd in cmds:\n                        old_cmd = find(\n                            lambda x, cmd=cmd: x.resolved_name == cmd.resolved_name,\n                            self.command_cache[module],\n                        )\n\n                        # Extract useful info\n                        old_args = old_cmd.options\n                        old_arg_names = []\n                        new_arg_names = []\n                        if old_args:\n                            old_arg_names = [x.name.default for x in old_args]\n                        new_args = cmd.options\n                        if new_args:\n                            new_arg_names = [x.name.default for x in new_args]\n\n                        # No changes\n                        if not old_args and not new_args:\n                            continue\n\n                        # Check if number of args has changed\n                        if len(old_arg_names) != len(new_arg_names):\n                            self.bot.logger.debug(\"Number of arguments changed, reloading\")\n                            try:\n                                self.bot.reload_extension(module)\n                            except Exception:\n                                self.bot.logger.exception(f\"Failed to update module {module}\", exc_info=True)\n\n                        # Check if arg names have changed\n                        elif len(set(old_arg_names) - set(new_arg_names)) &gt; 0:\n                            self.bot.logger.debug(\"Argument names changed, reloading\")\n                            try:\n                                self.bot.reload_extension(module)\n                            except Exception:\n                                self.bot.logger.exception(f\"Failed to update module {module}\", exc_info=True)\n\n                        # Check if arg types have changed\n                        elif any(new_args[idx].type != x.type for idx, x in enumerate(old_args)):\n                            self.bot.logger.debug(\"Argument types changed, reloading\")\n                            try:\n                                self.bot.reload_extension(module)\n                            except Exception:\n                                self.bot.logger.exception(f\"Failed to update module {module}\", exc_info=True)\n                        else:\n                            self.bot.logger.debug(\"No changes detected\")\n            self.command_cache.clear()\n</code></pre>"},{"location":"API%20Reference/ext/jurigged/#naff.ext.jurigged.Jurigged.jurigged_startup","title":"<code>jurigged_startup()</code>  <code>async</code>","text":"<p>Jurigged starting utility.</p> Source code in <code>naff\\ext\\jurigged.py</code> <pre><code>@listen(event_name=\"on_startup\")\nasync def jurigged_startup(self) -&gt; None:\n\"\"\"Jurigged starting utility.\"\"\"\n    self.command_cache = {}\n    self.bot.logger.warning(\"Setting sync_ext to True by default for syncing changes\")\n    self.bot.sync_ext = True\n\n    self.bot.logger.info(\"Loading jurigged\")\n    path = Path().resolve()\n    self.watcher = watch(f\"{path}/[!.]*.py\", logger=self.jurigged_log)\n    self.watcher.prerun.register(self.jurigged_prerun)\n    self.watcher.postrun.register(self.jurigged_postrun)\n</code></pre>"},{"location":"API%20Reference/ext/jurigged/#naff.ext.jurigged.Jurigged.jurigged_log","title":"<code>jurigged_log(event)</code>","text":"<p>Log a jurigged event</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>WatchOperation | AddOperation | DeleteOperation | UpdateOperation</code> <p>jurigged event</p> required Source code in <code>naff\\ext\\jurigged.py</code> <pre><code>def jurigged_log(self, event: WatchOperation | AddOperation | DeleteOperation | UpdateOperation) -&gt; None:\n\"\"\"\n    Log a jurigged event\n\n    Args:\n        event: jurigged event\n    \"\"\"\n    if isinstance(event, WatchOperation):\n        self.bot.logger.debug(f\"Watch {event.filename}\")\n    elif isinstance(event, (Exception, SyntaxError)):\n        self.bot.logger.exception(\"Jurigged encountered an error\", exc_info=True)\n    else:\n        event_str = \"{action} {dotpath}:{lineno}{extra}\"\n        action = None\n        lineno = event.defn.stashed.lineno\n        dotpath = event.defn.dotpath()\n        extra = \"\"\n\n        if isinstance(event.defn, LineDefinition):\n            dotpath = event.defn.parent.dotpath()\n            extra = f\" | {event.defn.text}\"\n\n        if isinstance(event, AddOperation):\n            action = \"Add\"\n            if isinstance(event.defn, LineDefinition):\n                action = \"Run\"\n        elif isinstance(event, UpdateOperation):\n            action = \"Update\"\n        elif isinstance(event, DeleteOperation):\n            action = \"Delete\"\n        if not action:\n            self.bot.logger.debug(event)\n        else:\n            self.bot.logger.debug(event_str.format(action=action, dotpath=dotpath, lineno=lineno, extra=extra))\n</code></pre>"},{"location":"API%20Reference/ext/jurigged/#naff.ext.jurigged.Jurigged.jurigged_prerun","title":"<code>jurigged_prerun(_path, cf)</code>","text":"<p>Jurigged prerun event.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <p>Path to file</p> required <code>cf</code> <code>CodeFile</code> <p>File information</p> required Source code in <code>naff\\ext\\jurigged.py</code> <pre><code>def jurigged_prerun(self, _path: str, cf: CodeFile) -&gt; None:\n\"\"\"\n    Jurigged prerun event.\n\n    Args:\n        path: Path to file\n        cf: File information\n    \"\"\"\n    if self.bot.get_ext(cf.module_name):\n        self.bot.logger.debug(f\"Caching {cf.module_name}\")\n        self.command_cache = get_all_commands(cf.module)\n</code></pre>"},{"location":"API%20Reference/ext/jurigged/#naff.ext.jurigged.Jurigged.jurigged_postrun","title":"<code>jurigged_postrun(_path, cf)</code>","text":"<p>Jurigged postrun event.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <p>Path to file</p> required <code>cf</code> <code>CodeFile</code> <p>File information</p> required Source code in <code>naff\\ext\\jurigged.py</code> <pre><code>def jurigged_postrun(self, _path: str, cf: CodeFile) -&gt; None:\n\"\"\"\n    Jurigged postrun event.\n\n    Args:\n        path: Path to file\n        cf: File information\n    \"\"\"\n    if self.bot.get_ext(cf.module_name):\n        self.bot.logger.debug(f\"Checking {cf.module_name}\")\n        commands = get_all_commands(cf.module)\n\n        self.bot.logger.debug(\"Checking for changes\")\n        for module, cmds in commands.items():\n            # Check if a module was removed\n            if module not in commands:\n                self.bot.logger.debug(f\"Module {module} removed\")\n                self.bot.unload_extension(module)\n\n            # Check if a module is new\n            elif module not in self.command_cache:\n                self.bot.logger.debug(f\"Module {module} added\")\n                try:\n                    self.bot.load_extension(module)\n                except ExtensionLoadException:\n                    self.bot.logger.warning(f\"Failed to load new module {module}\")\n\n            # Check if a module has more/less commands\n            elif len(self.command_cache[module]) != len(cmds):\n                self.bot.logger.debug(\"Number of commands changed, reloading\")\n                try:\n                    self.bot.reload_extension(module)\n                except ExtensionNotFound:\n                    try:\n                        self.bot.load_extension(module)\n                    except ExtensionLoadException:\n                        self.bot.logger.warning(f\"Failed to update module {module}\")\n                except ExtensionLoadException:\n                    self.bot.logger.warning(f\"Failed to update module {module}\")\n\n            # Check each command for differences\n            else:\n                for cmd in cmds:\n                    old_cmd = find(\n                        lambda x, cmd=cmd: x.resolved_name == cmd.resolved_name,\n                        self.command_cache[module],\n                    )\n\n                    # Extract useful info\n                    old_args = old_cmd.options\n                    old_arg_names = []\n                    new_arg_names = []\n                    if old_args:\n                        old_arg_names = [x.name.default for x in old_args]\n                    new_args = cmd.options\n                    if new_args:\n                        new_arg_names = [x.name.default for x in new_args]\n\n                    # No changes\n                    if not old_args and not new_args:\n                        continue\n\n                    # Check if number of args has changed\n                    if len(old_arg_names) != len(new_arg_names):\n                        self.bot.logger.debug(\"Number of arguments changed, reloading\")\n                        try:\n                            self.bot.reload_extension(module)\n                        except Exception:\n                            self.bot.logger.exception(f\"Failed to update module {module}\", exc_info=True)\n\n                    # Check if arg names have changed\n                    elif len(set(old_arg_names) - set(new_arg_names)) &gt; 0:\n                        self.bot.logger.debug(\"Argument names changed, reloading\")\n                        try:\n                            self.bot.reload_extension(module)\n                        except Exception:\n                            self.bot.logger.exception(f\"Failed to update module {module}\", exc_info=True)\n\n                    # Check if arg types have changed\n                    elif any(new_args[idx].type != x.type for idx, x in enumerate(old_args)):\n                        self.bot.logger.debug(\"Argument types changed, reloading\")\n                        try:\n                            self.bot.reload_extension(module)\n                        except Exception:\n                            self.bot.logger.exception(f\"Failed to update module {module}\", exc_info=True)\n                    else:\n                        self.bot.logger.debug(\"No changes detected\")\n        self.command_cache.clear()\n</code></pre>"},{"location":"API%20Reference/ext/paginators/","title":"Paginators","text":""},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Timeout","title":"<code>Timeout</code>","text":"Source code in <code>naff\\ext\\paginators.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Timeout:\n    paginator: \"Paginator\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The paginator that this timeout is associated with.\"\"\"\n    run: bool = attrs.field(repr=False, default=True)\n\"\"\"Whether or not this timeout is currently running.\"\"\"\n    ping: asyncio.Event = asyncio.Event()\n\"\"\"The event that is used to wait the paginator action.\"\"\"\n\n    async def __call__(self) -&gt; None:\n        while self.run:\n            try:\n                await asyncio.wait_for(self.ping.wait(), timeout=self.paginator.timeout_interval)\n            except asyncio.TimeoutError:\n                if self.paginator.message:\n                    await self.paginator.message.edit(components=self.paginator.create_components(True))\n                return\n            else:\n                self.ping.clear()\n</code></pre>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Timeout.paginator","title":"<code>paginator: Paginator = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The paginator that this timeout is associated with.</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Timeout.run","title":"<code>run: bool = attrs.field(repr=False, default=True)</code>  <code>class-attribute</code>","text":"<p>Whether or not this timeout is currently running.</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Timeout.ping","title":"<code>ping: asyncio.Event = asyncio.Event()</code>  <code>class-attribute</code>","text":"<p>The event that is used to wait the paginator action.</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Page","title":"<code>Page</code>","text":"Source code in <code>naff\\ext\\paginators.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Page:\n    content: str = attrs.field(\n        repr=False,\n    )\n\"\"\"The content of the page.\"\"\"\n    title: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The title of the page.\"\"\"\n    prefix: str = attrs.field(repr=False, kw_only=True, default=\"\")\n\"\"\"Content that is prepended to the page.\"\"\"\n    suffix: str = attrs.field(repr=False, kw_only=True, default=\"\")\n\"\"\"Content that is appended to the page.\"\"\"\n\n    @property\n    def get_summary(self) -&gt; str:\n\"\"\"Get the short version of the page content.\"\"\"\n        return self.title or textwrap.shorten(self.content, 40, placeholder=\"...\")\n\n    def to_embed(self) -&gt; Embed:\n\"\"\"Process the page to an embed.\"\"\"\n        return Embed(description=f\"{self.prefix}\\n{self.content}\\n{self.suffix}\", title=self.title)\n</code></pre>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Page.content","title":"<code>content: str = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The content of the page.</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Page.title","title":"<code>title: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The title of the page.</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Page.prefix","title":"<code>prefix: str = attrs.field(repr=False, kw_only=True, default='')</code>  <code>class-attribute</code>","text":"<p>Content that is prepended to the page.</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Page.suffix","title":"<code>suffix: str = attrs.field(repr=False, kw_only=True, default='')</code>  <code>class-attribute</code>","text":"<p>Content that is appended to the page.</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Page.get_summary","title":"<code>get_summary: str</code>  <code>property</code>","text":"<p>Get the short version of the page content.</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Page.to_embed","title":"<code>to_embed()</code>","text":"<p>Process the page to an embed.</p> Source code in <code>naff\\ext\\paginators.py</code> <pre><code>def to_embed(self) -&gt; Embed:\n\"\"\"Process the page to an embed.\"\"\"\n    return Embed(description=f\"{self.prefix}\\n{self.content}\\n{self.suffix}\", title=self.title)\n</code></pre>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator","title":"<code>Paginator</code>","text":"Source code in <code>naff\\ext\\paginators.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Paginator:\n    client: \"Client\" = attrs.field(\n        repr=False,\n    )\n\"\"\"The NAFF client to hook listeners into\"\"\"\n\n    page_index: int = attrs.field(repr=False, kw_only=True, default=0)\n\"\"\"The index of the current page being displayed\"\"\"\n    pages: Sequence[Page | Embed] = attrs.field(repr=False, factory=list, kw_only=True)\n\"\"\"The pages this paginator holds\"\"\"\n    timeout_interval: int = attrs.field(repr=False, default=0, kw_only=True)\n\"\"\"How long until this paginator disables itself\"\"\"\n    callback: Callable[..., Coroutine] = attrs.field(repr=False, default=None)\n\"\"\"A coroutine to call should the select button be pressed\"\"\"\n\n    show_first_button: bool = attrs.field(repr=False, default=True)\n\"\"\"Should a `First` button be shown\"\"\"\n    show_back_button: bool = attrs.field(repr=False, default=True)\n\"\"\"Should a `Back` button be shown\"\"\"\n    show_next_button: bool = attrs.field(repr=False, default=True)\n\"\"\"Should a `Next` button be shown\"\"\"\n    show_last_button: bool = attrs.field(repr=False, default=True)\n\"\"\"Should a `Last` button be shown\"\"\"\n    show_callback_button: bool = attrs.field(repr=False, default=False)\n\"\"\"Show a button which will call the `callback`\"\"\"\n    show_select_menu: bool = attrs.field(repr=False, default=False)\n\"\"\"Should a select menu be shown for navigation\"\"\"\n\n    first_button_emoji: Optional[Union[\"PartialEmoji\", dict, str]] = attrs.field(\n        repr=False, default=\"\u23ee\ufe0f\", metadata=export_converter(process_emoji)\n    )\n\"\"\"The emoji to use for the first button\"\"\"\n    back_button_emoji: Optional[Union[\"PartialEmoji\", dict, str]] = attrs.field(\n        repr=False, default=\"\u2b05\ufe0f\", metadata=export_converter(process_emoji)\n    )\n\"\"\"The emoji to use for the back button\"\"\"\n    next_button_emoji: Optional[Union[\"PartialEmoji\", dict, str]] = attrs.field(\n        repr=False, default=\"\u27a1\ufe0f\", metadata=export_converter(process_emoji)\n    )\n\"\"\"The emoji to use for the next button\"\"\"\n    last_button_emoji: Optional[Union[\"PartialEmoji\", dict, str]] = attrs.field(\n        repr=False, default=\"\u23e9\", metadata=export_converter(process_emoji)\n    )\n\"\"\"The emoji to use for the last button\"\"\"\n    callback_button_emoji: Optional[Union[\"PartialEmoji\", dict, str]] = attrs.field(\n        repr=False, default=\"\u2705\", metadata=export_converter(process_emoji)\n    )\n\"\"\"The emoji to use for the callback button\"\"\"\n\n    wrong_user_message: str = attrs.field(repr=False, default=\"This paginator is not for you\")\n\"\"\"The message to be sent when the wrong user uses this paginator\"\"\"\n\n    default_title: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The default title to show on the embeds\"\"\"\n    default_color: Color = attrs.field(repr=False, default=BrandColors.BLURPLE)\n\"\"\"The default colour to show on the embeds\"\"\"\n    default_button_color: Union[ButtonStyles, int] = attrs.field(repr=False, default=ButtonStyles.BLURPLE)\n\"\"\"The color of the buttons\"\"\"\n\n    _uuid: str = attrs.field(repr=False, factory=uuid.uuid4)\n    _message: Message = attrs.field(repr=False, default=MISSING)\n    _timeout_task: Timeout = attrs.field(repr=False, default=MISSING)\n    _author_id: Snowflake_Type = attrs.field(repr=False, default=MISSING)\n\n    def __attrs_post_init__(self) -&gt; None:\n        self.client.add_component_callback(\n            ComponentCommand(\n                name=f\"Paginator:{self._uuid}\",\n                callback=self._on_button,\n                listeners=[\n                    f\"{self._uuid}|select\",\n                    f\"{self._uuid}|first\",\n                    f\"{self._uuid}|back\",\n                    f\"{self._uuid}|callback\",\n                    f\"{self._uuid}|next\",\n                    f\"{self._uuid}|last\",\n                ],\n            )\n        )\n\n    @property\n    def message(self) -&gt; Message:\n\"\"\"The message this paginator is currently attached to\"\"\"\n        return self._message\n\n    @property\n    def author_id(self) -&gt; Snowflake_Type:\n\"\"\"The ID of the author of the message this paginator is currently attached to\"\"\"\n        return self._author_id\n\n    @classmethod\n    def create_from_embeds(cls, client: \"Client\", *embeds: Embed, timeout: int = 0) -&gt; \"Paginator\":\n\"\"\"Create a paginator system from a list of embeds.\n\n        Args:\n            client: A reference to the NAFF client\n            *embeds: The embeds to use for each page\n            timeout: A timeout to wait before closing the paginator\n\n        Returns:\n            A paginator system\n        \"\"\"\n        return cls(client, pages=list(embeds), timeout_interval=timeout)\n\n    @classmethod\n    def create_from_string(\n        cls, client: \"Client\", content: str, prefix: str = \"\", suffix: str = \"\", page_size: int = 4000, timeout: int = 0\n    ) -&gt; \"Paginator\":\n\"\"\"\n        Create a paginator system from a string.\n\n        Args:\n            client: A reference to the NAFF client\n            content: The content to paginate\n            prefix: The prefix for each page to use\n            suffix: The suffix for each page to use\n            page_size: The maximum characters for each page\n            timeout: A timeout to wait before closing the paginator\n\n        Returns:\n            A paginator system\n        \"\"\"\n        content_pages = textwrap.wrap(\n            content,\n            width=page_size - (len(prefix) + len(suffix)),\n            break_long_words=True,\n            break_on_hyphens=False,\n            replace_whitespace=False,\n        )\n        pages = [Page(c, prefix=prefix, suffix=suffix) for c in content_pages]\n        return cls(client, pages=pages, timeout_interval=timeout)\n\n    @classmethod\n    def create_from_list(\n        cls,\n        client: \"Client\",\n        content: list[str],\n        prefix: str = \"\",\n        suffix: str = \"\",\n        page_size: int = 4000,\n        timeout: int = 0,\n    ) -&gt; \"Paginator\":\n\"\"\"\n        Create a paginator from a list of strings. Useful to maintain formatting.\n\n        Args:\n            client: A reference to the NAFF client\n            content: The content to paginate\n            prefix: The prefix for each page to use\n            suffix: The suffix for each page to use\n            page_size: The maximum characters for each page\n            timeout: A timeout to wait before closing the paginator\n\n        Returns:\n            A paginator system\n        \"\"\"\n        pages = []\n        page = \"\"\n        for entry in content:\n            if len(page) + len(f\"\\n{entry}\") &lt;= page_size:\n                page += f\"{entry}\\n\"\n            else:\n                pages.append(Page(page, prefix=prefix, suffix=suffix))\n                page = \"\"\n        if page != \"\":\n            pages.append(Page(page, prefix=prefix, suffix=suffix))\n        return cls(client, pages=pages, timeout_interval=timeout)\n\n    def create_components(self, disable: bool = False) -&gt; List[ActionRow]:\n\"\"\"\n        Create the components for the paginator message.\n\n        Args:\n            disable: Should all the components be disabled?\n\n        Returns:\n            A list of ActionRows\n\n        \"\"\"\n        output = []\n\n        if self.show_select_menu:\n            current = self.pages[self.page_index]\n            output.append(\n                StringSelectMenu(\n                    [\n                        SelectOption(f\"{i+1} {p.get_summary if isinstance(p, Page) else p.title}\", str(i))\n                        for i, p in enumerate(self.pages)\n                    ],\n                    custom_id=f\"{self._uuid}|select\",\n                    placeholder=f\"{self.page_index+1} {current.get_summary if isinstance(current, Page) else current.title}\",\n                    max_values=1,\n                    disabled=disable,\n                )\n            )\n\n        if self.show_first_button:\n            output.append(\n                Button(\n                    self.default_button_color,\n                    emoji=self.first_button_emoji,\n                    custom_id=f\"{self._uuid}|first\",\n                    disabled=disable or self.page_index == 0,\n                )\n            )\n        if self.show_back_button:\n            output.append(\n                Button(\n                    self.default_button_color,\n                    emoji=self.back_button_emoji,\n                    custom_id=f\"{self._uuid}|back\",\n                    disabled=disable or self.page_index == 0,\n                )\n            )\n\n        if self.show_callback_button:\n            output.append(\n                Button(\n                    self.default_button_color,\n                    emoji=self.callback_button_emoji,\n                    custom_id=f\"{self._uuid}|callback\",\n                    disabled=disable,\n                )\n            )\n\n        if self.show_next_button:\n            output.append(\n                Button(\n                    self.default_button_color,\n                    emoji=self.next_button_emoji,\n                    custom_id=f\"{self._uuid}|next\",\n                    disabled=disable or self.page_index &gt;= len(self.pages) - 1,\n                )\n            )\n        if self.show_last_button:\n            output.append(\n                Button(\n                    self.default_button_color,\n                    emoji=self.last_button_emoji,\n                    custom_id=f\"{self._uuid}|last\",\n                    disabled=disable or self.page_index &gt;= len(self.pages) - 1,\n                )\n            )\n\n        return spread_to_rows(*output)\n\n    def to_dict(self) -&gt; dict:\n\"\"\"Convert this paginator into a dictionary for sending.\"\"\"\n        page = self.pages[self.page_index]\n\n        if isinstance(page, Page):\n            page = page.to_embed()\n            if not page.title and self.default_title:\n                page.title = self.default_title\n        if not page.footer:\n            page.set_footer(f\"Page {self.page_index+1}/{len(self.pages)}\")\n        if not page.color:\n            page.color = self.default_color\n\n        return {\"embeds\": [page.to_dict()], \"components\": [c.to_dict() for c in self.create_components()]}\n\n    async def send(self, ctx: Context) -&gt; Message:\n\"\"\"\n        Send this paginator.\n\n        Args:\n            ctx: The context to send this paginator with\n\n        Returns:\n            The resulting message\n\n        \"\"\"\n        self._message = await ctx.send(**self.to_dict())\n        self._author_id = ctx.author.id\n\n        if self.timeout_interval &gt; 1:\n            self._timeout_task = Timeout(self)\n            asyncio.create_task(self._timeout_task())\n\n        return self._message\n\n    async def reply(self, ctx: PrefixedContext) -&gt; Message:\n\"\"\"\n        Reply this paginator to ctx.\n\n        Args:\n            ctx: The context to reply this paginator with\n        Returns:\n            The resulting message\n        \"\"\"\n        self._message = await ctx.reply(**self.to_dict())\n        self._author_id = ctx.author.id\n\n        if self.timeout_interval &gt; 1:\n            self._timeout_task = Timeout(self)\n            asyncio.create_task(self._timeout_task())\n\n        return self._message\n\n    async def stop(self) -&gt; None:\n\"\"\"Disable this paginator.\"\"\"\n        if self._timeout_task:\n            self._timeout_task.run = False\n            self._timeout_task.ping.set()\n        await self._message.edit(components=self.create_components(True))\n\n    async def update(self) -&gt; None:\n\"\"\"\n        Update the paginator to the current state.\n\n        Use this if you have programmatically changed the page_index\n\n        \"\"\"\n        await self._message.edit(**self.to_dict())\n\n    async def _on_button(self, ctx: ComponentContext, *args, **kwargs) -&gt; Optional[Message]:\n        if ctx.author.id == self.author_id:\n            if self._timeout_task:\n                self._timeout_task.ping.set()\n            match ctx.custom_id.split(\"|\")[1]:\n                case \"first\":\n                    self.page_index = 0\n                case \"last\":\n                    self.page_index = len(self.pages) - 1\n                case \"next\":\n                    if (self.page_index + 1) &lt; len(self.pages):\n                        self.page_index += 1\n                case \"back\":\n                    if (self.page_index - 1) &gt;= 0:\n                        self.page_index -= 1\n                case \"select\":\n                    self.page_index = int(ctx.values[0])\n                case \"callback\":\n                    if self.callback:\n                        return await self.callback(ctx)\n\n            await ctx.edit_origin(**self.to_dict())\n        else:\n            if self.wrong_user_message:\n                return await ctx.send(self.wrong_user_message, ephemeral=True)\n            else:\n                # silently ignore\n                return await ctx.defer(edit_origin=True)\n        return None\n</code></pre>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.client","title":"<code>client: Client = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The NAFF client to hook listeners into</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.page_index","title":"<code>page_index: int = attrs.field(repr=False, kw_only=True, default=0)</code>  <code>class-attribute</code>","text":"<p>The index of the current page being displayed</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.pages","title":"<code>pages: Sequence[Page | Embed] = attrs.field(repr=False, factory=list, kw_only=True)</code>  <code>class-attribute</code>","text":"<p>The pages this paginator holds</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.timeout_interval","title":"<code>timeout_interval: int = attrs.field(repr=False, default=0, kw_only=True)</code>  <code>class-attribute</code>","text":"<p>How long until this paginator disables itself</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.callback","title":"<code>callback: Callable[..., Coroutine] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>A coroutine to call should the select button be pressed</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.show_first_button","title":"<code>show_first_button: bool = attrs.field(repr=False, default=True)</code>  <code>class-attribute</code>","text":"<p>Should a <code>First</code> button be shown</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.show_back_button","title":"<code>show_back_button: bool = attrs.field(repr=False, default=True)</code>  <code>class-attribute</code>","text":"<p>Should a <code>Back</code> button be shown</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.show_next_button","title":"<code>show_next_button: bool = attrs.field(repr=False, default=True)</code>  <code>class-attribute</code>","text":"<p>Should a <code>Next</code> button be shown</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.show_last_button","title":"<code>show_last_button: bool = attrs.field(repr=False, default=True)</code>  <code>class-attribute</code>","text":"<p>Should a <code>Last</code> button be shown</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.show_callback_button","title":"<code>show_callback_button: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>Show a button which will call the <code>callback</code></p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.show_select_menu","title":"<code>show_select_menu: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>Should a select menu be shown for navigation</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.first_button_emoji","title":"<code>first_button_emoji: Optional[Union[PartialEmoji, dict, str]] = attrs.field(repr=False, default='\u23ee\ufe0f', metadata=export_converter(process_emoji))</code>  <code>class-attribute</code>","text":"<p>The emoji to use for the first button</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.back_button_emoji","title":"<code>back_button_emoji: Optional[Union[PartialEmoji, dict, str]] = attrs.field(repr=False, default='\u2b05\ufe0f', metadata=export_converter(process_emoji))</code>  <code>class-attribute</code>","text":"<p>The emoji to use for the back button</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.next_button_emoji","title":"<code>next_button_emoji: Optional[Union[PartialEmoji, dict, str]] = attrs.field(repr=False, default='\u27a1\ufe0f', metadata=export_converter(process_emoji))</code>  <code>class-attribute</code>","text":"<p>The emoji to use for the next button</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.last_button_emoji","title":"<code>last_button_emoji: Optional[Union[PartialEmoji, dict, str]] = attrs.field(repr=False, default='\u23e9', metadata=export_converter(process_emoji))</code>  <code>class-attribute</code>","text":"<p>The emoji to use for the last button</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.callback_button_emoji","title":"<code>callback_button_emoji: Optional[Union[PartialEmoji, dict, str]] = attrs.field(repr=False, default='\u2705', metadata=export_converter(process_emoji))</code>  <code>class-attribute</code>","text":"<p>The emoji to use for the callback button</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.wrong_user_message","title":"<code>wrong_user_message: str = attrs.field(repr=False, default='This paginator is not for you')</code>  <code>class-attribute</code>","text":"<p>The message to be sent when the wrong user uses this paginator</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.default_title","title":"<code>default_title: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The default title to show on the embeds</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.default_color","title":"<code>default_color: Color = attrs.field(repr=False, default=BrandColors.BLURPLE)</code>  <code>class-attribute</code>","text":"<p>The default colour to show on the embeds</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.default_button_color","title":"<code>default_button_color: Union[ButtonStyles, int] = attrs.field(repr=False, default=ButtonStyles.BLURPLE)</code>  <code>class-attribute</code>","text":"<p>The color of the buttons</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.message","title":"<code>message: Message</code>  <code>property</code>","text":"<p>The message this paginator is currently attached to</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.author_id","title":"<code>author_id: Snowflake_Type</code>  <code>property</code>","text":"<p>The ID of the author of the message this paginator is currently attached to</p>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.create_from_embeds","title":"<code>create_from_embeds(client, *embeds, timeout=0)</code>  <code>classmethod</code>","text":"<p>Create a paginator system from a list of embeds.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>A reference to the NAFF client</p> required <code>*embeds</code> <code>Embed</code> <p>The embeds to use for each page</p> <code>()</code> <code>timeout</code> <code>int</code> <p>A timeout to wait before closing the paginator</p> <code>0</code> <p>Returns:</p> Type Description <code>Paginator</code> <p>A paginator system</p> Source code in <code>naff\\ext\\paginators.py</code> <pre><code>@classmethod\ndef create_from_embeds(cls, client: \"Client\", *embeds: Embed, timeout: int = 0) -&gt; \"Paginator\":\n\"\"\"Create a paginator system from a list of embeds.\n\n    Args:\n        client: A reference to the NAFF client\n        *embeds: The embeds to use for each page\n        timeout: A timeout to wait before closing the paginator\n\n    Returns:\n        A paginator system\n    \"\"\"\n    return cls(client, pages=list(embeds), timeout_interval=timeout)\n</code></pre>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.create_from_string","title":"<code>create_from_string(client, content, prefix='', suffix='', page_size=4000, timeout=0)</code>  <code>classmethod</code>","text":"<p>Create a paginator system from a string.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>A reference to the NAFF client</p> required <code>content</code> <code>str</code> <p>The content to paginate</p> required <code>prefix</code> <code>str</code> <p>The prefix for each page to use</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The suffix for each page to use</p> <code>''</code> <code>page_size</code> <code>int</code> <p>The maximum characters for each page</p> <code>4000</code> <code>timeout</code> <code>int</code> <p>A timeout to wait before closing the paginator</p> <code>0</code> <p>Returns:</p> Type Description <code>Paginator</code> <p>A paginator system</p> Source code in <code>naff\\ext\\paginators.py</code> <pre><code>@classmethod\ndef create_from_string(\n    cls, client: \"Client\", content: str, prefix: str = \"\", suffix: str = \"\", page_size: int = 4000, timeout: int = 0\n) -&gt; \"Paginator\":\n\"\"\"\n    Create a paginator system from a string.\n\n    Args:\n        client: A reference to the NAFF client\n        content: The content to paginate\n        prefix: The prefix for each page to use\n        suffix: The suffix for each page to use\n        page_size: The maximum characters for each page\n        timeout: A timeout to wait before closing the paginator\n\n    Returns:\n        A paginator system\n    \"\"\"\n    content_pages = textwrap.wrap(\n        content,\n        width=page_size - (len(prefix) + len(suffix)),\n        break_long_words=True,\n        break_on_hyphens=False,\n        replace_whitespace=False,\n    )\n    pages = [Page(c, prefix=prefix, suffix=suffix) for c in content_pages]\n    return cls(client, pages=pages, timeout_interval=timeout)\n</code></pre>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.create_from_list","title":"<code>create_from_list(client, content, prefix='', suffix='', page_size=4000, timeout=0)</code>  <code>classmethod</code>","text":"<p>Create a paginator from a list of strings. Useful to maintain formatting.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>A reference to the NAFF client</p> required <code>content</code> <code>list[str]</code> <p>The content to paginate</p> required <code>prefix</code> <code>str</code> <p>The prefix for each page to use</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The suffix for each page to use</p> <code>''</code> <code>page_size</code> <code>int</code> <p>The maximum characters for each page</p> <code>4000</code> <code>timeout</code> <code>int</code> <p>A timeout to wait before closing the paginator</p> <code>0</code> <p>Returns:</p> Type Description <code>Paginator</code> <p>A paginator system</p> Source code in <code>naff\\ext\\paginators.py</code> <pre><code>@classmethod\ndef create_from_list(\n    cls,\n    client: \"Client\",\n    content: list[str],\n    prefix: str = \"\",\n    suffix: str = \"\",\n    page_size: int = 4000,\n    timeout: int = 0,\n) -&gt; \"Paginator\":\n\"\"\"\n    Create a paginator from a list of strings. Useful to maintain formatting.\n\n    Args:\n        client: A reference to the NAFF client\n        content: The content to paginate\n        prefix: The prefix for each page to use\n        suffix: The suffix for each page to use\n        page_size: The maximum characters for each page\n        timeout: A timeout to wait before closing the paginator\n\n    Returns:\n        A paginator system\n    \"\"\"\n    pages = []\n    page = \"\"\n    for entry in content:\n        if len(page) + len(f\"\\n{entry}\") &lt;= page_size:\n            page += f\"{entry}\\n\"\n        else:\n            pages.append(Page(page, prefix=prefix, suffix=suffix))\n            page = \"\"\n    if page != \"\":\n        pages.append(Page(page, prefix=prefix, suffix=suffix))\n    return cls(client, pages=pages, timeout_interval=timeout)\n</code></pre>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.create_components","title":"<code>create_components(disable=False)</code>","text":"<p>Create the components for the paginator message.</p> <p>Parameters:</p> Name Type Description Default <code>disable</code> <code>bool</code> <p>Should all the components be disabled?</p> <code>False</code> <p>Returns:</p> Type Description <code>List[ActionRow]</code> <p>A list of ActionRows</p> Source code in <code>naff\\ext\\paginators.py</code> <pre><code>def create_components(self, disable: bool = False) -&gt; List[ActionRow]:\n\"\"\"\n    Create the components for the paginator message.\n\n    Args:\n        disable: Should all the components be disabled?\n\n    Returns:\n        A list of ActionRows\n\n    \"\"\"\n    output = []\n\n    if self.show_select_menu:\n        current = self.pages[self.page_index]\n        output.append(\n            StringSelectMenu(\n                [\n                    SelectOption(f\"{i+1} {p.get_summary if isinstance(p, Page) else p.title}\", str(i))\n                    for i, p in enumerate(self.pages)\n                ],\n                custom_id=f\"{self._uuid}|select\",\n                placeholder=f\"{self.page_index+1} {current.get_summary if isinstance(current, Page) else current.title}\",\n                max_values=1,\n                disabled=disable,\n            )\n        )\n\n    if self.show_first_button:\n        output.append(\n            Button(\n                self.default_button_color,\n                emoji=self.first_button_emoji,\n                custom_id=f\"{self._uuid}|first\",\n                disabled=disable or self.page_index == 0,\n            )\n        )\n    if self.show_back_button:\n        output.append(\n            Button(\n                self.default_button_color,\n                emoji=self.back_button_emoji,\n                custom_id=f\"{self._uuid}|back\",\n                disabled=disable or self.page_index == 0,\n            )\n        )\n\n    if self.show_callback_button:\n        output.append(\n            Button(\n                self.default_button_color,\n                emoji=self.callback_button_emoji,\n                custom_id=f\"{self._uuid}|callback\",\n                disabled=disable,\n            )\n        )\n\n    if self.show_next_button:\n        output.append(\n            Button(\n                self.default_button_color,\n                emoji=self.next_button_emoji,\n                custom_id=f\"{self._uuid}|next\",\n                disabled=disable or self.page_index &gt;= len(self.pages) - 1,\n            )\n        )\n    if self.show_last_button:\n        output.append(\n            Button(\n                self.default_button_color,\n                emoji=self.last_button_emoji,\n                custom_id=f\"{self._uuid}|last\",\n                disabled=disable or self.page_index &gt;= len(self.pages) - 1,\n            )\n        )\n\n    return spread_to_rows(*output)\n</code></pre>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert this paginator into a dictionary for sending.</p> Source code in <code>naff\\ext\\paginators.py</code> <pre><code>def to_dict(self) -&gt; dict:\n\"\"\"Convert this paginator into a dictionary for sending.\"\"\"\n    page = self.pages[self.page_index]\n\n    if isinstance(page, Page):\n        page = page.to_embed()\n        if not page.title and self.default_title:\n            page.title = self.default_title\n    if not page.footer:\n        page.set_footer(f\"Page {self.page_index+1}/{len(self.pages)}\")\n    if not page.color:\n        page.color = self.default_color\n\n    return {\"embeds\": [page.to_dict()], \"components\": [c.to_dict() for c in self.create_components()]}\n</code></pre>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.send","title":"<code>send(ctx)</code>  <code>async</code>","text":"<p>Send this paginator.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context to send this paginator with</p> required <p>Returns:</p> Type Description <code>Message</code> <p>The resulting message</p> Source code in <code>naff\\ext\\paginators.py</code> <pre><code>async def send(self, ctx: Context) -&gt; Message:\n\"\"\"\n    Send this paginator.\n\n    Args:\n        ctx: The context to send this paginator with\n\n    Returns:\n        The resulting message\n\n    \"\"\"\n    self._message = await ctx.send(**self.to_dict())\n    self._author_id = ctx.author.id\n\n    if self.timeout_interval &gt; 1:\n        self._timeout_task = Timeout(self)\n        asyncio.create_task(self._timeout_task())\n\n    return self._message\n</code></pre>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.reply","title":"<code>reply(ctx)</code>  <code>async</code>","text":"<p>Reply this paginator to ctx.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>PrefixedContext</code> <p>The context to reply this paginator with</p> required <p>Returns:</p> Type Description <code>Message</code> <p>The resulting message</p> Source code in <code>naff\\ext\\paginators.py</code> <pre><code>async def reply(self, ctx: PrefixedContext) -&gt; Message:\n\"\"\"\n    Reply this paginator to ctx.\n\n    Args:\n        ctx: The context to reply this paginator with\n    Returns:\n        The resulting message\n    \"\"\"\n    self._message = await ctx.reply(**self.to_dict())\n    self._author_id = ctx.author.id\n\n    if self.timeout_interval &gt; 1:\n        self._timeout_task = Timeout(self)\n        asyncio.create_task(self._timeout_task())\n\n    return self._message\n</code></pre>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Disable this paginator.</p> Source code in <code>naff\\ext\\paginators.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Disable this paginator.\"\"\"\n    if self._timeout_task:\n        self._timeout_task.run = False\n        self._timeout_task.ping.set()\n    await self._message.edit(components=self.create_components(True))\n</code></pre>"},{"location":"API%20Reference/ext/paginators/#naff.ext.paginators.Paginator.update","title":"<code>update()</code>  <code>async</code>","text":"<p>Update the paginator to the current state.</p> <p>Use this if you have programmatically changed the page_index</p> Source code in <code>naff\\ext\\paginators.py</code> <pre><code>async def update(self) -&gt; None:\n\"\"\"\n    Update the paginator to the current state.\n\n    Use this if you have programmatically changed the page_index\n\n    \"\"\"\n    await self._message.edit(**self.to_dict())\n</code></pre>"},{"location":"API%20Reference/ext/prefixed_help_command/","title":"Prefixed help command","text":""},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand","title":"<code>PrefixedHelpCommand</code>","text":"<p>A help command for all prefixed commands in a bot.</p> Source code in <code>naff\\ext\\prefixed_help.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, slots=True)\nclass PrefixedHelpCommand:\n\"\"\"A help command for all prefixed commands in a bot.\"\"\"\n\n    client: \"Client\" = attrs.field()\n\"\"\"The client to use for the help command.\"\"\"\n\n    show_hidden: bool = attrs.field(default=False, kw_only=True)\n\"\"\"Should hidden commands be shown?\"\"\"\n    show_disabled: bool = attrs.field(default=False, kw_only=True)\n\"\"\"Should disabled commands be shown?\"\"\"\n    run_checks: bool = attrs.field(default=False, kw_only=True)\n\"\"\"Should only commands that's checks pass be shown?\"\"\"\n    show_self: bool = attrs.field(default=False, kw_only=True)\n\"\"\"Should this command be shown in the help message?\"\"\"\n    show_usage: bool = attrs.field(default=False, kw_only=True)\n\"\"\"Should usage for commands be shown?\"\"\"\n    show_aliases: bool = attrs.field(default=False, kw_only=True)\n\"\"\"Should aliases for commands be shown?\"\"\"\n    show_prefix: bool = attrs.field(default=False, kw_only=True)\n\"\"\"Should the prefix be shown?\"\"\"\n    embed_color: Color = attrs.field(default=BrandColors.BLURPLE, kw_only=True)\n\"\"\"The colour to show in the Embeds.\"\"\"\n\n    embed_title: str = attrs.field(default=\"{username} Help Command\", kw_only=True)\n\"\"\"The title to use in the embed. {username} will be replaced by the client's username.\"\"\"\n    not_found_message: str = attrs.field(default=\"Sorry! No command called `{cmd_name}` was found.\", kw_only=True)\n\"\"\"The message to send when a command was not found. {cmd_name} will be replaced by the requested command.\"\"\"\n    fallback_help_string: str = attrs.field(default=\"No help message available.\", kw_only=True)\n\"\"\"The text to display when a command does not have a help string defined.\"\"\"\n    fallback_brief_string: str = attrs.field(default=\"No help message available.\", kw_only=True)\n\"\"\"The text to display when a command does not have a brief string defined.\"\"\"\n\n    _cmd: PrefixedCommand = attrs.field(init=False, default=None)\n    logger: Logger = attrs.field(init=False, factory=get_logger)\n\n    def __attrs_post_init__(self) -&gt; None:\n        if not self._cmd:\n            self._cmd = self._callback  # type: ignore\n\n    def register(self) -&gt; None:\n\"\"\"Registers the help command.\"\"\"\n        if not isinstance(self._cmd.callback, functools.partial):\n            # prevent wrap-nesting\n            self._cmd.callback = functools.partial(self._cmd.callback, self)\n\n        # replace existing help command if found\n        if \"help\" in self.client.prefixed_commands:\n            self.logger.warning(\"Replacing existing help command.\")\n            del self.client.prefixed_commands[\"help\"]\n\n        self.client.add_prefixed_command(self._cmd)  # type: ignore\n\n    async def send_help(self, ctx: PrefixedContext, cmd_name: str | None) -&gt; None:\n\"\"\"\n        Send a help message to the given context.\n\n        Args:\n            ctx: The context to use.\n            cmd_name: An optional command name to send help for.\n        \"\"\"\n        await self._callback.callback(ctx, cmd_name)  # type: ignore\n\n    @prefixed_command(name=\"help\")\n    async def _callback(self, ctx: PrefixedContext, *, cmd_name: str = None) -&gt; None:\n        if cmd_name:\n            return await self._help_specific(ctx, cmd_name)\n        await self._help_list(ctx)\n\n    async def _help_list(self, ctx: PrefixedContext) -&gt; None:\n        cmds = await self._gather(ctx)\n\n        output = []\n        for cmd in cmds.values():\n            _temp = self._generate_command_string(cmd, ctx)\n            _temp += f\"\\n{cmd.brief or self.fallback_brief_string}\"\n\n            output.append(self._sanitise_mentions(_temp))\n        if len(\"\\n\".join(output)) &gt; 500:\n            paginator = Paginator.create_from_list(self.client, output, page_size=500)\n            paginator.default_color = self.embed_color\n            paginator.default_title = self.embed_title.format(username=self.client.user.username)\n            await paginator.send(ctx)\n        else:\n            embed = Embed(\n                title=self.embed_title.format(username=self.client.user.username),\n                description=\"\\n\".join(output),\n                color=self.embed_color,\n            )\n            await ctx.reply(embeds=embed)\n\n    async def _help_specific(self, ctx: PrefixedContext, cmd_name: str) -&gt; None:\n        cmds = await self._gather(ctx)\n\n        if cmd := cmds.get(cmd_name.lower()):\n            _temp = self._generate_command_string(cmd, ctx)\n            _temp += f\"\\n{cmd.help or self.fallback_help_string}\"\n            await ctx.reply(self._sanitise_mentions(_temp))\n        else:\n            await ctx.reply(self.not_found_message.format(cmd_name=cmd_name))\n\n    async def _gather(self, ctx: PrefixedContext | None = None) -&gt; dict[str, PrefixedCommand]:\n\"\"\"\n        Gather commands based on the rules set out in the class attributes.\n\n        Args:\n            ctx: The context to use to establish usability.\n        Returns:\n            dict[str, PrefixedCommand]: A list of commands fit the class attribute configuration.\n        \"\"\"\n        out: dict[str, PrefixedCommand] = {}\n\n        for cmd in frozenset(self.client.prefixed_commands.values()):\n            if not cmd.enabled and not self.show_disabled:\n                continue\n\n            if cmd == self._cmd and not self.show_self:\n                continue\n\n            if cmd.hidden and not self.show_hidden:\n                continue\n\n            if ctx and cmd.checks and not self.run_checks:\n                # cmd._can_run would check the cooldowns, we don't want that so manual calling is required\n                for _c in cmd.checks:\n                    if not await _c(ctx):\n                        continue\n\n                if cmd.extension and cmd.extension.extension_checks:\n                    for _c in cmd.extension.extension_checks:\n                        if not await _c(ctx):\n                            continue\n\n            out[cmd.qualified_name] = cmd\n\n        return out\n\n    def _sanitise_mentions(self, text: str) -&gt; str:\n\"\"\"\n        Replace mentions with a format that won't ping or look weird in code blocks.\n\n        args:\n            The text to sanitise.\n        \"\"\"\n        mappings = {\n            \"@everyone\": \"@\\u200beveryone\",\n            \"@here\": \"@\\u200bhere\",\n            f\"&lt;@{self.client.user.id}&gt;\": f\"@{self.client.user.username}\",\n            f\"&lt;@!{self.client.user.id}&gt;\": f\"@{self.client.user.username}\",\n        }\n        for source, target in mappings.items():\n            text = text.replace(source, target)\n\n        return text\n\n    def _generate_command_string(self, cmd: PrefixedCommand, ctx: PrefixedContext) -&gt; str:\n\"\"\"\n        Generate a string based on a command, class attributes, and the context.\n\n        args:\n            cmd: The command in question.\n            ctx: The context for this command.\n        \"\"\"\n        _temp = f\"`{ctx.prefix if self.show_prefix else ''}{cmd.qualified_name}`\"\n\n        if cmd.aliases and self.show_aliases:\n            _temp += \"|\" + \"|\".join([f\"`{a}`\" for a in cmd.aliases])\n\n        if cmd.usage and self.show_usage:\n            _temp += f\" {cmd.usage}\"\n        return _temp\n</code></pre>"},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand.client","title":"<code>client: Client = attrs.field()</code>  <code>class-attribute</code>","text":"<p>The client to use for the help command.</p>"},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand.show_hidden","title":"<code>show_hidden: bool = attrs.field(default=False, kw_only=True)</code>  <code>class-attribute</code>","text":"<p>Should hidden commands be shown?</p>"},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand.show_disabled","title":"<code>show_disabled: bool = attrs.field(default=False, kw_only=True)</code>  <code>class-attribute</code>","text":"<p>Should disabled commands be shown?</p>"},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand.run_checks","title":"<code>run_checks: bool = attrs.field(default=False, kw_only=True)</code>  <code>class-attribute</code>","text":"<p>Should only commands that's checks pass be shown?</p>"},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand.show_self","title":"<code>show_self: bool = attrs.field(default=False, kw_only=True)</code>  <code>class-attribute</code>","text":"<p>Should this command be shown in the help message?</p>"},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand.show_usage","title":"<code>show_usage: bool = attrs.field(default=False, kw_only=True)</code>  <code>class-attribute</code>","text":"<p>Should usage for commands be shown?</p>"},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand.show_aliases","title":"<code>show_aliases: bool = attrs.field(default=False, kw_only=True)</code>  <code>class-attribute</code>","text":"<p>Should aliases for commands be shown?</p>"},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand.show_prefix","title":"<code>show_prefix: bool = attrs.field(default=False, kw_only=True)</code>  <code>class-attribute</code>","text":"<p>Should the prefix be shown?</p>"},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand.embed_color","title":"<code>embed_color: Color = attrs.field(default=BrandColors.BLURPLE, kw_only=True)</code>  <code>class-attribute</code>","text":"<p>The colour to show in the Embeds.</p>"},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand.embed_title","title":"<code>embed_title: str = attrs.field(default='{username} Help Command', kw_only=True)</code>  <code>class-attribute</code>","text":"<p>The title to use in the embed. {username} will be replaced by the client's username.</p>"},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand.not_found_message","title":"<code>not_found_message: str = attrs.field(default='Sorry! No command called `{cmd_name}` was found.', kw_only=True)</code>  <code>class-attribute</code>","text":"<p>The message to send when a command was not found. {cmd_name} will be replaced by the requested command.</p>"},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand.fallback_help_string","title":"<code>fallback_help_string: str = attrs.field(default='No help message available.', kw_only=True)</code>  <code>class-attribute</code>","text":"<p>The text to display when a command does not have a help string defined.</p>"},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand.fallback_brief_string","title":"<code>fallback_brief_string: str = attrs.field(default='No help message available.', kw_only=True)</code>  <code>class-attribute</code>","text":"<p>The text to display when a command does not have a brief string defined.</p>"},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand.register","title":"<code>register()</code>","text":"<p>Registers the help command.</p> Source code in <code>naff\\ext\\prefixed_help.py</code> <pre><code>def register(self) -&gt; None:\n\"\"\"Registers the help command.\"\"\"\n    if not isinstance(self._cmd.callback, functools.partial):\n        # prevent wrap-nesting\n        self._cmd.callback = functools.partial(self._cmd.callback, self)\n\n    # replace existing help command if found\n    if \"help\" in self.client.prefixed_commands:\n        self.logger.warning(\"Replacing existing help command.\")\n        del self.client.prefixed_commands[\"help\"]\n\n    self.client.add_prefixed_command(self._cmd)  # type: ignore\n</code></pre>"},{"location":"API%20Reference/ext/prefixed_help_command/#naff.ext.prefixed_help.PrefixedHelpCommand.send_help","title":"<code>send_help(ctx, cmd_name)</code>  <code>async</code>","text":"<p>Send a help message to the given context.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>PrefixedContext</code> <p>The context to use.</p> required <code>cmd_name</code> <code>str | None</code> <p>An optional command name to send help for.</p> required Source code in <code>naff\\ext\\prefixed_help.py</code> <pre><code>async def send_help(self, ctx: PrefixedContext, cmd_name: str | None) -&gt; None:\n\"\"\"\n    Send a help message to the given context.\n\n    Args:\n        ctx: The context to use.\n        cmd_name: An optional command name to send help for.\n    \"\"\"\n    await self._callback.callback(ctx, cmd_name)  # type: ignore\n</code></pre>"},{"location":"API%20Reference/models/","title":"Models","text":"<p>Within these pages, you will find a list of all available models within NAFF.</p> <ul> <li> <p>Discord</p> <ul> <li>Models representing Discord objects</li> </ul> </li> <li> <p>Client</p> <ul> <li>Models for library constructs</li> </ul> </li> <li> <p>Misc</p> <ul> <li>Models for constructs that fit neither category</li> </ul> </li> </ul>"},{"location":"API%20Reference/models/Discord/","title":"Discord Models Index","text":"<ul> <li>Activity</li> <li>Application</li> <li>Asset</li> <li>Base</li> <li>Channel</li> <li>Color</li> <li>Components</li> <li>Embed</li> <li>Emoji</li> <li>Enums</li> <li>File</li> <li>Guild</li> <li>Index</li> <li>Invite</li> <li>Message</li> <li>Modals</li> <li>Reaction</li> <li>Role</li> <li>Scheduled event</li> <li>Snowflake</li> <li>Stage instance</li> <li>Sticker</li> <li>Team</li> <li>Thread</li> <li>Timestamp</li> <li>User</li> <li>Voice state</li> <li>Webhooks</li> </ul>"},{"location":"API%20Reference/models/Discord/activity/","title":"Activity","text":""},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.ActivityTimestamps","title":"<code>ActivityTimestamps</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> Source code in <code>naff\\models\\discord\\activity.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ActivityTimestamps(DictSerializationMixin):\n    start: Optional[Timestamp] = attrs.field(repr=False, default=None, converter=optional(timestamp_converter))\n\"\"\"The start time of the activity. Shows \"elapsed\" timer on discord client.\"\"\"\n    end: Optional[Timestamp] = attrs.field(repr=False, default=None, converter=optional(timestamp_converter))\n\"\"\"The end time of the activity. Shows \"remaining\" timer on discord client.\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.ActivityTimestamps.start","title":"<code>start: Optional[Timestamp] = attrs.field(repr=False, default=None, converter=optional(timestamp_converter))</code>  <code>class-attribute</code>","text":"<p>The start time of the activity. Shows \"elapsed\" timer on discord client.</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.ActivityTimestamps.end","title":"<code>end: Optional[Timestamp] = attrs.field(repr=False, default=None, converter=optional(timestamp_converter))</code>  <code>class-attribute</code>","text":"<p>The end time of the activity. Shows \"remaining\" timer on discord client.</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.ActivityParty","title":"<code>ActivityParty</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> Source code in <code>naff\\models\\discord\\activity.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ActivityParty(DictSerializationMixin):\n    id: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"A unique identifier for this party\"\"\"\n    size: Optional[List[int]] = attrs.field(repr=False, default=None)\n\"\"\"Info about the size of the party\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.ActivityParty.id","title":"<code>id: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>A unique identifier for this party</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.ActivityParty.size","title":"<code>size: Optional[List[int]] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>Info about the size of the party</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.ActivityAssets","title":"<code>ActivityAssets</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> Source code in <code>naff\\models\\discord\\activity.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ActivityAssets(DictSerializationMixin):\n    large_image: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The large image for this activity. Uses discord's asset image url format.\"\"\"\n    large_text: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"Hover text for the large image\"\"\"\n    small_image: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The large image for this activity. Uses discord's asset image url format.\"\"\"\n    small_text: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"Hover text for the small image\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.ActivityAssets.large_image","title":"<code>large_image: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The large image for this activity. Uses discord's asset image url format.</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.ActivityAssets.large_text","title":"<code>large_text: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>Hover text for the large image</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.ActivityAssets.small_image","title":"<code>small_image: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The large image for this activity. Uses discord's asset image url format.</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.ActivityAssets.small_text","title":"<code>small_text: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>Hover text for the small image</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.ActivitySecrets","title":"<code>ActivitySecrets</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> Source code in <code>naff\\models\\discord\\activity.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ActivitySecrets(DictSerializationMixin):\n    join: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The secret for joining a party\"\"\"\n    spectate: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The secret for spectating a party\"\"\"\n    match: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The secret for a specific instanced match\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.ActivitySecrets.join","title":"<code>join: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The secret for joining a party</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.ActivitySecrets.spectate","title":"<code>spectate: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The secret for spectating a party</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.ActivitySecrets.match","title":"<code>match: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The secret for a specific instanced match</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity","title":"<code>Activity</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> <p>Represents a discord activity object use for rich presence in discord.</p> Source code in <code>naff\\models\\discord\\activity.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Activity(DictSerializationMixin):\n\"\"\"Represents a discord activity object use for rich presence in discord.\"\"\"\n\n    name: str = attrs.field(repr=True)\n\"\"\"The activity's name\"\"\"\n    type: ActivityType = attrs.field(repr=True, default=ActivityType.GAME)\n\"\"\"The type of activity\"\"\"\n    url: Optional[str] = attrs.field(repr=True, default=None)\n\"\"\"Stream url, is validated when type is 1\"\"\"\n    created_at: Optional[Timestamp] = attrs.field(repr=True, default=None, converter=optional(timestamp_converter))\n\"\"\"When the activity was added to the user's session\"\"\"\n    timestamps: Optional[ActivityTimestamps] = attrs.field(\n        repr=False, default=None, converter=optional(ActivityTimestamps.from_dict)\n    )\n\"\"\"Start and/or end of the game\"\"\"\n    application_id: \"Snowflake_Type\" = attrs.field(repr=False, default=None)\n\"\"\"Application id for the game\"\"\"\n    details: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"What the player is currently doing\"\"\"\n    state: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The user's current party status\"\"\"\n    emoji: Optional[PartialEmoji] = attrs.field(repr=False, default=None, converter=optional(PartialEmoji.from_dict))\n\"\"\"The emoji used for a custom status\"\"\"\n    party: Optional[ActivityParty] = attrs.field(repr=False, default=None, converter=optional(ActivityParty.from_dict))\n\"\"\"Information for the current party of the player\"\"\"\n    assets: Optional[ActivityAssets] = attrs.field(\n        repr=False, default=None, converter=optional(ActivityAssets.from_dict)\n    )\n\"\"\"Assets to display on the player's profile\"\"\"\n    secrets: Optional[ActivitySecrets] = attrs.field(\n        repr=False, default=None, converter=optional(ActivitySecrets.from_dict)\n    )\n\"\"\"Secrets for Rich Presence joining and spectating\"\"\"\n    instance: Optional[bool] = attrs.field(repr=False, default=False)\n\"\"\"Whether or not the activity is an instanced game session\"\"\"\n    flags: Optional[ActivityFlags] = attrs.field(repr=False, default=None, converter=optional(ActivityFlags))\n\"\"\"Activity flags bitwise OR together, describes what the payload includes\"\"\"\n    buttons: List[str] = attrs.field(repr=False, factory=list)\n\"\"\"The custom buttons shown in the Rich Presence (max 2)\"\"\"\n\n    @classmethod\n    def create(cls, name: str, type: ActivityType = ActivityType.GAME, url: Optional[str] = None) -&gt; \"Activity\":\n\"\"\"\n        Creates an activity object for the bot.\n\n        Args:\n            name: The new activity's name\n            type: Type of activity to create\n            url: Stream link for the activity\n\n        Returns:\n            The new activity object\n\n        \"\"\"\n        return cls(name=name, type=type, url=url)  # noqa\n\n    def to_dict(self) -&gt; dict:\n        return dict_filter_none({\"name\": self.name, \"type\": self.type, \"url\": self.url})\n</code></pre>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.name","title":"<code>name: str = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>The activity's name</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.type","title":"<code>type: ActivityType = attrs.field(repr=True, default=ActivityType.GAME)</code>  <code>class-attribute</code>","text":"<p>The type of activity</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.url","title":"<code>url: Optional[str] = attrs.field(repr=True, default=None)</code>  <code>class-attribute</code>","text":"<p>Stream url, is validated when type is 1</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.created_at","title":"<code>created_at: Optional[Timestamp] = attrs.field(repr=True, default=None, converter=optional(timestamp_converter))</code>  <code>class-attribute</code>","text":"<p>When the activity was added to the user's session</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.timestamps","title":"<code>timestamps: Optional[ActivityTimestamps] = attrs.field(repr=False, default=None, converter=optional(ActivityTimestamps.from_dict))</code>  <code>class-attribute</code>","text":"<p>Start and/or end of the game</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.application_id","title":"<code>application_id: Snowflake_Type = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>Application id for the game</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.details","title":"<code>details: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>What the player is currently doing</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.state","title":"<code>state: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The user's current party status</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.emoji","title":"<code>emoji: Optional[PartialEmoji] = attrs.field(repr=False, default=None, converter=optional(PartialEmoji.from_dict))</code>  <code>class-attribute</code>","text":"<p>The emoji used for a custom status</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.party","title":"<code>party: Optional[ActivityParty] = attrs.field(repr=False, default=None, converter=optional(ActivityParty.from_dict))</code>  <code>class-attribute</code>","text":"<p>Information for the current party of the player</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.assets","title":"<code>assets: Optional[ActivityAssets] = attrs.field(repr=False, default=None, converter=optional(ActivityAssets.from_dict))</code>  <code>class-attribute</code>","text":"<p>Assets to display on the player's profile</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.secrets","title":"<code>secrets: Optional[ActivitySecrets] = attrs.field(repr=False, default=None, converter=optional(ActivitySecrets.from_dict))</code>  <code>class-attribute</code>","text":"<p>Secrets for Rich Presence joining and spectating</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.instance","title":"<code>instance: Optional[bool] = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>Whether or not the activity is an instanced game session</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.flags","title":"<code>flags: Optional[ActivityFlags] = attrs.field(repr=False, default=None, converter=optional(ActivityFlags))</code>  <code>class-attribute</code>","text":"<p>Activity flags bitwise OR together, describes what the payload includes</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.buttons","title":"<code>buttons: List[str] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>The custom buttons shown in the Rich Presence (max 2)</p>"},{"location":"API%20Reference/models/Discord/activity/#naff.models.discord.activity.Activity.create","title":"<code>create(name, type=ActivityType.GAME, url=None)</code>  <code>classmethod</code>","text":"<p>Creates an activity object for the bot.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new activity's name</p> required <code>type</code> <code>ActivityType</code> <p>Type of activity to create</p> <code>ActivityType.GAME</code> <code>url</code> <code>Optional[str]</code> <p>Stream link for the activity</p> <code>None</code> <p>Returns:</p> Type Description <code>Activity</code> <p>The new activity object</p> Source code in <code>naff\\models\\discord\\activity.py</code> <pre><code>@classmethod\ndef create(cls, name: str, type: ActivityType = ActivityType.GAME, url: Optional[str] = None) -&gt; \"Activity\":\n\"\"\"\n    Creates an activity object for the bot.\n\n    Args:\n        name: The new activity's name\n        type: Type of activity to create\n        url: Stream link for the activity\n\n    Returns:\n        The new activity object\n\n    \"\"\"\n    return cls(name=name, type=type, url=url)  # noqa\n</code></pre>"},{"location":"API%20Reference/models/Discord/application/","title":"Application","text":""},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application","title":"<code>Application</code>","text":"<p>         Bases: <code>DiscordObject</code></p> <p>Represents a discord application.</p> Source code in <code>naff\\models\\discord\\application.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass Application(DiscordObject):\n\"\"\"Represents a discord application.\"\"\"\n\n    name: str = attrs.field(repr=True)\n\"\"\"The name of the application\"\"\"\n    icon: Optional[Asset] = attrs.field(repr=False, default=None)\n\"\"\"The icon of the application\"\"\"\n    description: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The description of the application\"\"\"\n    rpc_origins: Optional[List[str]] = attrs.field(repr=False, default=None)\n\"\"\"An array of rpc origin urls, if rpc is enabled\"\"\"\n    bot_public: bool = attrs.field(repr=False, default=True)\n\"\"\"When false only app owner can join the app's bot to guilds\"\"\"\n    bot_require_code_grant: bool = attrs.field(repr=False, default=False)\n\"\"\"When true the app's bot will only join upon completion of the full oauth2 code grant flow\"\"\"\n    terms_of_service_url: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The url of the app's terms of service\"\"\"\n    privacy_policy_url: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The url of the app's privacy policy\"\"\"\n    owner_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))\n\"\"\"The id of the owner of the application\"\"\"\n    summary: str = attrs.field(\n        repr=False,\n    )\n\"\"\"If this application is a game sold on Discord, this field will be the summary field for the store page of its primary sku\"\"\"\n    verify_key: Optional[str] = attrs.field(repr=False, default=MISSING)\n\"\"\"The hex encoded key for verification in interactions and the GameSDK's GetTicket\"\"\"\n    team: Optional[\"Team\"] = attrs.field(repr=False, default=None)\n\"\"\"If the application belongs to a team, this will be a list of the members of that team\"\"\"\n    guild_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None)\n\"\"\"If this application is a game sold on Discord, this field will be the guild to which it has been linked\"\"\"\n    primary_sku_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None)\n\"\"\"If this application is a game sold on Discord, this field will be the id of the \"Game SKU\" that is created, if exists\"\"\"\n    slug: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"If this application is a game sold on Discord, this field will be the URL slug that links to the store page\"\"\"\n    cover_image: Optional[Asset] = attrs.field(repr=False, default=None)\n\"\"\"The application's default rich presence invite cover\"\"\"\n    flags: Optional[\"ApplicationFlags\"] = attrs.field(repr=False, default=None, converter=optional(ApplicationFlags))\n\"\"\"The application's public flags\"\"\"\n    tags: Optional[List[str]] = attrs.field(repr=False, default=None)\n\"\"\"The application's tags describing its functionality and content\"\"\"\n    # todo: implement an ApplicationInstallParams object. See https://discord.com/developers/docs/resources/application#install-params-object\n    install_params: Optional[dict] = attrs.field(repr=False, default=None)\n\"\"\"The application's settings for in-app invitation to guilds\"\"\"\n    custom_install_url: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The application's custom authorization link for invitation to a guild\"\"\"\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        if data.get(\"team\"):\n            data[\"team\"] = Team.from_dict(data[\"team\"], client)\n            data[\"owner_id\"] = data[\"team\"].owner_user_id\n        else:\n            if \"owner\" in data:\n                owner = client.cache.place_user_data(data.pop(\"owner\"))\n                data[\"owner_id\"] = owner.id\n\n        if data.get(\"icon\"):\n            data[\"icon\"] = Asset.from_path_hash(client, f\"app-icons/{data['id']}/{{}}\", data[\"icon\"])\n        if data.get(\"cover_image\"):\n            data[\"cover_image\"] = Asset.from_path_hash(client, f\"app-icons/{data['id']}/{{}}\", data[\"cover_image\"])\n\n        return data\n\n    @property\n    def owner(self) -&gt; \"User\":\n\"\"\"The user object for the owner of this application\"\"\"\n        return self._client.cache.get_user(self.owner_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.name","title":"<code>name: str = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>The name of the application</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.icon","title":"<code>icon: Optional[Asset] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The icon of the application</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.description","title":"<code>description: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The description of the application</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.rpc_origins","title":"<code>rpc_origins: Optional[List[str]] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>An array of rpc origin urls, if rpc is enabled</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.bot_public","title":"<code>bot_public: bool = attrs.field(repr=False, default=True)</code>  <code>class-attribute</code>","text":"<p>When false only app owner can join the app's bot to guilds</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.bot_require_code_grant","title":"<code>bot_require_code_grant: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>When true the app's bot will only join upon completion of the full oauth2 code grant flow</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.terms_of_service_url","title":"<code>terms_of_service_url: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The url of the app's terms of service</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.privacy_policy_url","title":"<code>privacy_policy_url: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The url of the app's privacy policy</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.owner_id","title":"<code>owner_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))</code>  <code>class-attribute</code>","text":"<p>The id of the owner of the application</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.summary","title":"<code>summary: str = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>If this application is a game sold on Discord, this field will be the summary field for the store page of its primary sku</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.verify_key","title":"<code>verify_key: Optional[str] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>The hex encoded key for verification in interactions and the GameSDK's GetTicket</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.team","title":"<code>team: Optional[Team] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>If the application belongs to a team, this will be a list of the members of that team</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.guild_id","title":"<code>guild_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>If this application is a game sold on Discord, this field will be the guild to which it has been linked</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.primary_sku_id","title":"<code>primary_sku_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>If this application is a game sold on Discord, this field will be the id of the \"Game SKU\" that is created, if exists</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.slug","title":"<code>slug: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>If this application is a game sold on Discord, this field will be the URL slug that links to the store page</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.cover_image","title":"<code>cover_image: Optional[Asset] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The application's default rich presence invite cover</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.flags","title":"<code>flags: Optional[ApplicationFlags] = attrs.field(repr=False, default=None, converter=optional(ApplicationFlags))</code>  <code>class-attribute</code>","text":"<p>The application's public flags</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.tags","title":"<code>tags: Optional[List[str]] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The application's tags describing its functionality and content</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.install_params","title":"<code>install_params: Optional[dict] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The application's settings for in-app invitation to guilds</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.custom_install_url","title":"<code>custom_install_url: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The application's custom authorization link for invitation to a guild</p>"},{"location":"API%20Reference/models/Discord/application/#naff.models.discord.application.Application.owner","title":"<code>owner: User</code>  <code>property</code>","text":"<p>The user object for the owner of this application</p>"},{"location":"API%20Reference/models/Discord/asset/","title":"Asset","text":""},{"location":"API%20Reference/models/Discord/asset/#naff.models.discord.asset.Asset","title":"<code>Asset</code>","text":"<p>Represents a discord asset.</p> <p>Attributes:</p> Name Type Description <code>BASE</code> <code>str</code> <p>The <code>cdn</code> address for assets</p> <code>url</code> <code>str</code> <p>The URL of this asset</p> <code>hash</code> <code>Optional[str]</code> <p>The hash of this asset</p> Source code in <code>naff\\models\\discord\\asset.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Asset:\n\"\"\"\n    Represents a discord asset.\n\n    Attributes:\n        BASE str: The `cdn` address for assets\n        url str: The URL of this asset\n        hash Optional[str]: The hash of this asset\n\n    \"\"\"\n\n    BASE = \"https://cdn.discordapp.com\"\n\n    _client: \"Client\" = attrs.field(repr=False, metadata=no_export_meta)\n    _url: str = attrs.field(repr=True)\n    hash: Optional[str] = attrs.field(repr=True, default=None)\n\n    @classmethod\n    def from_path_hash(cls, client: \"Client\", path: str, asset_hash: str) -&gt; \"Asset\":\n\"\"\"\n        Create an asset from a path and asset's hash.\n\n        Args:\n            client: The NAFF bot instance\n            path: The CDN Endpoints for the type of asset.\n            asset_hash: The hash representation of the target asset.\n\n        Returns:\n            A new Asset object\n\n        \"\"\"\n        url = f\"{cls.BASE}/{path.format(asset_hash)}\"\n        return cls(client=client, url=url, hash=asset_hash)\n\n    @property\n    def url(self) -&gt; str:\n\"\"\"The URL of this asset.\"\"\"\n        ext = \".gif\" if self.animated else \".png\"\n        return f\"{self._url}{ext}?size=4096\"\n\n    def as_url(self, *, extension: str | None = None, size: int = 4096) -&gt; str:\n\"\"\"\n        Get the url of this asset.\n\n        args:\n            extension: The extension to override the assets default with\n            size: The size of asset to return\n\n        returns:\n            A url for this asset with the given parameters\n        \"\"\"\n        if not extension:\n            extension = \".gif\" if self.animated else \".png\"\n        elif not extension.startswith(\".\"):\n            extension = f\".{extension}\"\n\n        return f\"{self._url}{extension}?size={size}\"\n\n    @property\n    def animated(self) -&gt; bool:\n\"\"\"True if this asset is animated.\"\"\"\n        return bool(self.hash) and self.hash.startswith(\"a_\")\n\n    async def fetch(self, extension: Optional[str] = None, size: Optional[int] = None) -&gt; bytes:\n\"\"\"\n        Fetch the asset from the Discord CDN.\n\n        Args:\n            extension: File extension based on the target image format\n            size: The image size, can be any power of two between 16 and 4096.\n\n        Returns:\n            Raw byte array of the file\n\n        Raises:\n            ValueError: Incorrect file size if not power of 2 between 16 and 4096\n\n        \"\"\"\n        if not extension:\n            extension = \".gif\" if self.animated else \".png\"\n\n        url = self._url + extension\n\n        if size:\n            if not ((size != 0) and (size &amp; (size - 1) == 0)):  # if not power of 2\n                raise ValueError(\"Size should be a power of 2\")\n            if not 16 &lt;= size &lt;= 4096:\n                raise ValueError(\"Size should be between 16 and 4096\")\n\n            url = f\"{url}?size={size}\"\n\n        return await self._client.http.request_cdn(url, self)\n\n    async def save(\n        self, fd: Union[str, bytes, \"PathLike\", int], extension: Optional[str] = None, size: Optional[int] = None\n    ) -&gt; int:\n\"\"\"\n        Save the asset to a local file.\n\n        Args:\n            fd: Destination path to save the file to.\n            extension: File extension based on the target image format.\n            size: The image size, can be any power of two between 16 and 4096.\n\n        Returns:\n            Status code result of file write\n\n        \"\"\"\n        content = await self.fetch(extension=extension, size=size)\n        with open(fd, \"wb\") as f:\n            return f.write(content)\n</code></pre>"},{"location":"API%20Reference/models/Discord/asset/#naff.models.discord.asset.Asset.from_path_hash","title":"<code>from_path_hash(client, path, asset_hash)</code>  <code>classmethod</code>","text":"<p>Create an asset from a path and asset's hash.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The NAFF bot instance</p> required <code>path</code> <code>str</code> <p>The CDN Endpoints for the type of asset.</p> required <code>asset_hash</code> <code>str</code> <p>The hash representation of the target asset.</p> required <p>Returns:</p> Type Description <code>Asset</code> <p>A new Asset object</p> Source code in <code>naff\\models\\discord\\asset.py</code> <pre><code>@classmethod\ndef from_path_hash(cls, client: \"Client\", path: str, asset_hash: str) -&gt; \"Asset\":\n\"\"\"\n    Create an asset from a path and asset's hash.\n\n    Args:\n        client: The NAFF bot instance\n        path: The CDN Endpoints for the type of asset.\n        asset_hash: The hash representation of the target asset.\n\n    Returns:\n        A new Asset object\n\n    \"\"\"\n    url = f\"{cls.BASE}/{path.format(asset_hash)}\"\n    return cls(client=client, url=url, hash=asset_hash)\n</code></pre>"},{"location":"API%20Reference/models/Discord/asset/#naff.models.discord.asset.Asset.url","title":"<code>url: str</code>  <code>property</code>","text":"<p>The URL of this asset.</p>"},{"location":"API%20Reference/models/Discord/asset/#naff.models.discord.asset.Asset.as_url","title":"<code>as_url(*, extension=None, size=4096)</code>","text":"<p>Get the url of this asset.</p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>str | None</code> <p>The extension to override the assets default with</p> <code>None</code> <code>size</code> <code>int</code> <p>The size of asset to return</p> <code>4096</code> <p>Returns:</p> Type Description <code>str</code> <p>A url for this asset with the given parameters</p> Source code in <code>naff\\models\\discord\\asset.py</code> <pre><code>def as_url(self, *, extension: str | None = None, size: int = 4096) -&gt; str:\n\"\"\"\n    Get the url of this asset.\n\n    args:\n        extension: The extension to override the assets default with\n        size: The size of asset to return\n\n    returns:\n        A url for this asset with the given parameters\n    \"\"\"\n    if not extension:\n        extension = \".gif\" if self.animated else \".png\"\n    elif not extension.startswith(\".\"):\n        extension = f\".{extension}\"\n\n    return f\"{self._url}{extension}?size={size}\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/asset/#naff.models.discord.asset.Asset.animated","title":"<code>animated: bool</code>  <code>property</code>","text":"<p>True if this asset is animated.</p>"},{"location":"API%20Reference/models/Discord/asset/#naff.models.discord.asset.Asset.fetch","title":"<code>fetch(extension=None, size=None)</code>  <code>async</code>","text":"<p>Fetch the asset from the Discord CDN.</p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>Optional[str]</code> <p>File extension based on the target image format</p> <code>None</code> <code>size</code> <code>Optional[int]</code> <p>The image size, can be any power of two between 16 and 4096.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Raw byte array of the file</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Incorrect file size if not power of 2 between 16 and 4096</p> Source code in <code>naff\\models\\discord\\asset.py</code> <pre><code>async def fetch(self, extension: Optional[str] = None, size: Optional[int] = None) -&gt; bytes:\n\"\"\"\n    Fetch the asset from the Discord CDN.\n\n    Args:\n        extension: File extension based on the target image format\n        size: The image size, can be any power of two between 16 and 4096.\n\n    Returns:\n        Raw byte array of the file\n\n    Raises:\n        ValueError: Incorrect file size if not power of 2 between 16 and 4096\n\n    \"\"\"\n    if not extension:\n        extension = \".gif\" if self.animated else \".png\"\n\n    url = self._url + extension\n\n    if size:\n        if not ((size != 0) and (size &amp; (size - 1) == 0)):  # if not power of 2\n            raise ValueError(\"Size should be a power of 2\")\n        if not 16 &lt;= size &lt;= 4096:\n            raise ValueError(\"Size should be between 16 and 4096\")\n\n        url = f\"{url}?size={size}\"\n\n    return await self._client.http.request_cdn(url, self)\n</code></pre>"},{"location":"API%20Reference/models/Discord/asset/#naff.models.discord.asset.Asset.save","title":"<code>save(fd, extension=None, size=None)</code>  <code>async</code>","text":"<p>Save the asset to a local file.</p> <p>Parameters:</p> Name Type Description Default <code>fd</code> <code>Union[str, bytes, PathLike, int]</code> <p>Destination path to save the file to.</p> required <code>extension</code> <code>Optional[str]</code> <p>File extension based on the target image format.</p> <code>None</code> <code>size</code> <code>Optional[int]</code> <p>The image size, can be any power of two between 16 and 4096.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Status code result of file write</p> Source code in <code>naff\\models\\discord\\asset.py</code> <pre><code>async def save(\n    self, fd: Union[str, bytes, \"PathLike\", int], extension: Optional[str] = None, size: Optional[int] = None\n) -&gt; int:\n\"\"\"\n    Save the asset to a local file.\n\n    Args:\n        fd: Destination path to save the file to.\n        extension: File extension based on the target image format.\n        size: The image size, can be any power of two between 16 and 4096.\n\n    Returns:\n        Status code result of file write\n\n    \"\"\"\n    content = await self.fetch(extension=extension, size=size)\n    with open(fd, \"wb\") as f:\n        return f.write(content)\n</code></pre>"},{"location":"API%20Reference/models/Discord/base/","title":"Base","text":""},{"location":"API%20Reference/models/Discord/base/#naff.models.discord.base.ClientObject","title":"<code>ClientObject</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> <p>Serializable object that requires client reference.</p> Source code in <code>naff\\models\\discord\\base.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, slots=False)\nclass ClientObject(DictSerializationMixin):\n\"\"\"Serializable object that requires client reference.\"\"\"\n\n    _client: \"Client\" = attrs.field(repr=False, metadata=no_export_meta)\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        return super()._process_dict(data)\n\n    @classmethod\n    def from_dict(cls: Type[T], data: Dict[str, Any], client: \"Client\") -&gt; T:\n        data = cls._process_dict(data, client)\n        return cls(client=client, **cls._filter_kwargs(data, cls._get_init_keys()))\n\n    @classmethod\n    def from_list(cls: Type[T], datas: List[Dict[str, Any]], client: \"Client\") -&gt; List[T]:\n        return [cls.from_dict(data, client) for data in datas]\n\n    def update_from_dict(self, data) -&gt; T:\n        data = self._process_dict(data, self._client)\n        for key, value in self._filter_kwargs(data, self._get_keys()).items():\n            setattr(self, key, value)\n\n        return self\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/","title":"Channel","text":""},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ChannelHistory","title":"<code>ChannelHistory</code>","text":"<p>         Bases: <code>AsyncIterator</code></p> <p>An async iterator for searching through a channel's history.</p> <p>Attributes:</p> Name Type Description <code>channel</code> <code>BaseChannel</code> <p>The channel to search through</p> <code>limit</code> <code>BaseChannel</code> <p>The maximum number of messages to return (set to 0 for no limit)</p> <code>before</code> <code>Snowflake_Type</code> <p>get messages before this message ID</p> <code>after</code> <code>Snowflake_Type</code> <p>get messages after this message ID</p> <code>around</code> <code>Snowflake_Type</code> <p>get messages \"around\" this message ID</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>class ChannelHistory(AsyncIterator):\n\"\"\"\n    An async iterator for searching through a channel's history.\n\n    Attributes:\n        channel: The channel to search through\n        limit: The maximum number of messages to return (set to 0 for no limit)\n        before: get messages before this message ID\n        after: get messages after this message ID\n        around: get messages \"around\" this message ID\n\n    \"\"\"\n\n    def __init__(self, channel: \"BaseChannel\", limit=50, before=None, after=None, around=None) -&gt; None:\n        self.channel: \"BaseChannel\" = channel\n        self.before: Snowflake_Type = before\n        self.after: Snowflake_Type = after\n        self.around: Snowflake_Type = around\n        super().__init__(limit)\n\n    async def fetch(self) -&gt; List[\"models.Message\"]:\n\"\"\"\n        Fetch additional objects.\n\n        Your implementation of this method *must* return a list of objects.\n        If no more objects are available, raise QueueEmpty\n\n        Returns:\n            List of objects\n\n        Raises:\n              QueueEmpty: when no more objects are available.\n\n        \"\"\"\n        if self.after:\n            if not self.last:\n                self.last = namedtuple(\"temp\", \"id\")\n                self.last.id = self.after\n            messages = await self.channel.fetch_messages(limit=self.get_limit, after=self.last.id)\n            messages.sort(key=lambda x: x.id)\n\n        elif self.around:\n            messages = await self.channel.fetch_messages(limit=self.get_limit, around=self.around)\n            # todo: decide how getting *more* messages from `around` would work\n            self._limit = 1  # stops history from getting more messages\n\n        else:\n            if self.before and not self.last:\n                self.last = namedtuple(\"temp\", \"id\")\n                self.last.id = self.before\n\n            messages = await self.channel.fetch_messages(limit=self.get_limit, before=self.last.id)\n            messages.sort(key=lambda x: x.id, reverse=True)\n        return messages\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ChannelHistory.fetch","title":"<code>fetch()</code>  <code>async</code>","text":"<p>Fetch additional objects.</p> <p>Your implementation of this method must return a list of objects. If no more objects are available, raise QueueEmpty</p> <p>Returns:</p> Type Description <code>List[Message]</code> <p>List of objects</p> <p>Raises:</p> Type Description <code>QueueEmpty</code> <p>when no more objects are available.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch(self) -&gt; List[\"models.Message\"]:\n\"\"\"\n    Fetch additional objects.\n\n    Your implementation of this method *must* return a list of objects.\n    If no more objects are available, raise QueueEmpty\n\n    Returns:\n        List of objects\n\n    Raises:\n          QueueEmpty: when no more objects are available.\n\n    \"\"\"\n    if self.after:\n        if not self.last:\n            self.last = namedtuple(\"temp\", \"id\")\n            self.last.id = self.after\n        messages = await self.channel.fetch_messages(limit=self.get_limit, after=self.last.id)\n        messages.sort(key=lambda x: x.id)\n\n    elif self.around:\n        messages = await self.channel.fetch_messages(limit=self.get_limit, around=self.around)\n        # todo: decide how getting *more* messages from `around` would work\n        self._limit = 1  # stops history from getting more messages\n\n    else:\n        if self.before and not self.last:\n            self.last = namedtuple(\"temp\", \"id\")\n            self.last.id = self.before\n\n        messages = await self.channel.fetch_messages(limit=self.get_limit, before=self.last.id)\n        messages.sort(key=lambda x: x.id, reverse=True)\n    return messages\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.PermissionOverwrite","title":"<code>PermissionOverwrite</code>","text":"<p>         Bases: <code>SnowflakeObject</code>, <code>DictSerializationMixin</code></p> <p>Channel Permissions Overwrite object.</p> <p>Note</p> <p><code>id</code> here is not an attribute of the overwrite, it is the ID of the overwritten instance</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass PermissionOverwrite(SnowflakeObject, DictSerializationMixin):\n\"\"\"\n    Channel Permissions Overwrite object.\n\n    !!! note\n        `id` here is not an attribute of the overwrite, it is the ID of the overwritten instance\n\n    \"\"\"\n\n    type: \"OverwriteTypes\" = attrs.field(repr=True, converter=OverwriteTypes)\n\"\"\"Permission overwrite type (role or member)\"\"\"\n    allow: Optional[\"Permissions\"] = attrs.field(\n        repr=True, converter=optional_c(Permissions), kw_only=True, default=None\n    )\n\"\"\"Permissions to allow\"\"\"\n    deny: Optional[\"Permissions\"] = attrs.field(\n        repr=True, converter=optional_c(Permissions), kw_only=True, default=None\n    )\n\"\"\"Permissions to deny\"\"\"\n\n    @classmethod\n    def for_target(cls, target_type: Union[\"models.Role\", \"models.Member\", \"models.User\"]) -&gt; \"PermissionOverwrite\":\n\"\"\"\n        Create a PermissionOverwrite for a role or member.\n\n        Args:\n            target_type: The type of the target (role or member)\n\n        Returns:\n            PermissionOverwrite\n\n        \"\"\"\n        if isinstance(target_type, models.Role):\n            return cls(type=OverwriteTypes.ROLE, id=target_type.id)\n        elif isinstance(target_type, (models.Member, models.User)):\n            return cls(type=OverwriteTypes.MEMBER, id=target_type.id)\n        else:\n            raise TypeError(\"target_type must be a Role, Member or User\")\n\n    def add_allows(self, *perms: \"Permissions\") -&gt; None:\n\"\"\"\n        Add permissions to allow.\n\n        Args:\n            *perms: Permissions to add\n\n        \"\"\"\n        if not self.allow:\n            self.allow = Permissions.NONE\n        for perm in perms:\n            self.allow |= perm\n\n    def add_denies(self, *perms: \"Permissions\") -&gt; None:\n\"\"\"\n        Add permissions to deny.\n\n        Args:\n            *perms: Permissions to add\n\n        \"\"\"\n        if not self.deny:\n            self.deny = Permissions.NONE\n        for perm in perms:\n            self.deny |= perm\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.PermissionOverwrite.type","title":"<code>type: OverwriteTypes = attrs.field(repr=True, converter=OverwriteTypes)</code>  <code>class-attribute</code>","text":"<p>Permission overwrite type (role or member)</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.PermissionOverwrite.allow","title":"<code>allow: Optional[Permissions] = attrs.field(repr=True, converter=optional_c(Permissions), kw_only=True, default=None)</code>  <code>class-attribute</code>","text":"<p>Permissions to allow</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.PermissionOverwrite.deny","title":"<code>deny: Optional[Permissions] = attrs.field(repr=True, converter=optional_c(Permissions), kw_only=True, default=None)</code>  <code>class-attribute</code>","text":"<p>Permissions to deny</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.PermissionOverwrite.for_target","title":"<code>for_target(target_type)</code>  <code>classmethod</code>","text":"<p>Create a PermissionOverwrite for a role or member.</p> <p>Parameters:</p> Name Type Description Default <code>target_type</code> <code>Union[Role, Member, User]</code> <p>The type of the target (role or member)</p> required <p>Returns:</p> Type Description <code>PermissionOverwrite</code> <p>PermissionOverwrite</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@classmethod\ndef for_target(cls, target_type: Union[\"models.Role\", \"models.Member\", \"models.User\"]) -&gt; \"PermissionOverwrite\":\n\"\"\"\n    Create a PermissionOverwrite for a role or member.\n\n    Args:\n        target_type: The type of the target (role or member)\n\n    Returns:\n        PermissionOverwrite\n\n    \"\"\"\n    if isinstance(target_type, models.Role):\n        return cls(type=OverwriteTypes.ROLE, id=target_type.id)\n    elif isinstance(target_type, (models.Member, models.User)):\n        return cls(type=OverwriteTypes.MEMBER, id=target_type.id)\n    else:\n        raise TypeError(\"target_type must be a Role, Member or User\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.PermissionOverwrite.add_allows","title":"<code>add_allows(*perms)</code>","text":"<p>Add permissions to allow.</p> <p>Parameters:</p> Name Type Description Default <code>*perms</code> <code>Permissions</code> <p>Permissions to add</p> <code>()</code> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>def add_allows(self, *perms: \"Permissions\") -&gt; None:\n\"\"\"\n    Add permissions to allow.\n\n    Args:\n        *perms: Permissions to add\n\n    \"\"\"\n    if not self.allow:\n        self.allow = Permissions.NONE\n    for perm in perms:\n        self.allow |= perm\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.PermissionOverwrite.add_denies","title":"<code>add_denies(*perms)</code>","text":"<p>Add permissions to deny.</p> <p>Parameters:</p> Name Type Description Default <code>*perms</code> <code>Permissions</code> <p>Permissions to add</p> <code>()</code> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>def add_denies(self, *perms: \"Permissions\") -&gt; None:\n\"\"\"\n    Add permissions to deny.\n\n    Args:\n        *perms: Permissions to add\n\n    \"\"\"\n    if not self.deny:\n        self.deny = Permissions.NONE\n    for perm in perms:\n        self.deny |= perm\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.MessageableMixin","title":"<code>MessageableMixin</code>","text":"<p>         Bases: <code>SendMixin</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)\nclass MessageableMixin(SendMixin):\n    last_message_id: Optional[Snowflake_Type] = attrs.field(\n        repr=False, default=None\n    )  # TODO May need to think of dynamically updating this.\n\"\"\"The id of the last message sent in this channel (may not point to an existing or valid message)\"\"\"\n    default_auto_archive_duration: int = attrs.field(repr=False, default=AutoArchiveDuration.ONE_DAY)\n\"\"\"Default duration that the clients (not the API) will use for newly created threads, in minutes, to automatically archive the thread after recent activity\"\"\"\n    last_pin_timestamp: Optional[\"models.Timestamp\"] = attrs.field(\n        repr=False, default=None, converter=optional_c(timestamp_converter)\n    )\n\"\"\"When the last pinned message was pinned. This may be None when a message is not pinned.\"\"\"\n\n    async def _send_http_request(\n        self, message_payload: Union[dict, \"FormData\"], files: list[\"UPLOADABLE_TYPE\"] | None = None\n    ) -&gt; dict:\n        return await self._client.http.create_message(message_payload, self.id, files=files)\n\n    async def fetch_message(self, message_id: Snowflake_Type) -&gt; Optional[\"models.Message\"]:\n\"\"\"\n        Fetch a message from the channel.\n\n        Args:\n            message_id: ID of message to retrieve.\n\n        Returns:\n            The message object fetched. If the message is not found, returns None.\n\n        \"\"\"\n        try:\n            return await self._client.cache.fetch_message(self.id, message_id)\n        except NotFound:\n            return None\n\n    def get_message(self, message_id: Snowflake_Type) -&gt; \"models.Message\":\n\"\"\"\n        Get a message from the channel.\n\n        Args:\n            message_id: ID of message to retrieve.\n\n        Returns:\n            The message object fetched.\n\n        \"\"\"\n        message_id = to_snowflake(message_id)\n        message: \"models.Message\" = self._client.cache.get_message(self.id, message_id)\n        return message\n\n    def history(\n        self,\n        limit: int = 100,\n        before: Snowflake_Type = None,\n        after: Snowflake_Type = None,\n        around: Snowflake_Type = None,\n    ) -&gt; ChannelHistory:\n\"\"\"\n        Get an async iterator for the history of this channel.\n\n        Args:\n            limit: The maximum number of messages to return (set to 0 for no limit)\n            before: get messages before this message ID\n            after: get messages after this message ID\n            around: get messages \"around\" this message ID\n\n        ??? Hint \"Example Usage:\"\n            ```python\n            async for message in channel.history(limit=0):\n                if message.author.id == 174918559539920897:\n                    print(\"Found author's message\")\n                    # ...\n                    break\n            ```\n            or\n            ```python\n            history = channel.history(limit=250)\n            # Flatten the async iterator into a list\n            messages = await history.flatten()\n            ```\n\n        Returns:\n            ChannelHistory (AsyncIterator)\n\n        \"\"\"\n        return ChannelHistory(self, limit, before, after, around)\n\n    async def fetch_messages(\n        self,\n        limit: int = 50,\n        around: Snowflake_Type = MISSING,\n        before: Snowflake_Type = MISSING,\n        after: Snowflake_Type = MISSING,\n    ) -&gt; List[\"models.Message\"]:\n\"\"\"\n        Fetch multiple messages from the channel.\n\n        Args:\n            limit: Max number of messages to return, default `50`, max `100`\n            around: Message to get messages around\n            before: Message to get messages before\n            after: Message to get messages after\n\n        Returns:\n            A list of messages fetched.\n\n        \"\"\"\n        if limit &gt; 100:\n            raise ValueError(\"You cannot fetch more than 100 messages at once.\")\n\n        if around:\n            around = to_snowflake(around)\n        elif before:\n            before = to_snowflake(before)\n        elif after:\n            after = to_snowflake(after)\n\n        messages_data = await self._client.http.get_channel_messages(\n            self.id, limit, around=around, before=before, after=after\n        )\n        for m in messages_data:\n            m[\"guild_id\"] = self._guild_id\n\n        return [self._client.cache.place_message_data(m) for m in messages_data]\n\n    async def fetch_pinned_messages(self) -&gt; List[\"models.Message\"]:\n\"\"\"\n        Fetch pinned messages from the channel.\n\n        Returns:\n            A list of messages fetched.\n\n        \"\"\"\n        messages_data = await self._client.http.get_pinned_messages(self.id)\n        return [self._client.cache.place_message_data(message_data) for message_data in messages_data]\n\n    async def delete_messages(\n        self, messages: List[Union[Snowflake_Type, \"models.Message\"]], reason: Absent[Optional[str]] = MISSING\n    ) -&gt; None:\n\"\"\"\n        Bulk delete messages from channel.\n\n        Args:\n            messages: List of messages or message IDs to delete.\n            reason: The reason for this action. Used for audit logs.\n\n        \"\"\"\n        message_ids = [to_snowflake(message) for message in messages]\n        # TODO Add check for min/max and duplicates.\n\n        if len(message_ids) == 1:\n            # bulk delete messages will throw a http error if only 1 message is passed\n            await self.delete_message(message_ids[0], reason)\n        else:\n            await self._client.http.bulk_delete_messages(self.id, message_ids, reason)\n\n    async def delete_message(self, message: Union[Snowflake_Type, \"models.Message\"], reason: str = None) -&gt; None:\n\"\"\"\n        Delete a single message from a channel.\n\n        Args:\n            message: The message to delete\n            reason: The reason for this action\n\n        \"\"\"\n        message = to_snowflake(message)\n        await self._client.http.delete_message(self.id, message, reason=reason)\n\n    async def purge(\n        self,\n        deletion_limit: int = 50,\n        search_limit: int = 100,\n        predicate: Callable[[\"models.Message\"], bool] = MISSING,\n        avoid_loading_msg: bool = True,\n        before: Optional[Snowflake_Type] = MISSING,\n        after: Optional[Snowflake_Type] = MISSING,\n        around: Optional[Snowflake_Type] = MISSING,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; int:\n\"\"\"\n        Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit`.\n\n        ??? Hint \"Example Usage:\"\n            ```python\n            # this will delete the last 20 messages sent by a user with the given ID\n            deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897)\n            await channel.send(f\"{deleted} messages deleted\")\n            ```\n\n        Args:\n            deletion_limit: The target amount of messages to delete\n            search_limit: How many messages to search through\n            predicate: A function that returns True or False, and takes a message as an argument\n            avoid_loading_msg: Should the bot attempt to avoid deleting its own loading messages (recommended enabled)\n            before: Search messages before this ID\n            after: Search messages after this ID\n            around: Search messages around this ID\n            reason: The reason for this deletion\n\n        Returns:\n            The total amount of messages deleted\n\n        \"\"\"\n        if not predicate:\n\n            def predicate(m) -&gt; bool:\n                return True  # noqa\n\n        to_delete = []\n\n        # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake\n        fourteen_days_ago = int((time.time() - 1209600) * 1000.0 - DISCORD_EPOCH) &lt;&lt; 22\n        async for message in self.history(limit=search_limit, before=before, after=after, around=around):\n            if deletion_limit != 0 and len(to_delete) == deletion_limit:\n                break\n\n            if not predicate(message):\n                # fails predicate\n                continue\n\n            if avoid_loading_msg:\n                if message._author_id == self._client.user.id and MessageFlags.LOADING in message.flags:\n                    continue\n\n            if message.id &lt; fourteen_days_ago:\n                # message is too old to be purged\n                continue\n\n            to_delete.append(message.id)\n\n        count = len(to_delete)\n        while len(to_delete):\n            iteration = [to_delete.pop() for i in range(min(100, len(to_delete)))]\n            await self.delete_messages(iteration, reason=reason)\n        return count\n\n    async def trigger_typing(self) -&gt; None:\n\"\"\"Trigger a typing animation in this channel.\"\"\"\n        await self._client.http.trigger_typing_indicator(self.id)\n\n    @property\n    def typing(self) -&gt; Typing:\n\"\"\"A context manager to send a typing state to a given channel as long as long as the wrapped operation takes.\"\"\"\n        return Typing(self)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.MessageableMixin.last_message_id","title":"<code>last_message_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The id of the last message sent in this channel (may not point to an existing or valid message)</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.MessageableMixin.default_auto_archive_duration","title":"<code>default_auto_archive_duration: int = attrs.field(repr=False, default=AutoArchiveDuration.ONE_DAY)</code>  <code>class-attribute</code>","text":"<p>Default duration that the clients (not the API) will use for newly created threads, in minutes, to automatically archive the thread after recent activity</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.MessageableMixin.last_pin_timestamp","title":"<code>last_pin_timestamp: Optional[models.Timestamp] = attrs.field(repr=False, default=None, converter=optional_c(timestamp_converter))</code>  <code>class-attribute</code>","text":"<p>When the last pinned message was pinned. This may be None when a message is not pinned.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.MessageableMixin.fetch_message","title":"<code>fetch_message(message_id)</code>  <code>async</code>","text":"<p>Fetch a message from the channel.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Snowflake_Type</code> <p>ID of message to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Message]</code> <p>The message object fetched. If the message is not found, returns None.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_message(self, message_id: Snowflake_Type) -&gt; Optional[\"models.Message\"]:\n\"\"\"\n    Fetch a message from the channel.\n\n    Args:\n        message_id: ID of message to retrieve.\n\n    Returns:\n        The message object fetched. If the message is not found, returns None.\n\n    \"\"\"\n    try:\n        return await self._client.cache.fetch_message(self.id, message_id)\n    except NotFound:\n        return None\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.MessageableMixin.get_message","title":"<code>get_message(message_id)</code>","text":"<p>Get a message from the channel.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Snowflake_Type</code> <p>ID of message to retrieve.</p> required <p>Returns:</p> Type Description <code>Message</code> <p>The message object fetched.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>def get_message(self, message_id: Snowflake_Type) -&gt; \"models.Message\":\n\"\"\"\n    Get a message from the channel.\n\n    Args:\n        message_id: ID of message to retrieve.\n\n    Returns:\n        The message object fetched.\n\n    \"\"\"\n    message_id = to_snowflake(message_id)\n    message: \"models.Message\" = self._client.cache.get_message(self.id, message_id)\n    return message\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.MessageableMixin.history","title":"<code>history(limit=100, before=None, after=None, around=None)</code>","text":"<p>Get an async iterator for the history of this channel.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of messages to return (set to 0 for no limit)</p> <code>100</code> <code>before</code> <code>Snowflake_Type</code> <p>get messages before this message ID</p> <code>None</code> <code>after</code> <code>Snowflake_Type</code> <p>get messages after this message ID</p> <code>None</code> <code>around</code> <code>Snowflake_Type</code> <p>get messages \"around\" this message ID</p> <code>None</code> Example Usage: <p><pre><code>async for message in channel.history(limit=0):\n    if message.author.id == 174918559539920897:\n        print(\"Found author's message\")\n        # ...\n        break\n</code></pre> or <pre><code>history = channel.history(limit=250)\n# Flatten the async iterator into a list\nmessages = await history.flatten()\n</code></pre></p> <p>Returns:</p> Type Description <code>ChannelHistory</code> <p>ChannelHistory (AsyncIterator)</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>def history(\n    self,\n    limit: int = 100,\n    before: Snowflake_Type = None,\n    after: Snowflake_Type = None,\n    around: Snowflake_Type = None,\n) -&gt; ChannelHistory:\n\"\"\"\n    Get an async iterator for the history of this channel.\n\n    Args:\n        limit: The maximum number of messages to return (set to 0 for no limit)\n        before: get messages before this message ID\n        after: get messages after this message ID\n        around: get messages \"around\" this message ID\n\n    ??? Hint \"Example Usage:\"\n        ```python\n        async for message in channel.history(limit=0):\n            if message.author.id == 174918559539920897:\n                print(\"Found author's message\")\n                # ...\n                break\n        ```\n        or\n        ```python\n        history = channel.history(limit=250)\n        # Flatten the async iterator into a list\n        messages = await history.flatten()\n        ```\n\n    Returns:\n        ChannelHistory (AsyncIterator)\n\n    \"\"\"\n    return ChannelHistory(self, limit, before, after, around)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.MessageableMixin.fetch_messages","title":"<code>fetch_messages(limit=50, around=MISSING, before=MISSING, after=MISSING)</code>  <code>async</code>","text":"<p>Fetch multiple messages from the channel.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Max number of messages to return, default <code>50</code>, max <code>100</code></p> <code>50</code> <code>around</code> <code>Snowflake_Type</code> <p>Message to get messages around</p> <code>MISSING</code> <code>before</code> <code>Snowflake_Type</code> <p>Message to get messages before</p> <code>MISSING</code> <code>after</code> <code>Snowflake_Type</code> <p>Message to get messages after</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>List[Message]</code> <p>A list of messages fetched.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_messages(\n    self,\n    limit: int = 50,\n    around: Snowflake_Type = MISSING,\n    before: Snowflake_Type = MISSING,\n    after: Snowflake_Type = MISSING,\n) -&gt; List[\"models.Message\"]:\n\"\"\"\n    Fetch multiple messages from the channel.\n\n    Args:\n        limit: Max number of messages to return, default `50`, max `100`\n        around: Message to get messages around\n        before: Message to get messages before\n        after: Message to get messages after\n\n    Returns:\n        A list of messages fetched.\n\n    \"\"\"\n    if limit &gt; 100:\n        raise ValueError(\"You cannot fetch more than 100 messages at once.\")\n\n    if around:\n        around = to_snowflake(around)\n    elif before:\n        before = to_snowflake(before)\n    elif after:\n        after = to_snowflake(after)\n\n    messages_data = await self._client.http.get_channel_messages(\n        self.id, limit, around=around, before=before, after=after\n    )\n    for m in messages_data:\n        m[\"guild_id\"] = self._guild_id\n\n    return [self._client.cache.place_message_data(m) for m in messages_data]\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.MessageableMixin.fetch_pinned_messages","title":"<code>fetch_pinned_messages()</code>  <code>async</code>","text":"<p>Fetch pinned messages from the channel.</p> <p>Returns:</p> Type Description <code>List[Message]</code> <p>A list of messages fetched.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_pinned_messages(self) -&gt; List[\"models.Message\"]:\n\"\"\"\n    Fetch pinned messages from the channel.\n\n    Returns:\n        A list of messages fetched.\n\n    \"\"\"\n    messages_data = await self._client.http.get_pinned_messages(self.id)\n    return [self._client.cache.place_message_data(message_data) for message_data in messages_data]\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.MessageableMixin.delete_messages","title":"<code>delete_messages(messages, reason=MISSING)</code>  <code>async</code>","text":"<p>Bulk delete messages from channel.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>List[Union[Snowflake_Type, Message]]</code> <p>List of messages or message IDs to delete.</p> required <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for this action. Used for audit logs.</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def delete_messages(\n    self, messages: List[Union[Snowflake_Type, \"models.Message\"]], reason: Absent[Optional[str]] = MISSING\n) -&gt; None:\n\"\"\"\n    Bulk delete messages from channel.\n\n    Args:\n        messages: List of messages or message IDs to delete.\n        reason: The reason for this action. Used for audit logs.\n\n    \"\"\"\n    message_ids = [to_snowflake(message) for message in messages]\n    # TODO Add check for min/max and duplicates.\n\n    if len(message_ids) == 1:\n        # bulk delete messages will throw a http error if only 1 message is passed\n        await self.delete_message(message_ids[0], reason)\n    else:\n        await self._client.http.bulk_delete_messages(self.id, message_ids, reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.MessageableMixin.delete_message","title":"<code>delete_message(message, reason=None)</code>  <code>async</code>","text":"<p>Delete a single message from a channel.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Union[Snowflake_Type, Message]</code> <p>The message to delete</p> required <code>reason</code> <code>str</code> <p>The reason for this action</p> <code>None</code> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def delete_message(self, message: Union[Snowflake_Type, \"models.Message\"], reason: str = None) -&gt; None:\n\"\"\"\n    Delete a single message from a channel.\n\n    Args:\n        message: The message to delete\n        reason: The reason for this action\n\n    \"\"\"\n    message = to_snowflake(message)\n    await self._client.http.delete_message(self.id, message, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.MessageableMixin.purge","title":"<code>purge(deletion_limit=50, search_limit=100, predicate=MISSING, avoid_loading_msg=True, before=MISSING, after=MISSING, around=MISSING, reason=MISSING)</code>  <code>async</code>","text":"<p>Bulk delete messages within a channel. If a <code>predicate</code> is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the <code>deletion_limit</code>.</p> Example Usage: <pre><code># this will delete the last 20 messages sent by a user with the given ID\ndeleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897)\nawait channel.send(f\"{deleted} messages deleted\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>deletion_limit</code> <code>int</code> <p>The target amount of messages to delete</p> <code>50</code> <code>search_limit</code> <code>int</code> <p>How many messages to search through</p> <code>100</code> <code>predicate</code> <code>Callable[[Message], bool]</code> <p>A function that returns True or False, and takes a message as an argument</p> <code>MISSING</code> <code>avoid_loading_msg</code> <code>bool</code> <p>Should the bot attempt to avoid deleting its own loading messages (recommended enabled)</p> <code>True</code> <code>before</code> <code>Optional[Snowflake_Type]</code> <p>Search messages before this ID</p> <code>MISSING</code> <code>after</code> <code>Optional[Snowflake_Type]</code> <p>Search messages after this ID</p> <code>MISSING</code> <code>around</code> <code>Optional[Snowflake_Type]</code> <p>Search messages around this ID</p> <code>MISSING</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for this deletion</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>int</code> <p>The total amount of messages deleted</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def purge(\n    self,\n    deletion_limit: int = 50,\n    search_limit: int = 100,\n    predicate: Callable[[\"models.Message\"], bool] = MISSING,\n    avoid_loading_msg: bool = True,\n    before: Optional[Snowflake_Type] = MISSING,\n    after: Optional[Snowflake_Type] = MISSING,\n    around: Optional[Snowflake_Type] = MISSING,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; int:\n\"\"\"\n    Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit`.\n\n    ??? Hint \"Example Usage:\"\n        ```python\n        # this will delete the last 20 messages sent by a user with the given ID\n        deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897)\n        await channel.send(f\"{deleted} messages deleted\")\n        ```\n\n    Args:\n        deletion_limit: The target amount of messages to delete\n        search_limit: How many messages to search through\n        predicate: A function that returns True or False, and takes a message as an argument\n        avoid_loading_msg: Should the bot attempt to avoid deleting its own loading messages (recommended enabled)\n        before: Search messages before this ID\n        after: Search messages after this ID\n        around: Search messages around this ID\n        reason: The reason for this deletion\n\n    Returns:\n        The total amount of messages deleted\n\n    \"\"\"\n    if not predicate:\n\n        def predicate(m) -&gt; bool:\n            return True  # noqa\n\n    to_delete = []\n\n    # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake\n    fourteen_days_ago = int((time.time() - 1209600) * 1000.0 - DISCORD_EPOCH) &lt;&lt; 22\n    async for message in self.history(limit=search_limit, before=before, after=after, around=around):\n        if deletion_limit != 0 and len(to_delete) == deletion_limit:\n            break\n\n        if not predicate(message):\n            # fails predicate\n            continue\n\n        if avoid_loading_msg:\n            if message._author_id == self._client.user.id and MessageFlags.LOADING in message.flags:\n                continue\n\n        if message.id &lt; fourteen_days_ago:\n            # message is too old to be purged\n            continue\n\n        to_delete.append(message.id)\n\n    count = len(to_delete)\n    while len(to_delete):\n        iteration = [to_delete.pop() for i in range(min(100, len(to_delete)))]\n        await self.delete_messages(iteration, reason=reason)\n    return count\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.MessageableMixin.trigger_typing","title":"<code>trigger_typing()</code>  <code>async</code>","text":"<p>Trigger a typing animation in this channel.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def trigger_typing(self) -&gt; None:\n\"\"\"Trigger a typing animation in this channel.\"\"\"\n    await self._client.http.trigger_typing_indicator(self.id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.MessageableMixin.typing","title":"<code>typing: Typing</code>  <code>property</code>","text":"<p>A context manager to send a typing state to a given channel as long as long as the wrapped operation takes.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.InvitableMixin","title":"<code>InvitableMixin</code>","text":"Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)\nclass InvitableMixin:\n    async def create_invite(\n        self,\n        max_age: int = 86400,\n        max_uses: int = 0,\n        temporary: bool = False,\n        unique: bool = False,\n        target_type: Optional[InviteTargetTypes] = None,\n        target_user: Optional[Union[Snowflake_Type, \"models.User\"]] = None,\n        target_application: Optional[Union[Snowflake_Type, \"models.Application\"]] = None,\n        reason: Optional[str] = None,\n    ) -&gt; \"models.Invite\":\n\"\"\"\n        Creates a new channel invite.\n\n        Args:\n            max_age: Max age of invite in seconds, default 86400 (24 hours).\n            max_uses: Max uses of invite, default 0.\n            temporary: Grants temporary membership, default False.\n            unique: Invite is unique, default false.\n            target_type: Target type for streams and embedded applications.\n            target_user: Target User ID for Stream target type.\n            target_application: Target Application ID for Embedded App target type.\n            reason: The reason for creating this invite.\n\n        Returns:\n            Newly created Invite object.\n\n        \"\"\"\n        if target_type:\n            if target_type == InviteTargetTypes.STREAM and not target_user:\n                raise ValueError(\"Stream target must include target user id.\")\n            elif target_type == InviteTargetTypes.EMBEDDED_APPLICATION and not target_application:\n                raise ValueError(\"Embedded Application target must include target application id.\")\n\n        if target_user and target_application:\n            raise ValueError(\"Invite target must be either User or Embedded Application, not both.\")\n        elif target_user:\n            target_user = to_snowflake(target_user)\n            target_type = InviteTargetTypes.STREAM\n        elif target_application:\n            target_application = to_snowflake(target_application)\n            target_type = InviteTargetTypes.EMBEDDED_APPLICATION\n\n        invite_data = await self._client.http.create_channel_invite(\n            self.id,\n            max_age,\n            max_uses,\n            temporary,\n            unique,\n            target_user_id=target_user,\n            target_application_id=target_application,\n            reason=reason,\n        )\n        return models.Invite.from_dict(invite_data, self._client)\n\n    async def fetch_invites(self) -&gt; List[\"models.Invite\"]:\n\"\"\"\n        Fetches all invites (with invite metadata) for the channel.\n\n        Returns:\n            List of Invite objects.\n\n        \"\"\"\n        invites_data = await self._client.http.get_channel_invites(self.id)\n        return models.Invite.from_list(invites_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.InvitableMixin.create_invite","title":"<code>create_invite(max_age=86400, max_uses=0, temporary=False, unique=False, target_type=None, target_user=None, target_application=None, reason=None)</code>  <code>async</code>","text":"<p>Creates a new channel invite.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>int</code> <p>Max age of invite in seconds, default 86400 (24 hours).</p> <code>86400</code> <code>max_uses</code> <code>int</code> <p>Max uses of invite, default 0.</p> <code>0</code> <code>temporary</code> <code>bool</code> <p>Grants temporary membership, default False.</p> <code>False</code> <code>unique</code> <code>bool</code> <p>Invite is unique, default false.</p> <code>False</code> <code>target_type</code> <code>Optional[InviteTargetTypes]</code> <p>Target type for streams and embedded applications.</p> <code>None</code> <code>target_user</code> <code>Optional[Union[Snowflake_Type, User]]</code> <p>Target User ID for Stream target type.</p> <code>None</code> <code>target_application</code> <code>Optional[Union[Snowflake_Type, Application]]</code> <p>Target Application ID for Embedded App target type.</p> <code>None</code> <code>reason</code> <code>Optional[str]</code> <p>The reason for creating this invite.</p> <code>None</code> <p>Returns:</p> Type Description <code>Invite</code> <p>Newly created Invite object.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def create_invite(\n    self,\n    max_age: int = 86400,\n    max_uses: int = 0,\n    temporary: bool = False,\n    unique: bool = False,\n    target_type: Optional[InviteTargetTypes] = None,\n    target_user: Optional[Union[Snowflake_Type, \"models.User\"]] = None,\n    target_application: Optional[Union[Snowflake_Type, \"models.Application\"]] = None,\n    reason: Optional[str] = None,\n) -&gt; \"models.Invite\":\n\"\"\"\n    Creates a new channel invite.\n\n    Args:\n        max_age: Max age of invite in seconds, default 86400 (24 hours).\n        max_uses: Max uses of invite, default 0.\n        temporary: Grants temporary membership, default False.\n        unique: Invite is unique, default false.\n        target_type: Target type for streams and embedded applications.\n        target_user: Target User ID for Stream target type.\n        target_application: Target Application ID for Embedded App target type.\n        reason: The reason for creating this invite.\n\n    Returns:\n        Newly created Invite object.\n\n    \"\"\"\n    if target_type:\n        if target_type == InviteTargetTypes.STREAM and not target_user:\n            raise ValueError(\"Stream target must include target user id.\")\n        elif target_type == InviteTargetTypes.EMBEDDED_APPLICATION and not target_application:\n            raise ValueError(\"Embedded Application target must include target application id.\")\n\n    if target_user and target_application:\n        raise ValueError(\"Invite target must be either User or Embedded Application, not both.\")\n    elif target_user:\n        target_user = to_snowflake(target_user)\n        target_type = InviteTargetTypes.STREAM\n    elif target_application:\n        target_application = to_snowflake(target_application)\n        target_type = InviteTargetTypes.EMBEDDED_APPLICATION\n\n    invite_data = await self._client.http.create_channel_invite(\n        self.id,\n        max_age,\n        max_uses,\n        temporary,\n        unique,\n        target_user_id=target_user,\n        target_application_id=target_application,\n        reason=reason,\n    )\n    return models.Invite.from_dict(invite_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.InvitableMixin.fetch_invites","title":"<code>fetch_invites()</code>  <code>async</code>","text":"<p>Fetches all invites (with invite metadata) for the channel.</p> <p>Returns:</p> Type Description <code>List[Invite]</code> <p>List of Invite objects.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_invites(self) -&gt; List[\"models.Invite\"]:\n\"\"\"\n    Fetches all invites (with invite metadata) for the channel.\n\n    Returns:\n        List of Invite objects.\n\n    \"\"\"\n    invites_data = await self._client.http.get_channel_invites(self.id)\n    return models.Invite.from_list(invites_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadableMixin","title":"<code>ThreadableMixin</code>","text":"Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)\nclass ThreadableMixin:\n    async def create_thread(\n        self,\n        name: str,\n        message: Absent[Snowflake_Type] = MISSING,\n        thread_type: Absent[ChannelTypes] = MISSING,\n        invitable: Absent[bool] = MISSING,\n        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,\n        reason: Absent[str] = None,\n    ) -&gt; \"TYPE_THREAD_CHANNEL\":\n\"\"\"\n        Creates a new thread in this channel. If a message is provided, it will be used as the initial message.\n\n        Args:\n            name: 1-100 character thread name\n            message: The message to connect this thread to. Required for news channel.\n            thread_type: Is the thread private or public. Not applicable to news channel, it will always be GUILD_NEWS_THREAD.\n            invitable: whether non-moderators can add other non-moderators to a thread. Only applicable when creating a private thread.\n            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.\n            reason: The reason for creating this thread.\n\n        Returns:\n            The created thread, if successful\n\n        \"\"\"\n        if self.type == ChannelTypes.GUILD_NEWS and not message:\n            raise ValueError(\"News channel must include message to create thread from.\")\n\n        elif message and (thread_type or invitable):\n            raise ValueError(\"Message cannot be used with thread_type or invitable.\")\n\n        elif thread_type != ChannelTypes.GUILD_PRIVATE_THREAD and invitable:\n            raise ValueError(\"Invitable only applies to private threads.\")\n\n        thread_data = await self._client.http.create_thread(\n            channel_id=self.id,\n            name=name,\n            thread_type=thread_type,\n            invitable=invitable,\n            auto_archive_duration=auto_archive_duration,\n            message_id=to_optional_snowflake(message),\n            reason=reason,\n        )\n        return self._client.cache.place_channel_data(thread_data)\n\n    async def fetch_public_archived_threads(\n        self, limit: int = None, before: Optional[\"models.Timestamp\"] = None\n    ) -&gt; \"models.ThreadList\":\n\"\"\"\n        Get a `ThreadList` of archived **public** threads available in this channel.\n\n        Args:\n            limit: optional maximum number of threads to return\n            before: Returns threads before this timestamp\n\n        Returns:\n            A `ThreadList` of archived threads.\n\n        \"\"\"\n        threads_data = await self._client.http.list_public_archived_threads(\n            channel_id=self.id, limit=limit, before=before\n        )\n        threads_data[\"id\"] = self.id\n        return models.ThreadList.from_dict(threads_data, self._client)\n\n    async def fetch_private_archived_threads(\n        self, limit: int = None, before: Optional[\"models.Timestamp\"] = None\n    ) -&gt; \"models.ThreadList\":\n\"\"\"\n        Get a `ThreadList` of archived **private** threads available in this channel.\n\n        Args:\n            limit: optional maximum number of threads to return\n            before: Returns threads before this timestamp\n\n        Returns:\n            A `ThreadList` of archived threads.\n\n        \"\"\"\n        threads_data = await self._client.http.list_private_archived_threads(\n            channel_id=self.id, limit=limit, before=before\n        )\n        threads_data[\"id\"] = self.id\n        return models.ThreadList.from_dict(threads_data, self._client)\n\n    async def fetch_archived_threads(\n        self, limit: int = None, before: Optional[\"models.Timestamp\"] = None\n    ) -&gt; \"models.ThreadList\":\n\"\"\"\n        Get a `ThreadList` of archived threads available in this channel.\n\n        Args:\n            limit: optional maximum number of threads to return\n            before: Returns threads before this timestamp\n\n        Returns:\n            A `ThreadList` of archived threads.\n\n        \"\"\"\n        threads_data = await self._client.http.list_private_archived_threads(\n            channel_id=self.id, limit=limit, before=before\n        )\n        threads_data.update(\n            await self._client.http.list_public_archived_threads(channel_id=self.id, limit=limit, before=before)\n        )\n        threads_data[\"id\"] = self.id\n        return models.ThreadList.from_dict(threads_data, self._client)\n\n    async def fetch_joined_private_archived_threads(\n        self, limit: int = None, before: Optional[\"models.Timestamp\"] = None\n    ) -&gt; \"models.ThreadList\":\n\"\"\"\n        Get a `ThreadList` of threads the bot is a participant of in this channel.\n\n        Args:\n            limit: optional maximum number of threads to return\n            before: Returns threads before this timestamp\n\n        Returns:\n            A `ThreadList` of threads the bot is a participant of.\n\n        \"\"\"\n        threads_data = await self._client.http.list_joined_private_archived_threads(\n            channel_id=self.id, limit=limit, before=before\n        )\n        threads_data[\"id\"] = self.id\n        return models.ThreadList.from_dict(threads_data, self._client)\n\n    async def fetch_active_threads(self) -&gt; \"models.ThreadList\":\n\"\"\"\n        Gets all active threads in the channel, including public and private threads.\n\n        Returns:\n            A `ThreadList` of active threads.\n\n        \"\"\"\n        threads_data = await self._client.http.list_active_threads(guild_id=self._guild_id)\n\n        # delete the items where the channel_id does not match\n        removed_thread_ids = []\n        cleaned_threads_data_threads = []\n        for thread in threads_data[\"threads\"]:\n            if thread[\"parent_id\"] == str(self.id):\n                cleaned_threads_data_threads.append(thread)\n            else:\n                removed_thread_ids.append(thread[\"id\"])\n        threads_data[\"threads\"] = cleaned_threads_data_threads\n\n        # delete the member data which is not needed\n        cleaned_member_data_threads = []\n        for thread_member in threads_data[\"members\"]:\n            if thread_member[\"id\"] not in removed_thread_ids:\n                cleaned_member_data_threads.append(thread_member)\n        threads_data[\"members\"] = cleaned_member_data_threads\n\n        return models.ThreadList.from_dict(threads_data, self._client)\n\n    async def fetch_all_threads(self) -&gt; \"models.ThreadList\":\n\"\"\"\n        Gets all threads in the channel. Active and archived, including public and private threads.\n\n        Returns:\n            A `ThreadList` of all threads.\n\n        \"\"\"\n        threads = await self.fetch_active_threads()\n\n        # update that data with the archived threads\n        archived_threads = await self.fetch_archived_threads()\n        threads.threads.extend(archived_threads.threads)\n        threads.members.extend(archived_threads.members)\n\n        return threads\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadableMixin.create_thread","title":"<code>create_thread(name, message=MISSING, thread_type=MISSING, invitable=MISSING, auto_archive_duration=AutoArchiveDuration.ONE_DAY, reason=None)</code>  <code>async</code>","text":"<p>Creates a new thread in this channel. If a message is provided, it will be used as the initial message.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>1-100 character thread name</p> required <code>message</code> <code>Absent[Snowflake_Type]</code> <p>The message to connect this thread to. Required for news channel.</p> <code>MISSING</code> <code>thread_type</code> <code>Absent[ChannelTypes]</code> <p>Is the thread private or public. Not applicable to news channel, it will always be GUILD_NEWS_THREAD.</p> <code>MISSING</code> <code>invitable</code> <code>Absent[bool]</code> <p>whether non-moderators can add other non-moderators to a thread. Only applicable when creating a private thread.</p> <code>MISSING</code> <code>auto_archive_duration</code> <code>AutoArchiveDuration</code> <p>Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.</p> <code>AutoArchiveDuration.ONE_DAY</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for creating this thread.</p> <code>None</code> <p>Returns:</p> Type Description <code>TYPE_THREAD_CHANNEL</code> <p>The created thread, if successful</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def create_thread(\n    self,\n    name: str,\n    message: Absent[Snowflake_Type] = MISSING,\n    thread_type: Absent[ChannelTypes] = MISSING,\n    invitable: Absent[bool] = MISSING,\n    auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,\n    reason: Absent[str] = None,\n) -&gt; \"TYPE_THREAD_CHANNEL\":\n\"\"\"\n    Creates a new thread in this channel. If a message is provided, it will be used as the initial message.\n\n    Args:\n        name: 1-100 character thread name\n        message: The message to connect this thread to. Required for news channel.\n        thread_type: Is the thread private or public. Not applicable to news channel, it will always be GUILD_NEWS_THREAD.\n        invitable: whether non-moderators can add other non-moderators to a thread. Only applicable when creating a private thread.\n        auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.\n        reason: The reason for creating this thread.\n\n    Returns:\n        The created thread, if successful\n\n    \"\"\"\n    if self.type == ChannelTypes.GUILD_NEWS and not message:\n        raise ValueError(\"News channel must include message to create thread from.\")\n\n    elif message and (thread_type or invitable):\n        raise ValueError(\"Message cannot be used with thread_type or invitable.\")\n\n    elif thread_type != ChannelTypes.GUILD_PRIVATE_THREAD and invitable:\n        raise ValueError(\"Invitable only applies to private threads.\")\n\n    thread_data = await self._client.http.create_thread(\n        channel_id=self.id,\n        name=name,\n        thread_type=thread_type,\n        invitable=invitable,\n        auto_archive_duration=auto_archive_duration,\n        message_id=to_optional_snowflake(message),\n        reason=reason,\n    )\n    return self._client.cache.place_channel_data(thread_data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadableMixin.fetch_public_archived_threads","title":"<code>fetch_public_archived_threads(limit=None, before=None)</code>  <code>async</code>","text":"<p>Get a <code>ThreadList</code> of archived public threads available in this channel.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>optional maximum number of threads to return</p> <code>None</code> <code>before</code> <code>Optional[Timestamp]</code> <p>Returns threads before this timestamp</p> <code>None</code> <p>Returns:</p> Type Description <code>ThreadList</code> <p>A <code>ThreadList</code> of archived threads.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_public_archived_threads(\n    self, limit: int = None, before: Optional[\"models.Timestamp\"] = None\n) -&gt; \"models.ThreadList\":\n\"\"\"\n    Get a `ThreadList` of archived **public** threads available in this channel.\n\n    Args:\n        limit: optional maximum number of threads to return\n        before: Returns threads before this timestamp\n\n    Returns:\n        A `ThreadList` of archived threads.\n\n    \"\"\"\n    threads_data = await self._client.http.list_public_archived_threads(\n        channel_id=self.id, limit=limit, before=before\n    )\n    threads_data[\"id\"] = self.id\n    return models.ThreadList.from_dict(threads_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadableMixin.fetch_private_archived_threads","title":"<code>fetch_private_archived_threads(limit=None, before=None)</code>  <code>async</code>","text":"<p>Get a <code>ThreadList</code> of archived private threads available in this channel.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>optional maximum number of threads to return</p> <code>None</code> <code>before</code> <code>Optional[Timestamp]</code> <p>Returns threads before this timestamp</p> <code>None</code> <p>Returns:</p> Type Description <code>ThreadList</code> <p>A <code>ThreadList</code> of archived threads.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_private_archived_threads(\n    self, limit: int = None, before: Optional[\"models.Timestamp\"] = None\n) -&gt; \"models.ThreadList\":\n\"\"\"\n    Get a `ThreadList` of archived **private** threads available in this channel.\n\n    Args:\n        limit: optional maximum number of threads to return\n        before: Returns threads before this timestamp\n\n    Returns:\n        A `ThreadList` of archived threads.\n\n    \"\"\"\n    threads_data = await self._client.http.list_private_archived_threads(\n        channel_id=self.id, limit=limit, before=before\n    )\n    threads_data[\"id\"] = self.id\n    return models.ThreadList.from_dict(threads_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadableMixin.fetch_archived_threads","title":"<code>fetch_archived_threads(limit=None, before=None)</code>  <code>async</code>","text":"<p>Get a <code>ThreadList</code> of archived threads available in this channel.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>optional maximum number of threads to return</p> <code>None</code> <code>before</code> <code>Optional[Timestamp]</code> <p>Returns threads before this timestamp</p> <code>None</code> <p>Returns:</p> Type Description <code>ThreadList</code> <p>A <code>ThreadList</code> of archived threads.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_archived_threads(\n    self, limit: int = None, before: Optional[\"models.Timestamp\"] = None\n) -&gt; \"models.ThreadList\":\n\"\"\"\n    Get a `ThreadList` of archived threads available in this channel.\n\n    Args:\n        limit: optional maximum number of threads to return\n        before: Returns threads before this timestamp\n\n    Returns:\n        A `ThreadList` of archived threads.\n\n    \"\"\"\n    threads_data = await self._client.http.list_private_archived_threads(\n        channel_id=self.id, limit=limit, before=before\n    )\n    threads_data.update(\n        await self._client.http.list_public_archived_threads(channel_id=self.id, limit=limit, before=before)\n    )\n    threads_data[\"id\"] = self.id\n    return models.ThreadList.from_dict(threads_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadableMixin.fetch_joined_private_archived_threads","title":"<code>fetch_joined_private_archived_threads(limit=None, before=None)</code>  <code>async</code>","text":"<p>Get a <code>ThreadList</code> of threads the bot is a participant of in this channel.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>optional maximum number of threads to return</p> <code>None</code> <code>before</code> <code>Optional[Timestamp]</code> <p>Returns threads before this timestamp</p> <code>None</code> <p>Returns:</p> Type Description <code>ThreadList</code> <p>A <code>ThreadList</code> of threads the bot is a participant of.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_joined_private_archived_threads(\n    self, limit: int = None, before: Optional[\"models.Timestamp\"] = None\n) -&gt; \"models.ThreadList\":\n\"\"\"\n    Get a `ThreadList` of threads the bot is a participant of in this channel.\n\n    Args:\n        limit: optional maximum number of threads to return\n        before: Returns threads before this timestamp\n\n    Returns:\n        A `ThreadList` of threads the bot is a participant of.\n\n    \"\"\"\n    threads_data = await self._client.http.list_joined_private_archived_threads(\n        channel_id=self.id, limit=limit, before=before\n    )\n    threads_data[\"id\"] = self.id\n    return models.ThreadList.from_dict(threads_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadableMixin.fetch_active_threads","title":"<code>fetch_active_threads()</code>  <code>async</code>","text":"<p>Gets all active threads in the channel, including public and private threads.</p> <p>Returns:</p> Type Description <code>ThreadList</code> <p>A <code>ThreadList</code> of active threads.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_active_threads(self) -&gt; \"models.ThreadList\":\n\"\"\"\n    Gets all active threads in the channel, including public and private threads.\n\n    Returns:\n        A `ThreadList` of active threads.\n\n    \"\"\"\n    threads_data = await self._client.http.list_active_threads(guild_id=self._guild_id)\n\n    # delete the items where the channel_id does not match\n    removed_thread_ids = []\n    cleaned_threads_data_threads = []\n    for thread in threads_data[\"threads\"]:\n        if thread[\"parent_id\"] == str(self.id):\n            cleaned_threads_data_threads.append(thread)\n        else:\n            removed_thread_ids.append(thread[\"id\"])\n    threads_data[\"threads\"] = cleaned_threads_data_threads\n\n    # delete the member data which is not needed\n    cleaned_member_data_threads = []\n    for thread_member in threads_data[\"members\"]:\n        if thread_member[\"id\"] not in removed_thread_ids:\n            cleaned_member_data_threads.append(thread_member)\n    threads_data[\"members\"] = cleaned_member_data_threads\n\n    return models.ThreadList.from_dict(threads_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadableMixin.fetch_all_threads","title":"<code>fetch_all_threads()</code>  <code>async</code>","text":"<p>Gets all threads in the channel. Active and archived, including public and private threads.</p> <p>Returns:</p> Type Description <code>ThreadList</code> <p>A <code>ThreadList</code> of all threads.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_all_threads(self) -&gt; \"models.ThreadList\":\n\"\"\"\n    Gets all threads in the channel. Active and archived, including public and private threads.\n\n    Returns:\n        A `ThreadList` of all threads.\n\n    \"\"\"\n    threads = await self.fetch_active_threads()\n\n    # update that data with the archived threads\n    archived_threads = await self.fetch_archived_threads()\n    threads.threads.extend(archived_threads.threads)\n    threads.members.extend(archived_threads.members)\n\n    return threads\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.WebhookMixin","title":"<code>WebhookMixin</code>","text":"Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)\nclass WebhookMixin:\n    async def create_webhook(self, name: str, avatar: Absent[UPLOADABLE_TYPE] = MISSING) -&gt; \"models.Webhook\":\n\"\"\"\n        Create a webhook in this channel.\n\n        Args:\n            name: The name of the webhook\n            avatar: An optional default avatar image to use\n\n        Returns:\n            The created webhook object\n\n        Raises:\n            ValueError: If you try to name the webhook \"Clyde\"\n\n        \"\"\"\n        return await models.Webhook.create(self._client, self, name, avatar)  # type: ignore\n\n    async def delete_webhook(self, webhook: \"models.Webhook\") -&gt; None:\n\"\"\"\n        Delete a given webhook in this channel.\n\n        Args:\n            webhook: The webhook to delete\n\n        \"\"\"\n        return await webhook.delete()\n\n    async def fetch_webhooks(self) -&gt; List[\"models.Webhook\"]:\n\"\"\"\n        Fetches all the webhooks for this channel.\n\n        Returns:\n            List of webhook objects\n\n        \"\"\"\n        resp = await self._client.http.get_channel_webhooks(self.id)\n        return [models.Webhook.from_dict(d, self._client) for d in resp]\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.WebhookMixin.create_webhook","title":"<code>create_webhook(name, avatar=MISSING)</code>  <code>async</code>","text":"<p>Create a webhook in this channel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the webhook</p> required <code>avatar</code> <code>Absent[UPLOADABLE_TYPE]</code> <p>An optional default avatar image to use</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Webhook</code> <p>The created webhook object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If you try to name the webhook \"Clyde\"</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def create_webhook(self, name: str, avatar: Absent[UPLOADABLE_TYPE] = MISSING) -&gt; \"models.Webhook\":\n\"\"\"\n    Create a webhook in this channel.\n\n    Args:\n        name: The name of the webhook\n        avatar: An optional default avatar image to use\n\n    Returns:\n        The created webhook object\n\n    Raises:\n        ValueError: If you try to name the webhook \"Clyde\"\n\n    \"\"\"\n    return await models.Webhook.create(self._client, self, name, avatar)  # type: ignore\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.WebhookMixin.delete_webhook","title":"<code>delete_webhook(webhook)</code>  <code>async</code>","text":"<p>Delete a given webhook in this channel.</p> <p>Parameters:</p> Name Type Description Default <code>webhook</code> <code>Webhook</code> <p>The webhook to delete</p> required Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def delete_webhook(self, webhook: \"models.Webhook\") -&gt; None:\n\"\"\"\n    Delete a given webhook in this channel.\n\n    Args:\n        webhook: The webhook to delete\n\n    \"\"\"\n    return await webhook.delete()\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.WebhookMixin.fetch_webhooks","title":"<code>fetch_webhooks()</code>  <code>async</code>","text":"<p>Fetches all the webhooks for this channel.</p> <p>Returns:</p> Type Description <code>List[Webhook]</code> <p>List of webhook objects</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_webhooks(self) -&gt; List[\"models.Webhook\"]:\n\"\"\"\n    Fetches all the webhooks for this channel.\n\n    Returns:\n        List of webhook objects\n\n    \"\"\"\n    resp = await self._client.http.get_channel_webhooks(self.id)\n    return [models.Webhook.from_dict(d, self._client) for d in resp]\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.BaseChannel","title":"<code>BaseChannel</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)\nclass BaseChannel(DiscordObject):\n    name: Optional[str] = attrs.field(repr=True, default=None)\n\"\"\"The name of the channel (1-100 characters)\"\"\"\n    type: Union[ChannelTypes, int] = attrs.field(repr=True, converter=ChannelTypes)\n\"\"\"The channel topic (0-1024 characters)\"\"\"\n\n    @classmethod\n    def from_dict_factory(cls, data: dict, client: \"Client\") -&gt; \"TYPE_ALL_CHANNEL\":\n\"\"\"\n        Creates a channel object of the appropriate type.\n\n        Args:\n            data: The channel data.\n            client: The bot.\n\n        Returns:\n            The new channel object.\n\n        \"\"\"\n        channel_type = data.get(\"type\", None)\n        channel_class = TYPE_CHANNEL_MAPPING.get(channel_type, None)\n        if not channel_class:\n            client.logger.error(f\"Unsupported channel type for {data} ({channel_type}).\")\n            channel_class = BaseChannel\n\n        if channel_class == GuildPublicThread:\n            # attempt to determine if this thread is a forum post (thanks discord)\n            parent_channel = client.cache.get_channel(data[\"parent_id\"])\n            if parent_channel and parent_channel.type == ChannelTypes.GUILD_FORUM:\n                channel_class = GuildForumPost\n\n        return channel_class.from_dict(data, client)\n\n    @property\n    def mention(self) -&gt; str:\n\"\"\"Returns a string that would mention the channel.\"\"\"\n        return f\"&lt;#{self.id}&gt;\"\n\n    async def edit(\n        self,\n        *,\n        name: Absent[str] = MISSING,\n        icon: Absent[UPLOADABLE_TYPE] = MISSING,\n        type: Absent[ChannelTypes] = MISSING,\n        position: Absent[int] = MISSING,\n        topic: Absent[str] = MISSING,\n        nsfw: Absent[bool] = MISSING,\n        rate_limit_per_user: Absent[int] = MISSING,\n        bitrate: Absent[int] = MISSING,\n        user_limit: Absent[int] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n        ] = MISSING,\n        parent_id: Absent[Snowflake_Type] = MISSING,\n        rtc_region: Absent[Union[\"models.VoiceRegion\", str]] = MISSING,\n        video_quality_mode: Absent[VideoQualityModes] = MISSING,\n        default_auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,\n        archived: Absent[bool] = MISSING,\n        auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,\n        locked: Absent[bool] = MISSING,\n        invitable: Absent[bool] = MISSING,\n        reason: Absent[str] = MISSING,\n        **kwargs,\n    ) -&gt; \"TYPE_ALL_CHANNEL\":\n\"\"\"\n        Edits the channel.\n\n        Args:\n            name: 1-100 character channel name\n            icon: DM Group icon\n            type: The type of channel; only conversion between text and news is supported and only in guilds with the \"NEWS\" feature\n            position: The position of the channel in the left-hand listing\n            topic: 0-1024 character channel topic\n            nsfw: Whether the channel is nsfw\n            rate_limit_per_user: Amount of seconds a user has to wait before sending another message (0-21600)\n            bitrate: The bitrate (in bits) of the voice channel; 8000 to 96000 (128000 for VIP servers)\n            user_limit: The user limit of the voice channel; 0 refers to no limit, 1 to 99 refers to a user limit\n            permission_overwrites: Channel or category-specific permissions\n            parent_id: The id of the new parent category for a channel\n            rtc_region: Channel voice region id, automatic when set to None.\n            video_quality_mode: The camera video quality mode of the voice channel\n            default_auto_archive_duration: The default duration that the clients use (not the API) for newly created threads in the channel, in minutes, to automatically archive the thread after recent activity\n            archived: Whether the thread is archived\n            auto_archive_duration: Duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\n            locked: Whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it\n            invitable: Whether non-moderators can add other non-moderators to a thread; only available on private threads\n            reason: The reason for editing the channel\n\n        Returns:\n            The edited channel. May be a new object if the channel type changes.\n\n        \"\"\"\n        payload = {\n            \"name\": name,\n            \"icon\": to_image_data(icon),\n            \"type\": type,\n            \"position\": position,\n            \"topic\": topic,\n            \"nsfw\": nsfw,\n            \"rate_limit_per_user\": rate_limit_per_user,\n            \"bitrate\": bitrate,\n            \"user_limit\": user_limit,\n            \"permission_overwrites\": process_permission_overwrites(permission_overwrites),\n            \"parent_id\": to_optional_snowflake(parent_id),\n            \"rtc_region\": rtc_region.id if isinstance(rtc_region, models.VoiceRegion) else rtc_region,\n            \"video_quality_mode\": video_quality_mode,\n            \"default_auto_archive_duration\": default_auto_archive_duration,\n            \"archived\": archived,\n            \"auto_archive_duration\": auto_archive_duration,\n            \"locked\": locked,\n            \"invitable\": invitable,\n            **kwargs,\n        }\n        channel_data = await self._client.http.modify_channel(self.id, payload, reason)\n        if not channel_data:\n            raise TooManyChanges(\n                \"You have changed this channel too frequently, you need to wait a while before trying again.\"\n            ) from None\n\n        return self._client.cache.place_channel_data(channel_data)\n\n    async def delete(self, reason: Absent[Optional[str]] = MISSING) -&gt; None:\n\"\"\"\n        Delete this channel.\n\n        Args:\n            reason: The reason for deleting this channel\n\n        \"\"\"\n        await self._client.http.delete_channel(self.id, reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.BaseChannel.name","title":"<code>name: Optional[str] = attrs.field(repr=True, default=None)</code>  <code>class-attribute</code>","text":"<p>The name of the channel (1-100 characters)</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.BaseChannel.type","title":"<code>type: Union[ChannelTypes, int] = attrs.field(repr=True, converter=ChannelTypes)</code>  <code>class-attribute</code>","text":"<p>The channel topic (0-1024 characters)</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.BaseChannel.from_dict_factory","title":"<code>from_dict_factory(data, client)</code>  <code>classmethod</code>","text":"<p>Creates a channel object of the appropriate type.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The channel data.</p> required <code>client</code> <code>Client</code> <p>The bot.</p> required <p>Returns:</p> Type Description <code>TYPE_ALL_CHANNEL</code> <p>The new channel object.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@classmethod\ndef from_dict_factory(cls, data: dict, client: \"Client\") -&gt; \"TYPE_ALL_CHANNEL\":\n\"\"\"\n    Creates a channel object of the appropriate type.\n\n    Args:\n        data: The channel data.\n        client: The bot.\n\n    Returns:\n        The new channel object.\n\n    \"\"\"\n    channel_type = data.get(\"type\", None)\n    channel_class = TYPE_CHANNEL_MAPPING.get(channel_type, None)\n    if not channel_class:\n        client.logger.error(f\"Unsupported channel type for {data} ({channel_type}).\")\n        channel_class = BaseChannel\n\n    if channel_class == GuildPublicThread:\n        # attempt to determine if this thread is a forum post (thanks discord)\n        parent_channel = client.cache.get_channel(data[\"parent_id\"])\n        if parent_channel and parent_channel.type == ChannelTypes.GUILD_FORUM:\n            channel_class = GuildForumPost\n\n    return channel_class.from_dict(data, client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.BaseChannel.mention","title":"<code>mention: str</code>  <code>property</code>","text":"<p>Returns a string that would mention the channel.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.BaseChannel.edit","title":"<code>edit(*, name=MISSING, icon=MISSING, type=MISSING, position=MISSING, topic=MISSING, nsfw=MISSING, rate_limit_per_user=MISSING, bitrate=MISSING, user_limit=MISSING, permission_overwrites=MISSING, parent_id=MISSING, rtc_region=MISSING, video_quality_mode=MISSING, default_auto_archive_duration=MISSING, archived=MISSING, auto_archive_duration=MISSING, locked=MISSING, invitable=MISSING, reason=MISSING, **kwargs)</code>  <code>async</code>","text":"<p>Edits the channel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[str]</code> <p>1-100 character channel name</p> <code>MISSING</code> <code>icon</code> <code>Absent[UPLOADABLE_TYPE]</code> <p>DM Group icon</p> <code>MISSING</code> <code>type</code> <code>Absent[ChannelTypes]</code> <p>The type of channel; only conversion between text and news is supported and only in guilds with the \"NEWS\" feature</p> <code>MISSING</code> <code>position</code> <code>Absent[int]</code> <p>The position of the channel in the left-hand listing</p> <code>MISSING</code> <code>topic</code> <code>Absent[str]</code> <p>0-1024 character channel topic</p> <code>MISSING</code> <code>nsfw</code> <code>Absent[bool]</code> <p>Whether the channel is nsfw</p> <code>MISSING</code> <code>rate_limit_per_user</code> <code>Absent[int]</code> <p>Amount of seconds a user has to wait before sending another message (0-21600)</p> <code>MISSING</code> <code>bitrate</code> <code>Absent[int]</code> <p>The bitrate (in bits) of the voice channel; 8000 to 96000 (128000 for VIP servers)</p> <code>MISSING</code> <code>user_limit</code> <code>Absent[int]</code> <p>The user limit of the voice channel; 0 refers to no limit, 1 to 99 refers to a user limit</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>Channel or category-specific permissions</p> <code>MISSING</code> <code>parent_id</code> <code>Absent[Snowflake_Type]</code> <p>The id of the new parent category for a channel</p> <code>MISSING</code> <code>rtc_region</code> <code>Absent[Union[VoiceRegion, str]]</code> <p>Channel voice region id, automatic when set to None.</p> <code>MISSING</code> <code>video_quality_mode</code> <code>Absent[VideoQualityModes]</code> <p>The camera video quality mode of the voice channel</p> <code>MISSING</code> <code>default_auto_archive_duration</code> <code>Absent[AutoArchiveDuration]</code> <p>The default duration that the clients use (not the API) for newly created threads in the channel, in minutes, to automatically archive the thread after recent activity</p> <code>MISSING</code> <code>archived</code> <code>Absent[bool]</code> <p>Whether the thread is archived</p> <code>MISSING</code> <code>auto_archive_duration</code> <code>Absent[AutoArchiveDuration]</code> <p>Duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080</p> <code>MISSING</code> <code>locked</code> <code>Absent[bool]</code> <p>Whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it</p> <code>MISSING</code> <code>invitable</code> <code>Absent[bool]</code> <p>Whether non-moderators can add other non-moderators to a thread; only available on private threads</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for editing the channel</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>TYPE_ALL_CHANNEL</code> <p>The edited channel. May be a new object if the channel type changes.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: Absent[str] = MISSING,\n    icon: Absent[UPLOADABLE_TYPE] = MISSING,\n    type: Absent[ChannelTypes] = MISSING,\n    position: Absent[int] = MISSING,\n    topic: Absent[str] = MISSING,\n    nsfw: Absent[bool] = MISSING,\n    rate_limit_per_user: Absent[int] = MISSING,\n    bitrate: Absent[int] = MISSING,\n    user_limit: Absent[int] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n    ] = MISSING,\n    parent_id: Absent[Snowflake_Type] = MISSING,\n    rtc_region: Absent[Union[\"models.VoiceRegion\", str]] = MISSING,\n    video_quality_mode: Absent[VideoQualityModes] = MISSING,\n    default_auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,\n    archived: Absent[bool] = MISSING,\n    auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,\n    locked: Absent[bool] = MISSING,\n    invitable: Absent[bool] = MISSING,\n    reason: Absent[str] = MISSING,\n    **kwargs,\n) -&gt; \"TYPE_ALL_CHANNEL\":\n\"\"\"\n    Edits the channel.\n\n    Args:\n        name: 1-100 character channel name\n        icon: DM Group icon\n        type: The type of channel; only conversion between text and news is supported and only in guilds with the \"NEWS\" feature\n        position: The position of the channel in the left-hand listing\n        topic: 0-1024 character channel topic\n        nsfw: Whether the channel is nsfw\n        rate_limit_per_user: Amount of seconds a user has to wait before sending another message (0-21600)\n        bitrate: The bitrate (in bits) of the voice channel; 8000 to 96000 (128000 for VIP servers)\n        user_limit: The user limit of the voice channel; 0 refers to no limit, 1 to 99 refers to a user limit\n        permission_overwrites: Channel or category-specific permissions\n        parent_id: The id of the new parent category for a channel\n        rtc_region: Channel voice region id, automatic when set to None.\n        video_quality_mode: The camera video quality mode of the voice channel\n        default_auto_archive_duration: The default duration that the clients use (not the API) for newly created threads in the channel, in minutes, to automatically archive the thread after recent activity\n        archived: Whether the thread is archived\n        auto_archive_duration: Duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\n        locked: Whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it\n        invitable: Whether non-moderators can add other non-moderators to a thread; only available on private threads\n        reason: The reason for editing the channel\n\n    Returns:\n        The edited channel. May be a new object if the channel type changes.\n\n    \"\"\"\n    payload = {\n        \"name\": name,\n        \"icon\": to_image_data(icon),\n        \"type\": type,\n        \"position\": position,\n        \"topic\": topic,\n        \"nsfw\": nsfw,\n        \"rate_limit_per_user\": rate_limit_per_user,\n        \"bitrate\": bitrate,\n        \"user_limit\": user_limit,\n        \"permission_overwrites\": process_permission_overwrites(permission_overwrites),\n        \"parent_id\": to_optional_snowflake(parent_id),\n        \"rtc_region\": rtc_region.id if isinstance(rtc_region, models.VoiceRegion) else rtc_region,\n        \"video_quality_mode\": video_quality_mode,\n        \"default_auto_archive_duration\": default_auto_archive_duration,\n        \"archived\": archived,\n        \"auto_archive_duration\": auto_archive_duration,\n        \"locked\": locked,\n        \"invitable\": invitable,\n        **kwargs,\n    }\n    channel_data = await self._client.http.modify_channel(self.id, payload, reason)\n    if not channel_data:\n        raise TooManyChanges(\n            \"You have changed this channel too frequently, you need to wait a while before trying again.\"\n        ) from None\n\n    return self._client.cache.place_channel_data(channel_data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.BaseChannel.delete","title":"<code>delete(reason=MISSING)</code>  <code>async</code>","text":"<p>Delete this channel.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for deleting this channel</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def delete(self, reason: Absent[Optional[str]] = MISSING) -&gt; None:\n\"\"\"\n    Delete this channel.\n\n    Args:\n        reason: The reason for deleting this channel\n\n    \"\"\"\n    await self._client.http.delete_channel(self.id, reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.DMChannel","title":"<code>DMChannel</code>","text":"<p>         Bases: <code>BaseChannel</code>, <code>MessageableMixin</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)\nclass DMChannel(BaseChannel, MessageableMixin):\n    recipients: List[\"models.User\"] = attrs.field(repr=False, factory=list)\n\"\"\"The users of the DM that will receive messages sent\"\"\"\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        data = super()._process_dict(data, client)\n        if recipients := data.get(\"recipients\", None):\n            data[\"recipients\"] = [\n                client.cache.place_user_data(recipient) if isinstance(recipient, dict) else recipient\n                for recipient in recipients\n            ]\n        return data\n\n    @property\n    def members(self) -&gt; List[\"models.User\"]:\n\"\"\"Returns a list of users that are in this DM channel.\"\"\"\n        return self.recipients\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.DMChannel.recipients","title":"<code>recipients: List[models.User] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>The users of the DM that will receive messages sent</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.DMChannel.members","title":"<code>members: List[models.User]</code>  <code>property</code>","text":"<p>Returns a list of users that are in this DM channel.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.DM","title":"<code>DM</code>","text":"<p>         Bases: <code>DMChannel</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass DM(DMChannel):\n    @property\n    def recipient(self) -&gt; \"models.User\":\n\"\"\"Returns the user that is in this DM channel.\"\"\"\n        return self.recipients[0]\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.DM.recipient","title":"<code>recipient: models.User</code>  <code>property</code>","text":"<p>Returns the user that is in this DM channel.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.DMGroup","title":"<code>DMGroup</code>","text":"<p>         Bases: <code>DMChannel</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass DMGroup(DMChannel):\n    owner_id: Snowflake_Type = attrs.field(repr=True)\n\"\"\"id of the creator of the group DM\"\"\"\n    application_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)\n\"\"\"Application id of the group DM creator if it is bot-created\"\"\"\n\n    async def edit(\n        self,\n        *,\n        name: Absent[str] = MISSING,\n        icon: Absent[UPLOADABLE_TYPE] = MISSING,\n        reason: Absent[str] = MISSING,\n        **kwargs,\n    ) -&gt; \"DMGroup\":\n\"\"\"\n        Edit this DM Channel.\n\n        Args:\n            name: 1-100 character channel name\n            icon: An icon to use\n            reason: The reason for this change\n        \"\"\"\n        return await super().edit(name=name, icon=icon, reason=reason, **kwargs)\n\n    async def fetch_owner(self) -&gt; \"models.User\":\n\"\"\"Fetch the owner of this DM group\"\"\"\n        return await self._client.cache.fetch_user(self.owner_id)\n\n    def get_owner(self) -&gt; \"models.User\":\n\"\"\"Get the owner of this DM group\"\"\"\n        return self._client.cache.get_user(self.owner_id)\n\n    async def add_recipient(\n        self, user: Union[\"models.User\", Snowflake_Type], access_token: str, nickname: Absent[Optional[str]] = MISSING\n    ) -&gt; None:\n\"\"\"\n        Add a recipient to this DM Group.\n\n        Args:\n            user: The user to add\n            access_token: access token of a user that has granted your app the gdm.join scope\n            nickname: nickname to apply to the user being added\n\n        \"\"\"\n        user = await self._client.cache.fetch_user(user)\n        await self._client.http.group_dm_add_recipient(self.id, user.id, access_token, nickname)\n        self.recipients.append(user)\n\n    async def remove_recipient(self, user: Union[\"models.User\", Snowflake_Type]) -&gt; None:\n\"\"\"\n        Remove a recipient from this DM Group.\n\n        Args:\n            user: The user to remove\n\n        \"\"\"\n        user = await self._client.cache.fetch_user(user)\n        await self._client.http.group_dm_remove_recipient(self.id, user.id)\n        self.recipients.remove(user)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.DMGroup.owner_id","title":"<code>owner_id: Snowflake_Type = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>id of the creator of the group DM</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.DMGroup.application_id","title":"<code>application_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>Application id of the group DM creator if it is bot-created</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.DMGroup.edit","title":"<code>edit(*, name=MISSING, icon=MISSING, reason=MISSING, **kwargs)</code>  <code>async</code>","text":"<p>Edit this DM Channel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[str]</code> <p>1-100 character channel name</p> <code>MISSING</code> <code>icon</code> <code>Absent[UPLOADABLE_TYPE]</code> <p>An icon to use</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for this change</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: Absent[str] = MISSING,\n    icon: Absent[UPLOADABLE_TYPE] = MISSING,\n    reason: Absent[str] = MISSING,\n    **kwargs,\n) -&gt; \"DMGroup\":\n\"\"\"\n    Edit this DM Channel.\n\n    Args:\n        name: 1-100 character channel name\n        icon: An icon to use\n        reason: The reason for this change\n    \"\"\"\n    return await super().edit(name=name, icon=icon, reason=reason, **kwargs)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.DMGroup.fetch_owner","title":"<code>fetch_owner()</code>  <code>async</code>","text":"<p>Fetch the owner of this DM group</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_owner(self) -&gt; \"models.User\":\n\"\"\"Fetch the owner of this DM group\"\"\"\n    return await self._client.cache.fetch_user(self.owner_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.DMGroup.get_owner","title":"<code>get_owner()</code>","text":"<p>Get the owner of this DM group</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>def get_owner(self) -&gt; \"models.User\":\n\"\"\"Get the owner of this DM group\"\"\"\n    return self._client.cache.get_user(self.owner_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.DMGroup.add_recipient","title":"<code>add_recipient(user, access_token, nickname=MISSING)</code>  <code>async</code>","text":"<p>Add a recipient to this DM Group.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Union[User, Snowflake_Type]</code> <p>The user to add</p> required <code>access_token</code> <code>str</code> <p>access token of a user that has granted your app the gdm.join scope</p> required <code>nickname</code> <code>Absent[Optional[str]]</code> <p>nickname to apply to the user being added</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def add_recipient(\n    self, user: Union[\"models.User\", Snowflake_Type], access_token: str, nickname: Absent[Optional[str]] = MISSING\n) -&gt; None:\n\"\"\"\n    Add a recipient to this DM Group.\n\n    Args:\n        user: The user to add\n        access_token: access token of a user that has granted your app the gdm.join scope\n        nickname: nickname to apply to the user being added\n\n    \"\"\"\n    user = await self._client.cache.fetch_user(user)\n    await self._client.http.group_dm_add_recipient(self.id, user.id, access_token, nickname)\n    self.recipients.append(user)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.DMGroup.remove_recipient","title":"<code>remove_recipient(user)</code>  <code>async</code>","text":"<p>Remove a recipient from this DM Group.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Union[User, Snowflake_Type]</code> <p>The user to remove</p> required Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def remove_recipient(self, user: Union[\"models.User\", Snowflake_Type]) -&gt; None:\n\"\"\"\n    Remove a recipient from this DM Group.\n\n    Args:\n        user: The user to remove\n\n    \"\"\"\n    user = await self._client.cache.fetch_user(user)\n    await self._client.http.group_dm_remove_recipient(self.id, user.id)\n    self.recipients.remove(user)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel","title":"<code>GuildChannel</code>","text":"<p>         Bases: <code>BaseChannel</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)\nclass GuildChannel(BaseChannel):\n    position: Optional[int] = attrs.field(repr=False, default=0)\n\"\"\"Sorting position of the channel\"\"\"\n    nsfw: bool = attrs.field(repr=False, default=False)\n\"\"\"Whether the channel is nsfw\"\"\"\n    parent_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))\n\"\"\"id of the parent category for a channel (each parent category can contain up to 50 channels)\"\"\"\n    permission_overwrites: list[PermissionOverwrite] = attrs.field(repr=False, factory=list)\n\"\"\"A list of the overwritten permissions for the members and roles\"\"\"\n\n    _guild_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))\n\n    @property\n    def guild(self) -&gt; \"models.Guild\":\n\"\"\"The guild this channel belongs to.\"\"\"\n        return self._client.cache.get_guild(self._guild_id)\n\n    @property\n    def category(self) -&gt; Optional[\"GuildCategory\"]:\n\"\"\"The parent category of this channel.\"\"\"\n        return self._client.cache.get_channel(self.parent_id)\n\n    @property\n    def gui_position(self) -&gt; int:\n\"\"\"The position of this channel in the Discord interface.\"\"\"\n        return self.guild.get_channel_gui_position(self.id)\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        data = super()._process_dict(data, client)\n        if overwrites := data.get(\"permission_overwrites\"):\n            data[\"permission_overwrites\"] = PermissionOverwrite.from_list(overwrites)\n        return data\n\n    def permissions_for(self, instance: Snowflake_Type) -&gt; Permissions:\n\"\"\"\n        Calculates permissions for an instance\n\n        Args:\n            instance: Member or Role instance (or its ID)\n\n        Returns:\n            Permissions data\n\n        Raises:\n            ValueError: If could not find any member or role by given ID\n            RuntimeError: If given instance is from another guild\n\n        \"\"\"\n        if (is_member := isinstance(instance, models.Member)) or isinstance(instance, models.Role):\n            if instance._guild_id != self._guild_id:\n                raise RuntimeError(\"Unable to calculate permissions for the instance from different guild\")\n\n            if is_member:\n                return instance.channel_permissions(self)\n\n            else:\n                permissions = instance.permissions\n\n                for overwrite in self.permission_overwrites:\n                    if overwrite.id == instance.id:\n                        permissions &amp;= ~overwrite.deny\n                        permissions |= overwrite.allow\n                        break\n\n                return permissions\n\n        else:\n            instance = to_snowflake(instance)\n            guild = self.guild\n            instance = guild.get_member(instance) or guild.get_role(instance)\n\n            if not instance:\n                raise ValueError(\"Unable to find any member or role by given instance ID\")\n\n            return self.permissions_for(instance)\n\n    async def add_permission(\n        self,\n        target: Union[\"PermissionOverwrite\", \"models.Role\", \"models.User\", \"models.Member\", \"Snowflake_Type\"],\n        type: Optional[\"OverwriteTypes\"] = None,\n        allow: Optional[List[\"Permissions\"] | int] = None,\n        deny: Optional[List[\"Permissions\"] | int] = None,\n        reason: Optional[str] = None,\n    ) -&gt; None:\n\"\"\"\n        Add a permission to this channel.\n\n        Args:\n            target: The updated PermissionOverwrite object, or the Role or User object/id to update\n            type: The type of permission overwrite. Only applicable if target is an id\n            allow: List of permissions to allow. Only applicable if target is not an PermissionOverwrite object\n            deny: List of permissions to deny. Only applicable if target is not an PermissionOverwrite object\n            reason: The reason for this change\n\n        Raises:\n            ValueError: Invalid target for permission\n\n        \"\"\"\n        allow = allow or []\n        deny = deny or []\n        if not isinstance(target, PermissionOverwrite):\n            if isinstance(target, (models.User, models.Member)):\n                target = target.id\n                type = OverwriteTypes.MEMBER\n            elif isinstance(target, models.Role):\n                target = target.id\n                type = OverwriteTypes.ROLE\n            elif type and isinstance(target, Snowflake_Type):\n                target = to_snowflake(target)\n            else:\n                raise ValueError(\"Invalid target and/or type for permission\")\n            overwrite = PermissionOverwrite(id=target, type=type, allow=Permissions.NONE, deny=Permissions.NONE)\n            if isinstance(allow, int):\n                overwrite.allow |= allow\n            else:\n                for perm in allow:\n                    overwrite.allow |= perm\n            if isinstance(deny, int):\n                overwrite.deny |= deny\n            else:\n                for perm in deny:\n                    overwrite.deny |= perm\n        else:\n            overwrite = target\n\n        if exists := get(self.permission_overwrites, id=overwrite.id, type=overwrite.type):\n            exists.deny = (exists.deny | overwrite.deny) &amp; ~overwrite.allow\n            exists.allow = (exists.allow | overwrite.allow) &amp; ~overwrite.deny\n            await self.edit_permission(exists, reason)\n        else:\n            permission_overwrites = self.permission_overwrites\n            permission_overwrites.append(overwrite)\n            await self.edit(permission_overwrites=permission_overwrites)\n\n    async def edit_permission(self, overwrite: PermissionOverwrite, reason: Optional[str] = None) -&gt; None:\n\"\"\"\n        Edit the permissions for this channel.\n\n        Args:\n            overwrite: The permission overwrite to apply\n            reason: The reason for this change\n        \"\"\"\n        await self._client.http.edit_channel_permission(\n            self.id,\n            overwrite_id=overwrite.id,\n            allow=overwrite.allow,\n            deny=overwrite.deny,\n            perm_type=overwrite.type,\n            reason=reason,\n        )\n\n    async def delete_permission(\n        self,\n        target: Union[\"PermissionOverwrite\", \"models.Role\", \"models.User\"],\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; None:\n\"\"\"\n        Delete a permission overwrite for this channel.\n\n        Args:\n            target: The permission overwrite to delete\n            reason: The reason for this change\n\n        \"\"\"\n        target = to_snowflake(target)\n        await self._client.http.delete_channel_permission(self.id, target, reason)\n\n    async def set_permission(\n        self,\n        target: Union[\"models.Role\", \"models.Member\", \"models.User\"],\n        *,\n        add_reactions: bool | None = None,\n        administrator: bool | None = None,\n        attach_files: bool | None = None,\n        ban_members: bool | None = None,\n        change_nickname: bool | None = None,\n        connect: bool | None = None,\n        create_instant_invite: bool | None = None,\n        deafen_members: bool | None = None,\n        embed_links: bool | None = None,\n        kick_members: bool | None = None,\n        manage_channels: bool | None = None,\n        manage_emojis_and_stickers: bool | None = None,\n        manage_events: bool | None = None,\n        manage_guild: bool | None = None,\n        manage_messages: bool | None = None,\n        manage_nicknames: bool | None = None,\n        manage_roles: bool | None = None,\n        manage_threads: bool | None = None,\n        manage_webhooks: bool | None = None,\n        mention_everyone: bool | None = None,\n        moderate_members: bool | None = None,\n        move_members: bool | None = None,\n        mute_members: bool | None = None,\n        priority_speaker: bool | None = None,\n        read_message_history: bool | None = None,\n        request_to_speak: bool | None = None,\n        send_messages: bool | None = None,\n        send_messages_in_threads: bool | None = None,\n        send_tts_messages: bool | None = None,\n        speak: bool | None = None,\n        start_embedded_activities: bool | None = None,\n        stream: bool | None = None,\n        use_application_commands: bool | None = None,\n        use_external_emojis: bool | None = None,\n        use_external_stickers: bool | None = None,\n        use_private_threads: bool | None = None,\n        use_public_threads: bool | None = None,\n        use_vad: bool | None = None,\n        view_audit_log: bool | None = None,\n        view_channel: bool | None = None,\n        view_guild_insights: bool | None = None,\n        reason: str = None,\n    ) -&gt; None:\n\"\"\"\n        Set the Permission Overwrites for a given target.\n\n        Args:\n            target: The target to set permission overwrites for\n            add_reactions: Allows for the addition of reactions to messages\n            administrator: Allows all permissions and bypasses channel permission overwrites\n            attach_files: Allows for uploading images and files\n            ban_members: Allows banning members\n            change_nickname: Allows for modification of own nickname\n            connect: Allows for joining of a voice channel\n            create_instant_invite: Allows creation of instant invites\n            deafen_members: Allows for deafening of members in a voice channel\n            embed_links: Links sent by users with this permission will be auto-embedded\n            kick_members: Allows kicking members\n            manage_channels: Allows management and editing of channels\n            manage_emojis_and_stickers: Allows management and editing of emojis and stickers\n            manage_events: Allows for creating, editing, and deleting scheduled events\n            manage_guild: Allows management and editing of the guild\n            manage_messages: Allows for deletion of other users messages\n            manage_nicknames: Allows for modification of other users nicknames\n            manage_roles: Allows management and editing of roles\n            manage_threads: Allows for deleting and archiving threads, and viewing all private threads\n            manage_webhooks: Allows management and editing of webhooks\n            mention_everyone: Allows for using the `@everyone` tag to notify all users in a channel, and the `@here` tag to notify all online users in a channel\n            moderate_members: Allows for timing out users to prevent them from sending or reacting to messages in chat and threads, and from speaking in voice and stage channels\n            move_members: Allows for moving of members between voice channels\n            mute_members: Allows for muting members in a voice channel\n            priority_speaker: Allows for using priority speaker in a voice channel\n            read_message_history: Allows for reading of message history\n            request_to_speak: Allows for requesting to speak in stage channels. (This permission is under active development and may be changed or removed.)\n            send_messages:  Allows for sending messages in a channel (does not allow sending messages in threads)\n            send_messages_in_threads: Allows for sending messages in threads\n            send_tts_messages:  Allows for sending of `/tts` messages\n            speak: Allows for speaking in a voice channel\n            start_embedded_activities: Allows for using Activities (applications with the `EMBEDDED` flag) in a voice channel\n            stream: Allows the user to go live\n            use_application_commands: Allows members to use application commands, including slash commands and context menu commands\n            use_external_emojis: Allows the usage of custom emojis from other servers\n            use_external_stickers: Allows the usage of custom stickers from other servers\n            use_private_threads: Allows for creating private threads\n            use_public_threads:  Allows for creating public and announcement threads\n            use_vad: Allows for using voice-activity-detection in a voice channel\n            view_audit_log: Allows for viewing of audit logs\n            view_channel: Allows guild members to view a channel, which includes reading messages in text channels and joining voice channels\n            view_guild_insights: Allows for viewing guild insights\n            reason: The reason for creating this overwrite\n        \"\"\"\n        overwrite = PermissionOverwrite.for_target(target)\n\n        allow: Permissions = Permissions.NONE\n        deny: Permissions = Permissions.NONE\n\n        for name, val in locals().items():\n            if isinstance(val, bool):\n                if val:\n                    allow |= getattr(Permissions, name.upper())\n                else:\n                    deny |= getattr(Permissions, name.upper())\n\n        overwrite.add_allows(allow)\n        overwrite.add_denies(deny)\n\n        await self.edit_permission(overwrite, reason)\n\n    @property\n    def members(self) -&gt; List[\"models.Member\"]:\n\"\"\"Returns a list of members that can see this channel.\"\"\"\n        return [m for m in self.guild.members if Permissions.VIEW_CHANNEL in m.channel_permissions(self)]  # type: ignore\n\n    @property\n    def bots(self) -&gt; List[\"models.Member\"]:\n\"\"\"Returns a list of bots that can see this channel.\"\"\"\n        return [m for m in self.guild.members if m.bot and Permissions.VIEW_CHANNEL in m.channel_permissions(self)]  # type: ignore\n\n    @property\n    def humans(self) -&gt; List[\"models.Member\"]:\n\"\"\"Returns a list of humans that can see this channel.\"\"\"\n        return [m for m in self.guild.members if not m.bot and Permissions.VIEW_CHANNEL in m.channel_permissions(self)]  # type: ignore\n\n    async def clone(self, name: Optional[str] = None, reason: Absent[Optional[str]] = MISSING) -&gt; \"TYPE_GUILD_CHANNEL\":\n\"\"\"\n        Clone this channel and create a new one.\n\n        Args:\n            name: The name of the new channel. Defaults to the current name\n            reason: The reason for creating this channel\n\n        Returns:\n            The newly created channel.\n\n        \"\"\"\n        return await self.guild.create_channel(\n            channel_type=self.type,\n            name=name if name else self.name,\n            topic=getattr(self, \"topic\", MISSING),\n            position=self.position,\n            permission_overwrites=self.permission_overwrites,\n            category=self.category,\n            nsfw=self.nsfw,\n            bitrate=getattr(self, \"bitrate\", 64000),\n            user_limit=getattr(self, \"user_limit\", 0),\n            rate_limit_per_user=getattr(self, \"rate_limit_per_user\", 0),\n            reason=reason,\n        )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.position","title":"<code>position: Optional[int] = attrs.field(repr=False, default=0)</code>  <code>class-attribute</code>","text":"<p>Sorting position of the channel</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.nsfw","title":"<code>nsfw: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>Whether the channel is nsfw</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.parent_id","title":"<code>parent_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))</code>  <code>class-attribute</code>","text":"<p>id of the parent category for a channel (each parent category can contain up to 50 channels)</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.permission_overwrites","title":"<code>permission_overwrites: list[PermissionOverwrite] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>A list of the overwritten permissions for the members and roles</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.guild","title":"<code>guild: models.Guild</code>  <code>property</code>","text":"<p>The guild this channel belongs to.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.category","title":"<code>category: Optional[GuildCategory]</code>  <code>property</code>","text":"<p>The parent category of this channel.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.gui_position","title":"<code>gui_position: int</code>  <code>property</code>","text":"<p>The position of this channel in the Discord interface.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.permissions_for","title":"<code>permissions_for(instance)</code>","text":"<p>Calculates permissions for an instance</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Snowflake_Type</code> <p>Member or Role instance (or its ID)</p> required <p>Returns:</p> Type Description <code>Permissions</code> <p>Permissions data</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If could not find any member or role by given ID</p> <code>RuntimeError</code> <p>If given instance is from another guild</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>def permissions_for(self, instance: Snowflake_Type) -&gt; Permissions:\n\"\"\"\n    Calculates permissions for an instance\n\n    Args:\n        instance: Member or Role instance (or its ID)\n\n    Returns:\n        Permissions data\n\n    Raises:\n        ValueError: If could not find any member or role by given ID\n        RuntimeError: If given instance is from another guild\n\n    \"\"\"\n    if (is_member := isinstance(instance, models.Member)) or isinstance(instance, models.Role):\n        if instance._guild_id != self._guild_id:\n            raise RuntimeError(\"Unable to calculate permissions for the instance from different guild\")\n\n        if is_member:\n            return instance.channel_permissions(self)\n\n        else:\n            permissions = instance.permissions\n\n            for overwrite in self.permission_overwrites:\n                if overwrite.id == instance.id:\n                    permissions &amp;= ~overwrite.deny\n                    permissions |= overwrite.allow\n                    break\n\n            return permissions\n\n    else:\n        instance = to_snowflake(instance)\n        guild = self.guild\n        instance = guild.get_member(instance) or guild.get_role(instance)\n\n        if not instance:\n            raise ValueError(\"Unable to find any member or role by given instance ID\")\n\n        return self.permissions_for(instance)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.add_permission","title":"<code>add_permission(target, type=None, allow=None, deny=None, reason=None)</code>  <code>async</code>","text":"<p>Add a permission to this channel.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Union[PermissionOverwrite, Role, User, Member, Snowflake_Type]</code> <p>The updated PermissionOverwrite object, or the Role or User object/id to update</p> required <code>type</code> <code>Optional[OverwriteTypes]</code> <p>The type of permission overwrite. Only applicable if target is an id</p> <code>None</code> <code>allow</code> <code>Optional[List[Permissions] | int]</code> <p>List of permissions to allow. Only applicable if target is not an PermissionOverwrite object</p> <code>None</code> <code>deny</code> <code>Optional[List[Permissions] | int]</code> <p>List of permissions to deny. Only applicable if target is not an PermissionOverwrite object</p> <code>None</code> <code>reason</code> <code>Optional[str]</code> <p>The reason for this change</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid target for permission</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def add_permission(\n    self,\n    target: Union[\"PermissionOverwrite\", \"models.Role\", \"models.User\", \"models.Member\", \"Snowflake_Type\"],\n    type: Optional[\"OverwriteTypes\"] = None,\n    allow: Optional[List[\"Permissions\"] | int] = None,\n    deny: Optional[List[\"Permissions\"] | int] = None,\n    reason: Optional[str] = None,\n) -&gt; None:\n\"\"\"\n    Add a permission to this channel.\n\n    Args:\n        target: The updated PermissionOverwrite object, or the Role or User object/id to update\n        type: The type of permission overwrite. Only applicable if target is an id\n        allow: List of permissions to allow. Only applicable if target is not an PermissionOverwrite object\n        deny: List of permissions to deny. Only applicable if target is not an PermissionOverwrite object\n        reason: The reason for this change\n\n    Raises:\n        ValueError: Invalid target for permission\n\n    \"\"\"\n    allow = allow or []\n    deny = deny or []\n    if not isinstance(target, PermissionOverwrite):\n        if isinstance(target, (models.User, models.Member)):\n            target = target.id\n            type = OverwriteTypes.MEMBER\n        elif isinstance(target, models.Role):\n            target = target.id\n            type = OverwriteTypes.ROLE\n        elif type and isinstance(target, Snowflake_Type):\n            target = to_snowflake(target)\n        else:\n            raise ValueError(\"Invalid target and/or type for permission\")\n        overwrite = PermissionOverwrite(id=target, type=type, allow=Permissions.NONE, deny=Permissions.NONE)\n        if isinstance(allow, int):\n            overwrite.allow |= allow\n        else:\n            for perm in allow:\n                overwrite.allow |= perm\n        if isinstance(deny, int):\n            overwrite.deny |= deny\n        else:\n            for perm in deny:\n                overwrite.deny |= perm\n    else:\n        overwrite = target\n\n    if exists := get(self.permission_overwrites, id=overwrite.id, type=overwrite.type):\n        exists.deny = (exists.deny | overwrite.deny) &amp; ~overwrite.allow\n        exists.allow = (exists.allow | overwrite.allow) &amp; ~overwrite.deny\n        await self.edit_permission(exists, reason)\n    else:\n        permission_overwrites = self.permission_overwrites\n        permission_overwrites.append(overwrite)\n        await self.edit(permission_overwrites=permission_overwrites)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.edit_permission","title":"<code>edit_permission(overwrite, reason=None)</code>  <code>async</code>","text":"<p>Edit the permissions for this channel.</p> <p>Parameters:</p> Name Type Description Default <code>overwrite</code> <code>PermissionOverwrite</code> <p>The permission overwrite to apply</p> required <code>reason</code> <code>Optional[str]</code> <p>The reason for this change</p> <code>None</code> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def edit_permission(self, overwrite: PermissionOverwrite, reason: Optional[str] = None) -&gt; None:\n\"\"\"\n    Edit the permissions for this channel.\n\n    Args:\n        overwrite: The permission overwrite to apply\n        reason: The reason for this change\n    \"\"\"\n    await self._client.http.edit_channel_permission(\n        self.id,\n        overwrite_id=overwrite.id,\n        allow=overwrite.allow,\n        deny=overwrite.deny,\n        perm_type=overwrite.type,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.delete_permission","title":"<code>delete_permission(target, reason=MISSING)</code>  <code>async</code>","text":"<p>Delete a permission overwrite for this channel.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Union[PermissionOverwrite, Role, User]</code> <p>The permission overwrite to delete</p> required <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for this change</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def delete_permission(\n    self,\n    target: Union[\"PermissionOverwrite\", \"models.Role\", \"models.User\"],\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; None:\n\"\"\"\n    Delete a permission overwrite for this channel.\n\n    Args:\n        target: The permission overwrite to delete\n        reason: The reason for this change\n\n    \"\"\"\n    target = to_snowflake(target)\n    await self._client.http.delete_channel_permission(self.id, target, reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.set_permission","title":"<code>set_permission(target, *, add_reactions=None, administrator=None, attach_files=None, ban_members=None, change_nickname=None, connect=None, create_instant_invite=None, deafen_members=None, embed_links=None, kick_members=None, manage_channels=None, manage_emojis_and_stickers=None, manage_events=None, manage_guild=None, manage_messages=None, manage_nicknames=None, manage_roles=None, manage_threads=None, manage_webhooks=None, mention_everyone=None, moderate_members=None, move_members=None, mute_members=None, priority_speaker=None, read_message_history=None, request_to_speak=None, send_messages=None, send_messages_in_threads=None, send_tts_messages=None, speak=None, start_embedded_activities=None, stream=None, use_application_commands=None, use_external_emojis=None, use_external_stickers=None, use_private_threads=None, use_public_threads=None, use_vad=None, view_audit_log=None, view_channel=None, view_guild_insights=None, reason=None)</code>  <code>async</code>","text":"<p>Set the Permission Overwrites for a given target.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Union[Role, Member, User]</code> <p>The target to set permission overwrites for</p> required <code>add_reactions</code> <code>bool | None</code> <p>Allows for the addition of reactions to messages</p> <code>None</code> <code>administrator</code> <code>bool | None</code> <p>Allows all permissions and bypasses channel permission overwrites</p> <code>None</code> <code>attach_files</code> <code>bool | None</code> <p>Allows for uploading images and files</p> <code>None</code> <code>ban_members</code> <code>bool | None</code> <p>Allows banning members</p> <code>None</code> <code>change_nickname</code> <code>bool | None</code> <p>Allows for modification of own nickname</p> <code>None</code> <code>connect</code> <code>bool | None</code> <p>Allows for joining of a voice channel</p> <code>None</code> <code>create_instant_invite</code> <code>bool | None</code> <p>Allows creation of instant invites</p> <code>None</code> <code>deafen_members</code> <code>bool | None</code> <p>Allows for deafening of members in a voice channel</p> <code>None</code> <code>embed_links</code> <code>bool | None</code> <p>Links sent by users with this permission will be auto-embedded</p> <code>None</code> <code>kick_members</code> <code>bool | None</code> <p>Allows kicking members</p> <code>None</code> <code>manage_channels</code> <code>bool | None</code> <p>Allows management and editing of channels</p> <code>None</code> <code>manage_emojis_and_stickers</code> <code>bool | None</code> <p>Allows management and editing of emojis and stickers</p> <code>None</code> <code>manage_events</code> <code>bool | None</code> <p>Allows for creating, editing, and deleting scheduled events</p> <code>None</code> <code>manage_guild</code> <code>bool | None</code> <p>Allows management and editing of the guild</p> <code>None</code> <code>manage_messages</code> <code>bool | None</code> <p>Allows for deletion of other users messages</p> <code>None</code> <code>manage_nicknames</code> <code>bool | None</code> <p>Allows for modification of other users nicknames</p> <code>None</code> <code>manage_roles</code> <code>bool | None</code> <p>Allows management and editing of roles</p> <code>None</code> <code>manage_threads</code> <code>bool | None</code> <p>Allows for deleting and archiving threads, and viewing all private threads</p> <code>None</code> <code>manage_webhooks</code> <code>bool | None</code> <p>Allows management and editing of webhooks</p> <code>None</code> <code>mention_everyone</code> <code>bool | None</code> <p>Allows for using the <code>@everyone</code> tag to notify all users in a channel, and the <code>@here</code> tag to notify all online users in a channel</p> <code>None</code> <code>moderate_members</code> <code>bool | None</code> <p>Allows for timing out users to prevent them from sending or reacting to messages in chat and threads, and from speaking in voice and stage channels</p> <code>None</code> <code>move_members</code> <code>bool | None</code> <p>Allows for moving of members between voice channels</p> <code>None</code> <code>mute_members</code> <code>bool | None</code> <p>Allows for muting members in a voice channel</p> <code>None</code> <code>priority_speaker</code> <code>bool | None</code> <p>Allows for using priority speaker in a voice channel</p> <code>None</code> <code>read_message_history</code> <code>bool | None</code> <p>Allows for reading of message history</p> <code>None</code> <code>request_to_speak</code> <code>bool | None</code> <p>Allows for requesting to speak in stage channels. (This permission is under active development and may be changed or removed.)</p> <code>None</code> <code>send_messages</code> <code>bool | None</code> <p>Allows for sending messages in a channel (does not allow sending messages in threads)</p> <code>None</code> <code>send_messages_in_threads</code> <code>bool | None</code> <p>Allows for sending messages in threads</p> <code>None</code> <code>send_tts_messages</code> <code>bool | None</code> <p>Allows for sending of <code>/tts</code> messages</p> <code>None</code> <code>speak</code> <code>bool | None</code> <p>Allows for speaking in a voice channel</p> <code>None</code> <code>start_embedded_activities</code> <code>bool | None</code> <p>Allows for using Activities (applications with the <code>EMBEDDED</code> flag) in a voice channel</p> <code>None</code> <code>stream</code> <code>bool | None</code> <p>Allows the user to go live</p> <code>None</code> <code>use_application_commands</code> <code>bool | None</code> <p>Allows members to use application commands, including slash commands and context menu commands</p> <code>None</code> <code>use_external_emojis</code> <code>bool | None</code> <p>Allows the usage of custom emojis from other servers</p> <code>None</code> <code>use_external_stickers</code> <code>bool | None</code> <p>Allows the usage of custom stickers from other servers</p> <code>None</code> <code>use_private_threads</code> <code>bool | None</code> <p>Allows for creating private threads</p> <code>None</code> <code>use_public_threads</code> <code>bool | None</code> <p>Allows for creating public and announcement threads</p> <code>None</code> <code>use_vad</code> <code>bool | None</code> <p>Allows for using voice-activity-detection in a voice channel</p> <code>None</code> <code>view_audit_log</code> <code>bool | None</code> <p>Allows for viewing of audit logs</p> <code>None</code> <code>view_channel</code> <code>bool | None</code> <p>Allows guild members to view a channel, which includes reading messages in text channels and joining voice channels</p> <code>None</code> <code>view_guild_insights</code> <code>bool | None</code> <p>Allows for viewing guild insights</p> <code>None</code> <code>reason</code> <code>str</code> <p>The reason for creating this overwrite</p> <code>None</code> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def set_permission(\n    self,\n    target: Union[\"models.Role\", \"models.Member\", \"models.User\"],\n    *,\n    add_reactions: bool | None = None,\n    administrator: bool | None = None,\n    attach_files: bool | None = None,\n    ban_members: bool | None = None,\n    change_nickname: bool | None = None,\n    connect: bool | None = None,\n    create_instant_invite: bool | None = None,\n    deafen_members: bool | None = None,\n    embed_links: bool | None = None,\n    kick_members: bool | None = None,\n    manage_channels: bool | None = None,\n    manage_emojis_and_stickers: bool | None = None,\n    manage_events: bool | None = None,\n    manage_guild: bool | None = None,\n    manage_messages: bool | None = None,\n    manage_nicknames: bool | None = None,\n    manage_roles: bool | None = None,\n    manage_threads: bool | None = None,\n    manage_webhooks: bool | None = None,\n    mention_everyone: bool | None = None,\n    moderate_members: bool | None = None,\n    move_members: bool | None = None,\n    mute_members: bool | None = None,\n    priority_speaker: bool | None = None,\n    read_message_history: bool | None = None,\n    request_to_speak: bool | None = None,\n    send_messages: bool | None = None,\n    send_messages_in_threads: bool | None = None,\n    send_tts_messages: bool | None = None,\n    speak: bool | None = None,\n    start_embedded_activities: bool | None = None,\n    stream: bool | None = None,\n    use_application_commands: bool | None = None,\n    use_external_emojis: bool | None = None,\n    use_external_stickers: bool | None = None,\n    use_private_threads: bool | None = None,\n    use_public_threads: bool | None = None,\n    use_vad: bool | None = None,\n    view_audit_log: bool | None = None,\n    view_channel: bool | None = None,\n    view_guild_insights: bool | None = None,\n    reason: str = None,\n) -&gt; None:\n\"\"\"\n    Set the Permission Overwrites for a given target.\n\n    Args:\n        target: The target to set permission overwrites for\n        add_reactions: Allows for the addition of reactions to messages\n        administrator: Allows all permissions and bypasses channel permission overwrites\n        attach_files: Allows for uploading images and files\n        ban_members: Allows banning members\n        change_nickname: Allows for modification of own nickname\n        connect: Allows for joining of a voice channel\n        create_instant_invite: Allows creation of instant invites\n        deafen_members: Allows for deafening of members in a voice channel\n        embed_links: Links sent by users with this permission will be auto-embedded\n        kick_members: Allows kicking members\n        manage_channels: Allows management and editing of channels\n        manage_emojis_and_stickers: Allows management and editing of emojis and stickers\n        manage_events: Allows for creating, editing, and deleting scheduled events\n        manage_guild: Allows management and editing of the guild\n        manage_messages: Allows for deletion of other users messages\n        manage_nicknames: Allows for modification of other users nicknames\n        manage_roles: Allows management and editing of roles\n        manage_threads: Allows for deleting and archiving threads, and viewing all private threads\n        manage_webhooks: Allows management and editing of webhooks\n        mention_everyone: Allows for using the `@everyone` tag to notify all users in a channel, and the `@here` tag to notify all online users in a channel\n        moderate_members: Allows for timing out users to prevent them from sending or reacting to messages in chat and threads, and from speaking in voice and stage channels\n        move_members: Allows for moving of members between voice channels\n        mute_members: Allows for muting members in a voice channel\n        priority_speaker: Allows for using priority speaker in a voice channel\n        read_message_history: Allows for reading of message history\n        request_to_speak: Allows for requesting to speak in stage channels. (This permission is under active development and may be changed or removed.)\n        send_messages:  Allows for sending messages in a channel (does not allow sending messages in threads)\n        send_messages_in_threads: Allows for sending messages in threads\n        send_tts_messages:  Allows for sending of `/tts` messages\n        speak: Allows for speaking in a voice channel\n        start_embedded_activities: Allows for using Activities (applications with the `EMBEDDED` flag) in a voice channel\n        stream: Allows the user to go live\n        use_application_commands: Allows members to use application commands, including slash commands and context menu commands\n        use_external_emojis: Allows the usage of custom emojis from other servers\n        use_external_stickers: Allows the usage of custom stickers from other servers\n        use_private_threads: Allows for creating private threads\n        use_public_threads:  Allows for creating public and announcement threads\n        use_vad: Allows for using voice-activity-detection in a voice channel\n        view_audit_log: Allows for viewing of audit logs\n        view_channel: Allows guild members to view a channel, which includes reading messages in text channels and joining voice channels\n        view_guild_insights: Allows for viewing guild insights\n        reason: The reason for creating this overwrite\n    \"\"\"\n    overwrite = PermissionOverwrite.for_target(target)\n\n    allow: Permissions = Permissions.NONE\n    deny: Permissions = Permissions.NONE\n\n    for name, val in locals().items():\n        if isinstance(val, bool):\n            if val:\n                allow |= getattr(Permissions, name.upper())\n            else:\n                deny |= getattr(Permissions, name.upper())\n\n    overwrite.add_allows(allow)\n    overwrite.add_denies(deny)\n\n    await self.edit_permission(overwrite, reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.members","title":"<code>members: List[models.Member]</code>  <code>property</code>","text":"<p>Returns a list of members that can see this channel.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.bots","title":"<code>bots: List[models.Member]</code>  <code>property</code>","text":"<p>Returns a list of bots that can see this channel.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.humans","title":"<code>humans: List[models.Member]</code>  <code>property</code>","text":"<p>Returns a list of humans that can see this channel.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildChannel.clone","title":"<code>clone(name=None, reason=MISSING)</code>  <code>async</code>","text":"<p>Clone this channel and create a new one.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the new channel. Defaults to the current name</p> <code>None</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for creating this channel</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>TYPE_GUILD_CHANNEL</code> <p>The newly created channel.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def clone(self, name: Optional[str] = None, reason: Absent[Optional[str]] = MISSING) -&gt; \"TYPE_GUILD_CHANNEL\":\n\"\"\"\n    Clone this channel and create a new one.\n\n    Args:\n        name: The name of the new channel. Defaults to the current name\n        reason: The reason for creating this channel\n\n    Returns:\n        The newly created channel.\n\n    \"\"\"\n    return await self.guild.create_channel(\n        channel_type=self.type,\n        name=name if name else self.name,\n        topic=getattr(self, \"topic\", MISSING),\n        position=self.position,\n        permission_overwrites=self.permission_overwrites,\n        category=self.category,\n        nsfw=self.nsfw,\n        bitrate=getattr(self, \"bitrate\", 64000),\n        user_limit=getattr(self, \"user_limit\", 0),\n        rate_limit_per_user=getattr(self, \"rate_limit_per_user\", 0),\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildCategory","title":"<code>GuildCategory</code>","text":"<p>         Bases: <code>GuildChannel</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass GuildCategory(GuildChannel):\n    @property\n    def channels(self) -&gt; List[\"TYPE_GUILD_CHANNEL\"]:\n\"\"\"Get all channels within the category\"\"\"\n        return [channel for channel in self.guild.channels if channel.parent_id == self.id]\n\n    @property\n    def voice_channels(self) -&gt; List[\"GuildVoice\"]:\n\"\"\"Get all voice channels within the category\"\"\"\n        return [\n            channel\n            for channel in self.channels\n            if isinstance(channel, GuildVoice) and not isinstance(channel, GuildStageVoice)\n        ]\n\n    @property\n    def stage_channels(self) -&gt; List[\"GuildStageVoice\"]:\n\"\"\"Get all stage channels within the category\"\"\"\n        return [channel for channel in self.channels if isinstance(channel, GuildStageVoice)]\n\n    @property\n    def text_channels(self) -&gt; List[\"GuildText\"]:\n\"\"\"Get all text channels within the category\"\"\"\n        return [channel for channel in self.channels if isinstance(channel, GuildText)]\n\n    @property\n    def news_channels(self) -&gt; List[\"GuildNews\"]:\n\"\"\"Get all news channels within the category\"\"\"\n        return [channel for channel in self.channels if isinstance(channel, GuildNews)]\n\n    async def edit(\n        self,\n        *,\n        name: Absent[str] = MISSING,\n        position: Absent[int] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n        ] = MISSING,\n        reason: Absent[str] = MISSING,\n        **kwargs,\n    ) -&gt; \"GuildCategory\":\n\"\"\"\n        Edit this channel.\n\n        Args:\n            name: 1-100 character channel name\n            position: the position of the channel in the left-hand listing\n            permission_overwrites: channel or category-specific permissions\n            reason: the reason for this change\n\n        Returns:\n            The updated channel object.\n\n        \"\"\"\n        return await super().edit(\n            name=name,\n            position=position,\n            permission_overwrites=permission_overwrites,\n            reason=reason,\n            **kwargs,\n        )\n\n    async def create_channel(\n        self,\n        channel_type: Union[ChannelTypes, int],\n        name: str,\n        topic: Absent[Optional[str]] = MISSING,\n        position: Absent[Optional[int]] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n        ] = MISSING,\n        nsfw: bool = False,\n        bitrate: int = 64000,\n        user_limit: int = 0,\n        rate_limit_per_user: int = 0,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"TYPE_GUILD_CHANNEL\":\n\"\"\"\n        Create a guild channel within this category, allows for explicit channel type setting.\n\n        Args:\n            channel_type: The type of channel to create\n            name: The name of the channel\n            topic: The topic of the channel\n            position: The position of the channel in the channel list\n            permission_overwrites: Permission overwrites to apply to the channel\n            nsfw: Should this channel be marked nsfw\n            bitrate: The bitrate of this channel, only for voice\n            user_limit: The max users that can be in this channel, only for voice\n            rate_limit_per_user: The time users must wait between sending messages\n            reason: The reason for creating this channel\n\n        Returns:\n            The newly created channel.\n\n        \"\"\"\n        return await self.guild.create_channel(\n            channel_type=channel_type,\n            name=name,\n            topic=topic,\n            position=position,\n            permission_overwrites=permission_overwrites,\n            category=self.id,\n            nsfw=nsfw,\n            bitrate=bitrate,\n            user_limit=user_limit,\n            rate_limit_per_user=rate_limit_per_user,\n            reason=reason,\n        )\n\n    async def create_text_channel(\n        self,\n        name: str,\n        topic: Absent[Optional[str]] = MISSING,\n        position: Absent[Optional[int]] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n        ] = MISSING,\n        nsfw: bool = False,\n        rate_limit_per_user: int = 0,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"GuildText\":\n\"\"\"\n        Create a text channel in this guild within this category.\n\n        Args:\n            name: The name of the channel\n            topic: The topic of the channel\n            position: The position of the channel in the channel list\n            permission_overwrites: Permission overwrites to apply to the channel\n            nsfw: Should this channel be marked nsfw\n            rate_limit_per_user: The time users must wait between sending messages\n            reason: The reason for creating this channel\n\n        Returns:\n           The newly created text channel.\n\n        \"\"\"\n        return await self.create_channel(\n            channel_type=ChannelTypes.GUILD_TEXT,\n            name=name,\n            topic=topic,\n            position=position,\n            permission_overwrites=permission_overwrites,\n            nsfw=nsfw,\n            rate_limit_per_user=rate_limit_per_user,\n            reason=reason,\n        )\n\n    async def create_news_channel(\n        self,\n        name: str,\n        topic: Absent[Optional[str]] = MISSING,\n        position: Absent[Optional[int]] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n        ] = MISSING,\n        nsfw: bool = False,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"GuildNews\":\n\"\"\"\n        Create a news channel in this guild within this category.\n\n        Args:\n            name: The name of the channel\n            topic: The topic of the channel\n            position: The position of the channel in the channel list\n            permission_overwrites: Permission overwrites to apply to the channel\n            nsfw: Should this channel be marked nsfw\n            reason: The reason for creating this channel\n\n        Returns:\n           The newly created news channel.\n\n        \"\"\"\n        return await self.create_channel(\n            channel_type=ChannelTypes.GUILD_NEWS,\n            name=name,\n            topic=topic,\n            position=position,\n            permission_overwrites=permission_overwrites,\n            nsfw=nsfw,\n            reason=reason,\n        )\n\n    async def create_voice_channel(\n        self,\n        name: str,\n        topic: Absent[Optional[str]] = MISSING,\n        position: Absent[Optional[int]] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n        ] = MISSING,\n        nsfw: bool = False,\n        bitrate: int = 64000,\n        user_limit: int = 0,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"GuildVoice\":\n\"\"\"\n        Create a guild voice channel within this category.\n\n        Args:\n            name: The name of the channel\n            topic: The topic of the channel\n            position: The position of the channel in the channel list\n            permission_overwrites: Permission overwrites to apply to the channel\n            nsfw: Should this channel be marked nsfw\n            bitrate: The bitrate of this channel, only for voice\n            user_limit: The max users that can be in this channel, only for voice\n            reason: The reason for creating this channel\n\n        Returns:\n           The newly created voice channel.\n\n        \"\"\"\n        return await self.create_channel(\n            channel_type=ChannelTypes.GUILD_VOICE,\n            name=name,\n            topic=topic,\n            position=position,\n            permission_overwrites=permission_overwrites,\n            nsfw=nsfw,\n            bitrate=bitrate,\n            user_limit=user_limit,\n            reason=reason,\n        )\n\n    async def create_stage_channel(\n        self,\n        name: str,\n        topic: Absent[Optional[str]] = MISSING,\n        position: Absent[Optional[int]] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n        ] = MISSING,\n        bitrate: int = 64000,\n        user_limit: int = 0,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"GuildStageVoice\":\n\"\"\"\n        Create a guild stage channel within this category.\n\n        Args:\n            name: The name of the channel\n            topic: The topic of the channel\n            position: The position of the channel in the channel list\n            permission_overwrites: Permission overwrites to apply to the channel\n            bitrate: The bitrate of this channel, only for voice\n            user_limit: The max users that can be in this channel, only for voice\n            reason: The reason for creating this channel\n\n        Returns:\n            The newly created stage channel.\n\n        \"\"\"\n        return await self.create_channel(\n            channel_type=ChannelTypes.GUILD_STAGE_VOICE,\n            name=name,\n            topic=topic,\n            position=position,\n            permission_overwrites=permission_overwrites,\n            bitrate=bitrate,\n            user_limit=user_limit,\n            reason=reason,\n        )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildCategory.channels","title":"<code>channels: List[TYPE_GUILD_CHANNEL]</code>  <code>property</code>","text":"<p>Get all channels within the category</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildCategory.voice_channels","title":"<code>voice_channels: List[GuildVoice]</code>  <code>property</code>","text":"<p>Get all voice channels within the category</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildCategory.stage_channels","title":"<code>stage_channels: List[GuildStageVoice]</code>  <code>property</code>","text":"<p>Get all stage channels within the category</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildCategory.text_channels","title":"<code>text_channels: List[GuildText]</code>  <code>property</code>","text":"<p>Get all text channels within the category</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildCategory.news_channels","title":"<code>news_channels: List[GuildNews]</code>  <code>property</code>","text":"<p>Get all news channels within the category</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildCategory.edit","title":"<code>edit(*, name=MISSING, position=MISSING, permission_overwrites=MISSING, reason=MISSING, **kwargs)</code>  <code>async</code>","text":"<p>Edit this channel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[str]</code> <p>1-100 character channel name</p> <code>MISSING</code> <code>position</code> <code>Absent[int]</code> <p>the position of the channel in the left-hand listing</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>channel or category-specific permissions</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>the reason for this change</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildCategory</code> <p>The updated channel object.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: Absent[str] = MISSING,\n    position: Absent[int] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n    ] = MISSING,\n    reason: Absent[str] = MISSING,\n    **kwargs,\n) -&gt; \"GuildCategory\":\n\"\"\"\n    Edit this channel.\n\n    Args:\n        name: 1-100 character channel name\n        position: the position of the channel in the left-hand listing\n        permission_overwrites: channel or category-specific permissions\n        reason: the reason for this change\n\n    Returns:\n        The updated channel object.\n\n    \"\"\"\n    return await super().edit(\n        name=name,\n        position=position,\n        permission_overwrites=permission_overwrites,\n        reason=reason,\n        **kwargs,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildCategory.create_channel","title":"<code>create_channel(channel_type, name, topic=MISSING, position=MISSING, permission_overwrites=MISSING, nsfw=False, bitrate=64000, user_limit=0, rate_limit_per_user=0, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a guild channel within this category, allows for explicit channel type setting.</p> <p>Parameters:</p> Name Type Description Default <code>channel_type</code> <code>Union[ChannelTypes, int]</code> <p>The type of channel to create</p> required <code>name</code> <code>str</code> <p>The name of the channel</p> required <code>topic</code> <code>Absent[Optional[str]]</code> <p>The topic of the channel</p> <code>MISSING</code> <code>position</code> <code>Absent[Optional[int]]</code> <p>The position of the channel in the channel list</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>Permission overwrites to apply to the channel</p> <code>MISSING</code> <code>nsfw</code> <code>bool</code> <p>Should this channel be marked nsfw</p> <code>False</code> <code>bitrate</code> <code>int</code> <p>The bitrate of this channel, only for voice</p> <code>64000</code> <code>user_limit</code> <code>int</code> <p>The max users that can be in this channel, only for voice</p> <code>0</code> <code>rate_limit_per_user</code> <code>int</code> <p>The time users must wait between sending messages</p> <code>0</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for creating this channel</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>TYPE_GUILD_CHANNEL</code> <p>The newly created channel.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def create_channel(\n    self,\n    channel_type: Union[ChannelTypes, int],\n    name: str,\n    topic: Absent[Optional[str]] = MISSING,\n    position: Absent[Optional[int]] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n    ] = MISSING,\n    nsfw: bool = False,\n    bitrate: int = 64000,\n    user_limit: int = 0,\n    rate_limit_per_user: int = 0,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"TYPE_GUILD_CHANNEL\":\n\"\"\"\n    Create a guild channel within this category, allows for explicit channel type setting.\n\n    Args:\n        channel_type: The type of channel to create\n        name: The name of the channel\n        topic: The topic of the channel\n        position: The position of the channel in the channel list\n        permission_overwrites: Permission overwrites to apply to the channel\n        nsfw: Should this channel be marked nsfw\n        bitrate: The bitrate of this channel, only for voice\n        user_limit: The max users that can be in this channel, only for voice\n        rate_limit_per_user: The time users must wait between sending messages\n        reason: The reason for creating this channel\n\n    Returns:\n        The newly created channel.\n\n    \"\"\"\n    return await self.guild.create_channel(\n        channel_type=channel_type,\n        name=name,\n        topic=topic,\n        position=position,\n        permission_overwrites=permission_overwrites,\n        category=self.id,\n        nsfw=nsfw,\n        bitrate=bitrate,\n        user_limit=user_limit,\n        rate_limit_per_user=rate_limit_per_user,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildCategory.create_text_channel","title":"<code>create_text_channel(name, topic=MISSING, position=MISSING, permission_overwrites=MISSING, nsfw=False, rate_limit_per_user=0, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a text channel in this guild within this category.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the channel</p> required <code>topic</code> <code>Absent[Optional[str]]</code> <p>The topic of the channel</p> <code>MISSING</code> <code>position</code> <code>Absent[Optional[int]]</code> <p>The position of the channel in the channel list</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>Permission overwrites to apply to the channel</p> <code>MISSING</code> <code>nsfw</code> <code>bool</code> <p>Should this channel be marked nsfw</p> <code>False</code> <code>rate_limit_per_user</code> <code>int</code> <p>The time users must wait between sending messages</p> <code>0</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for creating this channel</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildText</code> <p>The newly created text channel.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def create_text_channel(\n    self,\n    name: str,\n    topic: Absent[Optional[str]] = MISSING,\n    position: Absent[Optional[int]] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n    ] = MISSING,\n    nsfw: bool = False,\n    rate_limit_per_user: int = 0,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"GuildText\":\n\"\"\"\n    Create a text channel in this guild within this category.\n\n    Args:\n        name: The name of the channel\n        topic: The topic of the channel\n        position: The position of the channel in the channel list\n        permission_overwrites: Permission overwrites to apply to the channel\n        nsfw: Should this channel be marked nsfw\n        rate_limit_per_user: The time users must wait between sending messages\n        reason: The reason for creating this channel\n\n    Returns:\n       The newly created text channel.\n\n    \"\"\"\n    return await self.create_channel(\n        channel_type=ChannelTypes.GUILD_TEXT,\n        name=name,\n        topic=topic,\n        position=position,\n        permission_overwrites=permission_overwrites,\n        nsfw=nsfw,\n        rate_limit_per_user=rate_limit_per_user,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildCategory.create_news_channel","title":"<code>create_news_channel(name, topic=MISSING, position=MISSING, permission_overwrites=MISSING, nsfw=False, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a news channel in this guild within this category.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the channel</p> required <code>topic</code> <code>Absent[Optional[str]]</code> <p>The topic of the channel</p> <code>MISSING</code> <code>position</code> <code>Absent[Optional[int]]</code> <p>The position of the channel in the channel list</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>Permission overwrites to apply to the channel</p> <code>MISSING</code> <code>nsfw</code> <code>bool</code> <p>Should this channel be marked nsfw</p> <code>False</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for creating this channel</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildNews</code> <p>The newly created news channel.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def create_news_channel(\n    self,\n    name: str,\n    topic: Absent[Optional[str]] = MISSING,\n    position: Absent[Optional[int]] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n    ] = MISSING,\n    nsfw: bool = False,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"GuildNews\":\n\"\"\"\n    Create a news channel in this guild within this category.\n\n    Args:\n        name: The name of the channel\n        topic: The topic of the channel\n        position: The position of the channel in the channel list\n        permission_overwrites: Permission overwrites to apply to the channel\n        nsfw: Should this channel be marked nsfw\n        reason: The reason for creating this channel\n\n    Returns:\n       The newly created news channel.\n\n    \"\"\"\n    return await self.create_channel(\n        channel_type=ChannelTypes.GUILD_NEWS,\n        name=name,\n        topic=topic,\n        position=position,\n        permission_overwrites=permission_overwrites,\n        nsfw=nsfw,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildCategory.create_voice_channel","title":"<code>create_voice_channel(name, topic=MISSING, position=MISSING, permission_overwrites=MISSING, nsfw=False, bitrate=64000, user_limit=0, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a guild voice channel within this category.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the channel</p> required <code>topic</code> <code>Absent[Optional[str]]</code> <p>The topic of the channel</p> <code>MISSING</code> <code>position</code> <code>Absent[Optional[int]]</code> <p>The position of the channel in the channel list</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>Permission overwrites to apply to the channel</p> <code>MISSING</code> <code>nsfw</code> <code>bool</code> <p>Should this channel be marked nsfw</p> <code>False</code> <code>bitrate</code> <code>int</code> <p>The bitrate of this channel, only for voice</p> <code>64000</code> <code>user_limit</code> <code>int</code> <p>The max users that can be in this channel, only for voice</p> <code>0</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for creating this channel</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildVoice</code> <p>The newly created voice channel.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def create_voice_channel(\n    self,\n    name: str,\n    topic: Absent[Optional[str]] = MISSING,\n    position: Absent[Optional[int]] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n    ] = MISSING,\n    nsfw: bool = False,\n    bitrate: int = 64000,\n    user_limit: int = 0,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"GuildVoice\":\n\"\"\"\n    Create a guild voice channel within this category.\n\n    Args:\n        name: The name of the channel\n        topic: The topic of the channel\n        position: The position of the channel in the channel list\n        permission_overwrites: Permission overwrites to apply to the channel\n        nsfw: Should this channel be marked nsfw\n        bitrate: The bitrate of this channel, only for voice\n        user_limit: The max users that can be in this channel, only for voice\n        reason: The reason for creating this channel\n\n    Returns:\n       The newly created voice channel.\n\n    \"\"\"\n    return await self.create_channel(\n        channel_type=ChannelTypes.GUILD_VOICE,\n        name=name,\n        topic=topic,\n        position=position,\n        permission_overwrites=permission_overwrites,\n        nsfw=nsfw,\n        bitrate=bitrate,\n        user_limit=user_limit,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildCategory.create_stage_channel","title":"<code>create_stage_channel(name, topic=MISSING, position=MISSING, permission_overwrites=MISSING, bitrate=64000, user_limit=0, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a guild stage channel within this category.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the channel</p> required <code>topic</code> <code>Absent[Optional[str]]</code> <p>The topic of the channel</p> <code>MISSING</code> <code>position</code> <code>Absent[Optional[int]]</code> <p>The position of the channel in the channel list</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>Permission overwrites to apply to the channel</p> <code>MISSING</code> <code>bitrate</code> <code>int</code> <p>The bitrate of this channel, only for voice</p> <code>64000</code> <code>user_limit</code> <code>int</code> <p>The max users that can be in this channel, only for voice</p> <code>0</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for creating this channel</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildStageVoice</code> <p>The newly created stage channel.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def create_stage_channel(\n    self,\n    name: str,\n    topic: Absent[Optional[str]] = MISSING,\n    position: Absent[Optional[int]] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n    ] = MISSING,\n    bitrate: int = 64000,\n    user_limit: int = 0,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"GuildStageVoice\":\n\"\"\"\n    Create a guild stage channel within this category.\n\n    Args:\n        name: The name of the channel\n        topic: The topic of the channel\n        position: The position of the channel in the channel list\n        permission_overwrites: Permission overwrites to apply to the channel\n        bitrate: The bitrate of this channel, only for voice\n        user_limit: The max users that can be in this channel, only for voice\n        reason: The reason for creating this channel\n\n    Returns:\n        The newly created stage channel.\n\n    \"\"\"\n    return await self.create_channel(\n        channel_type=ChannelTypes.GUILD_STAGE_VOICE,\n        name=name,\n        topic=topic,\n        position=position,\n        permission_overwrites=permission_overwrites,\n        bitrate=bitrate,\n        user_limit=user_limit,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildNews","title":"<code>GuildNews</code>","text":"<p>         Bases: <code>GuildChannel</code>, <code>MessageableMixin</code>, <code>InvitableMixin</code>, <code>ThreadableMixin</code>, <code>WebhookMixin</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass GuildNews(GuildChannel, MessageableMixin, InvitableMixin, ThreadableMixin, WebhookMixin):\n    topic: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The channel topic (0-1024 characters)\"\"\"\n\n    async def edit(\n        self,\n        *,\n        name: Absent[str] = MISSING,\n        position: Absent[int] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n        ] = MISSING,\n        parent_id: Absent[Snowflake_Type] = MISSING,\n        nsfw: Absent[bool] = MISSING,\n        topic: Absent[str] = MISSING,\n        channel_type: Absent[\"ChannelTypes\"] = MISSING,\n        default_auto_archive_duration: Absent[\"AutoArchiveDuration\"] = MISSING,\n        reason: Absent[str] = MISSING,\n        **kwargs,\n    ) -&gt; Union[\"GuildNews\", \"GuildText\"]:\n\"\"\"\n        Edit the guild text channel.\n\n        Args:\n            name: 1-100 character channel name\n            position: the position of the channel in the left-hand listing\n            permission_overwrites: a list of PermissionOverwrite\n            parent_id:  the parent category `Snowflake_Type` for the channel\n            nsfw: whether the channel is nsfw\n            topic: 0-1024 character channel topic\n            channel_type: the type of channel; only conversion between text and news is supported and only in guilds with the \"NEWS\" feature\n            default_auto_archive_duration: optional AutoArchiveDuration\n            reason: An optional reason for the audit log\n\n        Returns:\n            The edited channel.\n\n        \"\"\"\n        return await super().edit(\n            name=name,\n            position=position,\n            permission_overwrites=permission_overwrites,\n            parent_id=parent_id,\n            nsfw=nsfw,\n            topic=topic,\n            type=channel_type,\n            default_auto_archive_duration=default_auto_archive_duration,\n            reason=reason,\n            **kwargs,\n        )\n\n    async def follow(self, webhook_channel_id: Snowflake_Type) -&gt; None:\n\"\"\"\n        Follow this channel.\n\n        Args:\n            webhook_channel_id: The ID of the channel to post messages from this channel to\n\n        \"\"\"\n        await self._client.http.follow_news_channel(self.id, webhook_channel_id)\n\n    async def create_thread_from_message(\n        self,\n        name: str,\n        message: Snowflake_Type,\n        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,\n        reason: Absent[str] = None,\n    ) -&gt; \"GuildNewsThread\":\n\"\"\"\n        Creates a new news thread in this channel.\n\n        Args:\n            name: 1-100 character thread name.\n            message: The message to connect this thread to.\n            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.\n            reason: The reason for creating this thread.\n\n        Returns:\n            The created public thread, if successful\n\n        \"\"\"\n        return await self.create_thread(\n            name=name,\n            message=message,\n            auto_archive_duration=auto_archive_duration,\n            reason=reason,\n        )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildNews.topic","title":"<code>topic: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The channel topic (0-1024 characters)</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildNews.edit","title":"<code>edit(*, name=MISSING, position=MISSING, permission_overwrites=MISSING, parent_id=MISSING, nsfw=MISSING, topic=MISSING, channel_type=MISSING, default_auto_archive_duration=MISSING, reason=MISSING, **kwargs)</code>  <code>async</code>","text":"<p>Edit the guild text channel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[str]</code> <p>1-100 character channel name</p> <code>MISSING</code> <code>position</code> <code>Absent[int]</code> <p>the position of the channel in the left-hand listing</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>a list of PermissionOverwrite</p> <code>MISSING</code> <code>parent_id</code> <code>Absent[Snowflake_Type]</code> <p>the parent category <code>Snowflake_Type</code> for the channel</p> <code>MISSING</code> <code>nsfw</code> <code>Absent[bool]</code> <p>whether the channel is nsfw</p> <code>MISSING</code> <code>topic</code> <code>Absent[str]</code> <p>0-1024 character channel topic</p> <code>MISSING</code> <code>channel_type</code> <code>Absent[ChannelTypes]</code> <p>the type of channel; only conversion between text and news is supported and only in guilds with the \"NEWS\" feature</p> <code>MISSING</code> <code>default_auto_archive_duration</code> <code>Absent[AutoArchiveDuration]</code> <p>optional AutoArchiveDuration</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>An optional reason for the audit log</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Union[GuildNews, GuildText]</code> <p>The edited channel.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: Absent[str] = MISSING,\n    position: Absent[int] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n    ] = MISSING,\n    parent_id: Absent[Snowflake_Type] = MISSING,\n    nsfw: Absent[bool] = MISSING,\n    topic: Absent[str] = MISSING,\n    channel_type: Absent[\"ChannelTypes\"] = MISSING,\n    default_auto_archive_duration: Absent[\"AutoArchiveDuration\"] = MISSING,\n    reason: Absent[str] = MISSING,\n    **kwargs,\n) -&gt; Union[\"GuildNews\", \"GuildText\"]:\n\"\"\"\n    Edit the guild text channel.\n\n    Args:\n        name: 1-100 character channel name\n        position: the position of the channel in the left-hand listing\n        permission_overwrites: a list of PermissionOverwrite\n        parent_id:  the parent category `Snowflake_Type` for the channel\n        nsfw: whether the channel is nsfw\n        topic: 0-1024 character channel topic\n        channel_type: the type of channel; only conversion between text and news is supported and only in guilds with the \"NEWS\" feature\n        default_auto_archive_duration: optional AutoArchiveDuration\n        reason: An optional reason for the audit log\n\n    Returns:\n        The edited channel.\n\n    \"\"\"\n    return await super().edit(\n        name=name,\n        position=position,\n        permission_overwrites=permission_overwrites,\n        parent_id=parent_id,\n        nsfw=nsfw,\n        topic=topic,\n        type=channel_type,\n        default_auto_archive_duration=default_auto_archive_duration,\n        reason=reason,\n        **kwargs,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildNews.follow","title":"<code>follow(webhook_channel_id)</code>  <code>async</code>","text":"<p>Follow this channel.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel to post messages from this channel to</p> required Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def follow(self, webhook_channel_id: Snowflake_Type) -&gt; None:\n\"\"\"\n    Follow this channel.\n\n    Args:\n        webhook_channel_id: The ID of the channel to post messages from this channel to\n\n    \"\"\"\n    await self._client.http.follow_news_channel(self.id, webhook_channel_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildNews.create_thread_from_message","title":"<code>create_thread_from_message(name, message, auto_archive_duration=AutoArchiveDuration.ONE_DAY, reason=None)</code>  <code>async</code>","text":"<p>Creates a new news thread in this channel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>1-100 character thread name.</p> required <code>message</code> <code>Snowflake_Type</code> <p>The message to connect this thread to.</p> required <code>auto_archive_duration</code> <code>AutoArchiveDuration</code> <p>Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.</p> <code>AutoArchiveDuration.ONE_DAY</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for creating this thread.</p> <code>None</code> <p>Returns:</p> Type Description <code>GuildNewsThread</code> <p>The created public thread, if successful</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def create_thread_from_message(\n    self,\n    name: str,\n    message: Snowflake_Type,\n    auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,\n    reason: Absent[str] = None,\n) -&gt; \"GuildNewsThread\":\n\"\"\"\n    Creates a new news thread in this channel.\n\n    Args:\n        name: 1-100 character thread name.\n        message: The message to connect this thread to.\n        auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.\n        reason: The reason for creating this thread.\n\n    Returns:\n        The created public thread, if successful\n\n    \"\"\"\n    return await self.create_thread(\n        name=name,\n        message=message,\n        auto_archive_duration=auto_archive_duration,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildText","title":"<code>GuildText</code>","text":"<p>         Bases: <code>GuildChannel</code>, <code>MessageableMixin</code>, <code>InvitableMixin</code>, <code>ThreadableMixin</code>, <code>WebhookMixin</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass GuildText(GuildChannel, MessageableMixin, InvitableMixin, ThreadableMixin, WebhookMixin):\n    topic: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The channel topic (0-1024 characters)\"\"\"\n    rate_limit_per_user: int = attrs.field(repr=False, default=0)\n\"\"\"Amount of seconds a user has to wait before sending another message (0-21600)\"\"\"\n\n    async def edit(\n        self,\n        *,\n        name: Absent[str] = MISSING,\n        position: Absent[int] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n        ] = MISSING,\n        parent_id: Absent[Snowflake_Type] = MISSING,\n        nsfw: Absent[bool] = MISSING,\n        topic: Absent[str] = MISSING,\n        channel_type: Absent[\"ChannelTypes\"] = MISSING,\n        default_auto_archive_duration: Absent[\"AutoArchiveDuration\"] = MISSING,\n        rate_limit_per_user: Absent[int] = MISSING,\n        reason: Absent[str] = MISSING,\n        **kwargs,\n    ) -&gt; Union[\"GuildText\", \"GuildNews\"]:\n\"\"\"\n        Edit the guild text channel.\n\n        Args:\n            name: 1-100 character channel name\n            position: the position of the channel in the left-hand listing\n            permission_overwrites: a list of PermissionOverwrite\n            parent_id:  the parent category `Snowflake_Type` for the channel\n            nsfw: whether the channel is nsfw\n            topic: 0-1024 character channel topic\n            channel_type: the type of channel; only conversion between text and news is supported and only in guilds with the \"NEWS\" feature\n            default_auto_archive_duration: optional AutoArchiveDuration\n            rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)\n            reason: An optional reason for the audit log\n\n        Returns:\n            The edited channel.\n\n        \"\"\"\n        return await super().edit(\n            name=name,\n            position=position,\n            permission_overwrites=permission_overwrites,\n            parent_id=parent_id,\n            nsfw=nsfw,\n            topic=topic,\n            type=channel_type,\n            default_auto_archive_duration=default_auto_archive_duration,\n            rate_limit_per_user=rate_limit_per_user,\n            reason=reason,\n            **kwargs,\n        )\n\n    async def create_public_thread(\n        self,\n        name: str,\n        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,\n        reason: Absent[str] = None,\n    ) -&gt; \"GuildPublicThread\":\n\"\"\"\n        Creates a new public thread in this channel.\n\n        Args:\n            name: 1-100 character thread name.\n            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.\n            reason: The reason for creating this thread.\n\n        Returns:\n            The created public thread, if successful\n\n        \"\"\"\n        return await self.create_thread(\n            name=name,\n            thread_type=ChannelTypes.GUILD_PUBLIC_THREAD,\n            auto_archive_duration=auto_archive_duration,\n            reason=reason,\n        )\n\n    async def create_private_thread(\n        self,\n        name: str,\n        invitable: Absent[bool] = MISSING,\n        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,\n        reason: Absent[str] = None,\n    ) -&gt; \"GuildPrivateThread\":\n\"\"\"\n        Creates a new private thread in this channel.\n\n        Args:\n            name: 1-100 character thread name.\n            invitable: whether non-moderators can add other non-moderators to a thread.\n            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.\n            reason: The reason for creating this thread.\n\n        Returns:\n            The created thread, if successful\n\n        \"\"\"\n        return await self.create_thread(\n            name=name,\n            thread_type=ChannelTypes.GUILD_PRIVATE_THREAD,\n            invitable=invitable,\n            auto_archive_duration=auto_archive_duration,\n            reason=reason,\n        )\n\n    async def create_thread_from_message(\n        self,\n        name: str,\n        message: Snowflake_Type,\n        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,\n        reason: Absent[str] = None,\n    ) -&gt; \"GuildPublicThread\":\n\"\"\"\n        Creates a new public thread in this channel.\n\n        Args:\n            name: 1-100 character thread name.\n            message: The message to connect this thread to.\n            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.\n            reason: The reason for creating this thread.\n\n        Returns:\n            The created public thread, if successful\n\n        \"\"\"\n        return await self.create_thread(\n            name=name,\n            message=message,\n            auto_archive_duration=auto_archive_duration,\n            reason=reason,\n        )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildText.topic","title":"<code>topic: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The channel topic (0-1024 characters)</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildText.rate_limit_per_user","title":"<code>rate_limit_per_user: int = attrs.field(repr=False, default=0)</code>  <code>class-attribute</code>","text":"<p>Amount of seconds a user has to wait before sending another message (0-21600)</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildText.edit","title":"<code>edit(*, name=MISSING, position=MISSING, permission_overwrites=MISSING, parent_id=MISSING, nsfw=MISSING, topic=MISSING, channel_type=MISSING, default_auto_archive_duration=MISSING, rate_limit_per_user=MISSING, reason=MISSING, **kwargs)</code>  <code>async</code>","text":"<p>Edit the guild text channel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[str]</code> <p>1-100 character channel name</p> <code>MISSING</code> <code>position</code> <code>Absent[int]</code> <p>the position of the channel in the left-hand listing</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>a list of PermissionOverwrite</p> <code>MISSING</code> <code>parent_id</code> <code>Absent[Snowflake_Type]</code> <p>the parent category <code>Snowflake_Type</code> for the channel</p> <code>MISSING</code> <code>nsfw</code> <code>Absent[bool]</code> <p>whether the channel is nsfw</p> <code>MISSING</code> <code>topic</code> <code>Absent[str]</code> <p>0-1024 character channel topic</p> <code>MISSING</code> <code>channel_type</code> <code>Absent[ChannelTypes]</code> <p>the type of channel; only conversion between text and news is supported and only in guilds with the \"NEWS\" feature</p> <code>MISSING</code> <code>default_auto_archive_duration</code> <code>Absent[AutoArchiveDuration]</code> <p>optional AutoArchiveDuration</p> <code>MISSING</code> <code>rate_limit_per_user</code> <code>Absent[int]</code> <p>amount of seconds a user has to wait before sending another message (0-21600)</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>An optional reason for the audit log</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Union[GuildText, GuildNews]</code> <p>The edited channel.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: Absent[str] = MISSING,\n    position: Absent[int] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n    ] = MISSING,\n    parent_id: Absent[Snowflake_Type] = MISSING,\n    nsfw: Absent[bool] = MISSING,\n    topic: Absent[str] = MISSING,\n    channel_type: Absent[\"ChannelTypes\"] = MISSING,\n    default_auto_archive_duration: Absent[\"AutoArchiveDuration\"] = MISSING,\n    rate_limit_per_user: Absent[int] = MISSING,\n    reason: Absent[str] = MISSING,\n    **kwargs,\n) -&gt; Union[\"GuildText\", \"GuildNews\"]:\n\"\"\"\n    Edit the guild text channel.\n\n    Args:\n        name: 1-100 character channel name\n        position: the position of the channel in the left-hand listing\n        permission_overwrites: a list of PermissionOverwrite\n        parent_id:  the parent category `Snowflake_Type` for the channel\n        nsfw: whether the channel is nsfw\n        topic: 0-1024 character channel topic\n        channel_type: the type of channel; only conversion between text and news is supported and only in guilds with the \"NEWS\" feature\n        default_auto_archive_duration: optional AutoArchiveDuration\n        rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)\n        reason: An optional reason for the audit log\n\n    Returns:\n        The edited channel.\n\n    \"\"\"\n    return await super().edit(\n        name=name,\n        position=position,\n        permission_overwrites=permission_overwrites,\n        parent_id=parent_id,\n        nsfw=nsfw,\n        topic=topic,\n        type=channel_type,\n        default_auto_archive_duration=default_auto_archive_duration,\n        rate_limit_per_user=rate_limit_per_user,\n        reason=reason,\n        **kwargs,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildText.create_public_thread","title":"<code>create_public_thread(name, auto_archive_duration=AutoArchiveDuration.ONE_DAY, reason=None)</code>  <code>async</code>","text":"<p>Creates a new public thread in this channel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>1-100 character thread name.</p> required <code>auto_archive_duration</code> <code>AutoArchiveDuration</code> <p>Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.</p> <code>AutoArchiveDuration.ONE_DAY</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for creating this thread.</p> <code>None</code> <p>Returns:</p> Type Description <code>GuildPublicThread</code> <p>The created public thread, if successful</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def create_public_thread(\n    self,\n    name: str,\n    auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,\n    reason: Absent[str] = None,\n) -&gt; \"GuildPublicThread\":\n\"\"\"\n    Creates a new public thread in this channel.\n\n    Args:\n        name: 1-100 character thread name.\n        auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.\n        reason: The reason for creating this thread.\n\n    Returns:\n        The created public thread, if successful\n\n    \"\"\"\n    return await self.create_thread(\n        name=name,\n        thread_type=ChannelTypes.GUILD_PUBLIC_THREAD,\n        auto_archive_duration=auto_archive_duration,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildText.create_private_thread","title":"<code>create_private_thread(name, invitable=MISSING, auto_archive_duration=AutoArchiveDuration.ONE_DAY, reason=None)</code>  <code>async</code>","text":"<p>Creates a new private thread in this channel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>1-100 character thread name.</p> required <code>invitable</code> <code>Absent[bool]</code> <p>whether non-moderators can add other non-moderators to a thread.</p> <code>MISSING</code> <code>auto_archive_duration</code> <code>AutoArchiveDuration</code> <p>Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.</p> <code>AutoArchiveDuration.ONE_DAY</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for creating this thread.</p> <code>None</code> <p>Returns:</p> Type Description <code>GuildPrivateThread</code> <p>The created thread, if successful</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def create_private_thread(\n    self,\n    name: str,\n    invitable: Absent[bool] = MISSING,\n    auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,\n    reason: Absent[str] = None,\n) -&gt; \"GuildPrivateThread\":\n\"\"\"\n    Creates a new private thread in this channel.\n\n    Args:\n        name: 1-100 character thread name.\n        invitable: whether non-moderators can add other non-moderators to a thread.\n        auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.\n        reason: The reason for creating this thread.\n\n    Returns:\n        The created thread, if successful\n\n    \"\"\"\n    return await self.create_thread(\n        name=name,\n        thread_type=ChannelTypes.GUILD_PRIVATE_THREAD,\n        invitable=invitable,\n        auto_archive_duration=auto_archive_duration,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildText.create_thread_from_message","title":"<code>create_thread_from_message(name, message, auto_archive_duration=AutoArchiveDuration.ONE_DAY, reason=None)</code>  <code>async</code>","text":"<p>Creates a new public thread in this channel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>1-100 character thread name.</p> required <code>message</code> <code>Snowflake_Type</code> <p>The message to connect this thread to.</p> required <code>auto_archive_duration</code> <code>AutoArchiveDuration</code> <p>Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.</p> <code>AutoArchiveDuration.ONE_DAY</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for creating this thread.</p> <code>None</code> <p>Returns:</p> Type Description <code>GuildPublicThread</code> <p>The created public thread, if successful</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def create_thread_from_message(\n    self,\n    name: str,\n    message: Snowflake_Type,\n    auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,\n    reason: Absent[str] = None,\n) -&gt; \"GuildPublicThread\":\n\"\"\"\n    Creates a new public thread in this channel.\n\n    Args:\n        name: 1-100 character thread name.\n        message: The message to connect this thread to.\n        auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.\n        reason: The reason for creating this thread.\n\n    Returns:\n        The created public thread, if successful\n\n    \"\"\"\n    return await self.create_thread(\n        name=name,\n        message=message,\n        auto_archive_duration=auto_archive_duration,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel","title":"<code>ThreadChannel</code>","text":"<p>         Bases: <code>BaseChannel</code>, <code>MessageableMixin</code>, <code>WebhookMixin</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)\nclass ThreadChannel(BaseChannel, MessageableMixin, WebhookMixin):\n    parent_id: Snowflake_Type = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))\n\"\"\"id of the text channel this thread was created\"\"\"\n    owner_id: Snowflake_Type = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))\n\"\"\"id of the creator of the thread\"\"\"\n    topic: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The thread topic (0-1024 characters)\"\"\"\n    message_count: int = attrs.field(repr=False, default=0)\n\"\"\"An approximate count of messages in a thread, stops counting at 50\"\"\"\n    member_count: int = attrs.field(repr=False, default=0)\n\"\"\"An approximate count of users in a thread, stops counting at 50\"\"\"\n    archived: bool = attrs.field(repr=False, default=False)\n\"\"\"Whether the thread is archived\"\"\"\n    auto_archive_duration: int = attrs.field(\n        repr=False, default=attrs.Factory(lambda self: self.default_auto_archive_duration, takes_self=True)\n    )\n\"\"\"Duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\"\"\"\n    locked: bool = attrs.field(repr=False, default=False)\n\"\"\"Whether the thread is locked\"\"\"\n    archive_timestamp: Optional[\"models.Timestamp\"] = attrs.field(\n        repr=False, default=None, converter=optional_c(timestamp_converter)\n    )\n\"\"\"Timestamp when the thread's archive status was last changed, used for calculating recent activity\"\"\"\n    create_timestamp: Optional[\"models.Timestamp\"] = attrs.field(\n        repr=False, default=None, converter=optional_c(timestamp_converter)\n    )\n\"\"\"Timestamp when the thread was created\"\"\"\n    flags: ChannelFlags = attrs.field(repr=False, default=ChannelFlags.NONE, converter=ChannelFlags)\n\"\"\"Flags for the thread\"\"\"\n\n    _guild_id: Snowflake_Type = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        data = super()._process_dict(data, client)\n        thread_metadata: dict = data.get(\"thread_metadata\", {})\n        data.update(thread_metadata)\n        return data\n\n    @property\n    def is_private(self) -&gt; bool:\n\"\"\"Is this a private thread?\"\"\"\n        return self.type == ChannelTypes.GUILD_PRIVATE_THREAD\n\n    @property\n    def guild(self) -&gt; \"models.Guild\":\n\"\"\"The guild this channel belongs to.\"\"\"\n        return self._client.cache.get_guild(self._guild_id)\n\n    @property\n    def parent_channel(self) -&gt; Union[GuildText, \"GuildForum\"]:\n\"\"\"The channel this thread is a child of.\"\"\"\n        return self._client.cache.get_channel(self.parent_id)\n\n    @property\n    def parent_message(self) -&gt; Optional[\"Message\"]:\n\"\"\"The message this thread is a child of.\"\"\"\n        return self._client.cache.get_message(self.parent_id, self.id)\n\n    @property\n    def mention(self) -&gt; str:\n\"\"\"Returns a string that would mention this thread.\"\"\"\n        return f\"&lt;#{self.id}&gt;\"\n\n    @property\n    def permission_overwrites(self) -&gt; List[\"PermissionOverwrite\"]:\n\"\"\"The permission overwrites for this channel.\"\"\"\n        return []\n\n    def permissions_for(self, instance: Snowflake_Type) -&gt; Permissions:\n\"\"\"\n        Calculates permissions for an instance\n\n        Args:\n            instance: Member or Role instance (or its ID)\n\n        Returns:\n            Permissions data\n\n        Raises:\n            ValueError: If could not find any member or role by given ID\n            RuntimeError: If given instance is from another guild\n\n        \"\"\"\n        if self.parent_channel:\n            return self.parent_channel.permissions_for(instance)\n        return Permissions.NONE\n\n    async def fetch_members(self) -&gt; List[\"models.ThreadMember\"]:\n\"\"\"Get the members that have access to this thread.\"\"\"\n        members_data = await self._client.http.list_thread_members(self.id)\n        return models.ThreadMember.from_list(members_data, self._client)\n\n    async def add_member(self, member: Union[\"models.Member\", Snowflake_Type]) -&gt; None:\n\"\"\"\n        Add a member to this thread.\n\n        Args:\n            member: The member to add\n\n        \"\"\"\n        await self._client.http.add_thread_member(self.id, to_snowflake(member))\n\n    async def remove_member(self, member: Union[\"models.Member\", Snowflake_Type]) -&gt; None:\n\"\"\"\n        Remove a member from this thread.\n\n        Args:\n            member: The member to remove\n\n        \"\"\"\n        await self._client.http.remove_thread_member(self.id, to_snowflake(member))\n\n    async def join(self) -&gt; None:\n\"\"\"Join this thread.\"\"\"\n        await self._client.http.join_thread(self.id)\n\n    async def leave(self) -&gt; None:\n\"\"\"Leave this thread.\"\"\"\n        await self._client.http.leave_thread(self.id)\n\n    async def archive(self, locked: bool = False, reason: Absent[str] = MISSING) -&gt; \"TYPE_THREAD_CHANNEL\":\n\"\"\"\n        Helper method to archive this thread.\n\n        Args:\n            locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it\n            reason: The reason for this archive\n\n        Returns:\n            The archived thread channel object.\n\n        \"\"\"\n        return await super().edit(locked=locked, archived=True, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.parent_id","title":"<code>parent_id: Snowflake_Type = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))</code>  <code>class-attribute</code>","text":"<p>id of the text channel this thread was created</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.owner_id","title":"<code>owner_id: Snowflake_Type = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))</code>  <code>class-attribute</code>","text":"<p>id of the creator of the thread</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.topic","title":"<code>topic: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The thread topic (0-1024 characters)</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.message_count","title":"<code>message_count: int = attrs.field(repr=False, default=0)</code>  <code>class-attribute</code>","text":"<p>An approximate count of messages in a thread, stops counting at 50</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.member_count","title":"<code>member_count: int = attrs.field(repr=False, default=0)</code>  <code>class-attribute</code>","text":"<p>An approximate count of users in a thread, stops counting at 50</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.archived","title":"<code>archived: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>Whether the thread is archived</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.auto_archive_duration","title":"<code>auto_archive_duration: int = attrs.field(repr=False, default=attrs.Factory(lambda self: self.default_auto_archive_duration, takes_self=True))</code>  <code>class-attribute</code>","text":"<p>Duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.locked","title":"<code>locked: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>Whether the thread is locked</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.archive_timestamp","title":"<code>archive_timestamp: Optional[models.Timestamp] = attrs.field(repr=False, default=None, converter=optional_c(timestamp_converter))</code>  <code>class-attribute</code>","text":"<p>Timestamp when the thread's archive status was last changed, used for calculating recent activity</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.create_timestamp","title":"<code>create_timestamp: Optional[models.Timestamp] = attrs.field(repr=False, default=None, converter=optional_c(timestamp_converter))</code>  <code>class-attribute</code>","text":"<p>Timestamp when the thread was created</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.flags","title":"<code>flags: ChannelFlags = attrs.field(repr=False, default=ChannelFlags.NONE, converter=ChannelFlags)</code>  <code>class-attribute</code>","text":"<p>Flags for the thread</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.is_private","title":"<code>is_private: bool</code>  <code>property</code>","text":"<p>Is this a private thread?</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.guild","title":"<code>guild: models.Guild</code>  <code>property</code>","text":"<p>The guild this channel belongs to.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.parent_channel","title":"<code>parent_channel: Union[GuildText, GuildForum]</code>  <code>property</code>","text":"<p>The channel this thread is a child of.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.parent_message","title":"<code>parent_message: Optional[Message]</code>  <code>property</code>","text":"<p>The message this thread is a child of.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.mention","title":"<code>mention: str</code>  <code>property</code>","text":"<p>Returns a string that would mention this thread.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.permission_overwrites","title":"<code>permission_overwrites: List[PermissionOverwrite]</code>  <code>property</code>","text":"<p>The permission overwrites for this channel.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.permissions_for","title":"<code>permissions_for(instance)</code>","text":"<p>Calculates permissions for an instance</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Snowflake_Type</code> <p>Member or Role instance (or its ID)</p> required <p>Returns:</p> Type Description <code>Permissions</code> <p>Permissions data</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If could not find any member or role by given ID</p> <code>RuntimeError</code> <p>If given instance is from another guild</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>def permissions_for(self, instance: Snowflake_Type) -&gt; Permissions:\n\"\"\"\n    Calculates permissions for an instance\n\n    Args:\n        instance: Member or Role instance (or its ID)\n\n    Returns:\n        Permissions data\n\n    Raises:\n        ValueError: If could not find any member or role by given ID\n        RuntimeError: If given instance is from another guild\n\n    \"\"\"\n    if self.parent_channel:\n        return self.parent_channel.permissions_for(instance)\n    return Permissions.NONE\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.fetch_members","title":"<code>fetch_members()</code>  <code>async</code>","text":"<p>Get the members that have access to this thread.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_members(self) -&gt; List[\"models.ThreadMember\"]:\n\"\"\"Get the members that have access to this thread.\"\"\"\n    members_data = await self._client.http.list_thread_members(self.id)\n    return models.ThreadMember.from_list(members_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.add_member","title":"<code>add_member(member)</code>  <code>async</code>","text":"<p>Add a member to this thread.</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>Union[Member, Snowflake_Type]</code> <p>The member to add</p> required Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def add_member(self, member: Union[\"models.Member\", Snowflake_Type]) -&gt; None:\n\"\"\"\n    Add a member to this thread.\n\n    Args:\n        member: The member to add\n\n    \"\"\"\n    await self._client.http.add_thread_member(self.id, to_snowflake(member))\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.remove_member","title":"<code>remove_member(member)</code>  <code>async</code>","text":"<p>Remove a member from this thread.</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>Union[Member, Snowflake_Type]</code> <p>The member to remove</p> required Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def remove_member(self, member: Union[\"models.Member\", Snowflake_Type]) -&gt; None:\n\"\"\"\n    Remove a member from this thread.\n\n    Args:\n        member: The member to remove\n\n    \"\"\"\n    await self._client.http.remove_thread_member(self.id, to_snowflake(member))\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.join","title":"<code>join()</code>  <code>async</code>","text":"<p>Join this thread.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def join(self) -&gt; None:\n\"\"\"Join this thread.\"\"\"\n    await self._client.http.join_thread(self.id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.leave","title":"<code>leave()</code>  <code>async</code>","text":"<p>Leave this thread.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def leave(self) -&gt; None:\n\"\"\"Leave this thread.\"\"\"\n    await self._client.http.leave_thread(self.id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.ThreadChannel.archive","title":"<code>archive(locked=False, reason=MISSING)</code>  <code>async</code>","text":"<p>Helper method to archive this thread.</p> <p>Parameters:</p> Name Type Description Default <code>locked</code> <code>bool</code> <p>whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it</p> <code>False</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for this archive</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>TYPE_THREAD_CHANNEL</code> <p>The archived thread channel object.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def archive(self, locked: bool = False, reason: Absent[str] = MISSING) -&gt; \"TYPE_THREAD_CHANNEL\":\n\"\"\"\n    Helper method to archive this thread.\n\n    Args:\n        locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it\n        reason: The reason for this archive\n\n    Returns:\n        The archived thread channel object.\n\n    \"\"\"\n    return await super().edit(locked=locked, archived=True, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildNewsThread","title":"<code>GuildNewsThread</code>","text":"<p>         Bases: <code>ThreadChannel</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass GuildNewsThread(ThreadChannel):\n    async def edit(\n        self,\n        *,\n        name: Absent[str] = MISSING,\n        archived: Absent[bool] = MISSING,\n        auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,\n        locked: Absent[bool] = MISSING,\n        rate_limit_per_user: Absent[int] = MISSING,\n        reason: Absent[str] = MISSING,\n        **kwargs,\n    ) -&gt; \"GuildNewsThread\":\n\"\"\"\n        Edit this thread.\n\n        Args:\n            name: 1-100 character channel name\n            archived: whether the thread is archived\n            auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\n            locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it\n            rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)\n            reason: The reason for this change\n\n        Returns:\n            The edited thread channel object.\n\n        \"\"\"\n        return await super().edit(\n            name=name,\n            archived=archived,\n            auto_archive_duration=auto_archive_duration,\n            locked=locked,\n            rate_limit_per_user=rate_limit_per_user,\n            reason=reason,\n            **kwargs,\n        )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildNewsThread.edit","title":"<code>edit(*, name=MISSING, archived=MISSING, auto_archive_duration=MISSING, locked=MISSING, rate_limit_per_user=MISSING, reason=MISSING, **kwargs)</code>  <code>async</code>","text":"<p>Edit this thread.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[str]</code> <p>1-100 character channel name</p> <code>MISSING</code> <code>archived</code> <code>Absent[bool]</code> <p>whether the thread is archived</p> <code>MISSING</code> <code>auto_archive_duration</code> <code>Absent[AutoArchiveDuration]</code> <p>duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080</p> <code>MISSING</code> <code>locked</code> <code>Absent[bool]</code> <p>whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it</p> <code>MISSING</code> <code>rate_limit_per_user</code> <code>Absent[int]</code> <p>amount of seconds a user has to wait before sending another message (0-21600)</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for this change</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildNewsThread</code> <p>The edited thread channel object.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: Absent[str] = MISSING,\n    archived: Absent[bool] = MISSING,\n    auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,\n    locked: Absent[bool] = MISSING,\n    rate_limit_per_user: Absent[int] = MISSING,\n    reason: Absent[str] = MISSING,\n    **kwargs,\n) -&gt; \"GuildNewsThread\":\n\"\"\"\n    Edit this thread.\n\n    Args:\n        name: 1-100 character channel name\n        archived: whether the thread is archived\n        auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\n        locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it\n        rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)\n        reason: The reason for this change\n\n    Returns:\n        The edited thread channel object.\n\n    \"\"\"\n    return await super().edit(\n        name=name,\n        archived=archived,\n        auto_archive_duration=auto_archive_duration,\n        locked=locked,\n        rate_limit_per_user=rate_limit_per_user,\n        reason=reason,\n        **kwargs,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildPublicThread","title":"<code>GuildPublicThread</code>","text":"<p>         Bases: <code>ThreadChannel</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass GuildPublicThread(ThreadChannel):\n    async def edit(\n        self,\n        *,\n        name: Absent[str] = MISSING,\n        archived: Absent[bool] = MISSING,\n        auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,\n        locked: Absent[bool] = MISSING,\n        rate_limit_per_user: Absent[int] = MISSING,\n        flags: Absent[Union[int, ChannelFlags]] = MISSING,\n        reason: Absent[str] = MISSING,\n        **kwargs,\n    ) -&gt; \"GuildPublicThread\":\n\"\"\"\n        Edit this thread.\n\n        Args:\n            name: 1-100 character channel name\n            archived: whether the thread is archived\n            auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\n            locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it\n            rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)\n            flags: channel flags for forum threads\n            reason: The reason for this change\n\n        Returns:\n            The edited thread channel object.\n        \"\"\"\n        return await super().edit(\n            name=name,\n            archived=archived,\n            auto_archive_duration=auto_archive_duration,\n            locked=locked,\n            rate_limit_per_user=rate_limit_per_user,\n            reason=reason,\n            flags=flags,\n            **kwargs,\n        )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildPublicThread.edit","title":"<code>edit(*, name=MISSING, archived=MISSING, auto_archive_duration=MISSING, locked=MISSING, rate_limit_per_user=MISSING, flags=MISSING, reason=MISSING, **kwargs)</code>  <code>async</code>","text":"<p>Edit this thread.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[str]</code> <p>1-100 character channel name</p> <code>MISSING</code> <code>archived</code> <code>Absent[bool]</code> <p>whether the thread is archived</p> <code>MISSING</code> <code>auto_archive_duration</code> <code>Absent[AutoArchiveDuration]</code> <p>duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080</p> <code>MISSING</code> <code>locked</code> <code>Absent[bool]</code> <p>whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it</p> <code>MISSING</code> <code>rate_limit_per_user</code> <code>Absent[int]</code> <p>amount of seconds a user has to wait before sending another message (0-21600)</p> <code>MISSING</code> <code>flags</code> <code>Absent[Union[int, ChannelFlags]]</code> <p>channel flags for forum threads</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for this change</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildPublicThread</code> <p>The edited thread channel object.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: Absent[str] = MISSING,\n    archived: Absent[bool] = MISSING,\n    auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,\n    locked: Absent[bool] = MISSING,\n    rate_limit_per_user: Absent[int] = MISSING,\n    flags: Absent[Union[int, ChannelFlags]] = MISSING,\n    reason: Absent[str] = MISSING,\n    **kwargs,\n) -&gt; \"GuildPublicThread\":\n\"\"\"\n    Edit this thread.\n\n    Args:\n        name: 1-100 character channel name\n        archived: whether the thread is archived\n        auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\n        locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it\n        rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)\n        flags: channel flags for forum threads\n        reason: The reason for this change\n\n    Returns:\n        The edited thread channel object.\n    \"\"\"\n    return await super().edit(\n        name=name,\n        archived=archived,\n        auto_archive_duration=auto_archive_duration,\n        locked=locked,\n        rate_limit_per_user=rate_limit_per_user,\n        reason=reason,\n        flags=flags,\n        **kwargs,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForumPost","title":"<code>GuildForumPost</code>","text":"<p>         Bases: <code>GuildPublicThread</code></p> <p>A forum post</p> <p>Note</p> <p>This model is an abstraction of the api - In reality all posts are GuildPublicThread</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass GuildForumPost(GuildPublicThread):\n\"\"\"\n    A forum post\n\n    !!! note\n        This model is an abstraction of the api - In reality all posts are GuildPublicThread\n    \"\"\"\n\n    _applied_tags: list[Snowflake_Type] = attrs.field(repr=False, factory=list)\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        data = super()._process_dict(data, client)\n        data[\"_applied_tags\"] = data.pop(\"applied_tags\") if \"applied_tags\" in data else []\n        return data\n\n    async def edit(\n        self,\n        *,\n        name: Absent[str] = MISSING,\n        archived: Absent[bool] = MISSING,\n        auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,\n        applied_tags: Absent[List[Union[Snowflake_Type, ThreadTag]]] = MISSING,\n        locked: Absent[bool] = MISSING,\n        rate_limit_per_user: Absent[int] = MISSING,\n        flags: Absent[Union[int, ChannelFlags]] = MISSING,\n        reason: Absent[str] = MISSING,\n        **kwargs,\n    ) -&gt; \"GuildForumPost\":\n\"\"\"\n        Edit this thread.\n\n        Args:\n            name: 1-100 character channel name\n            archived: whether the thread is archived\n            applied_tags: list of tags to apply\n            auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\n            locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it\n            rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)\n            flags: channel flags to apply\n            reason: The reason for this change\n\n        Returns:\n            The edited thread channel object.\n        \"\"\"\n        if applied_tags != MISSING:\n            applied_tags = [str(tag.id) if isinstance(tag, ThreadTag) else str(tag) for tag in applied_tags]\n\n        return await super().edit(\n            name=name,\n            archived=archived,\n            auto_archive_duration=auto_archive_duration,\n            applied_tags=applied_tags,\n            locked=locked,\n            rate_limit_per_user=rate_limit_per_user,\n            reason=reason,\n            flags=flags,\n            **kwargs,\n        )\n\n    @property\n    def applied_tags(self) -&gt; list[ThreadTag]:\n\"\"\"The tags applied to this thread.\"\"\"\n        if not isinstance(self.parent_channel, GuildForum):\n            raise AttributeError(\"This is only available on forum threads.\")\n        return [tag for tag in self.parent_channel.available_tags if str(tag.id) in self._applied_tags]\n\n    @property\n    def initial_post(self) -&gt; Optional[\"Message\"]:\n\"\"\"The initial message posted by the OP.\"\"\"\n        if not isinstance(self.parent_channel, GuildForum):\n            raise AttributeError(\"This is only available on forum threads.\")\n        return self.get_message(self.id)\n\n    @property\n    def pinned(self) -&gt; bool:\n\"\"\"Whether this thread is pinned.\"\"\"\n        return ChannelFlags.PINNED in self.flags\n\n    async def pin(self, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n        Pin this thread.\n\n        Args:\n            reason: The reason for this pin\n\n        \"\"\"\n        flags = self.flags | ChannelFlags.PINNED\n        await self.edit(flags=flags, reason=reason)\n\n    async def unpin(self, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n        Unpin this thread.\n\n        Args:\n            reason: The reason for this unpin\n\n        \"\"\"\n        flags = self.flags &amp; ~ChannelFlags.PINNED\n        await self.edit(flags=flags, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForumPost.edit","title":"<code>edit(*, name=MISSING, archived=MISSING, auto_archive_duration=MISSING, applied_tags=MISSING, locked=MISSING, rate_limit_per_user=MISSING, flags=MISSING, reason=MISSING, **kwargs)</code>  <code>async</code>","text":"<p>Edit this thread.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[str]</code> <p>1-100 character channel name</p> <code>MISSING</code> <code>archived</code> <code>Absent[bool]</code> <p>whether the thread is archived</p> <code>MISSING</code> <code>applied_tags</code> <code>Absent[List[Union[Snowflake_Type, ThreadTag]]]</code> <p>list of tags to apply</p> <code>MISSING</code> <code>auto_archive_duration</code> <code>Absent[AutoArchiveDuration]</code> <p>duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080</p> <code>MISSING</code> <code>locked</code> <code>Absent[bool]</code> <p>whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it</p> <code>MISSING</code> <code>rate_limit_per_user</code> <code>Absent[int]</code> <p>amount of seconds a user has to wait before sending another message (0-21600)</p> <code>MISSING</code> <code>flags</code> <code>Absent[Union[int, ChannelFlags]]</code> <p>channel flags to apply</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for this change</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildForumPost</code> <p>The edited thread channel object.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: Absent[str] = MISSING,\n    archived: Absent[bool] = MISSING,\n    auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,\n    applied_tags: Absent[List[Union[Snowflake_Type, ThreadTag]]] = MISSING,\n    locked: Absent[bool] = MISSING,\n    rate_limit_per_user: Absent[int] = MISSING,\n    flags: Absent[Union[int, ChannelFlags]] = MISSING,\n    reason: Absent[str] = MISSING,\n    **kwargs,\n) -&gt; \"GuildForumPost\":\n\"\"\"\n    Edit this thread.\n\n    Args:\n        name: 1-100 character channel name\n        archived: whether the thread is archived\n        applied_tags: list of tags to apply\n        auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\n        locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it\n        rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)\n        flags: channel flags to apply\n        reason: The reason for this change\n\n    Returns:\n        The edited thread channel object.\n    \"\"\"\n    if applied_tags != MISSING:\n        applied_tags = [str(tag.id) if isinstance(tag, ThreadTag) else str(tag) for tag in applied_tags]\n\n    return await super().edit(\n        name=name,\n        archived=archived,\n        auto_archive_duration=auto_archive_duration,\n        applied_tags=applied_tags,\n        locked=locked,\n        rate_limit_per_user=rate_limit_per_user,\n        reason=reason,\n        flags=flags,\n        **kwargs,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForumPost.applied_tags","title":"<code>applied_tags: list[ThreadTag]</code>  <code>property</code>","text":"<p>The tags applied to this thread.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForumPost.initial_post","title":"<code>initial_post: Optional[Message]</code>  <code>property</code>","text":"<p>The initial message posted by the OP.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForumPost.pinned","title":"<code>pinned: bool</code>  <code>property</code>","text":"<p>Whether this thread is pinned.</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForumPost.pin","title":"<code>pin(reason=MISSING)</code>  <code>async</code>","text":"<p>Pin this thread.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Absent[str]</code> <p>The reason for this pin</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def pin(self, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n    Pin this thread.\n\n    Args:\n        reason: The reason for this pin\n\n    \"\"\"\n    flags = self.flags | ChannelFlags.PINNED\n    await self.edit(flags=flags, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForumPost.unpin","title":"<code>unpin(reason=MISSING)</code>  <code>async</code>","text":"<p>Unpin this thread.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Absent[str]</code> <p>The reason for this unpin</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def unpin(self, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n    Unpin this thread.\n\n    Args:\n        reason: The reason for this unpin\n\n    \"\"\"\n    flags = self.flags &amp; ~ChannelFlags.PINNED\n    await self.edit(flags=flags, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildPrivateThread","title":"<code>GuildPrivateThread</code>","text":"<p>         Bases: <code>ThreadChannel</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass GuildPrivateThread(ThreadChannel):\n    invitable: bool = attrs.field(repr=False, default=False)\n\"\"\"Whether non-moderators can add other non-moderators to a thread\"\"\"\n\n    async def edit(\n        self,\n        *,\n        name: Absent[str] = MISSING,\n        archived: Absent[bool] = MISSING,\n        auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,\n        locked: Absent[bool] = MISSING,\n        rate_limit_per_user: Absent[int] = MISSING,\n        invitable: Absent[bool] = MISSING,\n        reason: Absent[str] = MISSING,\n        **kwargs,\n    ) -&gt; \"GuildPrivateThread\":\n\"\"\"\n        Edit this thread.\n\n        Args:\n            name: 1-100 character channel name\n            archived: whether the thread is archived\n            auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\n            locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it\n            rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)\n            invitable: whether non-moderators can add other non-moderators to a thread; only available on private threads\n            reason: The reason for this change\n\n        Returns:\n            The edited thread channel object.\n\n        \"\"\"\n        return await super().edit(\n            name=name,\n            archived=archived,\n            auto_archive_duration=auto_archive_duration,\n            locked=locked,\n            rate_limit_per_user=rate_limit_per_user,\n            invitable=invitable,\n            reason=reason,\n            **kwargs,\n        )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildPrivateThread.invitable","title":"<code>invitable: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>Whether non-moderators can add other non-moderators to a thread</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildPrivateThread.edit","title":"<code>edit(*, name=MISSING, archived=MISSING, auto_archive_duration=MISSING, locked=MISSING, rate_limit_per_user=MISSING, invitable=MISSING, reason=MISSING, **kwargs)</code>  <code>async</code>","text":"<p>Edit this thread.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[str]</code> <p>1-100 character channel name</p> <code>MISSING</code> <code>archived</code> <code>Absent[bool]</code> <p>whether the thread is archived</p> <code>MISSING</code> <code>auto_archive_duration</code> <code>Absent[AutoArchiveDuration]</code> <p>duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080</p> <code>MISSING</code> <code>locked</code> <code>Absent[bool]</code> <p>whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it</p> <code>MISSING</code> <code>rate_limit_per_user</code> <code>Absent[int]</code> <p>amount of seconds a user has to wait before sending another message (0-21600)</p> <code>MISSING</code> <code>invitable</code> <code>Absent[bool]</code> <p>whether non-moderators can add other non-moderators to a thread; only available on private threads</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for this change</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildPrivateThread</code> <p>The edited thread channel object.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: Absent[str] = MISSING,\n    archived: Absent[bool] = MISSING,\n    auto_archive_duration: Absent[AutoArchiveDuration] = MISSING,\n    locked: Absent[bool] = MISSING,\n    rate_limit_per_user: Absent[int] = MISSING,\n    invitable: Absent[bool] = MISSING,\n    reason: Absent[str] = MISSING,\n    **kwargs,\n) -&gt; \"GuildPrivateThread\":\n\"\"\"\n    Edit this thread.\n\n    Args:\n        name: 1-100 character channel name\n        archived: whether the thread is archived\n        auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\n        locked: whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it\n        rate_limit_per_user: amount of seconds a user has to wait before sending another message (0-21600)\n        invitable: whether non-moderators can add other non-moderators to a thread; only available on private threads\n        reason: The reason for this change\n\n    Returns:\n        The edited thread channel object.\n\n    \"\"\"\n    return await super().edit(\n        name=name,\n        archived=archived,\n        auto_archive_duration=auto_archive_duration,\n        locked=locked,\n        rate_limit_per_user=rate_limit_per_user,\n        invitable=invitable,\n        reason=reason,\n        **kwargs,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.VoiceChannel","title":"<code>VoiceChannel</code>","text":"<p>         Bases: <code>GuildChannel</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, slots=False, kw_only=True)\nclass VoiceChannel(GuildChannel):  # May not be needed, can be directly just GuildVoice.\n    bitrate: int = attrs.field(\n        repr=False,\n    )\n\"\"\"The bitrate (in bits) of the voice channel\"\"\"\n    user_limit: int = attrs.field(\n        repr=False,\n    )\n\"\"\"The user limit of the voice channel\"\"\"\n    rtc_region: str = attrs.field(repr=False, default=\"auto\")\n\"\"\"Voice region id for the voice channel, automatic when set to None\"\"\"\n    video_quality_mode: Union[VideoQualityModes, int] = attrs.field(repr=False, default=VideoQualityModes.AUTO)\n\"\"\"The camera video quality mode of the voice channel, 1 when not present\"\"\"\n    _voice_member_ids: list[Snowflake_Type] = attrs.field(repr=False, factory=list)\n\n    async def edit(\n        self,\n        *,\n        name: Absent[str] = MISSING,\n        position: Absent[int] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n        ] = MISSING,\n        parent_id: Absent[Snowflake_Type] = MISSING,\n        bitrate: Absent[int] = MISSING,\n        user_limit: Absent[int] = MISSING,\n        rtc_region: Absent[str] = MISSING,\n        video_quality_mode: Absent[VideoQualityModes] = MISSING,\n        reason: Absent[str] = MISSING,\n        **kwargs,\n    ) -&gt; Union[\"GuildVoice\", \"GuildStageVoice\"]:\n\"\"\"\n        Edit guild voice channel.\n\n        Args:\n            name: 1-100 character channel name\n            position: the position of the channel in the left-hand listing\n            permission_overwrites: a list of `PermissionOverwrite` to apply to the channel\n            parent_id: the parent category `Snowflake_Type` for the channel\n            bitrate: the bitrate (in bits) of the voice channel; 8000 to 96000 (128000 for VIP servers)\n            user_limit: the user limit of the voice channel; 0 refers to no limit, 1 to 99 refers to a user limit\n            rtc_region: channel voice region id, automatic when not set\n            video_quality_mode: the camera video quality mode of the voice channel\n            reason: optional reason for audit logs\n\n        Returns:\n            The edited voice channel object.\n\n        \"\"\"\n        return await super().edit(\n            name=name,\n            position=position,\n            permission_overwrites=permission_overwrites,\n            parent_id=parent_id,\n            bitrate=bitrate,\n            user_limit=user_limit,\n            rtc_region=rtc_region,\n            video_quality_mode=video_quality_mode,\n            reason=reason,\n            **kwargs,\n        )\n\n    @property\n    def members(self) -&gt; List[\"models.Member\"]:\n\"\"\"Returns a list of members that have access to this voice channel\"\"\"\n        return [m for m in self.guild.members if Permissions.CONNECT in m.channel_permissions(self)]  # type: ignore\n\n    @property\n    def voice_members(self) -&gt; List[\"models.Member\"]:\n\"\"\"\n        Returns a list of members that are currently in the channel.\n\n        !!! note\n            This will not be accurate if the bot was offline while users joined the channel\n        \"\"\"\n        return [self._client.cache.get_member(self._guild_id, member_id) for member_id in self._voice_member_ids]\n\n    @property\n    def voice_state(self) -&gt; Optional[\"ActiveVoiceState\"]:\n\"\"\"Returns the voice state of the bot in this channel if it is connected\"\"\"\n        return self._client.get_bot_voice_state(self._guild_id)\n\n    async def connect(self, muted: bool = False, deafened: bool = False) -&gt; \"ActiveVoiceState\":\n\"\"\"\n        Connect the bot to this voice channel, or move the bot to this voice channel if it is already connected in another voice channel.\n\n        Args:\n            muted: Whether the bot should be muted when connected.\n            deafened: Whether the bot should be deafened when connected.\n\n        Returns:\n            The new active voice state on successfully connection.\n\n        \"\"\"\n        if not self.voice_state:\n            return await self._client.connect_to_vc(self._guild_id, self.id, muted, deafened)\n        await self.voice_state.move(self.id)\n        return self.voice_state\n\n    async def disconnect(self) -&gt; None:\n\"\"\"\n        Disconnect from the currently connected voice state.\n\n        Raises:\n            VoiceNotConnected: if the bot is not connected to a voice channel\n        \"\"\"\n        if self.voice_state:\n            return await self.voice_state.disconnect()\n        else:\n            raise VoiceNotConnected\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.VoiceChannel.bitrate","title":"<code>bitrate: int = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The bitrate (in bits) of the voice channel</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.VoiceChannel.user_limit","title":"<code>user_limit: int = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The user limit of the voice channel</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.VoiceChannel.rtc_region","title":"<code>rtc_region: str = attrs.field(repr=False, default='auto')</code>  <code>class-attribute</code>","text":"<p>Voice region id for the voice channel, automatic when set to None</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.VoiceChannel.video_quality_mode","title":"<code>video_quality_mode: Union[VideoQualityModes, int] = attrs.field(repr=False, default=VideoQualityModes.AUTO)</code>  <code>class-attribute</code>","text":"<p>The camera video quality mode of the voice channel, 1 when not present</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.VoiceChannel.edit","title":"<code>edit(*, name=MISSING, position=MISSING, permission_overwrites=MISSING, parent_id=MISSING, bitrate=MISSING, user_limit=MISSING, rtc_region=MISSING, video_quality_mode=MISSING, reason=MISSING, **kwargs)</code>  <code>async</code>","text":"<p>Edit guild voice channel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[str]</code> <p>1-100 character channel name</p> <code>MISSING</code> <code>position</code> <code>Absent[int]</code> <p>the position of the channel in the left-hand listing</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>a list of <code>PermissionOverwrite</code> to apply to the channel</p> <code>MISSING</code> <code>parent_id</code> <code>Absent[Snowflake_Type]</code> <p>the parent category <code>Snowflake_Type</code> for the channel</p> <code>MISSING</code> <code>bitrate</code> <code>Absent[int]</code> <p>the bitrate (in bits) of the voice channel; 8000 to 96000 (128000 for VIP servers)</p> <code>MISSING</code> <code>user_limit</code> <code>Absent[int]</code> <p>the user limit of the voice channel; 0 refers to no limit, 1 to 99 refers to a user limit</p> <code>MISSING</code> <code>rtc_region</code> <code>Absent[str]</code> <p>channel voice region id, automatic when not set</p> <code>MISSING</code> <code>video_quality_mode</code> <code>Absent[VideoQualityModes]</code> <p>the camera video quality mode of the voice channel</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>optional reason for audit logs</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Union[GuildVoice, GuildStageVoice]</code> <p>The edited voice channel object.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: Absent[str] = MISSING,\n    position: Absent[int] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n    ] = MISSING,\n    parent_id: Absent[Snowflake_Type] = MISSING,\n    bitrate: Absent[int] = MISSING,\n    user_limit: Absent[int] = MISSING,\n    rtc_region: Absent[str] = MISSING,\n    video_quality_mode: Absent[VideoQualityModes] = MISSING,\n    reason: Absent[str] = MISSING,\n    **kwargs,\n) -&gt; Union[\"GuildVoice\", \"GuildStageVoice\"]:\n\"\"\"\n    Edit guild voice channel.\n\n    Args:\n        name: 1-100 character channel name\n        position: the position of the channel in the left-hand listing\n        permission_overwrites: a list of `PermissionOverwrite` to apply to the channel\n        parent_id: the parent category `Snowflake_Type` for the channel\n        bitrate: the bitrate (in bits) of the voice channel; 8000 to 96000 (128000 for VIP servers)\n        user_limit: the user limit of the voice channel; 0 refers to no limit, 1 to 99 refers to a user limit\n        rtc_region: channel voice region id, automatic when not set\n        video_quality_mode: the camera video quality mode of the voice channel\n        reason: optional reason for audit logs\n\n    Returns:\n        The edited voice channel object.\n\n    \"\"\"\n    return await super().edit(\n        name=name,\n        position=position,\n        permission_overwrites=permission_overwrites,\n        parent_id=parent_id,\n        bitrate=bitrate,\n        user_limit=user_limit,\n        rtc_region=rtc_region,\n        video_quality_mode=video_quality_mode,\n        reason=reason,\n        **kwargs,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.VoiceChannel.members","title":"<code>members: List[models.Member]</code>  <code>property</code>","text":"<p>Returns a list of members that have access to this voice channel</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.VoiceChannel.voice_members","title":"<code>voice_members: List[models.Member]</code>  <code>property</code>","text":"<p>Returns a list of members that are currently in the channel.</p> <p>Note</p> <p>This will not be accurate if the bot was offline while users joined the channel</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.VoiceChannel.voice_state","title":"<code>voice_state: Optional[ActiveVoiceState]</code>  <code>property</code>","text":"<p>Returns the voice state of the bot in this channel if it is connected</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.VoiceChannel.connect","title":"<code>connect(muted=False, deafened=False)</code>  <code>async</code>","text":"<p>Connect the bot to this voice channel, or move the bot to this voice channel if it is already connected in another voice channel.</p> <p>Parameters:</p> Name Type Description Default <code>muted</code> <code>bool</code> <p>Whether the bot should be muted when connected.</p> <code>False</code> <code>deafened</code> <code>bool</code> <p>Whether the bot should be deafened when connected.</p> <code>False</code> <p>Returns:</p> Type Description <code>ActiveVoiceState</code> <p>The new active voice state on successfully connection.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def connect(self, muted: bool = False, deafened: bool = False) -&gt; \"ActiveVoiceState\":\n\"\"\"\n    Connect the bot to this voice channel, or move the bot to this voice channel if it is already connected in another voice channel.\n\n    Args:\n        muted: Whether the bot should be muted when connected.\n        deafened: Whether the bot should be deafened when connected.\n\n    Returns:\n        The new active voice state on successfully connection.\n\n    \"\"\"\n    if not self.voice_state:\n        return await self._client.connect_to_vc(self._guild_id, self.id, muted, deafened)\n    await self.voice_state.move(self.id)\n    return self.voice_state\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.VoiceChannel.disconnect","title":"<code>disconnect()</code>  <code>async</code>","text":"<p>Disconnect from the currently connected voice state.</p> <p>Raises:</p> Type Description <code>VoiceNotConnected</code> <p>if the bot is not connected to a voice channel</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def disconnect(self) -&gt; None:\n\"\"\"\n    Disconnect from the currently connected voice state.\n\n    Raises:\n        VoiceNotConnected: if the bot is not connected to a voice channel\n    \"\"\"\n    if self.voice_state:\n        return await self.voice_state.disconnect()\n    else:\n        raise VoiceNotConnected\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildStageVoice","title":"<code>GuildStageVoice</code>","text":"<p>         Bases: <code>GuildVoice</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass GuildStageVoice(GuildVoice):\n    stage_instance: \"models.StageInstance\" = attrs.field(repr=False, default=MISSING)\n\"\"\"The stage instance that this voice channel belongs to\"\"\"\n\n    # todo: Listeners and speakers properties (needs voice state caching)\n\n    async def fetch_stage_instance(self) -&gt; \"models.StageInstance\":\n\"\"\"\n        Fetches the stage instance associated with this channel.\n\n        Returns:\n            The stage instance associated with this channel. If no stage is live, will return None.\n\n        \"\"\"\n        self.stage_instance = models.StageInstance.from_dict(\n            await self._client.http.get_stage_instance(self.id), self._client\n        )\n        return self.stage_instance\n\n    async def create_stage_instance(\n        self,\n        topic: str,\n        privacy_level: StagePrivacyLevel = StagePrivacyLevel.GUILD_ONLY,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"models.StageInstance\":\n\"\"\"\n        Create a stage instance in this channel.\n\n        Args:\n            topic: The topic of the stage (1-120 characters)\n            privacy_level: The privacy level of the stage\n            reason: The reason for creating this instance\n\n        Returns:\n            The created stage instance object.\n\n        \"\"\"\n        self.stage_instance = models.StageInstance.from_dict(\n            await self._client.http.create_stage_instance(self.id, topic, privacy_level, reason), self._client\n        )\n        return self.stage_instance\n\n    async def close_stage(self, reason: Absent[Optional[str]] = MISSING) -&gt; None:\n\"\"\"\n        Closes the live stage instance.\n\n        Args:\n            reason: The reason for closing the stage\n\n        \"\"\"\n        if not self.stage_instance:\n            # we dont know of an active stage instance, so lets check for one\n            if not await self.get_stage_instance():\n                raise ValueError(\"No stage instance found\")\n\n        await self.stage_instance.delete(reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildStageVoice.stage_instance","title":"<code>stage_instance: models.StageInstance = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>The stage instance that this voice channel belongs to</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildStageVoice.fetch_stage_instance","title":"<code>fetch_stage_instance()</code>  <code>async</code>","text":"<p>Fetches the stage instance associated with this channel.</p> <p>Returns:</p> Type Description <code>StageInstance</code> <p>The stage instance associated with this channel. If no stage is live, will return None.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_stage_instance(self) -&gt; \"models.StageInstance\":\n\"\"\"\n    Fetches the stage instance associated with this channel.\n\n    Returns:\n        The stage instance associated with this channel. If no stage is live, will return None.\n\n    \"\"\"\n    self.stage_instance = models.StageInstance.from_dict(\n        await self._client.http.get_stage_instance(self.id), self._client\n    )\n    return self.stage_instance\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildStageVoice.create_stage_instance","title":"<code>create_stage_instance(topic, privacy_level=StagePrivacyLevel.GUILD_ONLY, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a stage instance in this channel.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>The topic of the stage (1-120 characters)</p> required <code>privacy_level</code> <code>StagePrivacyLevel</code> <p>The privacy level of the stage</p> <code>StagePrivacyLevel.GUILD_ONLY</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for creating this instance</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>StageInstance</code> <p>The created stage instance object.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def create_stage_instance(\n    self,\n    topic: str,\n    privacy_level: StagePrivacyLevel = StagePrivacyLevel.GUILD_ONLY,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"models.StageInstance\":\n\"\"\"\n    Create a stage instance in this channel.\n\n    Args:\n        topic: The topic of the stage (1-120 characters)\n        privacy_level: The privacy level of the stage\n        reason: The reason for creating this instance\n\n    Returns:\n        The created stage instance object.\n\n    \"\"\"\n    self.stage_instance = models.StageInstance.from_dict(\n        await self._client.http.create_stage_instance(self.id, topic, privacy_level, reason), self._client\n    )\n    return self.stage_instance\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildStageVoice.close_stage","title":"<code>close_stage(reason=MISSING)</code>  <code>async</code>","text":"<p>Closes the live stage instance.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for closing the stage</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def close_stage(self, reason: Absent[Optional[str]] = MISSING) -&gt; None:\n\"\"\"\n    Closes the live stage instance.\n\n    Args:\n        reason: The reason for closing the stage\n\n    \"\"\"\n    if not self.stage_instance:\n        # we dont know of an active stage instance, so lets check for one\n        if not await self.get_stage_instance():\n            raise ValueError(\"No stage instance found\")\n\n    await self.stage_instance.delete(reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForum","title":"<code>GuildForum</code>","text":"<p>         Bases: <code>GuildChannel</code></p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass GuildForum(GuildChannel):\n    available_tags: List[ThreadTag] = attrs.field(repr=False, factory=list)\n\"\"\"A list of tags available to assign to threads\"\"\"\n    last_message_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)\n    # TODO: Implement \"template\" once the API supports them\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        data = super()._process_dict(data, client)\n        data[\"available_tags\"] = [\n            ThreadTag.from_dict(tag_data | {\"parent_channel_id\": data[\"id\"]}, client)\n            for tag_data in data.get(\"available_tags\", [])\n        ]\n        return data\n\n    async def create_post(\n        self,\n        name: str,\n        content: str | None,\n        applied_tags: Optional[List[Union[\"Snowflake_Type\", \"ThreadTag\", str]]] = MISSING,\n        *,\n        auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,\n        rate_limit_per_user: Absent[int] = MISSING,\n        embeds: Optional[Union[List[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n        embed: Optional[Union[\"Embed\", dict]] = None,\n        components: Optional[\n            Union[List[List[Union[\"BaseComponent\", dict]]], List[Union[\"BaseComponent\", dict]], \"BaseComponent\", dict]\n        ] = None,\n        stickers: Optional[Union[List[Union[\"Sticker\", \"Snowflake_Type\"]], \"Sticker\", \"Snowflake_Type\"]] = None,\n        allowed_mentions: Optional[Union[\"AllowedMentions\", dict]] = None,\n        files: Optional[Union[\"UPLOADABLE_TYPE\", List[\"UPLOADABLE_TYPE\"]]] = None,\n        file: Optional[\"UPLOADABLE_TYPE\"] = None,\n        tts: bool = False,\n        reason: Absent[str] = MISSING,\n    ) -&gt; \"GuildForumPost\":\n\"\"\"\n        Create a post within this channel.\n\n        Args:\n            name: The name of the post\n            content: The text content of this post\n            applied_tags: A list of tag ids or tag objects to apply to this post\n            auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.\n            rate_limit_per_user: The time users must wait between sending messages\n            embeds: Embedded rich content (up to 6000 characters).\n            embed: Embedded rich content (up to 6000 characters).\n            components: The components to include with the message.\n            stickers: IDs of up to 3 stickers in the server to send in the message.\n            allowed_mentions: Allowed mentions for the message.\n            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n            tts: Should this message use Text To Speech.\n            reason: The reason for creating this post\n\n        Returns:\n            A GuildForumPost object representing the created post.\n        \"\"\"\n        if applied_tags != MISSING:\n            processed = []\n            for tag in applied_tags:\n                if isinstance(tag, ThreadTag):\n                    tag = tag.id\n                elif isinstance(tag, (str, int)):\n                    tag = self.get_tag(tag, case_insensitive=True)\n                    if not tag:\n                        continue\n                    tag = tag.id\n                elif isinstance(tag, dict):\n                    tag = tag[\"id\"]\n                processed.append(tag)\n\n            applied_tags = processed\n\n        message_payload = models.discord.message.process_message_payload(\n            content=content,\n            embeds=embeds or embed,\n            components=components,\n            stickers=stickers,\n            allowed_mentions=allowed_mentions,\n            tts=tts,\n        )\n\n        data = await self._client.http.create_forum_thread(\n            self.id,\n            name,\n            auto_archive_duration,\n            message_payload,\n            applied_tags,\n            rate_limit_per_user,\n            files=files or file,\n            reason=reason,\n        )\n        return self._client.cache.place_channel_data(data)\n\n    async def fetch_posts(self) -&gt; List[\"GuildForumPost\"]:\n\"\"\"\n        Requests all active posts within this channel.\n\n        Returns:\n            A list of GuildForumPost objects representing the posts.\n        \"\"\"\n        # I can guarantee this endpoint will need to be converted to an async iterator eventually\n        data = await self._client.http.list_active_threads(self._guild_id)\n        threads = [self._client.cache.place_channel_data(post_data) for post_data in data[\"threads\"]]\n\n        return [thread for thread in threads if thread.parent_id == self.id]\n\n    def get_posts(self, *, exclude_archived: bool = True) -&gt; List[\"GuildForumPost\"]:\n\"\"\"\n        List all, cached, active posts within this channel.\n\n        Args:\n            exclude_archived: Whether to exclude archived posts from the response\n\n        Returns:\n            A list of GuildForumPost objects representing the posts.\n        \"\"\"\n        out = [thread for thread in self.guild.threads if thread.parent_id == self.id]\n        if exclude_archived:\n            return [thread for thread in out if not thread.archived]\n        return out\n\n    def archived_posts(self, limit: int = 0, before: Snowflake_Type | None = None) -&gt; ArchivedForumPosts:\n\"\"\"An async iterator for all archived posts in this channel.\"\"\"\n        return ArchivedForumPosts(self, limit, before)\n\n    async def fetch_post(self, id: \"Snowflake_Type\") -&gt; \"GuildForumPost\":\n\"\"\"\n        Fetch a post within this channel.\n\n        Args:\n            id: The id of the post to fetch\n\n        Returns:\n            A GuildForumPost object representing the post.\n        \"\"\"\n        return await self._client.fetch_channel(id)\n\n    def get_post(self, id: \"Snowflake_Type\") -&gt; \"GuildForumPost\":\n\"\"\"\n        Get a post within this channel.\n\n        Args:\n            id: The id of the post to get\n\n        Returns:\n            A GuildForumPost object representing the post.\n        \"\"\"\n        return self._client.cache.get_channel(id)\n\n    def get_tag(self, value: str | Snowflake_Type, *, case_insensitive: bool = False) -&gt; Optional[\"ThreadTag\"]:\n\"\"\"\n        Get a tag within this channel.\n\n        Args:\n            value: The name or ID of the tag to get\n            case_insensitive: Whether to ignore case when searching for the tag\n\n        Returns:\n            A ThreadTag object representing the tag.\n        \"\"\"\n\n        def maybe_insensitive(string: str) -&gt; str:\n            return string.lower() if case_insensitive else string\n\n        def predicate(tag: ThreadTag) -&gt; Optional[\"ThreadTag\"]:\n            if str(tag.id) == str(value):\n                return tag\n            if maybe_insensitive(tag.name) == maybe_insensitive(value):\n                return tag\n\n        return next((tag for tag in self.available_tags if predicate(tag)), None)\n\n    async def create_tag(self, name: str, emoji: Union[\"models.PartialEmoji\", dict, str, None] = None) -&gt; \"ThreadTag\":\n\"\"\"\n        Create a tag for this forum.\n\n        Args:\n            name: The name of the tag\n            emoji: The emoji to use for the tag\n\n        !!! note\n            If the emoji is a custom emoji, it must be from the same guild as the channel.\n\n        Returns:\n            The created tag object.\n\n        \"\"\"\n        payload = {\"channel_id\": self.id, \"name\": name}\n\n        if emoji:\n            if isinstance(emoji, str):\n                emoji = PartialEmoji.from_str(emoji)\n            elif isinstance(emoji, dict):\n                emoji = PartialEmoji.from_dict(emoji)\n\n            if emoji.id:\n                payload[\"emoji_id\"] = emoji.id\n            else:\n                payload[\"emoji_name\"] = emoji.name\n\n        data = await self._client.http.create_tag(**payload)\n\n        channel_data = self._client.cache.place_channel_data(data)\n        return [tag for tag in channel_data.available_tags if tag.name == name][0]\n\n    async def edit_tag(\n        self,\n        tag_id: \"Snowflake_Type\",\n        *,\n        name: str | None = None,\n        emoji: Union[\"models.PartialEmoji\", dict, str, None] = None,\n    ) -&gt; \"ThreadTag\":\n\"\"\"\n        Edit a tag for this forum.\n\n        Args:\n            tag_id: The id of the tag to edit\n            name: The name for this tag\n            emoji: The emoji for this tag\n        \"\"\"\n        if isinstance(emoji, str):\n            emoji = PartialEmoji.from_str(emoji)\n        elif isinstance(emoji, dict):\n            emoji = PartialEmoji.from_dict(emoji)\n\n        if emoji.id:\n            data = await self._client.http.edit_tag(self.id, tag_id, name, emoji_id=emoji.id)\n        else:\n            data = await self._client.http.edit_tag(self.id, tag_id, name, emoji_name=emoji.name)\n\n        channel_data = self._client.cache.place_channel_data(data)\n        return [tag for tag in channel_data.available_tags if tag.name == name][0]\n\n    async def delete_tag(self, tag_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n        Delete a tag for this forum.\n\n        Args:\n            tag_id: The ID of the tag to delete\n        \"\"\"\n        data = await self._client.http.delete_tag(self.id, tag_id)\n        self._client.cache.place_channel_data(data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForum.available_tags","title":"<code>available_tags: List[ThreadTag] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>A list of tags available to assign to threads</p>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForum.create_post","title":"<code>create_post(name, content, applied_tags=MISSING, *, auto_archive_duration=AutoArchiveDuration.ONE_DAY, rate_limit_per_user=MISSING, embeds=None, embed=None, components=None, stickers=None, allowed_mentions=None, files=None, file=None, tts=False, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a post within this channel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the post</p> required <code>content</code> <code>str | None</code> <p>The text content of this post</p> required <code>applied_tags</code> <code>Optional[List[Union[Snowflake_Type, ThreadTag, str]]]</code> <p>A list of tag ids or tag objects to apply to this post</p> <code>MISSING</code> <code>auto_archive_duration</code> <code>AutoArchiveDuration</code> <p>Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.</p> <code>AutoArchiveDuration.ONE_DAY</code> <code>rate_limit_per_user</code> <code>Absent[int]</code> <p>The time users must wait between sending messages</p> <code>MISSING</code> <code>embeds</code> <code>Optional[Union[List[Union[Embed, dict]], Union[Embed, dict]]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>embed</code> <code>Optional[Union[Embed, dict]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>components</code> <code>Optional[Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict]]</code> <p>The components to include with the message.</p> <code>None</code> <code>stickers</code> <code>Optional[Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type]]</code> <p>IDs of up to 3 stickers in the server to send in the message.</p> <code>None</code> <code>allowed_mentions</code> <code>Optional[Union[AllowedMentions, dict]]</code> <p>Allowed mentions for the message.</p> <code>None</code> <code>files</code> <code>Optional[Union[UPLOADABLE_TYPE, List[UPLOADABLE_TYPE]]]</code> <p>Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.</p> <code>None</code> <code>file</code> <code>Optional[UPLOADABLE_TYPE]</code> <p>Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.</p> <code>None</code> <code>tts</code> <code>bool</code> <p>Should this message use Text To Speech.</p> <code>False</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for creating this post</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildForumPost</code> <p>A GuildForumPost object representing the created post.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def create_post(\n    self,\n    name: str,\n    content: str | None,\n    applied_tags: Optional[List[Union[\"Snowflake_Type\", \"ThreadTag\", str]]] = MISSING,\n    *,\n    auto_archive_duration: AutoArchiveDuration = AutoArchiveDuration.ONE_DAY,\n    rate_limit_per_user: Absent[int] = MISSING,\n    embeds: Optional[Union[List[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n    embed: Optional[Union[\"Embed\", dict]] = None,\n    components: Optional[\n        Union[List[List[Union[\"BaseComponent\", dict]]], List[Union[\"BaseComponent\", dict]], \"BaseComponent\", dict]\n    ] = None,\n    stickers: Optional[Union[List[Union[\"Sticker\", \"Snowflake_Type\"]], \"Sticker\", \"Snowflake_Type\"]] = None,\n    allowed_mentions: Optional[Union[\"AllowedMentions\", dict]] = None,\n    files: Optional[Union[\"UPLOADABLE_TYPE\", List[\"UPLOADABLE_TYPE\"]]] = None,\n    file: Optional[\"UPLOADABLE_TYPE\"] = None,\n    tts: bool = False,\n    reason: Absent[str] = MISSING,\n) -&gt; \"GuildForumPost\":\n\"\"\"\n    Create a post within this channel.\n\n    Args:\n        name: The name of the post\n        content: The text content of this post\n        applied_tags: A list of tag ids or tag objects to apply to this post\n        auto_archive_duration: Time before the thread will be automatically archived. Note 3 day and 7 day archive durations require the server to be boosted.\n        rate_limit_per_user: The time users must wait between sending messages\n        embeds: Embedded rich content (up to 6000 characters).\n        embed: Embedded rich content (up to 6000 characters).\n        components: The components to include with the message.\n        stickers: IDs of up to 3 stickers in the server to send in the message.\n        allowed_mentions: Allowed mentions for the message.\n        files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n        file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n        tts: Should this message use Text To Speech.\n        reason: The reason for creating this post\n\n    Returns:\n        A GuildForumPost object representing the created post.\n    \"\"\"\n    if applied_tags != MISSING:\n        processed = []\n        for tag in applied_tags:\n            if isinstance(tag, ThreadTag):\n                tag = tag.id\n            elif isinstance(tag, (str, int)):\n                tag = self.get_tag(tag, case_insensitive=True)\n                if not tag:\n                    continue\n                tag = tag.id\n            elif isinstance(tag, dict):\n                tag = tag[\"id\"]\n            processed.append(tag)\n\n        applied_tags = processed\n\n    message_payload = models.discord.message.process_message_payload(\n        content=content,\n        embeds=embeds or embed,\n        components=components,\n        stickers=stickers,\n        allowed_mentions=allowed_mentions,\n        tts=tts,\n    )\n\n    data = await self._client.http.create_forum_thread(\n        self.id,\n        name,\n        auto_archive_duration,\n        message_payload,\n        applied_tags,\n        rate_limit_per_user,\n        files=files or file,\n        reason=reason,\n    )\n    return self._client.cache.place_channel_data(data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForum.fetch_posts","title":"<code>fetch_posts()</code>  <code>async</code>","text":"<p>Requests all active posts within this channel.</p> <p>Returns:</p> Type Description <code>List[GuildForumPost]</code> <p>A list of GuildForumPost objects representing the posts.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_posts(self) -&gt; List[\"GuildForumPost\"]:\n\"\"\"\n    Requests all active posts within this channel.\n\n    Returns:\n        A list of GuildForumPost objects representing the posts.\n    \"\"\"\n    # I can guarantee this endpoint will need to be converted to an async iterator eventually\n    data = await self._client.http.list_active_threads(self._guild_id)\n    threads = [self._client.cache.place_channel_data(post_data) for post_data in data[\"threads\"]]\n\n    return [thread for thread in threads if thread.parent_id == self.id]\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForum.get_posts","title":"<code>get_posts(*, exclude_archived=True)</code>","text":"<p>List all, cached, active posts within this channel.</p> <p>Parameters:</p> Name Type Description Default <code>exclude_archived</code> <code>bool</code> <p>Whether to exclude archived posts from the response</p> <code>True</code> <p>Returns:</p> Type Description <code>List[GuildForumPost]</code> <p>A list of GuildForumPost objects representing the posts.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>def get_posts(self, *, exclude_archived: bool = True) -&gt; List[\"GuildForumPost\"]:\n\"\"\"\n    List all, cached, active posts within this channel.\n\n    Args:\n        exclude_archived: Whether to exclude archived posts from the response\n\n    Returns:\n        A list of GuildForumPost objects representing the posts.\n    \"\"\"\n    out = [thread for thread in self.guild.threads if thread.parent_id == self.id]\n    if exclude_archived:\n        return [thread for thread in out if not thread.archived]\n    return out\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForum.archived_posts","title":"<code>archived_posts(limit=0, before=None)</code>","text":"<p>An async iterator for all archived posts in this channel.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>def archived_posts(self, limit: int = 0, before: Snowflake_Type | None = None) -&gt; ArchivedForumPosts:\n\"\"\"An async iterator for all archived posts in this channel.\"\"\"\n    return ArchivedForumPosts(self, limit, before)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForum.fetch_post","title":"<code>fetch_post(id)</code>  <code>async</code>","text":"<p>Fetch a post within this channel.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>Snowflake_Type</code> <p>The id of the post to fetch</p> required <p>Returns:</p> Type Description <code>GuildForumPost</code> <p>A GuildForumPost object representing the post.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def fetch_post(self, id: \"Snowflake_Type\") -&gt; \"GuildForumPost\":\n\"\"\"\n    Fetch a post within this channel.\n\n    Args:\n        id: The id of the post to fetch\n\n    Returns:\n        A GuildForumPost object representing the post.\n    \"\"\"\n    return await self._client.fetch_channel(id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForum.get_post","title":"<code>get_post(id)</code>","text":"<p>Get a post within this channel.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>Snowflake_Type</code> <p>The id of the post to get</p> required <p>Returns:</p> Type Description <code>GuildForumPost</code> <p>A GuildForumPost object representing the post.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>def get_post(self, id: \"Snowflake_Type\") -&gt; \"GuildForumPost\":\n\"\"\"\n    Get a post within this channel.\n\n    Args:\n        id: The id of the post to get\n\n    Returns:\n        A GuildForumPost object representing the post.\n    \"\"\"\n    return self._client.cache.get_channel(id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForum.get_tag","title":"<code>get_tag(value, *, case_insensitive=False)</code>","text":"<p>Get a tag within this channel.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | Snowflake_Type</code> <p>The name or ID of the tag to get</p> required <code>case_insensitive</code> <code>bool</code> <p>Whether to ignore case when searching for the tag</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[ThreadTag]</code> <p>A ThreadTag object representing the tag.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>def get_tag(self, value: str | Snowflake_Type, *, case_insensitive: bool = False) -&gt; Optional[\"ThreadTag\"]:\n\"\"\"\n    Get a tag within this channel.\n\n    Args:\n        value: The name or ID of the tag to get\n        case_insensitive: Whether to ignore case when searching for the tag\n\n    Returns:\n        A ThreadTag object representing the tag.\n    \"\"\"\n\n    def maybe_insensitive(string: str) -&gt; str:\n        return string.lower() if case_insensitive else string\n\n    def predicate(tag: ThreadTag) -&gt; Optional[\"ThreadTag\"]:\n        if str(tag.id) == str(value):\n            return tag\n        if maybe_insensitive(tag.name) == maybe_insensitive(value):\n            return tag\n\n    return next((tag for tag in self.available_tags if predicate(tag)), None)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForum.create_tag","title":"<code>create_tag(name, emoji=None)</code>  <code>async</code>","text":"<p>Create a tag for this forum.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the tag</p> required <code>emoji</code> <code>Union[PartialEmoji, dict, str, None]</code> <p>The emoji to use for the tag</p> <code>None</code> <p>Note</p> <p>If the emoji is a custom emoji, it must be from the same guild as the channel.</p> <p>Returns:</p> Type Description <code>ThreadTag</code> <p>The created tag object.</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def create_tag(self, name: str, emoji: Union[\"models.PartialEmoji\", dict, str, None] = None) -&gt; \"ThreadTag\":\n\"\"\"\n    Create a tag for this forum.\n\n    Args:\n        name: The name of the tag\n        emoji: The emoji to use for the tag\n\n    !!! note\n        If the emoji is a custom emoji, it must be from the same guild as the channel.\n\n    Returns:\n        The created tag object.\n\n    \"\"\"\n    payload = {\"channel_id\": self.id, \"name\": name}\n\n    if emoji:\n        if isinstance(emoji, str):\n            emoji = PartialEmoji.from_str(emoji)\n        elif isinstance(emoji, dict):\n            emoji = PartialEmoji.from_dict(emoji)\n\n        if emoji.id:\n            payload[\"emoji_id\"] = emoji.id\n        else:\n            payload[\"emoji_name\"] = emoji.name\n\n    data = await self._client.http.create_tag(**payload)\n\n    channel_data = self._client.cache.place_channel_data(data)\n    return [tag for tag in channel_data.available_tags if tag.name == name][0]\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForum.edit_tag","title":"<code>edit_tag(tag_id, *, name=None, emoji=None)</code>  <code>async</code>","text":"<p>Edit a tag for this forum.</p> <p>Parameters:</p> Name Type Description Default <code>tag_id</code> <code>Snowflake_Type</code> <p>The id of the tag to edit</p> required <code>name</code> <code>str | None</code> <p>The name for this tag</p> <code>None</code> <code>emoji</code> <code>Union[PartialEmoji, dict, str, None]</code> <p>The emoji for this tag</p> <code>None</code> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def edit_tag(\n    self,\n    tag_id: \"Snowflake_Type\",\n    *,\n    name: str | None = None,\n    emoji: Union[\"models.PartialEmoji\", dict, str, None] = None,\n) -&gt; \"ThreadTag\":\n\"\"\"\n    Edit a tag for this forum.\n\n    Args:\n        tag_id: The id of the tag to edit\n        name: The name for this tag\n        emoji: The emoji for this tag\n    \"\"\"\n    if isinstance(emoji, str):\n        emoji = PartialEmoji.from_str(emoji)\n    elif isinstance(emoji, dict):\n        emoji = PartialEmoji.from_dict(emoji)\n\n    if emoji.id:\n        data = await self._client.http.edit_tag(self.id, tag_id, name, emoji_id=emoji.id)\n    else:\n        data = await self._client.http.edit_tag(self.id, tag_id, name, emoji_name=emoji.name)\n\n    channel_data = self._client.cache.place_channel_data(data)\n    return [tag for tag in channel_data.available_tags if tag.name == name][0]\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.GuildForum.delete_tag","title":"<code>delete_tag(tag_id)</code>  <code>async</code>","text":"<p>Delete a tag for this forum.</p> <p>Parameters:</p> Name Type Description Default <code>tag_id</code> <code>Snowflake_Type</code> <p>The ID of the tag to delete</p> required Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>async def delete_tag(self, tag_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n    Delete a tag for this forum.\n\n    Args:\n        tag_id: The ID of the tag to delete\n    \"\"\"\n    data = await self._client.http.delete_tag(self.id, tag_id)\n    self._client.cache.place_channel_data(data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/channel/#naff.models.discord.channel.process_permission_overwrites","title":"<code>process_permission_overwrites(overwrites)</code>","text":"<p>Processes a permission overwrite lists into format for sending to discord.</p> <p>Parameters:</p> Name Type Description Default <code>overwrites</code> <code>Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]</code> <p>The permission overwrites to process</p> required <p>Returns:</p> Type Description <code>List[dict]</code> <p>The processed permission overwrites</p> Source code in <code>naff\\models\\discord\\channel.py</code> <pre><code>def process_permission_overwrites(\n    overwrites: Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]\n) -&gt; List[dict]:\n\"\"\"\n    Processes a permission overwrite lists into format for sending to discord.\n\n    Args:\n        overwrites: The permission overwrites to process\n\n    Returns:\n        The processed permission overwrites\n\n    \"\"\"\n    if not overwrites:\n        return overwrites\n\n    if isinstance(overwrites, dict):\n        return [overwrites]\n\n    if isinstance(overwrites, list):\n        return list(map(to_dict, overwrites))\n\n    if isinstance(overwrites, PermissionOverwrite):\n        return [overwrites.to_dict()]\n\n    raise ValueError(f\"Invalid overwrites: {overwrites}\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/color/","title":"Color","text":""},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.Color","title":"<code>Color</code>","text":"Source code in <code>naff\\models\\discord\\color.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, init=False)\nclass Color:\n    value: int = attrs.field(repr=True)\n\"\"\"The color value as an integer.\"\"\"\n\n    def __init__(self, color: COLOR_TYPES | None = None) -&gt; None:\n        color = color or (0, 0, 0)\n        if isinstance(color, int):\n            self.value = color\n        elif isinstance(color, (tuple, list)):\n            color = tuple(color)\n            self.rgb = color\n        elif isinstance(color, str):\n            if re.match(hex_regex, color):\n                self.hex = color\n            else:\n                self.value = BrandColors[color].value\n        else:\n            raise TypeError\n\n    def __str__(self) -&gt; str:\n        return self.hex\n\n    # Helper methods\n\n    @staticmethod\n    def clamp(x, min_value=0, max_value=255) -&gt; int:\n\"\"\"Sanitise a value between a minimum and maximum value\"\"\"\n        return max(min_value, min(x, max_value))\n\n    # Constructor methods\n\n    @classmethod\n    def from_rgb(cls, r: int, g: int, b: int) -&gt; \"Color\":\n\"\"\"\n        Create a Color object from red, green and blue values.\n\n        Args:\n            r: The red value.\n            g: The green value.\n            b: The blue value.\n\n        Returns:\n            A Color object.\n\n        \"\"\"\n        return cls((r, g, b))\n\n    @classmethod\n    def from_hex(cls, value: str) -&gt; \"Color\":\n\"\"\"\n        Create a Color object from a hexadecimal string.\n\n        Args:\n            value: The hexadecimal string.\n\n        Returns:\n            A Color object.\n\n        \"\"\"\n        instance = cls()\n        instance.hex = value\n        return instance\n\n    @classmethod\n    def from_hsv(cls, h: int, s: int, v: int) -&gt; \"Color\":\n\"\"\"\n        Create a Color object from a hue, saturation and value.\n\n        Args:\n            h: The hue value.\n            s: The saturation value.\n            v: The value value.\n\n        Returns:\n            A Color object.\n\n        \"\"\"\n        instance = cls()\n        instance.hsv = h, s, v\n        return instance\n\n    @classmethod\n    def random(cls) -&gt; \"Color\":\n\"\"\"Returns random Color instance\"\"\"\n        # FFFFFF == 16777215\n        return cls(randint(0, 16777215))\n\n    # Properties and setter methods\n\n    def _get_byte(self, n) -&gt; int:\n\"\"\"\n        Get the nth byte of the color value\n\n        Args:\n            n: The index of the byte to get.\n\n        Returns:\n            The nth byte of the color value.\n\n        \"\"\"\n        return (self.value &gt;&gt; (8 * n)) &amp; 255\n\n    @property\n    def r(self) -&gt; int:\n\"\"\"Red color value\"\"\"\n        return self._get_byte(2)\n\n    @property\n    def g(self) -&gt; int:\n\"\"\"Green color value\"\"\"\n        return self._get_byte(1)\n\n    @property\n    def b(self) -&gt; int:\n\"\"\"Blue color value\"\"\"\n        return self._get_byte(0)\n\n    @property\n    def rgb(self) -&gt; tuple[int, int, int]:\n\"\"\"The red, green, blue color values in a tuple\"\"\"\n        return self.r, self.g, self.b\n\n    @rgb.setter\n    def rgb(self, value: tuple[int, int, int]) -&gt; None:\n\"\"\"Set the color value from a tuple of (r, g, b) values\"\"\"\n        # noinspection PyTypeChecker\n        r, g, b = (self.clamp(v) for v in value)\n        self.value = (r &lt;&lt; 16) + (g &lt;&lt; 8) + b\n\n    @property\n    def rgb_float(self) -&gt; tuple[float, float, float]:\n\"\"\"The red, green, blue color values in a tuple\"\"\"\n        # noinspection PyTypeChecker\n        return tuple(v / 255 for v in self.rgb)\n\n    @property\n    def hex(self) -&gt; str:\n\"\"\"Hexadecimal representation of color value\"\"\"\n        r, g, b = self.rgb\n        return f\"#{r:02x}{g:02x}{b:02x}\"\n\n    @hex.setter\n    def hex(self, value: str) -&gt; None:\n\"\"\"Set the color value from a hexadecimal string\"\"\"\n        value = value.lstrip(\"#\")\n        # split hex into 3 parts of 2 digits and convert each to int from base-16 number\n        self.rgb = tuple(int(value[i : i + 2], 16) for i in (0, 2, 4))\n\n    @property\n    def hsv(self) -&gt; tuple[float, float, float]:\n\"\"\"The hue, saturation, value color values in a tuple\"\"\"\n        return colorsys.rgb_to_hsv(*self.rgb_float)\n\n    @hsv.setter\n    def hsv(self, value) -&gt; None:\n\"\"\"Set the color value from a tuple of (h, s, v) values\"\"\"\n        self.rgb = tuple(round(v * 255) for v in colorsys.hsv_to_rgb(*value))\n</code></pre>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.Color.value","title":"<code>value: int = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>The color value as an integer.</p>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.Color.clamp","title":"<code>clamp(x, min_value=0, max_value=255)</code>  <code>staticmethod</code>","text":"<p>Sanitise a value between a minimum and maximum value</p> Source code in <code>naff\\models\\discord\\color.py</code> <pre><code>@staticmethod\ndef clamp(x, min_value=0, max_value=255) -&gt; int:\n\"\"\"Sanitise a value between a minimum and maximum value\"\"\"\n    return max(min_value, min(x, max_value))\n</code></pre>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.Color.from_rgb","title":"<code>from_rgb(r, g, b)</code>  <code>classmethod</code>","text":"<p>Create a Color object from red, green and blue values.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int</code> <p>The red value.</p> required <code>g</code> <code>int</code> <p>The green value.</p> required <code>b</code> <code>int</code> <p>The blue value.</p> required <p>Returns:</p> Type Description <code>Color</code> <p>A Color object.</p> Source code in <code>naff\\models\\discord\\color.py</code> <pre><code>@classmethod\ndef from_rgb(cls, r: int, g: int, b: int) -&gt; \"Color\":\n\"\"\"\n    Create a Color object from red, green and blue values.\n\n    Args:\n        r: The red value.\n        g: The green value.\n        b: The blue value.\n\n    Returns:\n        A Color object.\n\n    \"\"\"\n    return cls((r, g, b))\n</code></pre>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.Color.from_hex","title":"<code>from_hex(value)</code>  <code>classmethod</code>","text":"<p>Create a Color object from a hexadecimal string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The hexadecimal string.</p> required <p>Returns:</p> Type Description <code>Color</code> <p>A Color object.</p> Source code in <code>naff\\models\\discord\\color.py</code> <pre><code>@classmethod\ndef from_hex(cls, value: str) -&gt; \"Color\":\n\"\"\"\n    Create a Color object from a hexadecimal string.\n\n    Args:\n        value: The hexadecimal string.\n\n    Returns:\n        A Color object.\n\n    \"\"\"\n    instance = cls()\n    instance.hex = value\n    return instance\n</code></pre>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.Color.from_hsv","title":"<code>from_hsv(h, s, v)</code>  <code>classmethod</code>","text":"<p>Create a Color object from a hue, saturation and value.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>int</code> <p>The hue value.</p> required <code>s</code> <code>int</code> <p>The saturation value.</p> required <code>v</code> <code>int</code> <p>The value value.</p> required <p>Returns:</p> Type Description <code>Color</code> <p>A Color object.</p> Source code in <code>naff\\models\\discord\\color.py</code> <pre><code>@classmethod\ndef from_hsv(cls, h: int, s: int, v: int) -&gt; \"Color\":\n\"\"\"\n    Create a Color object from a hue, saturation and value.\n\n    Args:\n        h: The hue value.\n        s: The saturation value.\n        v: The value value.\n\n    Returns:\n        A Color object.\n\n    \"\"\"\n    instance = cls()\n    instance.hsv = h, s, v\n    return instance\n</code></pre>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.Color.random","title":"<code>random()</code>  <code>classmethod</code>","text":"<p>Returns random Color instance</p> Source code in <code>naff\\models\\discord\\color.py</code> <pre><code>@classmethod\ndef random(cls) -&gt; \"Color\":\n\"\"\"Returns random Color instance\"\"\"\n    # FFFFFF == 16777215\n    return cls(randint(0, 16777215))\n</code></pre>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.Color.r","title":"<code>r: int</code>  <code>property</code>","text":"<p>Red color value</p>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.Color.g","title":"<code>g: int</code>  <code>property</code>","text":"<p>Green color value</p>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.Color.b","title":"<code>b: int</code>  <code>property</code>","text":"<p>Blue color value</p>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.Color.rgb","title":"<code>rgb: tuple[int, int, int]</code>  <code>property</code> <code>writable</code>","text":"<p>The red, green, blue color values in a tuple</p>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.Color.rgb_float","title":"<code>rgb_float: tuple[float, float, float]</code>  <code>property</code>","text":"<p>The red, green, blue color values in a tuple</p>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.Color.hex","title":"<code>hex: str</code>  <code>property</code> <code>writable</code>","text":"<p>Hexadecimal representation of color value</p>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.Color.hsv","title":"<code>hsv: tuple[float, float, float]</code>  <code>property</code> <code>writable</code>","text":"<p>The hue, saturation, value color values in a tuple</p>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.BrandColors","title":"<code>BrandColors</code>","text":"<p>         Bases: <code>Color</code>, <code>Enum</code></p> <p>A collection of colors complying to the Discord Brand specification.</p> <p>https://discord.com/branding</p> Source code in <code>naff\\models\\discord\\color.py</code> <pre><code>class BrandColors(Color, Enum):\n\"\"\"\n    A collection of colors complying to the Discord Brand specification.\n\n    https://discord.com/branding\n\n    \"\"\"\n\n    BLURPLE = \"#5865F2\"\n    GREEN = \"#57F287\"\n    YELLOW = \"#FEE75C\"\n    FUCHSIA = \"#EB459E\"\n    RED = \"#ED4245\"\n    WHITE = \"#FFFFFF\"\n    BLACK = \"#000000\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.MaterialColors","title":"<code>MaterialColors</code>","text":"<p>         Bases: <code>Color</code>, <code>Enum</code></p> <p>A collection of material ui colors.</p> <p>https://www.materialpalette.com/</p> Source code in <code>naff\\models\\discord\\color.py</code> <pre><code>class MaterialColors(Color, Enum):\n\"\"\"\n    A collection of material ui colors.\n\n    https://www.materialpalette.com/\n\n    \"\"\"\n\n    RED = \"#F44336\"\n    PINK = \"#E91E63\"\n    LAVENDER = \"#EDB9F5\"\n    PURPLE = \"#9C27B0\"\n    DEEP_PURPLE = \"#673AB7\"\n    INDIGO = \"#3F51B5\"\n    BLUE = \"#2196F3\"\n    LIGHT_BLUE = \"#03A9F4\"\n    CYAN = \"#00BCD4\"\n    TEAL = \"#009688\"\n    GREEN = \"#4CAF50\"\n    LIGHT_GREEN = \"#8BC34A\"\n    LIME = \"#CDDC39\"\n    YELLOW = \"#FFEB3B\"\n    AMBER = \"#FFC107\"\n    ORANGE = \"#FF9800\"\n    DEEP_ORANGE = \"#FF5722\"\n    BROWN = \"#795548\"\n    GREY = \"#9E9E9E\"\n    BLUE_GREY = \"#607D8B\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.FlatUIColors","title":"<code>FlatUIColors</code>","text":"<p>         Bases: <code>Color</code>, <code>Enum</code></p> <p>A collection of flat ui colours.</p> <p>https://materialui.co/flatuicolors</p> Source code in <code>naff\\models\\discord\\color.py</code> <pre><code>class FlatUIColors(Color, Enum):\n\"\"\"\n    A collection of flat ui colours.\n\n    https://materialui.co/flatuicolors\n\n    \"\"\"\n\n    TURQUOISE = \"#1ABC9C\"\n    EMERLAND = \"#2ECC71\"\n    PETERRIVER = \"#3498DB\"\n    AMETHYST = \"#9B59B6\"\n    WETASPHALT = \"#34495E\"\n    GREENSEA = \"#16A085\"\n    NEPHRITIS = \"#27AE60\"\n    BELIZEHOLE = \"#2980B9\"\n    WISTERIA = \"#8E44AD\"\n    MIDNIGHTBLUE = \"#2C3E50\"\n    SUNFLOWER = \"#F1C40F\"\n    CARROT = \"#E67E22\"\n    ALIZARIN = \"#E74C3C\"\n    CLOUDS = \"#ECF0F1\"\n    CONCRETE = \"#95A5A6\"\n    ORANGE = \"#F39C12\"\n    PUMPKIN = \"#D35400\"\n    POMEGRANATE = \"#C0392B\"\n    SILVER = \"#BDC3C7\"\n    ASBESTOS = \"#7F8C8D\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.RoleColors","title":"<code>RoleColors</code>","text":"<p>         Bases: <code>Color</code>, <code>Enum</code></p> <p>A collection of the default role colors Discord provides.</p> Source code in <code>naff\\models\\discord\\color.py</code> <pre><code>class RoleColors(Color, Enum):\n\"\"\"A collection of the default role colors Discord provides.\"\"\"\n\n    TEAL = \"#1ABC9C\"\n    DARK_TEAL = \"#11806A\"\n    GREEN = \"#2ECC71\"\n    DARK_GREEN = \"#1F8B4C\"\n    BLUE = \"#3498DB\"\n    DARK_BLUE = \"#206694\"\n    PURPLE = \"#9B59B6\"\n    DARK_PURPLE = \"#71368A\"\n    MAGENTA = \"#E91E63\"\n    DARK_MAGENTA = \"#AD1457\"\n    YELLOW = \"#F1C40F\"\n    DARK_YELLOW = \"#C27C0E\"\n    ORANGE = \"#E67E22\"\n    DARK_ORANGE = \"#A84300\"\n    RED = \"#E74C3C\"\n    DARK_RED = \"#992D22\"\n    LIGHTER_GRAY = \"#95A5A6\"\n    LIGHT_GRAY = \"#979C9F\"\n    DARK_GRAY = \"#607D8B\"\n    DARKER_GRAY = \"#546E7A\"\n\n    # a certain other lib called the yellows this\n    # i honestly cannot decide if they are or not\n    # so why not satisfy everyone here?\n    GOLD = YELLOW\n    DARK_GOLD = DARK_YELLOW\n\n    # aliases\n    LIGHT_GREY = LIGHT_GRAY\n    LIGHTER_GREY = LIGHTER_GRAY\n    DARK_GREY = DARK_GRAY\n    DARKER_GREY = DARKER_GRAY\n</code></pre>"},{"location":"API%20Reference/models/Discord/color/#naff.models.discord.color.process_color","title":"<code>process_color(color)</code>","text":"<p>Process color to a format that can be used by discord.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>Color | dict | COLOR_TYPES | None</code> <p>The color to process.</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>The processed color value.</p> Source code in <code>naff\\models\\discord\\color.py</code> <pre><code>def process_color(color: Color | dict | COLOR_TYPES | None) -&gt; int | None:\n\"\"\"\n    Process color to a format that can be used by discord.\n\n    Args:\n        color: The color to process.\n\n    Returns:\n        The processed color value.\n\n    \"\"\"\n    if not color:\n        return None\n    elif isinstance(color, Color):\n        return color.value\n    elif isinstance(color, dict):\n        return color[\"value\"]\n    elif isinstance(color, (tuple, list, str, int)):\n        return Color(color).value\n\n    raise ValueError(f\"Invalid color: {type(color)}\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/components/","title":"Components","text":""},{"location":"API%20Reference/models/Discord/components/#naff.models.discord.components.BaseComponent","title":"<code>BaseComponent</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> <p>A base component class.</p> <p>Warning</p> <p>This should never be instantiated.</p> Source code in <code>naff\\models\\discord\\components.py</code> <pre><code>class BaseComponent(DictSerializationMixin):\n\"\"\"\n    A base component class.\n\n    !!! Warning\n        This should never be instantiated.\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        raise NotImplementedError\n\n    @classmethod\n    def from_dict_factory(cls, data: dict) -&gt; \"TYPE_ALL_COMPONENT\":\n        data.pop(\"hash\", None)  # Zero clue why discord sometimes include a hash attribute...\n\n        component_type = data.pop(\"type\", None)\n        component_class = TYPE_COMPONENT_MAPPING.get(component_type, None)\n        if not component_class:\n            raise TypeError(f\"Unsupported component type for {data} ({component_type}), please consult the docs.\")\n\n        return component_class.from_dict(data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/components/#naff.models.discord.components.InteractiveComponent","title":"<code>InteractiveComponent</code>","text":"<p>         Bases: <code>BaseComponent</code></p> <p>A base interactive component class.</p> <p>Warning</p> <p>This should never be instantiated.</p> Source code in <code>naff\\models\\discord\\components.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, slots=False)\nclass InteractiveComponent(BaseComponent):\n\"\"\"\n    A base interactive component class.\n\n    !!! Warning\n        This should never be instantiated.\n\n    \"\"\"\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if isinstance(other, dict):\n            other = BaseComponent.from_dict_factory(other)\n            return self.custom_id == other.custom_id and self.type == other.type\n        return False\n</code></pre>"},{"location":"API%20Reference/models/Discord/components/#naff.models.discord.components.Button","title":"<code>Button</code>","text":"<p>         Bases: <code>InteractiveComponent</code></p> <p>Represents a discord ui button.</p> <p>Attributes:</p> Name Type Description <code>style</code> <code>optional[ButtonStyles, int]</code> <p>Buttons come in a variety of styles to convey different types of actions.</p> <code>label</code> <code>optional[str]</code> <p>The text that appears on the button, max 80 characters.</p> <code>emoji</code> <code>optional[Union[PartialEmoji, dict, str]]</code> <p>The emoji that appears on the button.</p> <code>custom_id</code> <code>Optional[str]</code> <p>A developer-defined identifier for the button, max 100 characters.</p> <code>url</code> <code>Optional[str]</code> <p>A url for link-style buttons.</p> <code>disabled</code> <code>bool</code> <p>Disable the button and make it not interactable, default false.</p> Source code in <code>naff\\models\\discord\\components.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Button(InteractiveComponent):\n\"\"\"\n    Represents a discord ui button.\n\n    Attributes:\n        style optional[ButtonStyles, int]: Buttons come in a variety of styles to convey different types of actions.\n        label optional[str]: The text that appears on the button, max 80 characters.\n        emoji optional[Union[PartialEmoji, dict, str]]: The emoji that appears on the button.\n        custom_id Optional[str]: A developer-defined identifier for the button, max 100 characters.\n        url Optional[str]: A url for link-style buttons.\n        disabled bool: Disable the button and make it not interactable, default false.\n\n    \"\"\"\n\n    style: Union[ButtonStyles, int] = attrs.field(repr=True)\n    label: Optional[str] = attrs.field(repr=False, default=None)\n    emoji: Optional[Union[\"PartialEmoji\", dict, str]] = attrs.field(\n        repr=True, default=None, metadata=export_converter(process_emoji)\n    )\n    custom_id: Optional[str] = attrs.field(repr=True, default=MISSING, validator=str_validator)\n    url: Optional[str] = attrs.field(repr=True, default=None)\n    disabled: bool = attrs.field(repr=True, default=False)\n    type: Union[ComponentTypes, int] = attrs.field(\n        repr=True, default=ComponentTypes.BUTTON, init=False, on_setattr=attrs.setters.frozen\n    )\n\n    @style.validator\n    def _style_validator(self, attribute: str, value: int) -&gt; None:\n        if not isinstance(value, ButtonStyles) and value not in ButtonStyles.__members__.values():\n            raise ValueError(f'Button style type of \"{value}\" not recognized, please consult the docs.')\n\n    def __attrs_post_init__(self) -&gt; None:\n        if self.style != ButtonStyles.URL:\n            # handle adding a custom id to any button that requires a custom id\n            if self.custom_id is MISSING:\n                self.custom_id = str(uuid.uuid4())\n\n    def _check_object(self) -&gt; None:\n        if self.style == ButtonStyles.URL:\n            if self.custom_id not in (None, MISSING):\n                raise TypeError(\"A link button cannot have a `custom_id`!\")\n            if not self.url:\n                raise TypeError(\"A link button must have a `url`!\")\n        else:\n            if self.url:\n                raise TypeError(\"You can't have a URL on a non-link button!\")\n\n        if not self.label and not self.emoji:\n            raise TypeError(\"You must have at least a label or emoji on a button.\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/components/#naff.models.discord.components.SelectOption","title":"<code>SelectOption</code>","text":"<p>         Bases: <code>BaseComponent</code></p> <p>Represents a select option.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>The label (max 80 characters)</p> <code>value</code> <code>str</code> <p>The value of the select, this is whats sent to your bot</p> <code>description</code> <code>Optional[str]</code> <p>A description of this option</p> <code>emoji</code> <code>Optional[Union[PartialEmoji, dict, str]</code> <p>An emoji to show in this select option</p> <code>default</code> <code>bool</code> <p>Is this option selected by default</p> Source code in <code>naff\\models\\discord\\components.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass SelectOption(BaseComponent):\n\"\"\"\n    Represents a select option.\n\n    Attributes:\n        label str: The label (max 80 characters)\n        value str: The value of the select, this is whats sent to your bot\n        description Optional[str]: A description of this option\n        emoji Optional[Union[PartialEmoji, dict, str]: An emoji to show in this select option\n        default bool: Is this option selected by default\n\n    \"\"\"\n\n    label: str = attrs.field(repr=True, validator=str_validator)\n    value: str = attrs.field(repr=True, validator=str_validator)\n    description: Optional[str] = attrs.field(repr=True, default=None)\n    emoji: Optional[Union[\"PartialEmoji\", dict, str]] = attrs.field(\n        repr=True, default=None, metadata=export_converter(process_emoji)\n    )\n    default: bool = attrs.field(repr=True, default=False)\n\n    @classmethod\n    def converter(cls, value: Any) -&gt; \"SelectOption\":\n        if isinstance(value, SelectOption):\n            return value\n        if isinstance(value, dict):\n            return cls.from_dict(value)\n\n        if isinstance(value, str):\n            return cls(label=value, value=value)\n\n        try:\n            possible_iter = iter(value)\n\n            return cls(label=possible_iter[0], value=possible_iter[1])\n        except TypeError:\n            pass\n\n        raise TypeError(f\"Cannot convert {value} of type {type(value)} to a SelectOption\")\n\n    @label.validator\n    def _label_validator(self, attribute: str, value: str) -&gt; None:\n        if not value or len(value) &gt; SELECT_MAX_NAME_LENGTH:\n            raise ValueError(\"Label length should be between 1 and 100.\")\n\n    @value.validator\n    def _value_validator(self, attribute: str, value: str) -&gt; None:\n        if not value or len(value) &gt; SELECT_MAX_NAME_LENGTH:\n            raise ValueError(\"Value length should be between 1 and 100.\")\n\n    @description.validator\n    def _description_validator(self, attribute: str, value: str) -&gt; None:\n        if value is not None and len(value) &gt; SELECT_MAX_NAME_LENGTH:\n            raise ValueError(\"Description length must be 100 or lower.\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/components/#naff.models.discord.components.BaseSelectMenu","title":"<code>BaseSelectMenu</code>","text":"<p>         Bases: <code>InteractiveComponent</code></p> <p>Represents a select menu component</p> <p>Attributes:</p> Name Type Description <code>custom_id</code> <code>str</code> <p>A developer-defined identifier for the button, max 100 characters.</p> <code>placeholder</code> <code>str</code> <p>The custom placeholder text to show if nothing is selected, max 100 characters.</p> <code>min_values</code> <code>Optional[int]</code> <p>The minimum number of items that must be chosen. (default 1, min 0, max 25)</p> <code>max_values</code> <code>Optional[int]</code> <p>The maximum number of items that can be chosen. (default 1, max 25)</p> <code>disabled</code> <code>bool</code> <p>Disable the select and make it not intractable, default false.</p> <code>type</code> <code>Union[ComponentTypes, int]</code> <p>The action role type number defined by discord. This cannot be modified.</p> Source code in <code>naff\\models\\discord\\components.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass BaseSelectMenu(InteractiveComponent):\n\"\"\"\n    Represents a select menu component\n\n    Attributes:\n        custom_id str: A developer-defined identifier for the button, max 100 characters.\n        placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters.\n        min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25)\n        max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25)\n        disabled bool: Disable the select and make it not intractable, default false.\n        type Union[ComponentTypes, int]: The action role type number defined by discord. This cannot be modified.\n    \"\"\"\n\n    min_values: int = attrs.field(repr=True, default=1, kw_only=True)\n    max_values: int = attrs.field(repr=True, default=1, kw_only=True)\n    placeholder: Optional[str] = attrs.field(repr=True, default=None, kw_only=True)\n\n    # generic component attributes\n    disabled: bool = attrs.field(repr=True, default=False, kw_only=True)\n    custom_id: str = attrs.field(repr=True, factory=lambda: str(uuid.uuid4()), validator=str_validator, kw_only=True)\n    type: Union[ComponentTypes, int] = attrs.field(\n        repr=True, default=ComponentTypes.STRING_SELECT, init=False, on_setattr=attrs.setters.frozen\n    )\n\n    @placeholder.validator\n    def _placeholder_validator(self, attribute: str, value: str) -&gt; None:\n        if value is not None and len(value) &gt; SELECT_MAX_NAME_LENGTH:\n            raise ValueError(\"Placeholder length must be 100 or lower.\")\n\n    @min_values.validator\n    def _min_values_validator(self, attribute: str, value: int) -&gt; None:\n        if value &lt; 0:\n            raise ValueError(\"StringSelectMenu min value cannot be a negative number.\")\n\n    @max_values.validator\n    def _max_values_validator(self, attribute: str, value: int) -&gt; None:\n        if value &lt; 0:\n            raise ValueError(\"StringSelectMenu max value cannot be a negative number.\")\n\n    def _check_object(self) -&gt; None:\n        super()._check_object()\n        if not self.custom_id:\n            raise TypeError(\"You need to have a custom id to identify the select.\")\n\n        if self.max_values &lt; self.min_values:\n            raise TypeError(\"Selects max value cannot be less than min value.\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/components/#naff.models.discord.components.StringSelectMenu","title":"<code>StringSelectMenu</code>","text":"<p>         Bases: <code>BaseSelectMenu</code></p> <p>Represents a string select component.</p> <p>Attributes:</p> Name Type Description <code>options</code> <code>List[dict]</code> <p>The choices in the select, max 25.</p> <code>custom_id</code> <code>str</code> <p>A developer-defined identifier for the button, max 100 characters.</p> <code>placeholder</code> <code>str</code> <p>The custom placeholder text to show if nothing is selected, max 100 characters.</p> <code>min_values</code> <code>Optional[int]</code> <p>The minimum number of items that must be chosen. (default 1, min 0, max 25)</p> <code>max_values</code> <code>Optional[int]</code> <p>The maximum number of items that can be chosen. (default 1, max 25)</p> <code>disabled</code> <code>bool</code> <p>Disable the select and make it not intractable, default false.</p> <code>type</code> <code>Union[ComponentTypes, int]</code> <p>The action role type number defined by discord. This cannot be modified.</p> Source code in <code>naff\\models\\discord\\components.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass StringSelectMenu(BaseSelectMenu):\n\"\"\"\n    Represents a string select component.\n\n    Attributes:\n        options List[dict]: The choices in the select, max 25.\n        custom_id str: A developer-defined identifier for the button, max 100 characters.\n        placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters.\n        min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25)\n        max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25)\n        disabled bool: Disable the select and make it not intractable, default false.\n        type Union[ComponentTypes, int]: The action role type number defined by discord. This cannot be modified.\n    \"\"\"\n\n    options: list[SelectOption | str] = attrs.field(repr=True, converter=list_converter(SelectOption.converter))\n    type: Union[ComponentTypes, int] = attrs.field(\n        repr=True, default=ComponentTypes.STRING_SELECT, init=False, on_setattr=attrs.setters.frozen\n    )\n\n    @options.validator\n    def _options_validator(self, attribute: str, value: List[Union[SelectOption, Dict]]) -&gt; None:\n        if not all(isinstance(x, (SelectOption, Dict)) for x in value):\n            raise ValueError(\"StringSelectMenu options must be of type `SelectOption`\")\n\n    def _check_object(self) -&gt; None:\n        super()._check_object()\n\n        if not self.options:\n            raise TypeError(\"Selects needs to have at least 1 option.\")\n\n        if len(self.options) &gt; SELECTS_MAX_OPTIONS:\n            raise TypeError(\"Selects can only hold 25 options\")\n\n    def add_option(self, option: str | SelectOption) -&gt; None:\n        option = SelectOption.converter(option)\n        self.options.append(option)\n</code></pre>"},{"location":"API%20Reference/models/Discord/components/#naff.models.discord.components.UserSelectMenu","title":"<code>UserSelectMenu</code>","text":"<p>         Bases: <code>BaseSelectMenu</code></p> <p>Represents a user select component.</p> <p>Attributes:</p> Name Type Description <code>custom_id</code> <code>str</code> <p>A developer-defined identifier for the button, max 100 characters.</p> <code>placeholder</code> <code>str</code> <p>The custom placeholder text to show if nothing is selected, max 100 characters.</p> <code>min_values</code> <code>Optional[int]</code> <p>The minimum number of items that must be chosen. (default 1, min 0, max 25)</p> <code>max_values</code> <code>Optional[int]</code> <p>The maximum number of items that can be chosen. (default 1, max 25)</p> <code>disabled</code> <code>bool</code> <p>Disable the select and make it not intractable, default false.</p> <code>type</code> <code>Union[ComponentTypes, int]</code> <p>The action role type number defined by discord. This cannot be modified.</p> Source code in <code>naff\\models\\discord\\components.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass UserSelectMenu(BaseSelectMenu):\n\"\"\"\n    Represents a user select component.\n\n    Attributes:\n        custom_id str: A developer-defined identifier for the button, max 100 characters.\n        placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters.\n        min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25)\n        max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25)\n        disabled bool: Disable the select and make it not intractable, default false.\n        type Union[ComponentTypes, int]: The action role type number defined by discord. This cannot be modified.\n    \"\"\"\n\n    type: Union[ComponentTypes, int] = attrs.field(\n        repr=True, default=ComponentTypes.USER_SELECT, init=False, on_setattr=attrs.setters.frozen\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/components/#naff.models.discord.components.RoleSelectMenu","title":"<code>RoleSelectMenu</code>","text":"<p>         Bases: <code>BaseSelectMenu</code></p> <p>Represents a role select component.</p> <p>Attributes:</p> Name Type Description <code>custom_id</code> <code>str</code> <p>A developer-defined identifier for the button, max 100 characters.</p> <code>placeholder</code> <code>str</code> <p>The custom placeholder text to show if nothing is selected, max 100 characters.</p> <code>min_values</code> <code>Optional[int]</code> <p>The minimum number of items that must be chosen. (default 1, min 0, max 25)</p> <code>max_values</code> <code>Optional[int]</code> <p>The maximum number of items that can be chosen. (default 1, max 25)</p> <code>disabled</code> <code>bool</code> <p>Disable the select and make it not intractable, default false.</p> <code>type</code> <code>Union[ComponentTypes, int]</code> <p>The action role type number defined by discord. This cannot be modified.</p> Source code in <code>naff\\models\\discord\\components.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass RoleSelectMenu(BaseSelectMenu):\n\"\"\"\n    Represents a role select component.\n\n    Attributes:\n        custom_id str: A developer-defined identifier for the button, max 100 characters.\n        placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters.\n        min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25)\n        max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25)\n        disabled bool: Disable the select and make it not intractable, default false.\n        type Union[ComponentTypes, int]: The action role type number defined by discord. This cannot be modified.\n    \"\"\"\n\n    type: Union[ComponentTypes, int] = attrs.field(\n        repr=True, default=ComponentTypes.ROLE_SELECT, init=False, on_setattr=attrs.setters.frozen\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/components/#naff.models.discord.components.MentionableSelectMenu","title":"<code>MentionableSelectMenu</code>","text":"<p>         Bases: <code>BaseSelectMenu</code></p> <p>Represents a mentionable select component.</p> <p>Attributes:</p> Name Type Description <code>custom_id</code> <code>str</code> <p>A developer-defined identifier for the button, max 100 characters.</p> <code>placeholder</code> <code>str</code> <p>The custom placeholder text to show if nothing is selected, max 100 characters.</p> <code>min_values</code> <code>Optional[int]</code> <p>The minimum number of items that must be chosen. (default 1, min 0, max 25)</p> <code>max_values</code> <code>Optional[int]</code> <p>The maximum number of items that can be chosen. (default 1, max 25)</p> <code>disabled</code> <code>bool</code> <p>Disable the select and make it not intractable, default false.</p> <code>type</code> <code>Union[ComponentTypes, int]</code> <p>The action role type number defined by discord. This cannot be modified.</p> Source code in <code>naff\\models\\discord\\components.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass MentionableSelectMenu(BaseSelectMenu):\n\"\"\"\n    Represents a mentionable select component.\n\n    Attributes:\n        custom_id str: A developer-defined identifier for the button, max 100 characters.\n        placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters.\n        min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25)\n        max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25)\n        disabled bool: Disable the select and make it not intractable, default false.\n        type Union[ComponentTypes, int]: The action role type number defined by discord. This cannot be modified.\n    \"\"\"\n\n    type: Union[ComponentTypes, int] = attrs.field(\n        repr=True, default=ComponentTypes.MENTIONABLE_SELECT, init=False, on_setattr=attrs.setters.frozen\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/components/#naff.models.discord.components.ChannelSelectMenu","title":"<code>ChannelSelectMenu</code>","text":"<p>         Bases: <code>BaseSelectMenu</code></p> <p>Represents a channel select component.</p> <p>Attributes:</p> Name Type Description <code>channel_types</code> <code>List[ChannelTypes]</code> <p>List of channel types to include in the selection</p> <code>custom_id</code> <code>str</code> <p>A developer-defined identifier for the button, max 100 characters.</p> <code>placeholder</code> <code>str</code> <p>The custom placeholder text to show if nothing is selected, max 100 characters.</p> <code>min_values</code> <code>Optional[int]</code> <p>The minimum number of items that must be chosen. (default 1, min 0, max 25)</p> <code>max_values</code> <code>Optional[int]</code> <p>The maximum number of items that can be chosen. (default 1, max 25)</p> <code>disabled</code> <code>bool</code> <p>Disable the select and make it not intractable, default false.</p> <code>type</code> <code>Union[ComponentTypes, int]</code> <p>The action role type number defined by discord. This cannot be modified.</p> Source code in <code>naff\\models\\discord\\components.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ChannelSelectMenu(BaseSelectMenu):\n\"\"\"\n    Represents a channel select component.\n\n    Attributes:\n        channel_types List[ChannelTypes]: List of channel types to include in the selection\n        custom_id str: A developer-defined identifier for the button, max 100 characters.\n        placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters.\n        min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25)\n        max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25)\n        disabled bool: Disable the select and make it not intractable, default false.\n        type Union[ComponentTypes, int]: The action role type number defined by discord. This cannot be modified.\n    \"\"\"\n\n    channel_types: list[ChannelTypes] = attrs.field(factory=list, repr=True, converter=list_converter(ChannelTypes))\n\n    type: Union[ComponentTypes, int] = attrs.field(\n        repr=True, default=ComponentTypes.CHANNEL_SELECT, init=False, on_setattr=attrs.setters.frozen\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/components/#naff.models.discord.components.ActionRow","title":"<code>ActionRow</code>","text":"<p>         Bases: <code>BaseComponent</code></p> <p>Represents an action row.</p> <p>Attributes:</p> Name Type Description <code>components</code> <code>List[Union[dict, StringSelectMenu, Button]]</code> <p>The components within this action row</p> <code>type</code> <code>Union[ComponentTypes, int]</code> <p>The action role type number defined by discord. This cannot be modified.</p> Source code in <code>naff\\models\\discord\\components.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ActionRow(BaseComponent):\n\"\"\"\n    Represents an action row.\n\n    Attributes:\n        components List[Union[dict, StringSelectMenu, Button]]: The components within this action row\n        type Union[ComponentTypes, int]: The action role type number defined by discord. This cannot be modified.\n\n    \"\"\"\n\n    _max_items = ACTION_ROW_MAX_ITEMS\n\n    components: Sequence[Union[dict, StringSelectMenu, Button]] = attrs.field(repr=True, factory=list)\n    type: Union[ComponentTypes, int] = attrs.field(\n        repr=False, default=ComponentTypes.ACTION_ROW, init=False, on_setattr=attrs.setters.frozen\n    )\n\n    def __init__(self, *components: Union[dict, StringSelectMenu, Button]) -&gt; None:\n        self.__attrs_init__(components)\n        self.components = [self._component_checks(c) for c in self.components]\n\n    def __len__(self) -&gt; int:\n        return len(self.components)\n\n    @classmethod\n    def from_dict(cls, data) -&gt; \"ActionRow\":\n        return cls(*data[\"components\"])\n\n    def _component_checks(self, component: Union[dict, StringSelectMenu, Button]) -&gt; Union[StringSelectMenu, Button]:\n        if isinstance(component, dict):\n            component = BaseComponent.from_dict_factory(component)\n\n        if not issubclass(type(component), InteractiveComponent):\n            raise TypeError(\"You can only add select or button to the action row.\")\n\n        component._check_object()\n        return component\n\n    def _check_object(self) -&gt; None:\n        if not (0 &lt; len(self.components) &lt;= ActionRow._max_items):\n            raise TypeError(f\"Number of components in one row should be between 1 and {ActionRow._max_items}.\")\n\n        if any(x.type == ComponentTypes.STRING_SELECT for x in self.components) and len(self.components) != 1:\n            raise TypeError(\"Action row must have only one select component and nothing else.\")\n\n    def add_components(self, *components: Union[dict, Button, StringSelectMenu]) -&gt; None:\n\"\"\"\n        Add one or more component(s) to this action row.\n\n        Args:\n            *components: The components to add\n\n        \"\"\"\n        self.components += [self._component_checks(c) for c in components]\n</code></pre>"},{"location":"API%20Reference/models/Discord/components/#naff.models.discord.components.ActionRow.add_components","title":"<code>add_components(*components)</code>","text":"<p>Add one or more component(s) to this action row.</p> <p>Parameters:</p> Name Type Description Default <code>*components</code> <code>Union[dict, Button, StringSelectMenu]</code> <p>The components to add</p> <code>()</code> Source code in <code>naff\\models\\discord\\components.py</code> <pre><code>def add_components(self, *components: Union[dict, Button, StringSelectMenu]) -&gt; None:\n\"\"\"\n    Add one or more component(s) to this action row.\n\n    Args:\n        *components: The components to add\n\n    \"\"\"\n    self.components += [self._component_checks(c) for c in components]\n</code></pre>"},{"location":"API%20Reference/models/Discord/components/#naff.models.discord.components.process_components","title":"<code>process_components(components)</code>","text":"<p>Process the passed components into a format discord will understand.</p> <p>Parameters:</p> Name Type Description Default <code>components</code> <code>Optional[Union[List[List[Union[BaseComponent, Dict]]], List[Union[BaseComponent, Dict]], BaseComponent, Dict]]</code> <p>List of dict / components to process</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>formatted dictionary for discord</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid components</p> Source code in <code>naff\\models\\discord\\components.py</code> <pre><code>def process_components(\n    components: Optional[\n        Union[List[List[Union[BaseComponent, Dict]]], List[Union[BaseComponent, Dict]], BaseComponent, Dict]\n    ]\n) -&gt; List[Dict]:\n\"\"\"\n    Process the passed components into a format discord will understand.\n\n    Args:\n        components: List of dict / components to process\n\n    Returns:\n        formatted dictionary for discord\n\n    Raises:\n        ValueError: Invalid components\n\n    \"\"\"\n    if not components:\n        # Its just empty, so nothing to process.\n        return components\n\n    if isinstance(components, dict):\n        # If a naked dictionary is passed, assume the user knows what they're doing and send it blindly\n        # after wrapping it in a list for discord\n        return [components]\n\n    if issubclass(type(components), BaseComponent):\n        # Naked component was passed\n        components = [components]\n\n    if isinstance(components, list):\n        if all(isinstance(c, dict) for c in components):\n            # user has passed a list of dicts, this is the correct format, blindly send it\n            return components\n\n        if all(isinstance(c, list) for c in components):\n            # list of lists... actionRow-less sending\n            return [ActionRow(*row).to_dict() for row in components]\n\n        if all(issubclass(type(c), InteractiveComponent) for c in components):\n            # list of naked components\n            return [ActionRow(*components).to_dict()]\n\n        if all(isinstance(c, ActionRow) for c in components):\n            # we have a list of action rows\n            return [action_row.to_dict() for action_row in components]\n\n    raise ValueError(f\"Invalid components: {components}\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/components/#naff.models.discord.components.spread_to_rows","title":"<code>spread_to_rows(*components, max_in_row=5)</code>","text":"<p>A helper function that spreads your components into <code>ActionRow</code>s of a set size.</p> <p>Parameters:</p> Name Type Description Default <code>*components</code> <code>Union[ActionRow, Button, StringSelectMenu]</code> <p>The components to spread, use <code>None</code> to explicit start a new row</p> <code>()</code> <code>max_in_row</code> <code>int</code> <p>The maximum number of components in each row</p> <code>5</code> <p>Returns:</p> Type Description <code>List[ActionRow]</code> <p>List[ActionRow] of components spread to rows</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Too many or few components or rows</p> Source code in <code>naff\\models\\discord\\components.py</code> <pre><code>def spread_to_rows(*components: Union[ActionRow, Button, StringSelectMenu], max_in_row: int = 5) -&gt; List[ActionRow]:\n\"\"\"\n    A helper function that spreads your components into `ActionRow`s of a set size.\n\n    Args:\n        *components: The components to spread, use `None` to explicit start a new row\n        max_in_row: The maximum number of components in each row\n\n    Returns:\n        List[ActionRow] of components spread to rows\n\n    Raises:\n        ValueError: Too many or few components or rows\n\n    \"\"\"\n    # todo: incorrect format errors\n    if not components or len(components) &gt; 25:\n        raise ValueError(\"Number of components should be between 1 and 25.\")\n    if not 1 &lt;= max_in_row &lt;= 5:\n        raise ValueError(\"max_in_row should be between 1 and 5.\")\n\n    rows = []\n    button_row = []\n    for component in list(components):\n        if component is not None and component.type == ComponentTypes.BUTTON:\n            button_row.append(component)\n\n            if len(button_row) == max_in_row:\n                rows.append(ActionRow(*button_row))\n                button_row = []\n\n            continue\n\n        if button_row:\n            rows.append(ActionRow(*button_row))\n            button_row = []\n\n        if component is not None:\n            if component.type == ComponentTypes.ACTION_ROW:\n                rows.append(component)\n            elif component.type == ComponentTypes.STRING_SELECT:\n                rows.append(ActionRow(component))\n    if button_row:\n        rows.append(ActionRow(*button_row))\n\n    if len(rows) &gt; 5:\n        raise ValueError(\"Number of rows exceeds 5.\")\n\n    return rows\n</code></pre>"},{"location":"API%20Reference/models/Discord/components/#naff.models.discord.components.get_components_ids","title":"<code>get_components_ids(component)</code>","text":"<p>Creates a generator with the <code>custom_id</code> of a component or list of components.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>Union[str, dict, list, InteractiveComponent]</code> <p>Objects to get <code>custom_id</code>s from</p> required <p>Returns:</p> Type Description <code>Iterator[str]</code> <p>Generator with the <code>custom_id</code> of a component or list of components.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Unknown component type</p> Source code in <code>naff\\models\\discord\\components.py</code> <pre><code>def get_components_ids(component: Union[str, dict, list, InteractiveComponent]) -&gt; Iterator[str]:\n\"\"\"\n    Creates a generator with the `custom_id` of a component or list of components.\n\n    Args:\n        component: Objects to get `custom_id`s from\n\n    Returns:\n        Generator with the `custom_id` of a component or list of components.\n\n    Raises:\n        ValueError: Unknown component type\n\n    \"\"\"\n    if isinstance(component, str):\n        yield component\n    elif isinstance(component, dict):\n        if component[\"type\"] == ComponentTypes.actionrow:\n            yield from (comp[\"custom_id\"] for comp in component[\"components\"] if \"custom_id\" in comp)\n        elif \"custom_id\" in component:\n            yield component[\"custom_id\"]\n    elif c_id := getattr(component, \"custom_id\", None):\n        yield c_id\n    elif isinstance(component, ActionRow):\n        yield from (comp_id for comp in component.components for comp_id in get_components_ids(comp))\n\n    elif isinstance(component, list):\n        yield from (comp_id for comp in component for comp_id in get_components_ids(comp))\n    else:\n        raise ValueError(f\"Unknown component type of {component} ({type(component)}). \" f\"Expected str, dict or list\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/embed/","title":"Embed","text":""},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.EmbedField","title":"<code>EmbedField</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> <p>Representation of an embed field.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Field name</p> <code>value</code> <code>str</code> <p>Field value</p> <code>inline</code> <code>bool</code> <p>If the field should be inline</p> Source code in <code>naff\\models\\discord\\embed.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass EmbedField(DictSerializationMixin):\n\"\"\"\n    Representation of an embed field.\n\n    Attributes:\n        name: Field name\n        value: Field value\n        inline: If the field should be inline\n\n    \"\"\"\n\n    name: str = attrs.field(\n        repr=False,\n    )\n    value: str = attrs.field(\n        repr=False,\n    )\n    inline: bool = attrs.field(repr=False, default=False)\n\n    @name.validator\n    def _name_validation(self, attribute: str, value: Any) -&gt; None:\n        if len(value) &gt; EMBED_MAX_NAME_LENGTH:\n            raise ValueError(f\"Field name cannot exceed {EMBED_MAX_NAME_LENGTH} characters\")\n\n    @value.validator\n    def _value_validation(self, attribute: str, value: Any) -&gt; None:\n        if len(value) &gt; EMBED_FIELD_VALUE_LENGTH:\n            raise ValueError(f\"Field value cannot exceed {EMBED_FIELD_VALUE_LENGTH} characters\")\n\n    def __len__(self) -&gt; int:\n        return len(self.name) + len(self.value)\n</code></pre>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.EmbedAuthor","title":"<code>EmbedAuthor</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> <p>Representation of an embed author.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Optional[str]</code> <p>Name to show on embed</p> <code>url</code> <code>Optional[str]</code> <p>Url to go to when name is clicked</p> <code>icon_url</code> <code>Optional[str]</code> <p>Icon to show next to name</p> <code>proxy_icon_url</code> <code>Optional[str]</code> <p>Proxy icon url</p> Source code in <code>naff\\models\\discord\\embed.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass EmbedAuthor(DictSerializationMixin):\n\"\"\"\n    Representation of an embed author.\n\n    Attributes:\n        name: Name to show on embed\n        url: Url to go to when name is clicked\n        icon_url: Icon to show next to name\n        proxy_icon_url: Proxy icon url\n\n    \"\"\"\n\n    name: Optional[str] = attrs.field(repr=False, default=None)\n    url: Optional[str] = attrs.field(repr=False, default=None)\n    icon_url: Optional[str] = attrs.field(repr=False, default=None)\n    proxy_icon_url: Optional[str] = attrs.field(repr=False, default=None, metadata=no_export_meta)\n\n    @name.validator\n    def _name_validation(self, attribute: str, value: Any) -&gt; None:\n        if len(value) &gt; EMBED_MAX_NAME_LENGTH:\n            raise ValueError(f\"Field name cannot exceed {EMBED_MAX_NAME_LENGTH} characters\")\n\n    def __len__(self) -&gt; int:\n        return len(self.name)\n</code></pre>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.EmbedAttachment","title":"<code>EmbedAttachment</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> <p>Representation of an attachment.</p> <p>Attributes:</p> Name Type Description <code>url</code> <code>Optional[str]</code> <p>Attachment url</p> <code>proxy_url</code> <code>Optional[str]</code> <p>Proxy url</p> <code>height</code> <code>Optional[int]</code> <p>Attachment height</p> <code>width</code> <code>Optional[int]</code> <p>Attachment width</p> Source code in <code>naff\\models\\discord\\embed.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass EmbedAttachment(DictSerializationMixin):  # thumbnail or image or video\n\"\"\"\n    Representation of an attachment.\n\n    Attributes:\n        url: Attachment url\n        proxy_url: Proxy url\n        height: Attachment height\n        width: Attachment width\n\n    \"\"\"\n\n    url: Optional[str] = attrs.field(repr=False, default=None)\n    proxy_url: Optional[str] = attrs.field(repr=False, default=None, metadata=no_export_meta)\n    height: Optional[int] = attrs.field(repr=False, default=None, metadata=no_export_meta)\n    width: Optional[int] = attrs.field(repr=False, default=None, metadata=no_export_meta)\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        if isinstance(data, str):\n            return {\"url\": data}\n        return data\n\n    @property\n    def size(self) -&gt; tuple[Optional[int], Optional[int]]:\n        return self.height, self.width\n</code></pre>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.EmbedFooter","title":"<code>EmbedFooter</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> <p>Representation of an Embed Footer.</p> <p>Attributes:</p> Name Type Description <code>text</code> <code>str</code> <p>Footer text</p> <code>icon_url</code> <code>Optional[str]</code> <p>Footer icon url</p> <code>proxy_icon_url</code> <code>Optional[str]</code> <p>Proxy icon url</p> Source code in <code>naff\\models\\discord\\embed.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass EmbedFooter(DictSerializationMixin):\n\"\"\"\n    Representation of an Embed Footer.\n\n    Attributes:\n        text: Footer text\n        icon_url: Footer icon url\n        proxy_icon_url: Proxy icon url\n\n    \"\"\"\n\n    text: str = attrs.field(\n        repr=False,\n    )\n    icon_url: Optional[str] = attrs.field(repr=False, default=None)\n    proxy_icon_url: Optional[str] = attrs.field(repr=False, default=None, metadata=no_export_meta)\n\n    @classmethod\n    def converter(cls, ingest: Union[dict, str, \"EmbedFooter\"]) -&gt; \"EmbedFooter\":\n\"\"\"\n        A converter to handle users passing raw strings or dictionaries as footers to the Embed object.\n\n        Args:\n            ingest: The data to convert\n\n        Returns:\n            An EmbedFooter object\n        \"\"\"\n        if isinstance(ingest, str):\n            return cls(text=ingest)\n        else:\n            return cls.from_dict(ingest)\n\n    def __len__(self) -&gt; int:\n        return len(self.text)\n</code></pre>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.EmbedFooter.converter","title":"<code>converter(ingest)</code>  <code>classmethod</code>","text":"<p>A converter to handle users passing raw strings or dictionaries as footers to the Embed object.</p> <p>Parameters:</p> Name Type Description Default <code>ingest</code> <code>Union[dict, str, EmbedFooter]</code> <p>The data to convert</p> required <p>Returns:</p> Type Description <code>EmbedFooter</code> <p>An EmbedFooter object</p> Source code in <code>naff\\models\\discord\\embed.py</code> <pre><code>@classmethod\ndef converter(cls, ingest: Union[dict, str, \"EmbedFooter\"]) -&gt; \"EmbedFooter\":\n\"\"\"\n    A converter to handle users passing raw strings or dictionaries as footers to the Embed object.\n\n    Args:\n        ingest: The data to convert\n\n    Returns:\n        An EmbedFooter object\n    \"\"\"\n    if isinstance(ingest, str):\n        return cls(text=ingest)\n    else:\n        return cls.from_dict(ingest)\n</code></pre>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.EmbedProvider","title":"<code>EmbedProvider</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> <p>Represents an embed's provider.</p> <p>Note</p> <p>Only used by system embeds, not bots</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Optional[str]</code> <p>Provider name</p> <code>url</code> <code>Optional[str]</code> <p>Provider url</p> Source code in <code>naff\\models\\discord\\embed.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass EmbedProvider(DictSerializationMixin):\n\"\"\"\n    Represents an embed's provider.\n\n    !!! note\n        Only used by system embeds, not bots\n\n    Attributes:\n        name: Provider name\n        url: Provider url\n\n    \"\"\"\n\n    name: Optional[str] = attrs.field(repr=False, default=None)\n    url: Optional[str] = attrs.field(repr=False, default=None)\n</code></pre>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed","title":"<code>Embed</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> <p>Represents a discord embed object.</p> Source code in <code>naff\\models\\discord\\embed.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Embed(DictSerializationMixin):\n\"\"\"Represents a discord embed object.\"\"\"\n\n    title: Optional[str] = attrs.field(default=None, repr=True)\n\"\"\"The title of the embed\"\"\"\n    description: Optional[str] = attrs.field(default=None, repr=True)\n\"\"\"The description of the embed\"\"\"\n    color: Optional[Union[Color, dict, tuple, list, str, int]] = attrs.field(\n        default=None, repr=True, metadata=export_converter(process_color)\n    )\n\"\"\"The colour of the embed\"\"\"\n    url: Optional[str] = attrs.field(default=None, validator=v_optional(instance_of(str)), repr=True)\n\"\"\"The url the embed should direct to when clicked\"\"\"\n    timestamp: Optional[Timestamp] = attrs.field(\n        default=None,\n        converter=c_optional(timestamp_converter),\n        validator=v_optional(instance_of((datetime, float, int))),\n        repr=True,\n    )\n\"\"\"Timestamp of embed content\"\"\"\n    fields: List[EmbedField] = attrs.field(factory=list, converter=EmbedField.from_list, repr=True)\n\"\"\"A list of [fields][naff.models.discord.embed.EmbedField] to go in the embed\"\"\"\n    author: Optional[EmbedAuthor] = attrs.field(repr=False, default=None, converter=c_optional(EmbedAuthor.from_dict))\n\"\"\"The author of the embed\"\"\"\n    thumbnail: Optional[EmbedAttachment] = attrs.field(\n        repr=False, default=None, converter=c_optional(EmbedAttachment.from_dict)\n    )\n\"\"\"The thumbnail of the embed\"\"\"\n    image: Optional[EmbedAttachment] = attrs.field(\n        repr=False, default=None, converter=c_optional(EmbedAttachment.from_dict)\n    )\n\"\"\"The image of the embed\"\"\"\n    video: Optional[EmbedAttachment] = attrs.field(\n        repr=False, default=None, converter=c_optional(EmbedAttachment.from_dict), metadata=no_export_meta\n    )\n\"\"\"The video of the embed, only used by system embeds\"\"\"\n    footer: Optional[EmbedFooter] = attrs.field(repr=False, default=None, converter=c_optional(EmbedFooter.converter))\n\"\"\"The footer of the embed\"\"\"\n    provider: Optional[EmbedProvider] = attrs.field(\n        repr=False, default=None, converter=c_optional(EmbedProvider.from_dict), metadata=no_export_meta\n    )\n\"\"\"The provider of the embed, only used for system embeds\"\"\"\n    type: EmbedTypes = attrs.field(\n        repr=False, default=EmbedTypes.RICH, converter=c_optional(EmbedTypes), metadata=no_export_meta\n    )\n\n    @title.validator\n    def _name_validation(self, attribute: str, value: Any) -&gt; None:\n\"\"\"Validate the embed title.\"\"\"\n        if value is not None:\n            if isinstance(value, str):\n                if len(value) &gt; EMBED_MAX_NAME_LENGTH:\n                    raise ValueError(f\"Title cannot exceed {EMBED_MAX_NAME_LENGTH} characters\")\n                return\n            raise TypeError(\"Title must be of type String\")\n\n    @description.validator\n    def _description_validation(self, attribute: str, value: Any) -&gt; None:\n\"\"\"Validate the description.\"\"\"\n        if value is not None:\n            if isinstance(value, str):\n                if len(value) &gt; EMBED_MAX_DESC_LENGTH:\n                    raise ValueError(f\"Description cannot exceed {EMBED_MAX_DESC_LENGTH} characters\")\n                return\n            raise TypeError(\"Description must be of type String\")\n\n    @fields.validator\n    def _fields_validation(self, attribute: str, value: Any) -&gt; None:\n\"\"\"Validate the fields.\"\"\"\n        if isinstance(value, list):\n            if len(value) &gt; EMBED_MAX_FIELDS:\n                raise ValueError(f\"Embeds can only hold {EMBED_MAX_FIELDS} fields\")\n\n    def _check_object(self) -&gt; None:\n        self._name_validation(\"title\", self.title)\n        self._description_validation(\"description\", self.description)\n        self._fields_validation(\"fields\", self.fields)\n\n        if len(self) &gt; EMBED_TOTAL_MAX:\n            raise ValueError(\n                \"Your embed is too large, more info at https://discord.com/developers/docs/resources/channel#embed-limits\"\n            )\n\n    def __len__(self) -&gt; int:\n        # yes i know there are far more optimal ways to write this\n        # its written like this for readability\n        total: int = 0\n        if self.title:\n            total += len(self.title)\n        if self.description:\n            total += len(self.description)\n        if self.footer:\n            total += len(self.footer)\n        if self.author:\n            total += len(self.author)\n        if self.fields:\n            total += sum(map(len, self.fields))\n        return total\n\n    def __bool__(self) -&gt; bool:\n        return any(\n            (\n                self.title,\n                self.description,\n                self.fields,\n                self.author,\n                self.thumbnail,\n                self.footer,\n                self.image,\n                self.video,\n            )\n        )\n\n    def set_author(\n        self,\n        name: str,\n        url: Optional[str] = None,\n        icon_url: Optional[str] = None,\n    ) -&gt; None:\n\"\"\"\n        Set the author field of the embed.\n\n        Args:\n            name: The text to go in the title section\n            url: A url link to the author\n            icon_url: A url of an image to use as the icon\n\n        \"\"\"\n        self.author = EmbedAuthor(name=name, url=url, icon_url=icon_url)\n\n    def set_thumbnail(self, url: str) -&gt; None:\n\"\"\"\n        Set the thumbnail of the embed.\n\n        Args:\n            url: the url of the image to use\n\n        \"\"\"\n        self.thumbnail = EmbedAttachment(url=url)\n\n    def set_image(self, url: str) -&gt; None:\n\"\"\"\n        Set the image of the embed.\n\n        Args:\n            url: the url of the image to use\n\n        \"\"\"\n        self.image = EmbedAttachment(url=url)\n\n    def set_footer(self, text: str, icon_url: Optional[str] = None) -&gt; None:\n\"\"\"\n        Set the footer field of the embed.\n\n        Args:\n            text: The text to go in the title section\n            icon_url: A url of an image to use as the icon\n\n        \"\"\"\n        self.footer = EmbedFooter(text=text, icon_url=icon_url)\n\n    def add_field(self, name: str, value: Any, inline: bool = False) -&gt; None:\n\"\"\"\n        Add a field to the embed.\n\n        Args:\n            name: The title of this field\n            value: The value in this field\n            inline: Should this field be inline with other fields?\n\n        \"\"\"\n        self.fields.append(EmbedField(name, str(value), inline))\n        self._fields_validation(\"fields\", self.fields)\n\n    def add_fields(self, *fields: EmbedField | str | dict) -&gt; None:\n\"\"\"\n        Add multiple fields to the embed.\n\n        Args:\n            fields: The fields to add\n\n        \"\"\"\n        for _field in fields:\n            if isinstance(_field, EmbedField):\n                self.fields.append(_field)\n                self._fields_validation(\"fields\", self.fields)\n            elif isinstance(_field, str):\n                self.add_field(_field, _field)\n            elif isinstance(_field, dict):\n                self.add_field(**_field)\n            else:\n                raise TypeError(f\"Expected EmbedField, str or dict, got {type(_field).__name__}\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.title","title":"<code>title: Optional[str] = attrs.field(default=None, repr=True)</code>  <code>class-attribute</code>","text":"<p>The title of the embed</p>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.description","title":"<code>description: Optional[str] = attrs.field(default=None, repr=True)</code>  <code>class-attribute</code>","text":"<p>The description of the embed</p>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.color","title":"<code>color: Optional[Union[Color, dict, tuple, list, str, int]] = attrs.field(default=None, repr=True, metadata=export_converter(process_color))</code>  <code>class-attribute</code>","text":"<p>The colour of the embed</p>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.url","title":"<code>url: Optional[str] = attrs.field(default=None, validator=v_optional(instance_of(str)), repr=True)</code>  <code>class-attribute</code>","text":"<p>The url the embed should direct to when clicked</p>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.timestamp","title":"<code>timestamp: Optional[Timestamp] = attrs.field(default=None, converter=c_optional(timestamp_converter), validator=v_optional(instance_of((datetime, float, int))), repr=True)</code>  <code>class-attribute</code>","text":"<p>Timestamp of embed content</p>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.fields","title":"<code>fields: List[EmbedField] = attrs.field(factory=list, converter=EmbedField.from_list, repr=True)</code>  <code>class-attribute</code>","text":"<p>A list of fields to go in the embed</p>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.author","title":"<code>author: Optional[EmbedAuthor] = attrs.field(repr=False, default=None, converter=c_optional(EmbedAuthor.from_dict))</code>  <code>class-attribute</code>","text":"<p>The author of the embed</p>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.thumbnail","title":"<code>thumbnail: Optional[EmbedAttachment] = attrs.field(repr=False, default=None, converter=c_optional(EmbedAttachment.from_dict))</code>  <code>class-attribute</code>","text":"<p>The thumbnail of the embed</p>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.image","title":"<code>image: Optional[EmbedAttachment] = attrs.field(repr=False, default=None, converter=c_optional(EmbedAttachment.from_dict))</code>  <code>class-attribute</code>","text":"<p>The image of the embed</p>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.video","title":"<code>video: Optional[EmbedAttachment] = attrs.field(repr=False, default=None, converter=c_optional(EmbedAttachment.from_dict), metadata=no_export_meta)</code>  <code>class-attribute</code>","text":"<p>The video of the embed, only used by system embeds</p>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.footer","title":"<code>footer: Optional[EmbedFooter] = attrs.field(repr=False, default=None, converter=c_optional(EmbedFooter.converter))</code>  <code>class-attribute</code>","text":"<p>The footer of the embed</p>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.provider","title":"<code>provider: Optional[EmbedProvider] = attrs.field(repr=False, default=None, converter=c_optional(EmbedProvider.from_dict), metadata=no_export_meta)</code>  <code>class-attribute</code>","text":"<p>The provider of the embed, only used for system embeds</p>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.set_author","title":"<code>set_author(name, url=None, icon_url=None)</code>","text":"<p>Set the author field of the embed.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The text to go in the title section</p> required <code>url</code> <code>Optional[str]</code> <p>A url link to the author</p> <code>None</code> <code>icon_url</code> <code>Optional[str]</code> <p>A url of an image to use as the icon</p> <code>None</code> Source code in <code>naff\\models\\discord\\embed.py</code> <pre><code>def set_author(\n    self,\n    name: str,\n    url: Optional[str] = None,\n    icon_url: Optional[str] = None,\n) -&gt; None:\n\"\"\"\n    Set the author field of the embed.\n\n    Args:\n        name: The text to go in the title section\n        url: A url link to the author\n        icon_url: A url of an image to use as the icon\n\n    \"\"\"\n    self.author = EmbedAuthor(name=name, url=url, icon_url=icon_url)\n</code></pre>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.set_thumbnail","title":"<code>set_thumbnail(url)</code>","text":"<p>Set the thumbnail of the embed.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>the url of the image to use</p> required Source code in <code>naff\\models\\discord\\embed.py</code> <pre><code>def set_thumbnail(self, url: str) -&gt; None:\n\"\"\"\n    Set the thumbnail of the embed.\n\n    Args:\n        url: the url of the image to use\n\n    \"\"\"\n    self.thumbnail = EmbedAttachment(url=url)\n</code></pre>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.set_image","title":"<code>set_image(url)</code>","text":"<p>Set the image of the embed.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>the url of the image to use</p> required Source code in <code>naff\\models\\discord\\embed.py</code> <pre><code>def set_image(self, url: str) -&gt; None:\n\"\"\"\n    Set the image of the embed.\n\n    Args:\n        url: the url of the image to use\n\n    \"\"\"\n    self.image = EmbedAttachment(url=url)\n</code></pre>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.set_footer","title":"<code>set_footer(text, icon_url=None)</code>","text":"<p>Set the footer field of the embed.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to go in the title section</p> required <code>icon_url</code> <code>Optional[str]</code> <p>A url of an image to use as the icon</p> <code>None</code> Source code in <code>naff\\models\\discord\\embed.py</code> <pre><code>def set_footer(self, text: str, icon_url: Optional[str] = None) -&gt; None:\n\"\"\"\n    Set the footer field of the embed.\n\n    Args:\n        text: The text to go in the title section\n        icon_url: A url of an image to use as the icon\n\n    \"\"\"\n    self.footer = EmbedFooter(text=text, icon_url=icon_url)\n</code></pre>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.add_field","title":"<code>add_field(name, value, inline=False)</code>","text":"<p>Add a field to the embed.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The title of this field</p> required <code>value</code> <code>Any</code> <p>The value in this field</p> required <code>inline</code> <code>bool</code> <p>Should this field be inline with other fields?</p> <code>False</code> Source code in <code>naff\\models\\discord\\embed.py</code> <pre><code>def add_field(self, name: str, value: Any, inline: bool = False) -&gt; None:\n\"\"\"\n    Add a field to the embed.\n\n    Args:\n        name: The title of this field\n        value: The value in this field\n        inline: Should this field be inline with other fields?\n\n    \"\"\"\n    self.fields.append(EmbedField(name, str(value), inline))\n    self._fields_validation(\"fields\", self.fields)\n</code></pre>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.Embed.add_fields","title":"<code>add_fields(*fields)</code>","text":"<p>Add multiple fields to the embed.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>EmbedField | str | dict</code> <p>The fields to add</p> <code>()</code> Source code in <code>naff\\models\\discord\\embed.py</code> <pre><code>def add_fields(self, *fields: EmbedField | str | dict) -&gt; None:\n\"\"\"\n    Add multiple fields to the embed.\n\n    Args:\n        fields: The fields to add\n\n    \"\"\"\n    for _field in fields:\n        if isinstance(_field, EmbedField):\n            self.fields.append(_field)\n            self._fields_validation(\"fields\", self.fields)\n        elif isinstance(_field, str):\n            self.add_field(_field, _field)\n        elif isinstance(_field, dict):\n            self.add_field(**_field)\n        else:\n            raise TypeError(f\"Expected EmbedField, str or dict, got {type(_field).__name__}\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/embed/#naff.models.discord.embed.process_embeds","title":"<code>process_embeds(embeds)</code>","text":"<p>Process the passed embeds into a format discord will understand.</p> <p>Parameters:</p> Name Type Description Default <code>embeds</code> <code>Optional[Union[List[Union[Embed, Dict]], Union[Embed, Dict]]]</code> <p>List of dict / embeds to process</p> required <p>Returns:</p> Type Description <code>Optional[List[dict]]</code> <p>formatted list for discord</p> Source code in <code>naff\\models\\discord\\embed.py</code> <pre><code>def process_embeds(embeds: Optional[Union[List[Union[Embed, Dict]], Union[Embed, Dict]]]) -&gt; Optional[List[dict]]:\n\"\"\"\n    Process the passed embeds into a format discord will understand.\n\n    Args:\n        embeds: List of dict / embeds to process\n\n    Returns:\n        formatted list for discord\n\n    \"\"\"\n    if embeds is None:\n        # Its just empty, so nothing to process.\n        return embeds\n\n    if isinstance(embeds, Embed):\n        # Single embed, convert it to dict and wrap it into a list for discord.\n        return [embeds.to_dict()]\n\n    if isinstance(embeds, dict):\n        # We assume the dict correctly represents a single discord embed and just send it blindly\n        # after wrapping it in a list for discord\n        return [embeds]\n\n    if isinstance(embeds, list):\n        # A list of embeds, convert Embed to dict representation if needed.\n        return [embed.to_dict() if isinstance(embed, Embed) else embed for embed in embeds]\n\n    raise ValueError(f\"Invalid embeds: {embeds}\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/emoji/","title":"Emoji","text":""},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.PartialEmoji","title":"<code>PartialEmoji</code>","text":"<p>         Bases: <code>SnowflakeObject</code>, <code>DictSerializationMixin</code></p> <p>Represent a basic (\"partial\") emoji used in discord.</p> Source code in <code>naff\\models\\discord\\emoji.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass PartialEmoji(SnowflakeObject, DictSerializationMixin):\n\"\"\"Represent a basic (\"partial\") emoji used in discord.\"\"\"\n\n    id: Optional[\"Snowflake_Type\"] = attrs.field(\n        repr=True, default=None, converter=optional(to_snowflake)\n    )  # can be None for Standard Emoji\n\"\"\"The custom emoji id. Leave empty if you are using standard unicode emoji.\"\"\"\n    name: Optional[str] = attrs.field(repr=True, default=None)\n\"\"\"The custom emoji name, or standard unicode emoji in string\"\"\"\n    animated: bool = attrs.field(repr=True, default=False)\n\"\"\"Whether this emoji is animated\"\"\"\n\n    @classmethod\n    def from_str(cls, emoji_str: str, *, language: str = \"alias\") -&gt; Optional[\"PartialEmoji\"]:\n\"\"\"\n        Generate a PartialEmoji from a discord Emoji string representation, or unicode emoji.\n\n        Handles:\n            &lt;:emoji_name:emoji_id&gt;\n            :emoji_name:emoji_id\n            &lt;a:emoji_name:emoji_id&gt;\n            a:emoji_name:emoji_id\n            \ud83d\udc4b\n            :wave:\n\n        Args:\n            emoji_str: The string representation an emoji\n            language: The language to use for the unicode emoji parsing\n\n        Returns:\n            A PartialEmoji object\n\n        Raises:\n            ValueError: if the string cannot be parsed\n\n        \"\"\"\n        parsed = emoji_regex.findall(emoji_str)\n        if parsed:\n            parsed = tuple(filter(None, parsed[0]))\n            if len(parsed) == 3:\n                return cls(name=parsed[1], id=parsed[2], animated=True)\n            elif len(parsed) == 2:\n                return cls(name=parsed[0], id=parsed[1])\n            else:\n                _name = emoji.emojize(emoji_str, language=language)\n                _emoji_list = emoji.distinct_emoji_list(_name)\n                if _emoji_list:\n                    return cls(name=_emoji_list[0])\n        else:\n            # check if it's a unicode emoji\n            _emoji_list = emoji.distinct_emoji_list(emoji_str)\n            if _emoji_list:\n                return cls(name=_emoji_list[0])\n\n            # the emoji lib handles *most* emoji, however there are certain ones that it misses\n            # this acts as a fallback check\n            if matches := unicode_emoji_reg.search(emoji_str):\n                match = matches.group()\n\n                # the regex will match certain special characters, so this acts as a final failsafe\n                if match not in string.printable:\n                    if unicodedata.category(match) == \"So\":\n                        return cls(name=match)\n        return None\n\n    def __str__(self) -&gt; str:\n        s = self.req_format\n        if self.id:\n            s = f\"&lt;{'a:' if self.animated else ':'}{s}&gt;\"\n        return s\n\n    def __eq__(self, other) -&gt; bool:\n        if not isinstance(other, PartialEmoji):\n            return False\n        if self.id:\n            return self.id == other.id\n        return self.name == other.name\n\n    @property\n    def req_format(self) -&gt; str:\n\"\"\"Format used for web request.\"\"\"\n        if self.id:\n            return f\"{self.name}:{self.id}\"\n        else:\n            return self.name\n</code></pre>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.PartialEmoji.id","title":"<code>id: Optional[Snowflake_Type] = attrs.field(repr=True, default=None, converter=optional(to_snowflake))</code>  <code>class-attribute</code>","text":"<p>The custom emoji id. Leave empty if you are using standard unicode emoji.</p>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.PartialEmoji.name","title":"<code>name: Optional[str] = attrs.field(repr=True, default=None)</code>  <code>class-attribute</code>","text":"<p>The custom emoji name, or standard unicode emoji in string</p>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.PartialEmoji.animated","title":"<code>animated: bool = attrs.field(repr=True, default=False)</code>  <code>class-attribute</code>","text":"<p>Whether this emoji is animated</p>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.PartialEmoji.from_str","title":"<code>from_str(emoji_str, *, language='alias')</code>  <code>classmethod</code>","text":"<p>Generate a PartialEmoji from a discord Emoji string representation, or unicode emoji.</p> Handles <p>&lt;:emoji_name:emoji_id&gt; :emoji_name:emoji_id  a:emoji_name:emoji_id \ud83d\udc4b  <p>Parameters:</p> Name Type Description Default <code>emoji_str</code> <code>str</code> <p>The string representation an emoji</p> required <code>language</code> <code>str</code> <p>The language to use for the unicode emoji parsing</p> <code>'alias'</code> <p>Returns:</p> Type Description <code>Optional[PartialEmoji]</code> <p>A PartialEmoji object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the string cannot be parsed</p> Source code in <code>naff\\models\\discord\\emoji.py</code> <pre><code>@classmethod\ndef from_str(cls, emoji_str: str, *, language: str = \"alias\") -&gt; Optional[\"PartialEmoji\"]:\n\"\"\"\n    Generate a PartialEmoji from a discord Emoji string representation, or unicode emoji.\n\n    Handles:\n        &lt;:emoji_name:emoji_id&gt;\n        :emoji_name:emoji_id\n        &lt;a:emoji_name:emoji_id&gt;\n        a:emoji_name:emoji_id\n        \ud83d\udc4b\n        :wave:\n\n    Args:\n        emoji_str: The string representation an emoji\n        language: The language to use for the unicode emoji parsing\n\n    Returns:\n        A PartialEmoji object\n\n    Raises:\n        ValueError: if the string cannot be parsed\n\n    \"\"\"\n    parsed = emoji_regex.findall(emoji_str)\n    if parsed:\n        parsed = tuple(filter(None, parsed[0]))\n        if len(parsed) == 3:\n            return cls(name=parsed[1], id=parsed[2], animated=True)\n        elif len(parsed) == 2:\n            return cls(name=parsed[0], id=parsed[1])\n        else:\n            _name = emoji.emojize(emoji_str, language=language)\n            _emoji_list = emoji.distinct_emoji_list(_name)\n            if _emoji_list:\n                return cls(name=_emoji_list[0])\n    else:\n        # check if it's a unicode emoji\n        _emoji_list = emoji.distinct_emoji_list(emoji_str)\n        if _emoji_list:\n            return cls(name=_emoji_list[0])\n\n        # the emoji lib handles *most* emoji, however there are certain ones that it misses\n        # this acts as a fallback check\n        if matches := unicode_emoji_reg.search(emoji_str):\n            match = matches.group()\n\n            # the regex will match certain special characters, so this acts as a final failsafe\n            if match not in string.printable:\n                if unicodedata.category(match) == \"So\":\n                    return cls(name=match)\n    return None\n</code></pre>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.PartialEmoji.req_format","title":"<code>req_format: str</code>  <code>property</code>","text":"<p>Format used for web request.</p>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.CustomEmoji","title":"<code>CustomEmoji</code>","text":"<p>         Bases: <code>PartialEmoji</code>, <code>ClientObject</code></p> <p>Represent a custom emoji in a guild with all its properties.</p> Source code in <code>naff\\models\\discord\\emoji.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass CustomEmoji(PartialEmoji, ClientObject):\n\"\"\"Represent a custom emoji in a guild with all its properties.\"\"\"\n\n    _client: \"Client\" = attrs.field(repr=False, metadata=no_export_meta)\n\n    require_colons: bool = attrs.field(repr=False, default=False)\n\"\"\"Whether this emoji must be wrapped in colons\"\"\"\n    managed: bool = attrs.field(repr=False, default=False)\n\"\"\"Whether this emoji is managed\"\"\"\n    available: bool = attrs.field(repr=False, default=False)\n\"\"\"Whether this emoji can be used, may be false due to loss of Server Boosts.\"\"\"\n\n    _creator_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))\n    _role_ids: List[\"Snowflake_Type\"] = attrs.field(\n        repr=False, factory=list, converter=optional(list_converter(to_snowflake))\n    )\n    _guild_id: \"Snowflake_Type\" = attrs.field(repr=False, default=None, converter=to_snowflake)\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        creator_dict = data.pop(\"user\", None)\n        data[\"creator_id\"] = client.cache.place_user_data(creator_dict).id if creator_dict else None\n\n        if \"roles\" in data:\n            data[\"role_ids\"] = data.pop(\"roles\")\n\n        return data\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any], client: \"Client\", guild_id: int) -&gt; \"CustomEmoji\":\n        data = cls._process_dict(data, client)\n        return cls(client=client, guild_id=guild_id, **cls._filter_kwargs(data, cls._get_init_keys()))\n\n    @property\n    def guild(self) -&gt; \"Guild\":\n\"\"\"The guild this emoji belongs to.\"\"\"\n        return self._client.cache.get_guild(self._guild_id)\n\n    @property\n    def creator(self) -&gt; Optional[Union[\"Member\", \"User\"]]:\n\"\"\"The member that created this emoji.\"\"\"\n        return self._client.cache.get_member(self._creator_id, self._guild_id) or self._client.cache.get_user(\n            self._creator_id\n        )\n\n    @property\n    def roles(self) -&gt; List[\"Role\"]:\n\"\"\"The roles allowed to use this emoji.\"\"\"\n        return [self._client.cache.get_role(role_id) for role_id in self._role_ids]\n\n    @property\n    def is_usable(self) -&gt; bool:\n\"\"\"Determines if this emoji is usable by the current user.\"\"\"\n        if not self.available:\n            return False\n\n        guild = self.guild\n        return any(e_role_id in guild.me._role_ids for e_role_id in self._role_ids)\n\n    async def edit(\n        self,\n        *,\n        name: Optional[str] = None,\n        roles: Optional[List[Union[\"Snowflake_Type\", \"Role\"]]] = None,\n        reason: Optional[str] = None,\n    ) -&gt; \"CustomEmoji\":\n\"\"\"\n        Modify the custom emoji information.\n\n        Args:\n            name: The name of the emoji.\n            roles: The roles allowed to use this emoji.\n            reason: Attach a reason to this action, used for audit logs.\n\n        Returns:\n            The newly modified custom emoji.\n\n        \"\"\"\n        data_payload = dict_filter_none(\n            {\n                \"name\": name,\n                \"roles\": roles,\n            }\n        )\n\n        updated_data = await self._client.http.modify_guild_emoji(data_payload, self._guild_id, self.id, reason=reason)\n        self.update_from_dict(updated_data)\n        return self\n\n    async def delete(self, reason: Optional[str] = None) -&gt; None:\n\"\"\"\n        Deletes the custom emoji from the guild.\n\n        Args:\n            reason: Attach a reason to this action, used for audit logs.\n\n        \"\"\"\n        if not self._guild_id:\n            raise ValueError(\"Cannot delete emoji, no guild id set.\")\n\n        await self._client.http.delete_guild_emoji(self._guild_id, self.id, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.CustomEmoji.require_colons","title":"<code>require_colons: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>Whether this emoji must be wrapped in colons</p>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.CustomEmoji.managed","title":"<code>managed: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>Whether this emoji is managed</p>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.CustomEmoji.available","title":"<code>available: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>Whether this emoji can be used, may be false due to loss of Server Boosts.</p>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.CustomEmoji.guild","title":"<code>guild: Guild</code>  <code>property</code>","text":"<p>The guild this emoji belongs to.</p>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.CustomEmoji.creator","title":"<code>creator: Optional[Union[Member, User]]</code>  <code>property</code>","text":"<p>The member that created this emoji.</p>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.CustomEmoji.roles","title":"<code>roles: List[Role]</code>  <code>property</code>","text":"<p>The roles allowed to use this emoji.</p>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.CustomEmoji.is_usable","title":"<code>is_usable: bool</code>  <code>property</code>","text":"<p>Determines if this emoji is usable by the current user.</p>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.CustomEmoji.edit","title":"<code>edit(*, name=None, roles=None, reason=None)</code>  <code>async</code>","text":"<p>Modify the custom emoji information.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the emoji.</p> <code>None</code> <code>roles</code> <code>Optional[List[Union[Snowflake_Type, Role]]]</code> <p>The roles allowed to use this emoji.</p> <code>None</code> <code>reason</code> <code>Optional[str]</code> <p>Attach a reason to this action, used for audit logs.</p> <code>None</code> <p>Returns:</p> Type Description <code>CustomEmoji</code> <p>The newly modified custom emoji.</p> Source code in <code>naff\\models\\discord\\emoji.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: Optional[str] = None,\n    roles: Optional[List[Union[\"Snowflake_Type\", \"Role\"]]] = None,\n    reason: Optional[str] = None,\n) -&gt; \"CustomEmoji\":\n\"\"\"\n    Modify the custom emoji information.\n\n    Args:\n        name: The name of the emoji.\n        roles: The roles allowed to use this emoji.\n        reason: Attach a reason to this action, used for audit logs.\n\n    Returns:\n        The newly modified custom emoji.\n\n    \"\"\"\n    data_payload = dict_filter_none(\n        {\n            \"name\": name,\n            \"roles\": roles,\n        }\n    )\n\n    updated_data = await self._client.http.modify_guild_emoji(data_payload, self._guild_id, self.id, reason=reason)\n    self.update_from_dict(updated_data)\n    return self\n</code></pre>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.CustomEmoji.delete","title":"<code>delete(reason=None)</code>  <code>async</code>","text":"<p>Deletes the custom emoji from the guild.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Optional[str]</code> <p>Attach a reason to this action, used for audit logs.</p> <code>None</code> Source code in <code>naff\\models\\discord\\emoji.py</code> <pre><code>async def delete(self, reason: Optional[str] = None) -&gt; None:\n\"\"\"\n    Deletes the custom emoji from the guild.\n\n    Args:\n        reason: Attach a reason to this action, used for audit logs.\n\n    \"\"\"\n    if not self._guild_id:\n        raise ValueError(\"Cannot delete emoji, no guild id set.\")\n\n    await self._client.http.delete_guild_emoji(self._guild_id, self.id, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.process_emoji_req_format","title":"<code>process_emoji_req_format(emoji)</code>","text":"<p>Processes the emoji parameter into the str format required by the API.</p> <p>Parameters:</p> Name Type Description Default <code>emoji</code> <code>Optional[Union[PartialEmoji, dict, str]]</code> <p>The emoji to process.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>formatted string for discord</p> Source code in <code>naff\\models\\discord\\emoji.py</code> <pre><code>def process_emoji_req_format(emoji: Optional[Union[PartialEmoji, dict, str]]) -&gt; Optional[str]:\n\"\"\"\n    Processes the emoji parameter into the str format required by the API.\n\n    Args:\n        emoji: The emoji to process.\n\n    Returns:\n        formatted string for discord\n\n    \"\"\"\n    if not emoji:\n        return emoji\n\n    if isinstance(emoji, str):\n        emoji = PartialEmoji.from_str(emoji)\n\n    if isinstance(emoji, dict):\n        emoji = PartialEmoji.from_dict(emoji)\n\n    if isinstance(emoji, PartialEmoji):\n        return emoji.req_format\n\n    raise ValueError(f\"Invalid emoji: {emoji}\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/emoji/#naff.models.discord.emoji.process_emoji","title":"<code>process_emoji(emoji)</code>","text":"<p>Processes the emoji parameter into the dictionary format required by the API.</p> <p>Parameters:</p> Name Type Description Default <code>emoji</code> <code>Optional[Union[PartialEmoji, dict, str]]</code> <p>The emoji to process.</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>formatted dictionary for discord</p> Source code in <code>naff\\models\\discord\\emoji.py</code> <pre><code>def process_emoji(emoji: Optional[Union[PartialEmoji, dict, str]]) -&gt; Optional[dict]:\n\"\"\"\n    Processes the emoji parameter into the dictionary format required by the API.\n\n    Args:\n        emoji: The emoji to process.\n\n    Returns:\n        formatted dictionary for discord\n\n    \"\"\"\n    if not emoji:\n        return emoji\n\n    if isinstance(emoji, dict):\n        return emoji\n\n    if isinstance(emoji, str):\n        emoji = PartialEmoji.from_str(emoji)\n\n    if isinstance(emoji, PartialEmoji):\n        return emoji.to_dict()\n\n    raise ValueError(f\"Invalid emoji: {emoji}\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/","title":"Enums","text":""},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.CursedIntEnum","title":"<code>CursedIntEnum</code>","text":"<p>         Bases: <code>IntEnum</code></p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class CursedIntEnum(IntEnum):\n    @classmethod\n    def _missing_(cls: Type[SELF], value) -&gt; SELF:\n\"\"\"Construct a new enum item to represent this new unknown type - without losing the value\"\"\"\n        return _return_cursed_enum(cls, value)\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.WebSocketOPCodes","title":"<code>WebSocketOPCodes</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>Codes used by the Gateway to signify events.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class WebSocketOPCodes(CursedIntEnum):\n\"\"\"Codes used by the Gateway to signify events.\"\"\"\n\n    DISPATCH = 0\n\"\"\"An event was dispatched\"\"\"\n    HEARTBEAT = 1\n\"\"\"Fired periodically by the client to keep the connection alive\"\"\"\n    IDENTIFY = 2\n\"\"\"Starts a new session during the initial handshake.\"\"\"\n    PRESENCE = 3\n\"\"\"Update the client's presence.\"\"\"\n    VOICE_STATE = 4\n\"\"\"Used to join/leave or move between voice channels.\"\"\"\n    VOICE_PING = 5\n    RESUME = 6\n\"\"\"Resume a previous session that was disconnected.\"\"\"\n    RECONNECT = 7\n\"\"\"You should attempt to reconnect and resume immediately.\"\"\"\n    REQUEST_MEMBERS = 8\n\"\"\"Request information about offline guild members in a large guild.\"\"\"\n    INVALIDATE_SESSION = 9\n\"\"\"The session has been invalidated. You should reconnect and identify/resume accordingly.\"\"\"\n    HELLO = 10\n\"\"\"Sent immediately after connecting, contains the `heartbeat_interval` to use.\"\"\"\n    HEARTBEAT_ACK = 11\n\"\"\"Sent in response to receiving a heartbeat to acknowledge that it has been received.\"\"\"\n    GUILD_SYNC = 12\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.WebSocketOPCodes.DISPATCH","title":"<code>DISPATCH = 0</code>  <code>class-attribute</code>","text":"<p>An event was dispatched</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.WebSocketOPCodes.HEARTBEAT","title":"<code>HEARTBEAT = 1</code>  <code>class-attribute</code>","text":"<p>Fired periodically by the client to keep the connection alive</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.WebSocketOPCodes.IDENTIFY","title":"<code>IDENTIFY = 2</code>  <code>class-attribute</code>","text":"<p>Starts a new session during the initial handshake.</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.WebSocketOPCodes.PRESENCE","title":"<code>PRESENCE = 3</code>  <code>class-attribute</code>","text":"<p>Update the client's presence.</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.WebSocketOPCodes.VOICE_STATE","title":"<code>VOICE_STATE = 4</code>  <code>class-attribute</code>","text":"<p>Used to join/leave or move between voice channels.</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.WebSocketOPCodes.RESUME","title":"<code>RESUME = 6</code>  <code>class-attribute</code>","text":"<p>Resume a previous session that was disconnected.</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.WebSocketOPCodes.RECONNECT","title":"<code>RECONNECT = 7</code>  <code>class-attribute</code>","text":"<p>You should attempt to reconnect and resume immediately.</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.WebSocketOPCodes.REQUEST_MEMBERS","title":"<code>REQUEST_MEMBERS = 8</code>  <code>class-attribute</code>","text":"<p>Request information about offline guild members in a large guild.</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.WebSocketOPCodes.INVALIDATE_SESSION","title":"<code>INVALIDATE_SESSION = 9</code>  <code>class-attribute</code>","text":"<p>The session has been invalidated. You should reconnect and identify/resume accordingly.</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.WebSocketOPCodes.HELLO","title":"<code>HELLO = 10</code>  <code>class-attribute</code>","text":"<p>Sent immediately after connecting, contains the <code>heartbeat_interval</code> to use.</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.WebSocketOPCodes.HEARTBEAT_ACK","title":"<code>HEARTBEAT_ACK = 11</code>  <code>class-attribute</code>","text":"<p>Sent in response to receiving a heartbeat to acknowledge that it has been received.</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Intents","title":"<code>Intents</code>","text":"<p>         Bases: <code>DiscordIntFlag</code></p> <p>When identifying to the gateway, you can specify an intents parameter which allows you to conditionally subscribe to pre-defined \"intents\", groups of events defined by Discord.</p> info <p>For details about what intents do, or which intents you'll want, please read the Discord API Documentation</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class Intents(DiscordIntFlag):  # type: ignore\n\"\"\"\n    When identifying to the gateway, you can specify an intents parameter which allows you to conditionally subscribe to pre-defined \"intents\", groups of events defined by Discord.\n\n    info:\n        For details about what intents do, or which intents you'll want, please read the [Discord API Documentation](https://discord.com/developers/docs/topics/gateway#gateway-intents)\n\n    \"\"\"\n\n    GUILDS = 1 &lt;&lt; 0\n    GUILD_MEMBERS = 1 &lt;&lt; 1\n    GUILD_BANS = 1 &lt;&lt; 2\n    GUILD_EMOJIS_AND_STICKERS = 1 &lt;&lt; 3\n    GUILD_INTEGRATIONS = 1 &lt;&lt; 4\n    GUILD_WEBHOOKS = 1 &lt;&lt; 5\n    GUILD_INVITES = 1 &lt;&lt; 6\n    GUILD_VOICE_STATES = 1 &lt;&lt; 7\n    GUILD_PRESENCES = 1 &lt;&lt; 8\n    GUILD_MESSAGES = 1 &lt;&lt; 9\n    GUILD_MESSAGE_REACTIONS = 1 &lt;&lt; 10\n    GUILD_MESSAGE_TYPING = 1 &lt;&lt; 11\n    DIRECT_MESSAGES = 1 &lt;&lt; 12\n    DIRECT_MESSAGE_REACTIONS = 1 &lt;&lt; 13\n    DIRECT_MESSAGE_TYPING = 1 &lt;&lt; 14\n    GUILD_MESSAGE_CONTENT = 1 &lt;&lt; 15\n    GUILD_SCHEDULED_EVENTS = 1 &lt;&lt; 16\n    AUTO_MODERATION_CONFIGURATION = 1 &lt;&lt; 20\n    AUTO_MODERATION_EXECUTION = 1 &lt;&lt; 21\n\n    # Shortcuts/grouping/aliases\n    MESSAGES = GUILD_MESSAGES | DIRECT_MESSAGES\n    REACTIONS = GUILD_MESSAGE_REACTIONS | DIRECT_MESSAGE_REACTIONS\n    TYPING = GUILD_MESSAGE_TYPING | DIRECT_MESSAGE_TYPING\n    AUTO_MOD = AUTO_MODERATION_CONFIGURATION | AUTO_MODERATION_EXECUTION\n\n    PRIVILEGED = GUILD_PRESENCES | GUILD_MEMBERS | GUILD_MESSAGE_CONTENT\n    NON_PRIVILEGED = AntiFlag(PRIVILEGED)\n    DEFAULT = NON_PRIVILEGED\n\n    # Special members\n    NONE = 0\n    ALL = AntiFlag()\n\n    @classmethod\n    def new(\n        cls,\n        guilds=False,\n        guild_members=False,\n        guild_bans=False,\n        guild_emojis_and_stickers=False,\n        guild_integrations=False,\n        guild_webhooks=False,\n        guild_invites=False,\n        guild_voice_states=False,\n        guild_presences=False,\n        guild_messages=False,\n        guild_message_reactions=False,\n        guild_message_typing=False,\n        direct_messages=False,\n        direct_message_reactions=False,\n        direct_message_typing=False,\n        guild_message_content=False,\n        guild_scheduled_events=False,\n        messages=False,\n        reactions=False,\n        typing=False,\n        privileged=False,\n        non_privileged=False,\n        default=False,\n        all=False,\n    ) -&gt; \"Intents\":\n\"\"\"Set your desired intents.\"\"\"\n        kwargs = locals()\n        del kwargs[\"cls\"]\n\n        intents = cls.NONE\n        for key in kwargs:\n            if kwargs[key]:\n                intents |= getattr(cls, key.upper())\n        return intents\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Intents.new","title":"<code>new(guilds=False, guild_members=False, guild_bans=False, guild_emojis_and_stickers=False, guild_integrations=False, guild_webhooks=False, guild_invites=False, guild_voice_states=False, guild_presences=False, guild_messages=False, guild_message_reactions=False, guild_message_typing=False, direct_messages=False, direct_message_reactions=False, direct_message_typing=False, guild_message_content=False, guild_scheduled_events=False, messages=False, reactions=False, typing=False, privileged=False, non_privileged=False, default=False, all=False)</code>  <code>classmethod</code>","text":"<p>Set your desired intents.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    guilds=False,\n    guild_members=False,\n    guild_bans=False,\n    guild_emojis_and_stickers=False,\n    guild_integrations=False,\n    guild_webhooks=False,\n    guild_invites=False,\n    guild_voice_states=False,\n    guild_presences=False,\n    guild_messages=False,\n    guild_message_reactions=False,\n    guild_message_typing=False,\n    direct_messages=False,\n    direct_message_reactions=False,\n    direct_message_typing=False,\n    guild_message_content=False,\n    guild_scheduled_events=False,\n    messages=False,\n    reactions=False,\n    typing=False,\n    privileged=False,\n    non_privileged=False,\n    default=False,\n    all=False,\n) -&gt; \"Intents\":\n\"\"\"Set your desired intents.\"\"\"\n    kwargs = locals()\n    del kwargs[\"cls\"]\n\n    intents = cls.NONE\n    for key in kwargs:\n        if kwargs[key]:\n            intents |= getattr(cls, key.upper())\n    return intents\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags","title":"<code>UserFlags</code>","text":"<p>         Bases: <code>DiscordIntFlag</code></p> <p>Flags a user can have.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class UserFlags(DiscordIntFlag):  # type: ignore\n\"\"\"Flags a user can have.\"\"\"\n\n    DISCORD_EMPLOYEE = 1 &lt;&lt; 0\n\"\"\"This person works for Discord\"\"\"\n    PARTNERED_SERVER_OWNER = 1 &lt;&lt; 1\n\"\"\"User owns a partnered server\"\"\"\n    HYPESQUAD_EVENTS = 1 &lt;&lt; 2\n\"\"\"User has helped with a hypesquad event\"\"\"\n    BUG_HUNTER_LEVEL_1 = 1 &lt;&lt; 3\n\"\"\"User has passed the bug hunters quiz\"\"\"\n\n    HOUSE_BRAVERY = 1 &lt;&lt; 6\n\"\"\"User belongs to the `bravery` house\"\"\"\n    HOUSE_BRILLIANCE = 1 &lt;&lt; 7\n\"\"\"User belongs to the `brilliance` house\"\"\"\n    HOUSE_BALANCE = 1 &lt;&lt; 8\n\"\"\"User belongs to the `balance` house\"\"\"\n    EARLY_SUPPORTER = 1 &lt;&lt; 9\n\"\"\"This person had Nitro prior to Wednesday, October 10th, 2018\"\"\"\n\n    TEAM_USER = 1 &lt;&lt; 10\n\"\"\"A team user\"\"\"\n\n    BUG_HUNTER_LEVEL_2 = 1 &lt;&lt; 14\n\"\"\"User is a bug hunter level 2\"\"\"\n\n    VERIFIED_BOT = 1 &lt;&lt; 16\n\"\"\"This bot has been verified by Discord\"\"\"\n    EARLY_VERIFIED_BOT_DEVELOPER = 1 &lt;&lt; 17\n\"\"\"This user was one of the first to be verified\"\"\"\n    DISCORD_CERTIFIED_MODERATOR = 1 &lt;&lt; 18\n\"\"\"This user is a certified moderator\"\"\"\n\n    BOT_HTTP_INTERACTIONS = 1 &lt;&lt; 19\n\"\"\"Bot uses only HTTP interactions and is shown in the online member list\"\"\"\n\n    SPAMMER = 1 &lt;&lt; 20\n\"\"\"A user who is suspected of spamming\"\"\"\n    DISABLE_PREMIUM = 1 &lt;&lt; 21\n\"\"\"Nitro features disabled for this user. Only used by Discord Staff for testing\"\"\"\n    ACTIVE_DEVELOPER = 1 &lt;&lt; 22\n\"\"\"This user is an active developer\"\"\"\n\n    # Shortcuts/grouping/aliases\n    HYPESQUAD = HOUSE_BRAVERY | HOUSE_BRILLIANCE | HOUSE_BALANCE\n    BUG_HUNTER = BUG_HUNTER_LEVEL_1 | BUG_HUNTER_LEVEL_2\n\n    # Special members\n    NONE = 0\n    ALL = AntiFlag()\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.DISCORD_EMPLOYEE","title":"<code>DISCORD_EMPLOYEE = 1 &lt;&lt; 0</code>  <code>class-attribute</code>","text":"<p>This person works for Discord</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.PARTNERED_SERVER_OWNER","title":"<code>PARTNERED_SERVER_OWNER = 1 &lt;&lt; 1</code>  <code>class-attribute</code>","text":"<p>User owns a partnered server</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.HYPESQUAD_EVENTS","title":"<code>HYPESQUAD_EVENTS = 1 &lt;&lt; 2</code>  <code>class-attribute</code>","text":"<p>User has helped with a hypesquad event</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.BUG_HUNTER_LEVEL_1","title":"<code>BUG_HUNTER_LEVEL_1 = 1 &lt;&lt; 3</code>  <code>class-attribute</code>","text":"<p>User has passed the bug hunters quiz</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.HOUSE_BRAVERY","title":"<code>HOUSE_BRAVERY = 1 &lt;&lt; 6</code>  <code>class-attribute</code>","text":"<p>User belongs to the <code>bravery</code> house</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.HOUSE_BRILLIANCE","title":"<code>HOUSE_BRILLIANCE = 1 &lt;&lt; 7</code>  <code>class-attribute</code>","text":"<p>User belongs to the <code>brilliance</code> house</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.HOUSE_BALANCE","title":"<code>HOUSE_BALANCE = 1 &lt;&lt; 8</code>  <code>class-attribute</code>","text":"<p>User belongs to the <code>balance</code> house</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.EARLY_SUPPORTER","title":"<code>EARLY_SUPPORTER = 1 &lt;&lt; 9</code>  <code>class-attribute</code>","text":"<p>This person had Nitro prior to Wednesday, October 10th, 2018</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.TEAM_USER","title":"<code>TEAM_USER = 1 &lt;&lt; 10</code>  <code>class-attribute</code>","text":"<p>A team user</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.BUG_HUNTER_LEVEL_2","title":"<code>BUG_HUNTER_LEVEL_2 = 1 &lt;&lt; 14</code>  <code>class-attribute</code>","text":"<p>User is a bug hunter level 2</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.VERIFIED_BOT","title":"<code>VERIFIED_BOT = 1 &lt;&lt; 16</code>  <code>class-attribute</code>","text":"<p>This bot has been verified by Discord</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.EARLY_VERIFIED_BOT_DEVELOPER","title":"<code>EARLY_VERIFIED_BOT_DEVELOPER = 1 &lt;&lt; 17</code>  <code>class-attribute</code>","text":"<p>This user was one of the first to be verified</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.DISCORD_CERTIFIED_MODERATOR","title":"<code>DISCORD_CERTIFIED_MODERATOR = 1 &lt;&lt; 18</code>  <code>class-attribute</code>","text":"<p>This user is a certified moderator</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.BOT_HTTP_INTERACTIONS","title":"<code>BOT_HTTP_INTERACTIONS = 1 &lt;&lt; 19</code>  <code>class-attribute</code>","text":"<p>Bot uses only HTTP interactions and is shown in the online member list</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.SPAMMER","title":"<code>SPAMMER = 1 &lt;&lt; 20</code>  <code>class-attribute</code>","text":"<p>A user who is suspected of spamming</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.DISABLE_PREMIUM","title":"<code>DISABLE_PREMIUM = 1 &lt;&lt; 21</code>  <code>class-attribute</code>","text":"<p>Nitro features disabled for this user. Only used by Discord Staff for testing</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.UserFlags.ACTIVE_DEVELOPER","title":"<code>ACTIVE_DEVELOPER = 1 &lt;&lt; 22</code>  <code>class-attribute</code>","text":"<p>This user is an active developer</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ApplicationFlags","title":"<code>ApplicationFlags</code>","text":"<p>         Bases: <code>DiscordIntFlag</code></p> <p>Flags an application can have.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class ApplicationFlags(DiscordIntFlag):  # type: ignore\n\"\"\"Flags an application can have.\"\"\"\n\n    # Flags defined by the Discord API\n    GATEWAY_PRESENCE = 1 &lt;&lt; 12\n\"\"\"Verified to use presence intent\"\"\"\n    GATEWAY_PRESENCE_LIMITED = 1 &lt;&lt; 13\n\"\"\"Using presence intent, without verification\"\"\"\n    GATEWAY_GUILD_MEMBERS = 1 &lt;&lt; 14\n\"\"\"Verified to use guild members intent\"\"\"\n    GATEWAY_GUILD_MEMBERS_LIMITED = 1 &lt;&lt; 15\n\"\"\"Using members intent, without verification\"\"\"\n    VERIFICATION_PENDING_GUILD_LIMIT = 1 &lt;&lt; 16\n\"\"\"Bot has hit guild limit, and has not been successfully verified\"\"\"\n    EMBEDDED = 1 &lt;&lt; 17\n\"\"\"Application is a voice channel activity (ie YouTube Together)\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ApplicationFlags.GATEWAY_PRESENCE","title":"<code>GATEWAY_PRESENCE = 1 &lt;&lt; 12</code>  <code>class-attribute</code>","text":"<p>Verified to use presence intent</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ApplicationFlags.GATEWAY_PRESENCE_LIMITED","title":"<code>GATEWAY_PRESENCE_LIMITED = 1 &lt;&lt; 13</code>  <code>class-attribute</code>","text":"<p>Using presence intent, without verification</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ApplicationFlags.GATEWAY_GUILD_MEMBERS","title":"<code>GATEWAY_GUILD_MEMBERS = 1 &lt;&lt; 14</code>  <code>class-attribute</code>","text":"<p>Verified to use guild members intent</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ApplicationFlags.GATEWAY_GUILD_MEMBERS_LIMITED","title":"<code>GATEWAY_GUILD_MEMBERS_LIMITED = 1 &lt;&lt; 15</code>  <code>class-attribute</code>","text":"<p>Using members intent, without verification</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ApplicationFlags.VERIFICATION_PENDING_GUILD_LIMIT","title":"<code>VERIFICATION_PENDING_GUILD_LIMIT = 1 &lt;&lt; 16</code>  <code>class-attribute</code>","text":"<p>Bot has hit guild limit, and has not been successfully verified</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ApplicationFlags.EMBEDDED","title":"<code>EMBEDDED = 1 &lt;&lt; 17</code>  <code>class-attribute</code>","text":"<p>Application is a voice channel activity (ie YouTube Together)</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.TeamMembershipState","title":"<code>TeamMembershipState</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>Status of membership in the team.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class TeamMembershipState(CursedIntEnum):\n\"\"\"Status of membership in the team.\"\"\"\n\n    INVITED = 1\n    ACCEPTED = 2\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.PremiumTypes","title":"<code>PremiumTypes</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>Types of premium membership.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class PremiumTypes(CursedIntEnum):\n\"\"\"Types of premium membership.\"\"\"\n\n    NONE = 0\n\"\"\"No premium membership\"\"\"\n    NITRO_CLASSIC = 1\n\"\"\"Using Nitro Classic\"\"\"\n    NITRO = 2\n\"\"\"Full Nitro membership\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.PremiumTypes.NONE","title":"<code>NONE = 0</code>  <code>class-attribute</code>","text":"<p>No premium membership</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.PremiumTypes.NITRO_CLASSIC","title":"<code>NITRO_CLASSIC = 1</code>  <code>class-attribute</code>","text":"<p>Using Nitro Classic</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.PremiumTypes.NITRO","title":"<code>NITRO = 2</code>  <code>class-attribute</code>","text":"<p>Full Nitro membership</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageTypes","title":"<code>MessageTypes</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>Types of message.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class MessageTypes(CursedIntEnum):\n\"\"\"Types of message.\"\"\"\n\n    DEFAULT = 0\n    RECIPIENT_ADD = 1\n    RECIPIENT_REMOVE = 2\n    CALL = 3\n    CHANNEL_NAME_CHANGE = 4\n    CHANNEL_ICON_CHANGE = 5\n    CHANNEL_PINNED_MESSAGE = 6\n    GUILD_MEMBER_JOIN = 7\n    USER_PREMIUM_GUILD_SUBSCRIPTION = 8\n    USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1 = 9\n    USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2 = 10\n    USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3 = 11\n    CHANNEL_FOLLOW_ADD = 12\n    GUILD_DISCOVERY_DISQUALIFIED = 14\n    GUILD_DISCOVERY_REQUALIFIED = 15\n    GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING = 16\n    GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING = 17\n    THREAD_CREATED = 18\n    REPLY = 19\n    APPLICATION_COMMAND = 20\n    THREAD_STARTER_MESSAGE = 21\n    GUILD_INVITE_REMINDER = 22\n    CONTEXT_MENU_COMMAND = 23\n    AUTO_MODERATION_ACTION = 24\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.EmbedTypes","title":"<code>EmbedTypes</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Types of embed.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class EmbedTypes(Enum):\n\"\"\"Types of embed.\"\"\"\n\n    RICH = \"rich\"\n    IMAGE = \"image\"\n    VIDEO = \"video\"\n    GIFV = \"gifv\"\n    ARTICLE = \"article\"\n    LINK = \"link\"\n    AUTOMOD_MESSAGE = \"auto_moderation_message\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageActivityTypes","title":"<code>MessageActivityTypes</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>An activity object, similar to an embed.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class MessageActivityTypes(CursedIntEnum):\n\"\"\"An activity object, similar to an embed.\"\"\"\n\n    JOIN = 1\n\"\"\"Join the event\"\"\"\n    SPECTATE = 2\n\"\"\"Watch the event\"\"\"\n    LISTEN = 3\n\"\"\"Listen along to the event\"\"\"\n    JOIN_REQUEST = 5\n\"\"\"Asking a user to join the activity\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageActivityTypes.JOIN","title":"<code>JOIN = 1</code>  <code>class-attribute</code>","text":"<p>Join the event</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageActivityTypes.SPECTATE","title":"<code>SPECTATE = 2</code>  <code>class-attribute</code>","text":"<p>Watch the event</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageActivityTypes.LISTEN","title":"<code>LISTEN = 3</code>  <code>class-attribute</code>","text":"<p>Listen along to the event</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageActivityTypes.JOIN_REQUEST","title":"<code>JOIN_REQUEST = 5</code>  <code>class-attribute</code>","text":"<p>Asking a user to join the activity</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageFlags","title":"<code>MessageFlags</code>","text":"<p>         Bases: <code>DiscordIntFlag</code></p> <p>Message flags.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class MessageFlags(DiscordIntFlag):  # type: ignore\n\"\"\"Message flags.\"\"\"\n\n    CROSSPOSTED = 1 &lt;&lt; 0\n\"\"\"This message has been published to subscribed channels (via Channel Following)\"\"\"\n    IS_CROSSPOST = 1 &lt;&lt; 1\n\"\"\"This message originated from a message in another channel (via Channel Following)\"\"\"\n    SUPPRESS_EMBEDS = 1 &lt;&lt; 2\n\"\"\"Do not include any embeds when serializing this message\"\"\"\n    SOURCE_MESSAGE_DELETED = 1 &lt;&lt; 3\n\"\"\"The source message for this crosspost has been deleted (via Channel Following)\"\"\"\n    URGENT = 1 &lt;&lt; 4\n\"\"\"This message came from the urgent message system\"\"\"\n    HAS_THREAD = 1 &lt;&lt; 5\n\"\"\"This message has an associated thread, with the same id as the message\"\"\"\n    EPHEMERAL = 1 &lt;&lt; 6\n\"\"\"This message is only visible to the user who invoked the Interaction\"\"\"\n    LOADING = 1 &lt;&lt; 7\n\"\"\"This message is an Interaction Response and the bot is \"thinking\"\"\"\n    FAILED_TO_MENTION_SOME_ROLES_IN_THREAD = 1 &lt;&lt; 8\n\"\"\"This message failed to mention some roles and add their members to the thread\"\"\"\n    SHOULD_SHOW_LINK_NOT_DISCORD_WARNING = 1 &lt;&lt; 10\n\"\"\"This message contains a abusive website link, pops up a warning when clicked\"\"\"\n\n    # Special members\n    NONE = 0\n    ALL = AntiFlag()\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageFlags.CROSSPOSTED","title":"<code>CROSSPOSTED = 1 &lt;&lt; 0</code>  <code>class-attribute</code>","text":"<p>This message has been published to subscribed channels (via Channel Following)</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageFlags.IS_CROSSPOST","title":"<code>IS_CROSSPOST = 1 &lt;&lt; 1</code>  <code>class-attribute</code>","text":"<p>This message originated from a message in another channel (via Channel Following)</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageFlags.SUPPRESS_EMBEDS","title":"<code>SUPPRESS_EMBEDS = 1 &lt;&lt; 2</code>  <code>class-attribute</code>","text":"<p>Do not include any embeds when serializing this message</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageFlags.SOURCE_MESSAGE_DELETED","title":"<code>SOURCE_MESSAGE_DELETED = 1 &lt;&lt; 3</code>  <code>class-attribute</code>","text":"<p>The source message for this crosspost has been deleted (via Channel Following)</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageFlags.URGENT","title":"<code>URGENT = 1 &lt;&lt; 4</code>  <code>class-attribute</code>","text":"<p>This message came from the urgent message system</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageFlags.HAS_THREAD","title":"<code>HAS_THREAD = 1 &lt;&lt; 5</code>  <code>class-attribute</code>","text":"<p>This message has an associated thread, with the same id as the message</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageFlags.EPHEMERAL","title":"<code>EPHEMERAL = 1 &lt;&lt; 6</code>  <code>class-attribute</code>","text":"<p>This message is only visible to the user who invoked the Interaction</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageFlags.LOADING","title":"<code>LOADING = 1 &lt;&lt; 7</code>  <code>class-attribute</code>","text":"<p>This message is an Interaction Response and the bot is \"thinking</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageFlags.FAILED_TO_MENTION_SOME_ROLES_IN_THREAD","title":"<code>FAILED_TO_MENTION_SOME_ROLES_IN_THREAD = 1 &lt;&lt; 8</code>  <code>class-attribute</code>","text":"<p>This message failed to mention some roles and add their members to the thread</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MessageFlags.SHOULD_SHOW_LINK_NOT_DISCORD_WARNING","title":"<code>SHOULD_SHOW_LINK_NOT_DISCORD_WARNING = 1 &lt;&lt; 10</code>  <code>class-attribute</code>","text":"<p>This message contains a abusive website link, pops up a warning when clicked</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions","title":"<code>Permissions</code>","text":"<p>         Bases: <code>DiscordIntFlag</code></p> <p>Permissions a user or role may have.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class Permissions(DiscordIntFlag):  # type: ignore\n\"\"\"Permissions a user or role may have.\"\"\"\n\n    # Permissions defined by Discord API\n    CREATE_INSTANT_INVITE = 1 &lt;&lt; 0\n\"\"\"Allows creation of instant invites\"\"\"\n    KICK_MEMBERS = 1 &lt;&lt; 1\n\"\"\"Allows kicking members\"\"\"\n    BAN_MEMBERS = 1 &lt;&lt; 2\n\"\"\"Allows banning members\"\"\"\n    ADMINISTRATOR = 1 &lt;&lt; 3\n\"\"\"Allows all permissions and bypasses channel permission overwrites\"\"\"\n    MANAGE_CHANNELS = 1 &lt;&lt; 4\n\"\"\"Allows management and editing of channels\"\"\"\n    MANAGE_GUILD = 1 &lt;&lt; 5\n\"\"\"Allows management and editing of the guild\"\"\"\n    ADD_REACTIONS = 1 &lt;&lt; 6\n\"\"\"Allows for the addition of reactions to messages\"\"\"\n    VIEW_AUDIT_LOG = 1 &lt;&lt; 7\n\"\"\"Allows for viewing of audit logs\"\"\"\n    PRIORITY_SPEAKER = 1 &lt;&lt; 8\n\"\"\"Allows for using priority speaker in a voice channel\"\"\"\n    STREAM = 1 &lt;&lt; 9\n\"\"\"Allows the user to go live\"\"\"\n    VIEW_CHANNEL = 1 &lt;&lt; 10\n\"\"\"Allows guild members to view a channel, which includes reading messages in text channels and joining voice channels\"\"\"\n    SEND_MESSAGES = 1 &lt;&lt; 11\n\"\"\"\tAllows for sending messages in a channel (does not allow sending messages in threads)\"\"\"\n    CREATE_POSTS = 1 &lt;&lt; 11\n\"\"\"Allow members to create posts in this channel. Alias to SEND_MESSAGES\"\"\"\n    SEND_TTS_MESSAGES = 1 &lt;&lt; 12\n\"\"\"\tAllows for sending of `/tts` messages\"\"\"\n    MANAGE_MESSAGES = 1 &lt;&lt; 13\n\"\"\"Allows for deletion of other users messages\"\"\"\n    EMBED_LINKS = 1 &lt;&lt; 14\n\"\"\"Links sent by users with this permission will be auto-embedded\"\"\"\n    ATTACH_FILES = 1 &lt;&lt; 15\n\"\"\"Allows for uploading images and files\"\"\"\n    READ_MESSAGE_HISTORY = 1 &lt;&lt; 16\n\"\"\"Allows for reading of message history\"\"\"\n    MENTION_EVERYONE = 1 &lt;&lt; 17\n\"\"\"Allows for using the `@everyone` tag to notify all users in a channel, and the `@here` tag to notify all online users in a channel\"\"\"\n    USE_EXTERNAL_EMOJIS = 1 &lt;&lt; 18\n\"\"\"Allows the usage of custom emojis from other servers\"\"\"\n    VIEW_GUILD_INSIGHTS = 1 &lt;&lt; 19\n\"\"\"Allows for viewing guild insights\"\"\"\n    CONNECT = 1 &lt;&lt; 20\n\"\"\"Allows for joining of a voice channel\"\"\"\n    SPEAK = 1 &lt;&lt; 21\n\"\"\"Allows for speaking in a voice channel\"\"\"\n    MUTE_MEMBERS = 1 &lt;&lt; 22\n\"\"\"Allows for muting members in a voice channel\"\"\"\n    DEAFEN_MEMBERS = 1 &lt;&lt; 23\n\"\"\"Allows for deafening of members in a voice channel\"\"\"\n    MOVE_MEMBERS = 1 &lt;&lt; 24\n\"\"\"Allows for moving of members between voice channels\"\"\"\n    USE_VAD = 1 &lt;&lt; 25\n\"\"\"Allows for using voice-activity-detection in a voice channel\"\"\"\n    CHANGE_NICKNAME = 1 &lt;&lt; 26\n\"\"\"Allows for modification of own nickname\"\"\"\n    MANAGE_NICKNAMES = 1 &lt;&lt; 27\n\"\"\"Allows for modification of other users nicknames\"\"\"\n    MANAGE_ROLES = 1 &lt;&lt; 28\n\"\"\"Allows management and editing of roles\"\"\"\n    MANAGE_WEBHOOKS = 1 &lt;&lt; 29\n\"\"\"Allows management and editing of webhooks\"\"\"\n    MANAGE_EMOJIS_AND_STICKERS = 1 &lt;&lt; 30\n\"\"\"Allows management and editing of emojis and stickers\"\"\"\n    USE_APPLICATION_COMMANDS = 1 &lt;&lt; 31\n\"\"\"Allows members to use application commands, including slash commands and context menu commands\"\"\"\n    REQUEST_TO_SPEAK = 1 &lt;&lt; 32\n\"\"\"Allows for requesting to speak in stage channels. (This permission is under active development and may be changed or removed.)\"\"\"\n    MANAGE_EVENTS = 1 &lt;&lt; 33\n\"\"\"Allows for creating, editing, and deleting scheduled events\"\"\"\n    MANAGE_THREADS = 1 &lt;&lt; 34\n\"\"\"Allows for deleting and archiving threads, and viewing all private threads\"\"\"\n    USE_PUBLIC_THREADS = 1 &lt;&lt; 35\n\"\"\"\tAllows for creating public and announcement threads\"\"\"\n    USE_PRIVATE_THREADS = 1 &lt;&lt; 36\n\"\"\"Allows for creating private threads\"\"\"\n    USE_EXTERNAL_STICKERS = 1 &lt;&lt; 37\n\"\"\"Allows the usage of custom stickers from other servers\"\"\"\n    SEND_MESSAGES_IN_THREADS = 1 &lt;&lt; 38\n\"\"\"Allows for sending messages in threads\"\"\"\n    START_EMBEDDED_ACTIVITIES = 1 &lt;&lt; 39\n\"\"\"Allows for using Activities (applications with the `EMBEDDED` flag) in a voice channel\"\"\"\n    MODERATE_MEMBERS = 1 &lt;&lt; 40\n\"\"\"Allows for timing out users to prevent them from sending or reacting to messages in chat and threads, and from speaking in voice and stage channels\"\"\"\n\n    # Shortcuts/grouping/aliases\n    REQUIRES_MFA = (\n        KICK_MEMBERS\n        | BAN_MEMBERS\n        | ADMINISTRATOR\n        | MANAGE_CHANNELS\n        | MANAGE_GUILD\n        | MANAGE_MESSAGES\n        | MANAGE_ROLES\n        | MANAGE_WEBHOOKS\n        | MANAGE_EMOJIS_AND_STICKERS\n        | MANAGE_THREADS\n        | MODERATE_MEMBERS\n    )\n    USE_SLASH_COMMANDS = USE_APPLICATION_COMMANDS\n\"\"\"Legacy alias for :attr:`USE_APPLICATION_COMMANDS`\"\"\"\n\n    # Special members\n    NONE = 0\n    ALL = AntiFlag()\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.CREATE_INSTANT_INVITE","title":"<code>CREATE_INSTANT_INVITE = 1 &lt;&lt; 0</code>  <code>class-attribute</code>","text":"<p>Allows creation of instant invites</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.KICK_MEMBERS","title":"<code>KICK_MEMBERS = 1 &lt;&lt; 1</code>  <code>class-attribute</code>","text":"<p>Allows kicking members</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.BAN_MEMBERS","title":"<code>BAN_MEMBERS = 1 &lt;&lt; 2</code>  <code>class-attribute</code>","text":"<p>Allows banning members</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.ADMINISTRATOR","title":"<code>ADMINISTRATOR = 1 &lt;&lt; 3</code>  <code>class-attribute</code>","text":"<p>Allows all permissions and bypasses channel permission overwrites</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.MANAGE_CHANNELS","title":"<code>MANAGE_CHANNELS = 1 &lt;&lt; 4</code>  <code>class-attribute</code>","text":"<p>Allows management and editing of channels</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.MANAGE_GUILD","title":"<code>MANAGE_GUILD = 1 &lt;&lt; 5</code>  <code>class-attribute</code>","text":"<p>Allows management and editing of the guild</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.ADD_REACTIONS","title":"<code>ADD_REACTIONS = 1 &lt;&lt; 6</code>  <code>class-attribute</code>","text":"<p>Allows for the addition of reactions to messages</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.VIEW_AUDIT_LOG","title":"<code>VIEW_AUDIT_LOG = 1 &lt;&lt; 7</code>  <code>class-attribute</code>","text":"<p>Allows for viewing of audit logs</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.PRIORITY_SPEAKER","title":"<code>PRIORITY_SPEAKER = 1 &lt;&lt; 8</code>  <code>class-attribute</code>","text":"<p>Allows for using priority speaker in a voice channel</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.STREAM","title":"<code>STREAM = 1 &lt;&lt; 9</code>  <code>class-attribute</code>","text":"<p>Allows the user to go live</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.VIEW_CHANNEL","title":"<code>VIEW_CHANNEL = 1 &lt;&lt; 10</code>  <code>class-attribute</code>","text":"<p>Allows guild members to view a channel, which includes reading messages in text channels and joining voice channels</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.SEND_MESSAGES","title":"<code>SEND_MESSAGES = 1 &lt;&lt; 11</code>  <code>class-attribute</code>","text":"<p>Allows for sending messages in a channel (does not allow sending messages in threads)</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.CREATE_POSTS","title":"<code>CREATE_POSTS = 1 &lt;&lt; 11</code>  <code>class-attribute</code>","text":"<p>Allow members to create posts in this channel. Alias to SEND_MESSAGES</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.SEND_TTS_MESSAGES","title":"<code>SEND_TTS_MESSAGES = 1 &lt;&lt; 12</code>  <code>class-attribute</code>","text":"<p>Allows for sending of <code>/tts</code> messages</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.MANAGE_MESSAGES","title":"<code>MANAGE_MESSAGES = 1 &lt;&lt; 13</code>  <code>class-attribute</code>","text":"<p>Allows for deletion of other users messages</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.EMBED_LINKS","title":"<code>EMBED_LINKS = 1 &lt;&lt; 14</code>  <code>class-attribute</code>","text":"<p>Links sent by users with this permission will be auto-embedded</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.ATTACH_FILES","title":"<code>ATTACH_FILES = 1 &lt;&lt; 15</code>  <code>class-attribute</code>","text":"<p>Allows for uploading images and files</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.READ_MESSAGE_HISTORY","title":"<code>READ_MESSAGE_HISTORY = 1 &lt;&lt; 16</code>  <code>class-attribute</code>","text":"<p>Allows for reading of message history</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.MENTION_EVERYONE","title":"<code>MENTION_EVERYONE = 1 &lt;&lt; 17</code>  <code>class-attribute</code>","text":"<p>Allows for using the <code>@everyone</code> tag to notify all users in a channel, and the <code>@here</code> tag to notify all online users in a channel</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.USE_EXTERNAL_EMOJIS","title":"<code>USE_EXTERNAL_EMOJIS = 1 &lt;&lt; 18</code>  <code>class-attribute</code>","text":"<p>Allows the usage of custom emojis from other servers</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.VIEW_GUILD_INSIGHTS","title":"<code>VIEW_GUILD_INSIGHTS = 1 &lt;&lt; 19</code>  <code>class-attribute</code>","text":"<p>Allows for viewing guild insights</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.CONNECT","title":"<code>CONNECT = 1 &lt;&lt; 20</code>  <code>class-attribute</code>","text":"<p>Allows for joining of a voice channel</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.SPEAK","title":"<code>SPEAK = 1 &lt;&lt; 21</code>  <code>class-attribute</code>","text":"<p>Allows for speaking in a voice channel</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.MUTE_MEMBERS","title":"<code>MUTE_MEMBERS = 1 &lt;&lt; 22</code>  <code>class-attribute</code>","text":"<p>Allows for muting members in a voice channel</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.DEAFEN_MEMBERS","title":"<code>DEAFEN_MEMBERS = 1 &lt;&lt; 23</code>  <code>class-attribute</code>","text":"<p>Allows for deafening of members in a voice channel</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.MOVE_MEMBERS","title":"<code>MOVE_MEMBERS = 1 &lt;&lt; 24</code>  <code>class-attribute</code>","text":"<p>Allows for moving of members between voice channels</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.USE_VAD","title":"<code>USE_VAD = 1 &lt;&lt; 25</code>  <code>class-attribute</code>","text":"<p>Allows for using voice-activity-detection in a voice channel</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.CHANGE_NICKNAME","title":"<code>CHANGE_NICKNAME = 1 &lt;&lt; 26</code>  <code>class-attribute</code>","text":"<p>Allows for modification of own nickname</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.MANAGE_NICKNAMES","title":"<code>MANAGE_NICKNAMES = 1 &lt;&lt; 27</code>  <code>class-attribute</code>","text":"<p>Allows for modification of other users nicknames</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.MANAGE_ROLES","title":"<code>MANAGE_ROLES = 1 &lt;&lt; 28</code>  <code>class-attribute</code>","text":"<p>Allows management and editing of roles</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.MANAGE_WEBHOOKS","title":"<code>MANAGE_WEBHOOKS = 1 &lt;&lt; 29</code>  <code>class-attribute</code>","text":"<p>Allows management and editing of webhooks</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.MANAGE_EMOJIS_AND_STICKERS","title":"<code>MANAGE_EMOJIS_AND_STICKERS = 1 &lt;&lt; 30</code>  <code>class-attribute</code>","text":"<p>Allows management and editing of emojis and stickers</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.USE_APPLICATION_COMMANDS","title":"<code>USE_APPLICATION_COMMANDS = 1 &lt;&lt; 31</code>  <code>class-attribute</code>","text":"<p>Allows members to use application commands, including slash commands and context menu commands</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.REQUEST_TO_SPEAK","title":"<code>REQUEST_TO_SPEAK = 1 &lt;&lt; 32</code>  <code>class-attribute</code>","text":"<p>Allows for requesting to speak in stage channels. (This permission is under active development and may be changed or removed.)</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.MANAGE_EVENTS","title":"<code>MANAGE_EVENTS = 1 &lt;&lt; 33</code>  <code>class-attribute</code>","text":"<p>Allows for creating, editing, and deleting scheduled events</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.MANAGE_THREADS","title":"<code>MANAGE_THREADS = 1 &lt;&lt; 34</code>  <code>class-attribute</code>","text":"<p>Allows for deleting and archiving threads, and viewing all private threads</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.USE_PUBLIC_THREADS","title":"<code>USE_PUBLIC_THREADS = 1 &lt;&lt; 35</code>  <code>class-attribute</code>","text":"<p>Allows for creating public and announcement threads</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.USE_PRIVATE_THREADS","title":"<code>USE_PRIVATE_THREADS = 1 &lt;&lt; 36</code>  <code>class-attribute</code>","text":"<p>Allows for creating private threads</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.USE_EXTERNAL_STICKERS","title":"<code>USE_EXTERNAL_STICKERS = 1 &lt;&lt; 37</code>  <code>class-attribute</code>","text":"<p>Allows the usage of custom stickers from other servers</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.SEND_MESSAGES_IN_THREADS","title":"<code>SEND_MESSAGES_IN_THREADS = 1 &lt;&lt; 38</code>  <code>class-attribute</code>","text":"<p>Allows for sending messages in threads</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.START_EMBEDDED_ACTIVITIES","title":"<code>START_EMBEDDED_ACTIVITIES = 1 &lt;&lt; 39</code>  <code>class-attribute</code>","text":"<p>Allows for using Activities (applications with the <code>EMBEDDED</code> flag) in a voice channel</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.MODERATE_MEMBERS","title":"<code>MODERATE_MEMBERS = 1 &lt;&lt; 40</code>  <code>class-attribute</code>","text":"<p>Allows for timing out users to prevent them from sending or reacting to messages in chat and threads, and from speaking in voice and stage channels</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Permissions.USE_SLASH_COMMANDS","title":"<code>USE_SLASH_COMMANDS = USE_APPLICATION_COMMANDS</code>  <code>class-attribute</code>","text":"<p>Legacy alias for :attr:<code>USE_APPLICATION_COMMANDS</code></p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelTypes","title":"<code>ChannelTypes</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>Types of channel.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class ChannelTypes(CursedIntEnum):\n\"\"\"Types of channel.\"\"\"\n\n    GUILD_TEXT = 0\n\"\"\"Text channel within a server\"\"\"\n    DM = 1\n\"\"\"Direct message between users\"\"\"\n    GUILD_VOICE = 2\n\"\"\"Voice channel within a server\"\"\"\n    GROUP_DM = 3\n\"\"\"Direct message between multiple users\"\"\"\n    GUILD_CATEGORY = 4\n\"\"\"Organizational category that contains up to 50 channels\"\"\"\n    GUILD_NEWS = 5\n\"\"\"Channel that users can follow and crosspost into their own server\"\"\"\n    GUILD_NEWS_THREAD = 10\n\"\"\"Temporary sub-channel within a GUILD_NEWS channel\"\"\"\n    GUILD_PUBLIC_THREAD = 11\n\"\"\"Temporary sub-channel within a GUILD_TEXT channel\"\"\"\n    GUILD_PRIVATE_THREAD = 12\n\"\"\"Temporary sub-channel within a GUILD_TEXT channel that is only viewable by those invited and those with the MANAGE_THREADS permission\"\"\"\n    GUILD_STAGE_VOICE = 13\n\"\"\"Voice channel for hosting events with an audience\"\"\"\n    GUILD_FORUM = 15\n\"\"\"A Forum channel\"\"\"\n\n    @property\n    def guild(self) -&gt; bool:\n\"\"\"Whether this channel is a guild channel.\"\"\"\n        return self.value not in {1, 3}\n\n    @property\n    def voice(self) -&gt; bool:\n\"\"\"Whether this channel is a voice channel.\"\"\"\n        return self.value in {2, 13}\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelTypes.GUILD_TEXT","title":"<code>GUILD_TEXT = 0</code>  <code>class-attribute</code>","text":"<p>Text channel within a server</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelTypes.DM","title":"<code>DM = 1</code>  <code>class-attribute</code>","text":"<p>Direct message between users</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelTypes.GUILD_VOICE","title":"<code>GUILD_VOICE = 2</code>  <code>class-attribute</code>","text":"<p>Voice channel within a server</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelTypes.GROUP_DM","title":"<code>GROUP_DM = 3</code>  <code>class-attribute</code>","text":"<p>Direct message between multiple users</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelTypes.GUILD_CATEGORY","title":"<code>GUILD_CATEGORY = 4</code>  <code>class-attribute</code>","text":"<p>Organizational category that contains up to 50 channels</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelTypes.GUILD_NEWS","title":"<code>GUILD_NEWS = 5</code>  <code>class-attribute</code>","text":"<p>Channel that users can follow and crosspost into their own server</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelTypes.GUILD_NEWS_THREAD","title":"<code>GUILD_NEWS_THREAD = 10</code>  <code>class-attribute</code>","text":"<p>Temporary sub-channel within a GUILD_NEWS channel</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelTypes.GUILD_PUBLIC_THREAD","title":"<code>GUILD_PUBLIC_THREAD = 11</code>  <code>class-attribute</code>","text":"<p>Temporary sub-channel within a GUILD_TEXT channel</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelTypes.GUILD_PRIVATE_THREAD","title":"<code>GUILD_PRIVATE_THREAD = 12</code>  <code>class-attribute</code>","text":"<p>Temporary sub-channel within a GUILD_TEXT channel that is only viewable by those invited and those with the MANAGE_THREADS permission</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelTypes.GUILD_STAGE_VOICE","title":"<code>GUILD_STAGE_VOICE = 13</code>  <code>class-attribute</code>","text":"<p>Voice channel for hosting events with an audience</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelTypes.GUILD_FORUM","title":"<code>GUILD_FORUM = 15</code>  <code>class-attribute</code>","text":"<p>A Forum channel</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelTypes.guild","title":"<code>guild: bool</code>  <code>property</code>","text":"<p>Whether this channel is a guild channel.</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelTypes.voice","title":"<code>voice: bool</code>  <code>property</code>","text":"<p>Whether this channel is a voice channel.</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ComponentTypes","title":"<code>ComponentTypes</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>The types of components supported by discord.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class ComponentTypes(CursedIntEnum):\n\"\"\"The types of components supported by discord.\"\"\"\n\n    ACTION_ROW = 1\n\"\"\"Container for other components\"\"\"\n    BUTTON = 2\n\"\"\"Button object\"\"\"\n    STRING_SELECT = 3\n\"\"\"Select menu for picking from text choices\"\"\"\n    INPUT_TEXT = 4\n\"\"\"Text input object\"\"\"\n    USER_SELECT = 5\n\"\"\"Select menu for picking from users\"\"\"\n    ROLE_SELECT = 6\n\"\"\"Select menu for picking from roles\"\"\"\n    MENTIONABLE_SELECT = 7\n\"\"\"Select menu for picking from mentionable objects\"\"\"\n    CHANNEL_SELECT = 8\n\"\"\"Select menu for picking from channels\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ComponentTypes.ACTION_ROW","title":"<code>ACTION_ROW = 1</code>  <code>class-attribute</code>","text":"<p>Container for other components</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ComponentTypes.BUTTON","title":"<code>BUTTON = 2</code>  <code>class-attribute</code>","text":"<p>Button object</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ComponentTypes.STRING_SELECT","title":"<code>STRING_SELECT = 3</code>  <code>class-attribute</code>","text":"<p>Select menu for picking from text choices</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ComponentTypes.INPUT_TEXT","title":"<code>INPUT_TEXT = 4</code>  <code>class-attribute</code>","text":"<p>Text input object</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ComponentTypes.USER_SELECT","title":"<code>USER_SELECT = 5</code>  <code>class-attribute</code>","text":"<p>Select menu for picking from users</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ComponentTypes.ROLE_SELECT","title":"<code>ROLE_SELECT = 6</code>  <code>class-attribute</code>","text":"<p>Select menu for picking from roles</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ComponentTypes.MENTIONABLE_SELECT","title":"<code>MENTIONABLE_SELECT = 7</code>  <code>class-attribute</code>","text":"<p>Select menu for picking from mentionable objects</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ComponentTypes.CHANNEL_SELECT","title":"<code>CHANNEL_SELECT = 8</code>  <code>class-attribute</code>","text":"<p>Select menu for picking from channels</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.CommandTypes","title":"<code>CommandTypes</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>The interaction commands supported by discord.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class CommandTypes(CursedIntEnum):\n\"\"\"The interaction commands supported by discord.\"\"\"\n\n    CHAT_INPUT = 1\n\"\"\"Slash commands; a text-based command that shows up when a user types `/`\"\"\"\n    USER = 2\n\"\"\"A UI-based command that shows up when you right click or tap on a user\"\"\"\n    MESSAGE = 3\n\"\"\"A UI-based command that shows up when you right click or tap on a message\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.CommandTypes.CHAT_INPUT","title":"<code>CHAT_INPUT = 1</code>  <code>class-attribute</code>","text":"<p>Slash commands; a text-based command that shows up when a user types <code>/</code></p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.CommandTypes.USER","title":"<code>USER = 2</code>  <code>class-attribute</code>","text":"<p>A UI-based command that shows up when you right click or tap on a user</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.CommandTypes.MESSAGE","title":"<code>MESSAGE = 3</code>  <code>class-attribute</code>","text":"<p>A UI-based command that shows up when you right click or tap on a message</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.InteractionTypes","title":"<code>InteractionTypes</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>The type of interaction received by discord.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class InteractionTypes(CursedIntEnum):\n\"\"\"The type of interaction received by discord.\"\"\"\n\n    PING = 1\n    APPLICATION_COMMAND = 2\n    MESSAGE_COMPONENT = 3\n    AUTOCOMPLETE = 4\n    MODAL_RESPONSE = 5\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.InteractionPermissionTypes","title":"<code>InteractionPermissionTypes</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>The type of interaction permission received by discord.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class InteractionPermissionTypes(CursedIntEnum):\n\"\"\"The type of interaction permission received by discord.\"\"\"\n\n    ROLE = 1\n    USER = 2\n    CHANNEL = 3\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ButtonStyles","title":"<code>ButtonStyles</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>The styles of buttons supported.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class ButtonStyles(CursedIntEnum):\n\"\"\"The styles of buttons supported.\"\"\"\n\n    # Based on discord api\n    PRIMARY = 1\n\"\"\"blurple\"\"\"\n    SECONDARY = 2\n\"\"\"grey\"\"\"\n    SUCCESS = 3\n\"\"\"green\"\"\"\n    DANGER = 4\n\"\"\"red\"\"\"\n    LINK = 5\n\"\"\"url button\"\"\"\n\n    # Aliases\n    BLUE = 1\n    BLURPLE = 1\n    GRAY = 2\n    GREY = 2\n    GREEN = 3\n    RED = 4\n    URL = 5\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ButtonStyles.PRIMARY","title":"<code>PRIMARY = 1</code>  <code>class-attribute</code>","text":"<p>blurple</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ButtonStyles.SECONDARY","title":"<code>SECONDARY = 2</code>  <code>class-attribute</code>","text":"<p>grey</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ButtonStyles.SUCCESS","title":"<code>SUCCESS = 3</code>  <code>class-attribute</code>","text":"<p>green</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ButtonStyles.DANGER","title":"<code>DANGER = 4</code>  <code>class-attribute</code>","text":"<p>red</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ButtonStyles.LINK","title":"<code>LINK = 5</code>  <code>class-attribute</code>","text":"<p>url button</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MentionTypes","title":"<code>MentionTypes</code>","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>Types of mention.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class MentionTypes(str, Enum):\n\"\"\"Types of mention.\"\"\"\n\n    EVERYONE = \"everyone\"\n    ROLES = \"roles\"\n    USERS = \"users\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.OverwriteTypes","title":"<code>OverwriteTypes</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>Types of permission overwrite.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class OverwriteTypes(CursedIntEnum):\n\"\"\"Types of permission overwrite.\"\"\"\n\n    ROLE = 0\n    MEMBER = 1\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.DefaultNotificationLevels","title":"<code>DefaultNotificationLevels</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>Default Notification levels for dms and guilds.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class DefaultNotificationLevels(CursedIntEnum):\n\"\"\"Default Notification levels for dms and guilds.\"\"\"\n\n    ALL_MESSAGES = 0\n    ONLY_MENTIONS = 1\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ExplicitContentFilterLevels","title":"<code>ExplicitContentFilterLevels</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>Automatic filtering of explicit content.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class ExplicitContentFilterLevels(CursedIntEnum):\n\"\"\"Automatic filtering of explicit content.\"\"\"\n\n    DISABLED = 0\n    MEMBERS_WITHOUT_ROLES = 1\n    ALL_MEMBERS = 2\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.MFALevels","title":"<code>MFALevels</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>Does the user use 2FA.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class MFALevels(CursedIntEnum):\n\"\"\"Does the user use 2FA.\"\"\"\n\n    NONE = 0\n    ELEVATED = 1\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.VerificationLevels","title":"<code>VerificationLevels</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>Levels of verification needed by a guild.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class VerificationLevels(CursedIntEnum):\n\"\"\"Levels of verification needed by a guild.\"\"\"\n\n    NONE = 0\n\"\"\"No verification needed\"\"\"\n    LOW = 1\n\"\"\"Must have a verified email on their Discord Account\"\"\"\n    MEDIUM = 2\n\"\"\"Must also be registered on Discord for longer than 5 minutes\"\"\"\n    HIGH = 3\n\"\"\"Must also be a member of this server for longer than 10 minutes\"\"\"\n    VERY_HIGH = 4\n\"\"\"Must have a verified phone number on their Discord Account\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.VerificationLevels.NONE","title":"<code>NONE = 0</code>  <code>class-attribute</code>","text":"<p>No verification needed</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.VerificationLevels.LOW","title":"<code>LOW = 1</code>  <code>class-attribute</code>","text":"<p>Must have a verified email on their Discord Account</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.VerificationLevels.MEDIUM","title":"<code>MEDIUM = 2</code>  <code>class-attribute</code>","text":"<p>Must also be registered on Discord for longer than 5 minutes</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.VerificationLevels.HIGH","title":"<code>HIGH = 3</code>  <code>class-attribute</code>","text":"<p>Must also be a member of this server for longer than 10 minutes</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.VerificationLevels.VERY_HIGH","title":"<code>VERY_HIGH = 4</code>  <code>class-attribute</code>","text":"<p>Must have a verified phone number on their Discord Account</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.NSFWLevels","title":"<code>NSFWLevels</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>A guilds NSFW Level.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class NSFWLevels(CursedIntEnum):\n\"\"\"A guilds NSFW Level.\"\"\"\n\n    DEFAULT = 0\n    EXPLICIT = 1\n    SAFE = 2\n    AGE_RESTRICTED = 3\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.PremiumTiers","title":"<code>PremiumTiers</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>The boost level of a server.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class PremiumTiers(CursedIntEnum):\n\"\"\"The boost level of a server.\"\"\"\n\n    NONE = 0\n\"\"\"Guild has not unlocked any Server Boost perks\"\"\"\n    TIER_1 = 1\n\"\"\"Guild has unlocked Tier 1 Server Boost perks\"\"\"\n    TIER_2 = 2\n\"\"\"Guild has unlocked Tier 2 Server Boost perks\"\"\"\n    TIER_3 = 3\n\"\"\"Guild has unlocked Tier 3 Server Boost perks\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.PremiumTiers.NONE","title":"<code>NONE = 0</code>  <code>class-attribute</code>","text":"<p>Guild has not unlocked any Server Boost perks</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.PremiumTiers.TIER_1","title":"<code>TIER_1 = 1</code>  <code>class-attribute</code>","text":"<p>Guild has unlocked Tier 1 Server Boost perks</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.PremiumTiers.TIER_2","title":"<code>TIER_2 = 2</code>  <code>class-attribute</code>","text":"<p>Guild has unlocked Tier 2 Server Boost perks</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.PremiumTiers.TIER_3","title":"<code>TIER_3 = 3</code>  <code>class-attribute</code>","text":"<p>Guild has unlocked Tier 3 Server Boost perks</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.SystemChannelFlags","title":"<code>SystemChannelFlags</code>","text":"<p>         Bases: <code>DiscordIntFlag</code></p> <p>System channel settings.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class SystemChannelFlags(DiscordIntFlag):\n\"\"\"System channel settings.\"\"\"\n\n    SUPPRESS_JOIN_NOTIFICATIONS = 1 &lt;&lt; 0\n\"\"\"Suppress member join notifications\"\"\"\n    SUPPRESS_PREMIUM_SUBSCRIPTIONS = 1 &lt;&lt; 1\n\"\"\"Suppress server boost notifications\"\"\"\n    SUPPRESS_GUILD_REMINDER_NOTIFICATIONS = 1 &lt;&lt; 2\n\"\"\"Suppress server setup tips\"\"\"\n    SUPPRESS_JOIN_NOTIFICATION_REPLIES = 1 &lt;&lt; 3\n\"\"\"Hide member join sticker reply buttons\"\"\"\n\n    # Special members\n    NONE = 0\n    ALL = AntiFlag()\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.SystemChannelFlags.SUPPRESS_JOIN_NOTIFICATIONS","title":"<code>SUPPRESS_JOIN_NOTIFICATIONS = 1 &lt;&lt; 0</code>  <code>class-attribute</code>","text":"<p>Suppress member join notifications</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.SystemChannelFlags.SUPPRESS_PREMIUM_SUBSCRIPTIONS","title":"<code>SUPPRESS_PREMIUM_SUBSCRIPTIONS = 1 &lt;&lt; 1</code>  <code>class-attribute</code>","text":"<p>Suppress server boost notifications</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.SystemChannelFlags.SUPPRESS_GUILD_REMINDER_NOTIFICATIONS","title":"<code>SUPPRESS_GUILD_REMINDER_NOTIFICATIONS = 1 &lt;&lt; 2</code>  <code>class-attribute</code>","text":"<p>Suppress server setup tips</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.SystemChannelFlags.SUPPRESS_JOIN_NOTIFICATION_REPLIES","title":"<code>SUPPRESS_JOIN_NOTIFICATION_REPLIES = 1 &lt;&lt; 3</code>  <code>class-attribute</code>","text":"<p>Hide member join sticker reply buttons</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelFlags","title":"<code>ChannelFlags</code>","text":"<p>         Bases: <code>DiscordIntFlag</code></p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class ChannelFlags(DiscordIntFlag):\n    PINNED = 1 &lt;&lt; 1\n\"\"\" Thread is pinned to the top of its parent forum channel \"\"\"\n\n    # Special members\n    NONE = 0\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ChannelFlags.PINNED","title":"<code>PINNED = 1 &lt;&lt; 1</code>  <code>class-attribute</code>","text":"<p>Thread is pinned to the top of its parent forum channel</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.VideoQualityModes","title":"<code>VideoQualityModes</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>Video quality settings.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class VideoQualityModes(CursedIntEnum):\n\"\"\"Video quality settings.\"\"\"\n\n    AUTO = 1\n    FULL = 2\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.AutoArchiveDuration","title":"<code>AutoArchiveDuration</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>Thread archive duration, in minutes.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class AutoArchiveDuration(CursedIntEnum):\n\"\"\"Thread archive duration, in minutes.\"\"\"\n\n    ONE_HOUR = 60\n    ONE_DAY = 1440\n    THREE_DAY = 4320\n    ONE_WEEK = 10080\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ActivityType","title":"<code>ActivityType</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>The types of presence activity that can be used in presences.</p> <p>Note</p> <p>Only <code>GAME</code> <code>STREAMING</code> <code>LISTENING</code> <code>WATCHING</code> and <code>COMPETING</code> are usable by bots</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class ActivityType(CursedIntEnum):\n\"\"\"\n    The types of presence activity that can be used in presences.\n\n    !!! note\n        Only `GAME` `STREAMING` `LISTENING` `WATCHING` and `COMPETING` are usable by bots\n\n    \"\"\"\n\n    GAME = 0\n\"\"\"Playing {name}; Example: Playing Rocket League\"\"\"\n    STREAMING = 1\n\"\"\"Streaming {details}; Example: Streaming Rocket League\"\"\"\n    LISTENING = 2\n\"\"\"Listening to {name}; Example: Listening to Spotify\"\"\"\n    WATCHING = 3\n\"\"\"Watching {name}; Example: Watching YouTube Together\"\"\"\n    CUSTOM = 4\n\"\"\"{emoji} {name}; Example: `:smiley: I am cool`\"\"\"\n    COMPETING = 5\n\"\"\"Competing in {name}; Example: Competing in Arena World Champions\"\"\"\n\n    PLAYING = GAME\n\"\"\"Alias for `GAME`\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ActivityType.GAME","title":"<code>GAME = 0</code>  <code>class-attribute</code>","text":"<p>Playing {name}; Example: Playing Rocket League</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ActivityType.STREAMING","title":"<code>STREAMING = 1</code>  <code>class-attribute</code>","text":"<p>Streaming {details}; Example: Streaming Rocket League</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ActivityType.LISTENING","title":"<code>LISTENING = 2</code>  <code>class-attribute</code>","text":"<p>Listening to {name}; Example: Listening to Spotify</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ActivityType.WATCHING","title":"<code>WATCHING = 3</code>  <code>class-attribute</code>","text":"<p>Watching {name}; Example: Watching YouTube Together</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ActivityType.CUSTOM","title":"<code>CUSTOM = 4</code>  <code>class-attribute</code>","text":"<p>{emoji} {name}; Example: <code>:smiley: I am cool</code></p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ActivityType.COMPETING","title":"<code>COMPETING = 5</code>  <code>class-attribute</code>","text":"<p>Competing in {name}; Example: Competing in Arena World Champions</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ActivityType.PLAYING","title":"<code>PLAYING = GAME</code>  <code>class-attribute</code>","text":"<p>Alias for <code>GAME</code></p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.Status","title":"<code>Status</code>","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>Represents the statuses a user may have.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class Status(str, Enum):\n\"\"\"Represents the statuses a user may have.\"\"\"\n\n    ONLINE = \"online\"\n    OFFLINE = \"offline\"\n    DND = \"dnd\"\n    IDLE = \"idle\"\n    INVISIBLE = \"invisible\"\n\n    AFK = IDLE\n    DO_NOT_DISTURB = DND\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ScheduledEventPrivacyLevel","title":"<code>ScheduledEventPrivacyLevel</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>The privacy level of the scheduled event.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class ScheduledEventPrivacyLevel(CursedIntEnum):\n\"\"\"The privacy level of the scheduled event.\"\"\"\n\n    GUILD_ONLY = 2\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ScheduledEventType","title":"<code>ScheduledEventType</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>The type of entity that the scheduled event is attached to.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class ScheduledEventType(CursedIntEnum):\n\"\"\"The type of entity that the scheduled event is attached to.\"\"\"\n\n    STAGE_INSTANCE = 1\n\"\"\" Stage Channel \"\"\"\n    VOICE = 2\n\"\"\" Voice Channel \"\"\"\n    EXTERNAL = 3\n\"\"\" External URL \"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ScheduledEventType.STAGE_INSTANCE","title":"<code>STAGE_INSTANCE = 1</code>  <code>class-attribute</code>","text":"<p>Stage Channel</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ScheduledEventType.VOICE","title":"<code>VOICE = 2</code>  <code>class-attribute</code>","text":"<p>Voice Channel</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ScheduledEventType.EXTERNAL","title":"<code>EXTERNAL = 3</code>  <code>class-attribute</code>","text":"<p>External URL</p>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.ScheduledEventStatus","title":"<code>ScheduledEventStatus</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>The status of the scheduled event.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class ScheduledEventStatus(CursedIntEnum):\n\"\"\"The status of the scheduled event.\"\"\"\n\n    SCHEDULED = 1\n    ACTIVE = 2\n    COMPLETED = 3\n    CANCELED = 4\n</code></pre>"},{"location":"API%20Reference/models/Discord/enums/#naff.models.discord.enums.AuditLogEventType","title":"<code>AuditLogEventType</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>The type of audit log entry type</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class AuditLogEventType(CursedIntEnum):\n\"\"\"The type of audit log entry type\"\"\"\n\n    GUILD_UPDATE = 1\n    CHANNEL_CREATE = 10\n    CHANNEL_UPDATE = 11\n    CHANNEL_DELETE = 12\n    CHANNEL_OVERWRITE_CREATE = 13\n    CHANNEL_OVERWRITE_UPDATE = 14\n    CHANNEL_OVERWRITE_DELETE = 15\n    MEMBER_KICK = 20\n    MEMBER_PRUNE = 21\n    MEMBER_BAN_ADD = 22\n    MEMBER_BAN_REMOVE = 23\n    MEMBER_UPDATE = 24\n    MEMBER_ROLE_UPDATE = 25\n    MEMBER_MOVE = 26\n    MEMBER_DISCONNECT = 27\n    BOT_ADD = 28\n    ROLE_CREATE = 30\n    ROLE_UPDATE = 31\n    ROLE_DELETE = 32\n    INVITE_CREATE = 40\n    INVITE_UPDATE = 41\n    INVITE_DELETE = 42\n    WEBHOOK_CREATE = 50\n    WEBHOOK_UPDATE = 51\n    WEBHOOK_DELETE = 52\n    EMOJI_CREATE = 60\n    EMOJI_UPDATE = 61\n    EMOJI_DELETE = 62\n    MESSAGE_DELETE = 72\n    MESSAGE_BULK_DELETE = 73\n    MESSAGE_PIN = 74\n    MESSAGE_UNPIN = 75\n    INTEGRATION_CREATE = 80\n    INTEGRATION_UPDATE = 81\n    INTEGRATION_DELETE = 82\n    STAGE_INSTANCE_CREATE = 83\n    STAGE_INSTANCE_UPDATE = 84\n    STAGE_INSTANCE_DELETE = 85\n    STICKER_CREATE = 90\n    STICKER_UPDATE = 91\n    STICKER_DELETE = 92\n    GUILD_SCHEDULED_EVENT_CREATE = 100\n    GUILD_SCHEDULED_EVENT_UPDATE = 101\n    GUILD_SCHEDULED_EVENT_DELETE = 102\n    THREAD_CREATE = 110\n    THREAD_UPDATE = 111\n    THREAD_DELETE = 112\n    APPLICATION_COMMAND_PERMISSION_UPDATE = 121\n    AUTO_MODERATION_RULE_CREATE = 140\n    AUTO_MODERATION_RULE_UPDATE = 141\n    AUTO_MODERATION_RULE_DELETE = 142\n    AUTO_MODERATION_BLOCK_MESSAGE = 143\n    CREATOR_MONETIZATION_REQUEST_CREATED = 150\n    CREATOR_MONETIZATION_TERMS_ACCEPTED = 151\n    ROLE_PROMPT_CREATE = 160\n    ROLE_PROMPT_UPDATE = 161\n    ROLE_PROMPT_DELETE = 162\n    GUILD_HOME_FEATURE_ITEM = 171\n    GUILD_HOME_FEATURE_ITEM_UPDATE = 172\n</code></pre>"},{"location":"API%20Reference/models/Discord/file/","title":"File","text":""},{"location":"API%20Reference/models/Discord/file/#naff.models.discord.file.File","title":"<code>File</code>","text":"<p>Representation of a file.</p> <p>Used for sending files to discord.</p> Source code in <code>naff\\models\\discord\\file.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass File:\n\"\"\"\n    Representation of a file.\n\n    Used for sending files to discord.\n\n    \"\"\"\n\n    file: Union[\"IOBase\", BinaryIO, \"Path\", str] = attrs.field(repr=True)\n\"\"\"Location of file to send or the bytes.\"\"\"\n    file_name: Optional[str] = attrs.field(repr=True, default=None)\n\"\"\"Set a filename that will be displayed when uploaded to discord. If you leave this empty, the file will be called `file` by default\"\"\"\n\n    def open_file(self) -&gt; BinaryIO:\n\"\"\"\n        Opens the file.\n\n        Returns:\n            A file-like BinaryIO object.\n\n        \"\"\"\n        if isinstance(self.file, (IOBase, BinaryIO)):\n            return self.file\n        else:\n            return open(str(self.file), \"rb\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/file/#naff.models.discord.file.File.file","title":"<code>file: Union[IOBase, BinaryIO, Path, str] = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>Location of file to send or the bytes.</p>"},{"location":"API%20Reference/models/Discord/file/#naff.models.discord.file.File.file_name","title":"<code>file_name: Optional[str] = attrs.field(repr=True, default=None)</code>  <code>class-attribute</code>","text":"<p>Set a filename that will be displayed when uploaded to discord. If you leave this empty, the file will be called <code>file</code> by default</p>"},{"location":"API%20Reference/models/Discord/file/#naff.models.discord.file.File.open_file","title":"<code>open_file()</code>","text":"<p>Opens the file.</p> <p>Returns:</p> Type Description <code>BinaryIO</code> <p>A file-like BinaryIO object.</p> Source code in <code>naff\\models\\discord\\file.py</code> <pre><code>def open_file(self) -&gt; BinaryIO:\n\"\"\"\n    Opens the file.\n\n    Returns:\n        A file-like BinaryIO object.\n\n    \"\"\"\n    if isinstance(self.file, (IOBase, BinaryIO)):\n        return self.file\n    else:\n        return open(str(self.file), \"rb\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/file/#naff.models.discord.file.open_file","title":"<code>open_file(file)</code>","text":"<p>Opens the file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>UPLOADABLE_TYPE</code> <p>The target file or path to file.</p> required <p>Returns:</p> Type Description <code>BinaryIO</code> <p>A file-like BinaryIO object.</p> Source code in <code>naff\\models\\discord\\file.py</code> <pre><code>def open_file(file: UPLOADABLE_TYPE) -&gt; BinaryIO:\n\"\"\"\n    Opens the file.\n\n    Args:\n        file: The target file or path to file.\n\n    Returns:\n        A file-like BinaryIO object.\n\n    \"\"\"\n    match file:\n        case File():\n            return file.open_file()\n        case IOBase() | BinaryIO():\n            return file\n        case Path() | str():\n            return open(str(file), \"rb\")\n        case _:\n            raise ValueError(f\"{file} is not a valid file\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/","title":"Guild","text":""},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildBan","title":"<code>GuildBan</code>","text":"Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass GuildBan:\n    reason: Optional[str]\n\"\"\"The reason for the ban\"\"\"\n    user: \"models.User\"\n\"\"\"The banned user\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildBan.reason","title":"<code>reason: Optional[str]</code>  <code>class-attribute</code>","text":"<p>The reason for the ban</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildBan.user","title":"<code>user: models.User</code>  <code>class-attribute</code>","text":"<p>The banned user</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.BaseGuild","title":"<code>BaseGuild</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass BaseGuild(DiscordObject):\n    name: str = attrs.field(repr=True)\n\"\"\"Name of guild. (2-100 characters, excluding trailing and leading whitespace)\"\"\"\n    description: Optional[str] = attrs.field(repr=True, default=None)\n\"\"\"The description for the guild, if the guild is discoverable\"\"\"\n\n    icon: Optional[\"models.Asset\"] = attrs.field(repr=False, default=None)\n\"\"\"Icon image asset\"\"\"\n    splash: Optional[\"models.Asset\"] = attrs.field(repr=False, default=None)\n\"\"\"Splash image asset\"\"\"\n    discovery_splash: Optional[\"models.Asset\"] = attrs.field(repr=False, default=None)\n\"\"\"Discovery splash image. Only present for guilds with the \"DISCOVERABLE\" feature.\"\"\"\n    features: List[str] = attrs.field(repr=False, factory=list)\n\"\"\"The features of this guild\"\"\"\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        if icon_hash := data.pop(\"icon\", None):\n            data[\"icon\"] = models.Asset.from_path_hash(client, f\"icons/{data['id']}/{{}}\", icon_hash)\n        if splash_hash := data.pop(\"splash\", None):\n            data[\"splash\"] = models.Asset.from_path_hash(client, f\"splashes/{data['id']}/{{}}\", splash_hash)\n        if disco_splash := data.pop(\"discovery_splash\", None):\n            data[\"discovery_splash\"] = models.Asset.from_path_hash(\n                client, f\"discovery-splashes/{data['id']}/{{}}\", disco_splash\n            )\n        return data\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.BaseGuild.name","title":"<code>name: str = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>Name of guild. (2-100 characters, excluding trailing and leading whitespace)</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.BaseGuild.description","title":"<code>description: Optional[str] = attrs.field(repr=True, default=None)</code>  <code>class-attribute</code>","text":"<p>The description for the guild, if the guild is discoverable</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.BaseGuild.icon","title":"<code>icon: Optional[models.Asset] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>Icon image asset</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.BaseGuild.splash","title":"<code>splash: Optional[models.Asset] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>Splash image asset</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.BaseGuild.discovery_splash","title":"<code>discovery_splash: Optional[models.Asset] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>Discovery splash image. Only present for guilds with the \"DISCOVERABLE\" feature.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.BaseGuild.features","title":"<code>features: List[str] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>The features of this guild</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildPreview","title":"<code>GuildPreview</code>","text":"<p>         Bases: <code>BaseGuild</code></p> <p>A partial guild object.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass GuildPreview(BaseGuild):\n\"\"\"A partial guild object.\"\"\"\n\n    emoji: list[\"models.PartialEmoji\"] = attrs.field(repr=False, factory=list)\n\"\"\"A list of custom emoji from this guild\"\"\"\n    approximate_member_count: int = attrs.field(repr=False, default=0)\n\"\"\"Approximate number of members in this guild\"\"\"\n    approximate_presence_count: int = attrs.field(repr=False, default=0)\n\"\"\"Approximate number of online members in this guild\"\"\"\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        return super()._process_dict(data, client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildPreview.emoji","title":"<code>emoji: list[models.PartialEmoji] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>A list of custom emoji from this guild</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildPreview.approximate_member_count","title":"<code>approximate_member_count: int = attrs.field(repr=False, default=0)</code>  <code>class-attribute</code>","text":"<p>Approximate number of members in this guild</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildPreview.approximate_presence_count","title":"<code>approximate_presence_count: int = attrs.field(repr=False, default=0)</code>  <code>class-attribute</code>","text":"<p>Approximate number of online members in this guild</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild","title":"<code>Guild</code>","text":"<p>         Bases: <code>BaseGuild</code></p> <p>Guilds in Discord represent an isolated collection of users and channels, and are often referred to as \"servers\" in the UI.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass Guild(BaseGuild):\n\"\"\"Guilds in Discord represent an isolated collection of users and channels, and are often referred to as \"servers\" in the UI.\"\"\"\n\n    unavailable: bool = attrs.field(repr=False, default=False)\n\"\"\"True if this guild is unavailable due to an outage.\"\"\"\n    # owner: bool = attrs.field(repr=False, default=False)  # we get this from api but it's kinda useless to store\n    afk_channel_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)\n\"\"\"The channel id for afk.\"\"\"\n    afk_timeout: Optional[int] = attrs.field(repr=False, default=None)\n\"\"\"afk timeout in seconds.\"\"\"\n    widget_enabled: bool = attrs.field(repr=False, default=False)\n\"\"\"True if the server widget is enabled.\"\"\"\n    widget_channel_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)\n\"\"\"The channel id that the widget will generate an invite to, or None if set to no invite.\"\"\"\n    verification_level: Union[VerificationLevels, int] = attrs.field(repr=False, default=VerificationLevels.NONE)\n\"\"\"The verification level required for the guild.\"\"\"\n    default_message_notifications: Union[DefaultNotificationLevels, int] = attrs.field(\n        repr=False, default=DefaultNotificationLevels.ALL_MESSAGES\n    )\n\"\"\"The default message notifications level.\"\"\"\n    explicit_content_filter: Union[ExplicitContentFilterLevels, int] = attrs.field(\n        repr=False, default=ExplicitContentFilterLevels.DISABLED\n    )\n\"\"\"The explicit content filter level.\"\"\"\n    mfa_level: Union[MFALevels, int] = attrs.field(repr=False, default=MFALevels.NONE)\n\"\"\"The required MFA (Multi Factor Authentication) level for the guild.\"\"\"\n    system_channel_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)\n\"\"\"The id of the channel where guild notices such as welcome messages and boost events are posted.\"\"\"\n    system_channel_flags: SystemChannelFlags = attrs.field(\n        repr=False, default=SystemChannelFlags.NONE, converter=SystemChannelFlags\n    )\n\"\"\"The system channel flags.\"\"\"\n    rules_channel_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)\n\"\"\"The id of the channel where Community guilds can display rules and/or guidelines.\"\"\"\n    joined_at: str = attrs.field(repr=False, default=None, converter=optional(timestamp_converter))\n\"\"\"When this guild was joined at.\"\"\"\n    large: bool = attrs.field(repr=False, default=False)\n\"\"\"True if this is considered a large guild.\"\"\"\n    member_count: int = attrs.field(repr=False, default=0)\n\"\"\"The total number of members in this guild.\"\"\"\n    presences: List[dict] = attrs.field(repr=False, factory=list)\n\"\"\"The presences of the members in the guild, will only include non-offline members if the size is greater than large threshold.\"\"\"\n    max_presences: Optional[int] = attrs.field(repr=False, default=None)\n\"\"\"The maximum number of presences for the guild. (None is always returned, apart from the largest of guilds)\"\"\"\n    max_members: Optional[int] = attrs.field(repr=False, default=None)\n\"\"\"The maximum number of members for the guild.\"\"\"\n    vanity_url_code: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The vanity url code for the guild.\"\"\"\n    banner: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"Hash for banner image.\"\"\"\n    premium_tier: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"The premium tier level. (Server Boost level)\"\"\"\n    premium_subscription_count: int = attrs.field(repr=False, default=0)\n\"\"\"The number of boosts this guild currently has.\"\"\"\n    preferred_locale: str = attrs.field(\n        repr=False,\n    )\n\"\"\"The preferred locale of a Community guild. Used in server discovery and notices from Discord. Defaults to \\\"en-US\\\"\"\"\"\n    public_updates_channel_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)\n\"\"\"The id of the channel where admins and moderators of Community guilds receive notices from Discord.\"\"\"\n    max_video_channel_users: int = attrs.field(repr=False, default=0)\n\"\"\"The maximum amount of users in a video channel.\"\"\"\n    welcome_screen: Optional[\"GuildWelcome\"] = attrs.field(repr=False, default=None)\n\"\"\"The welcome screen of a Community guild, shown to new members, returned in an Invite's guild object.\"\"\"\n    nsfw_level: Union[NSFWLevels, int] = attrs.field(repr=False, default=NSFWLevels.DEFAULT)\n\"\"\"The guild NSFW level.\"\"\"\n    stage_instances: List[dict] = attrs.field(repr=False, factory=list)  # TODO stage instance objects\n\"\"\"Stage instances in the guild.\"\"\"\n    chunked = attrs.field(repr=False, factory=asyncio.Event, metadata=no_export_meta)\n\"\"\"An event that is fired when this guild has been chunked\"\"\"\n    command_permissions: dict[Snowflake_Type, CommandPermissions] = attrs.field(\n        repr=False, factory=dict, metadata=no_export_meta\n    )\n\"\"\"A cache of all command permissions for this guild\"\"\"\n\n    _owner_id: Snowflake_Type = attrs.field(repr=False, converter=to_snowflake)\n    _channel_ids: Set[Snowflake_Type] = attrs.field(repr=False, factory=set)\n    _thread_ids: Set[Snowflake_Type] = attrs.field(repr=False, factory=set)\n    _member_ids: Set[Snowflake_Type] = attrs.field(repr=False, factory=set)\n    _role_ids: Set[Snowflake_Type] = attrs.field(repr=False, factory=set)\n    _chunk_cache: list = attrs.field(repr=False, factory=list)\n    _channel_gui_positions: Dict[Snowflake_Type, int] = attrs.field(repr=False, factory=dict)\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        data = super()._process_dict(data, client)\n        guild_id = data[\"id\"]\n\n        channels_data = data.pop(\"channels\", [])\n        for c in channels_data:\n            c[\"guild_id\"] = guild_id\n        data[\"channel_ids\"] = {client.cache.place_channel_data(channel_data).id for channel_data in channels_data}\n\n        threads_data = data.pop(\"threads\", [])\n        data[\"thread_ids\"] = {client.cache.place_channel_data(thread_data).id for thread_data in threads_data}\n\n        members_data = data.pop(\"members\", [])\n        data[\"member_ids\"] = {client.cache.place_member_data(guild_id, member_data).id for member_data in members_data}\n\n        roles_data = data.pop(\"roles\", [])\n        data[\"role_ids\"] = set(client.cache.place_role_data(guild_id, roles_data).keys())\n\n        if welcome_screen := data.get(\"welcome_screen\"):\n            data[\"welcome_screen\"] = GuildWelcome.from_dict(welcome_screen, client)\n\n        if voice_states := data.get(\"voice_states\"):\n            [\n                asyncio.create_task(client.cache.place_voice_state_data(state | {\"guild_id\": guild_id}))\n                for state in voice_states\n            ]\n        return data\n\n    @classmethod\n    async def create(\n        cls,\n        name: str,\n        client: \"Client\",\n        *,\n        icon: Absent[Optional[UPLOADABLE_TYPE]] = MISSING,\n        verification_level: Absent[\"VerificationLevels\"] = MISSING,\n        default_message_notifications: Absent[\"DefaultNotificationLevels\"] = MISSING,\n        explicit_content_filter: Absent[\"ExplicitContentFilterLevels\"] = MISSING,\n        roles: Absent[list[dict]] = MISSING,\n        channels: Absent[list[dict]] = MISSING,\n        afk_channel_id: Absent[\"Snowflake_Type\"] = MISSING,\n        afk_timeout: Absent[int] = MISSING,\n        system_channel_id: Absent[\"Snowflake_Type\"] = MISSING,\n        system_channel_flags: Absent[\"SystemChannelFlags\"] = MISSING,\n    ) -&gt; \"Guild\":\n\"\"\"\n        Create a guild.\n\n        !!! note\n            This method will only work for bots in less than 10 guilds.\n\n        ??? note \"Param notes\"\n            Roles:\n                - When using the `roles` parameter, the first member of the array is used to change properties of the guild's `@everyone` role. If you are trying to bootstrap a guild with additional roles, keep this in mind.\n                - When using the `roles` parameter, the required id field within each role object is an integer placeholder, and will be replaced by the API upon consumption. Its purpose is to allow you to overwrite a role's permissions in a channel when also passing in channels with the channels array.\n\n            Channels:\n                - When using the `channels` parameter, the position field is ignored, and none of the default channels are created.\n                - When using the `channels` parameter, the id field within each channel object may be set to an integer placeholder, and will be replaced by the API upon consumption. Its purpose is to allow you to create `GUILD_CATEGORY` channels by setting the `parent_id` field on any children to the category's id field. Category channels must be listed before any children.\n\n        Args:\n            name: name of the guild (2-100 characters)\n            client: The NAFF client\n            icon: An icon for the guild\n            verification_level: The guild's verification level\n            default_message_notifications: The default message notification level\n            explicit_content_filter: The guild's explicit content filter level\n            roles: An array of partial role dictionaries\n            channels: An array of partial channel dictionaries\n            afk_channel_id: id for afk channel\n            afk_timeout: afk timeout in seconds\n            system_channel_id: the id of the channel where guild notices should go\n            system_channel_flags: flags for the system channel\n\n        Returns:\n            The created guild object\n\n        \"\"\"\n        data = await client.http.create_guild(\n            name=name,\n            icon=to_image_data(icon) if icon else MISSING,\n            verification_level=verification_level,\n            default_message_notifications=default_message_notifications,\n            explicit_content_filter=explicit_content_filter,\n            roles=roles,\n            channels=channels,\n            afk_channel_id=afk_channel_id,\n            afk_timeout=afk_timeout,\n            system_channel_id=system_channel_id,\n            system_channel_flags=int(system_channel_flags) if system_channel_flags else MISSING,\n        )\n        return client.cache.place_guild_data(data)\n\n    @property\n    def channels(self) -&gt; List[\"models.TYPE_GUILD_CHANNEL\"]:\n\"\"\"Returns a list of channels associated with this guild.\"\"\"\n        channels = [self._client.cache.get_channel(c_id) for c_id in self._channel_ids]\n        return [c for c in channels if c]\n\n    @property\n    def threads(self) -&gt; List[\"models.TYPE_THREAD_CHANNEL\"]:\n\"\"\"Returns a list of threads associated with this guild.\"\"\"\n        return [self._client.cache.get_channel(t_id) for t_id in self._thread_ids]\n\n    @property\n    def members(self) -&gt; List[\"models.Member\"]:\n\"\"\"Returns a list of all members within this guild.\"\"\"\n        return [self._client.cache.get_member(self.id, m_id) for m_id in self._member_ids]\n\n    @property\n    def premium_subscribers(self) -&gt; List[\"models.Member\"]:\n\"\"\"Returns a list of all premium subscribers\"\"\"\n        return [member for member in self.members if member.premium]\n\n    @property\n    def bots(self) -&gt; List[\"models.Member\"]:\n\"\"\"Returns a list of all bots within this guild\"\"\"\n        return [member for member in self.members if member.bot]\n\n    @property\n    def humans(self) -&gt; List[\"models.Member\"]:\n\"\"\"Returns a list of all humans within this guild\"\"\"\n        return [member for member in self.members if not member.bot]\n\n    @property\n    def roles(self) -&gt; List[\"models.Role\"]:\n\"\"\"Returns a list of roles associated with this guild.\"\"\"\n        return [self._client.cache.get_role(r_id) for r_id in self._role_ids]\n\n    @property\n    def me(self) -&gt; \"models.Member\":\n\"\"\"Returns this bots member object within this guild.\"\"\"\n        return self._client.cache.get_member(self.id, self._client.user.id)\n\n    @property\n    def system_channel(self) -&gt; Optional[\"models.GuildText\"]:\n\"\"\"Returns the channel this guild uses for system messages.\"\"\"\n        return self._client.cache.get_channel(self.system_channel_id)\n\n    @property\n    def rules_channel(self) -&gt; Optional[\"models.GuildText\"]:\n\"\"\"Returns the channel declared as a rules channel.\"\"\"\n        return self._client.cache.get_channel(self.rules_channel_id)\n\n    @property\n    def public_updates_channel(self) -&gt; Optional[\"models.GuildText\"]:\n\"\"\"Returns the channel where server staff receive notices from Discord.\"\"\"\n        return self._client.cache.get_channel(self.public_updates_channel_id)\n\n    @property\n    def emoji_limit(self) -&gt; int:\n\"\"\"The maximum number of emoji this guild can have.\"\"\"\n        base = 200 if \"MORE_EMOJI\" in self.features else 50\n        return max(base, PREMIUM_GUILD_LIMITS[self.premium_tier][\"emoji\"])\n\n    @property\n    def sticker_limit(self) -&gt; int:\n\"\"\"The maximum number of stickers this guild can have.\"\"\"\n        base = 60 if \"MORE_STICKERS\" in self.features else 0\n        return max(base, PREMIUM_GUILD_LIMITS[self.premium_tier][\"stickers\"])\n\n    @property\n    def bitrate_limit(self) -&gt; int:\n\"\"\"The maximum bitrate for this guild.\"\"\"\n        base = 128000 if \"VIP_REGIONS\" in self.features else 96000\n        return max(base, PREMIUM_GUILD_LIMITS[self.premium_tier][\"bitrate\"])\n\n    @property\n    def filesize_limit(self) -&gt; int:\n\"\"\"The maximum filesize that may be uploaded within this guild.\"\"\"\n        return PREMIUM_GUILD_LIMITS[self.premium_tier][\"filesize\"]\n\n    @property\n    def default_role(self) -&gt; \"models.Role\":\n\"\"\"The `@everyone` role in this guild.\"\"\"\n        return self._client.cache.get_role(self.id)  # type: ignore\n\n    @property\n    def premium_subscriber_role(self) -&gt; Optional[\"models.Role\"]:\n\"\"\"The role given to boosters of this server, if set.\"\"\"\n        for role in self.roles:\n            if role.premium_subscriber:\n                return role\n        return None\n\n    @property\n    def my_role(self) -&gt; Optional[\"models.Role\"]:\n\"\"\"The role associated with this client, if set.\"\"\"\n        m_r_id = self._client.user.id\n        for role in self.roles:\n            if role._bot_id == m_r_id:\n                return role\n        return None\n\n    @property\n    def permissions(self) -&gt; Permissions:\n\"\"\"Alias for me.guild_permissions\"\"\"\n        return self.me.guild_permissions\n\n    @property\n    def voice_state(self) -&gt; Optional[\"models.VoiceState\"]:\n\"\"\"Get the bot's voice state for the guild.\"\"\"\n        return self._client.cache.get_bot_voice_state(self.id)\n\n    @property\n    def voice_states(self) -&gt; List[\"models.VoiceState\"]:\n\"\"\"Get a list of the active voice states in this guild.\"\"\"\n        # this is *very* ick, but we cache by user_id, so we have to do it this way,\n        # alternative would be maintaining a lookup table in this guild object, which is inherently unreliable\n        # noinspection PyProtectedMember\n        return [v_state for v_state in self._client.cache.voice_state_cache.values() if v_state._guild_id == self.id]\n\n    async def fetch_member(self, member_id: Snowflake_Type) -&gt; Optional[\"models.Member\"]:\n\"\"\"\n        Return the Member with the given discord ID, fetching from the API if necessary.\n\n        Args:\n            member_id: The ID of the member.\n\n        Returns:\n            The member object fetched. If the member is not in this guild, returns None.\n\n        \"\"\"\n        try:\n            return await self._client.cache.fetch_member(self.id, member_id)\n        except NotFound:\n            return None\n\n    def get_member(self, member_id: Snowflake_Type) -&gt; Optional[\"models.Member\"]:\n\"\"\"\n        Return the Member with the given discord ID.\n\n        Args:\n            member_id: The ID of the member\n\n        Returns:\n            Member object or None\n\n        \"\"\"\n        return self._client.cache.get_member(self.id, member_id)\n\n    async def fetch_owner(self) -&gt; \"models.Member\":\n\"\"\"\n        Return the Guild owner, fetching from the API if necessary.\n\n        Returns:\n            Member object or None\n\n        \"\"\"\n        return await self._client.cache.fetch_member(self.id, self._owner_id)\n\n    def get_owner(self) -&gt; \"models.Member\":\n\"\"\"\n        Return the Guild owner\n\n        Returns:\n            Member object or None\n\n        \"\"\"\n        return self._client.cache.get_member(self.id, self._owner_id)\n\n    async def fetch_channels(self) -&gt; List[\"models.TYPE_VOICE_CHANNEL\"]:\n\"\"\"\n        Fetch this guild's channels.\n\n        Returns:\n            A list of channels in this guild\n\n        \"\"\"\n        data = await self._client.http.get_guild_channels(self.id)\n        return [self._client.cache.place_channel_data(channel_data) for channel_data in data]\n\n    async def fetch_app_cmd_perms(self) -&gt; dict[Snowflake_Type, \"CommandPermissions\"]:\n\"\"\"\n        Fetch the application command permissions for this guild.\n\n        Returns:\n            The application command permissions for this guild.\n\n        \"\"\"\n        data = await self._client.http.batch_get_application_command_permissions(self._client.app.id, self.id)\n\n        for command in data:\n            command_permissions = CommandPermissions(client=self._client, command_id=command[\"id\"], guild=self)\n            perms = [ApplicationCommandPermission.from_dict(perm, self) for perm in command[\"permissions\"]]\n\n            command_permissions.update_permissions(*perms)\n\n            self.command_permissions[int(command[\"id\"])] = command_permissions\n\n        return self.command_permissions\n\n    def is_owner(self, user: Snowflake_Type) -&gt; bool:\n\"\"\"\n        Whether the user is owner of the guild.\n\n        Args:\n            user: The user to check\n\n        Returns:\n            True if the user is the owner of the guild, False otherwise.\n\n        !!! note\n            the `user` argument can be any type that meets `Snowflake_Type`\n\n        \"\"\"\n        return self._owner_id == to_snowflake(user)\n\n    async def edit_nickname(self, new_nickname: Absent[str] = MISSING, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n        Alias for me.edit_nickname\n\n        Args:\n            new_nickname: The new nickname to apply\n            reason: The reason for this change\n\n        !!! note\n            Leave `new_nickname` empty to clean user's nickname\n\n        \"\"\"\n        await self.me.edit_nickname(new_nickname, reason=reason)\n\n    async def http_chunk(self) -&gt; None:\n\"\"\"Populates all members of this guild using the REST API.\"\"\"\n        start_time = time.perf_counter()\n\n        iterator = MemberIterator(self)\n        async for member in iterator:\n            self._client.cache.place_member_data(self.id, member)\n\n        self.chunked.set()\n        self.logger.info(\n            f\"Cached {iterator.total_retrieved} members for {self.id} in {time.perf_counter() - start_time:.2f} seconds\"\n        )\n\n    async def gateway_chunk(self, wait=True, presences=True) -&gt; None:\n\"\"\"\n        Trigger a gateway `get_members` event, populating this object with members.\n\n        Args:\n            wait: Wait for chunking to be completed before continuing\n            presences: Do you need presence data for members?\n        \"\"\"\n        ws = self._client.get_guild_websocket(self.id)\n        await ws.request_member_chunks(self.id, limit=0, presences=presences)\n        if wait:\n            await self.chunked.wait()\n\n    async def chunk(self) -&gt; None:\n\"\"\"Populates all members of this guild using the REST API.\"\"\"\n        await self.http_chunk()\n\n    async def chunk_guild(self, wait=True, presences=True) -&gt; None:\n\"\"\"\n        Trigger a gateway `get_members` event, populating this object with members.\n\n        !!! warning \"Depreciation Warning\"\n            Gateway chunking is deprecated and replaced by http chunking. Use `guild.gateway_chunk` if you need gateway chunking.\n\n        Args:\n            wait: Wait for chunking to be completed before continuing\n            presences: Do you need presence data for members?\n\n        \"\"\"\n        warn(\n            \"Gateway chunking is deprecated and replaced by http chunking. Use `guild.gateway_chunk` if you need gateway chunking.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        await self.gateway_chunk(wait=wait, presences=presences)\n\n    async def process_member_chunk(self, chunk: dict) -&gt; None:\n\"\"\"\n        Receive and either cache or process the chunks of members from gateway.\n\n        Args:\n            chunk: A member chunk from discord\n\n        \"\"\"\n        if self.chunked.is_set():\n            self.chunked.clear()\n\n        if presences := chunk.get(\"presences\"):\n            # combine the presence dict into the members dict\n            for presence in presences:\n                u_id = presence[\"user\"][\"id\"]\n                # find the user this presence is for\n                member_index = next(\n                    (index for (index, d) in enumerate(chunk.get(\"members\")) if d[\"user\"][\"id\"] == u_id), None\n                )\n                del presence[\"user\"]\n                chunk[\"members\"][member_index][\"user\"] = chunk[\"members\"][member_index][\"user\"] | presence\n\n        if not self._chunk_cache:\n            self._chunk_cache: List = chunk.get(\"members\")\n        else:\n            self._chunk_cache = self._chunk_cache + chunk.get(\"members\")\n\n        if chunk.get(\"chunk_index\") != chunk.get(\"chunk_count\") - 1:\n            return self.logger.debug(f\"Cached chunk of {len(chunk.get('members'))} members for {self.id}\")\n        else:\n            members = self._chunk_cache\n            self.logger.info(f\"Processing {len(members)} members for {self.id}\")\n\n            s = time.monotonic()\n            start_time = time.perf_counter()\n\n            for member in members:\n                self._client.cache.place_member_data(self.id, member)\n                if (time.monotonic() - s) &gt; 0.05:\n                    # look, i get this *could* be a thread, but because it needs to modify data in the main thread,\n                    # it is still blocking. So by periodically yielding to the event loop, we can avoid blocking, and still\n                    # process this data properly\n                    await asyncio.sleep(0)\n                    s = time.monotonic()\n\n            total_time = time.perf_counter() - start_time\n            self.chunk_cache = []\n            self.logger.info(f\"Cached members for {self.id} in {total_time:.2f} seconds\")\n            self.chunked.set()\n\n    async def fetch_audit_log(\n        self,\n        user_id: Optional[\"Snowflake_Type\"] = MISSING,\n        action_type: Optional[\"AuditLogEventType\"] = MISSING,\n        before: Optional[\"Snowflake_Type\"] = MISSING,\n        after: Optional[\"Snowflake_Type\"] = MISSING,\n        limit: int = 100,\n    ) -&gt; \"AuditLog\":\n\"\"\"\n        Fetch section of the audit log for this guild.\n\n        Args:\n            user_id: The ID of the user to filter by\n            action_type: The type of action to filter by\n            before: The ID of the entry to start at\n            after: The ID of the entry to end at\n            limit: The number of entries to return\n\n        Returns:\n            An AuditLog object\n\n        \"\"\"\n        data = await self._client.http.get_audit_log(self.id, user_id, action_type, before, after, limit)\n        return AuditLog.from_dict(data, self._client)\n\n    def audit_log_history(\n        self,\n        user_id: Optional[\"Snowflake_Type\"] = MISSING,\n        action_type: Optional[\"AuditLogEventType\"] = MISSING,\n        before: Optional[\"Snowflake_Type\"] = MISSING,\n        after: Optional[\"Snowflake_Type\"] = MISSING,\n        limit: int = 100,\n    ) -&gt; \"AuditLogHistory\":\n\"\"\"\n        Get an async iterator for the history of the audit log.\n\n        Args:\n            user_id (:class:`Snowflake_Type`): The user ID to search for.\n            action_type (:class:`AuditLogEventType`): The action type to search for.\n            before: get entries before this message ID\n            after: get entries after this message ID\n            limit: The maximum number of entries to return (set to 0 for no limit)\n\n        ??? Hint \"Example Usage:\"\n            ```python\n            async for entry in guild.audit_log_history(limit=0):\n                entry: \"AuditLogEntry\"\n                if entry.changes:\n                    # ...\n            ```\n            or\n            ```python\n            history = guild.audit_log_history(limit=250)\n            # Flatten the async iterator into a list\n            entries = await history.flatten()\n            ```\n\n        Returns:\n            AuditLogHistory (AsyncIterator)\n\n        \"\"\"\n        return AuditLogHistory(self, user_id, action_type, before, after, limit)\n\n    async def edit(\n        self,\n        *,\n        name: Absent[Optional[str]] = MISSING,\n        description: Absent[Optional[str]] = MISSING,\n        verification_level: Absent[Optional[\"VerificationLevels\"]] = MISSING,\n        default_message_notifications: Absent[Optional[\"DefaultNotificationLevels\"]] = MISSING,\n        explicit_content_filter: Absent[Optional[\"ExplicitContentFilterLevels\"]] = MISSING,\n        afk_channel: Absent[Optional[Union[\"models.GuildVoice\", Snowflake_Type]]] = MISSING,\n        afk_timeout: Absent[Optional[int]] = MISSING,\n        system_channel: Absent[Optional[Union[\"models.GuildText\", Snowflake_Type]]] = MISSING,\n        system_channel_flags: Absent[Union[SystemChannelFlags, int]] = MISSING,\n        owner: Absent[Optional[Union[\"models.Member\", Snowflake_Type]]] = MISSING,\n        icon: Absent[Optional[UPLOADABLE_TYPE]] = MISSING,\n        splash: Absent[Optional[UPLOADABLE_TYPE]] = MISSING,\n        discovery_splash: Absent[Optional[UPLOADABLE_TYPE]] = MISSING,\n        banner: Absent[Optional[UPLOADABLE_TYPE]] = MISSING,\n        rules_channel: Absent[Optional[Union[\"models.GuildText\", Snowflake_Type]]] = MISSING,\n        public_updates_channel: Absent[Optional[Union[\"models.GuildText\", Snowflake_Type]]] = MISSING,\n        preferred_locale: Absent[Optional[str]] = MISSING,\n        # ToDo: Fill in guild features. No idea how this works - https://discord.com/developers/docs/resources/guild#guild-object-guild-features\n        features: Absent[Optional[list[str]]] = MISSING,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; None:\n\"\"\"\n        Edit the guild.\n\n        Args:\n            name: The new name of the guild.\n            description: The new description of the guild.\n            verification_level: The new verification level for the guild.\n            default_message_notifications: The new notification level for the guild.\n            explicit_content_filter: The new explicit content filter level for the guild.\n            afk_channel: The voice channel that should be the new AFK channel.\n            afk_timeout: How many seconds does a member need to be afk before they get moved to the AFK channel. Must be either `60`, `300`, `900`, `1800` or `3600`, otherwise HTTPException will be raised.\n            icon: The new icon. Requires a bytes like object or a path to an image.\n            owner: The new owner of the guild. You, the bot, need to be owner for this to work.\n            splash: The new invite splash image. Requires a bytes like object or a path to an image.\n            discovery_splash: The new discovery image. Requires a bytes like object or a path to an image.\n            banner: The new banner image. Requires a bytes like object or a path to an image.\n            system_channel: The text channel where new system messages should appear. This includes boosts and welcome messages.\n            system_channel_flags: The new settings for the system channel.\n            rules_channel: The text channel where your rules and community guidelines are displayed.\n            public_updates_channel: The text channel where updates from discord should appear.\n            preferred_locale: The new preferred locale of the guild. Must be an ISO 639 code.\n            features: The enabled guild features\n            reason: An optional reason for the audit log.\n\n        \"\"\"\n        await self._client.http.modify_guild(\n            guild_id=self.id,\n            name=name,\n            description=description,\n            verification_level=int(verification_level) if verification_level else MISSING,\n            default_message_notifications=int(default_message_notifications)\n            if default_message_notifications\n            else MISSING,\n            explicit_content_filter=int(explicit_content_filter) if explicit_content_filter else MISSING,\n            afk_channel_id=to_snowflake(afk_channel) if afk_channel else MISSING,\n            afk_timeout=afk_timeout,\n            icon=to_image_data(icon) if icon else MISSING,\n            owner_id=to_snowflake(owner) if owner else MISSING,\n            splash=to_image_data(splash) if splash else MISSING,\n            discovery_splash=to_image_data(discovery_splash) if discovery_splash else MISSING,\n            banner=to_image_data(banner) if banner else MISSING,\n            system_channel_id=to_snowflake(system_channel) if system_channel else MISSING,\n            system_channel_flags=int(system_channel_flags) if system_channel_flags else MISSING,\n            rules_channel_id=to_snowflake(rules_channel) if rules_channel else MISSING,\n            public_updates_channel_id=to_snowflake(public_updates_channel) if public_updates_channel else MISSING,\n            preferred_locale=preferred_locale,\n            features=features,\n            reason=reason,\n        )\n\n    async def create_custom_emoji(\n        self,\n        name: str,\n        imagefile: UPLOADABLE_TYPE,\n        roles: Absent[List[Union[Snowflake_Type, \"models.Role\"]]] = MISSING,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"models.CustomEmoji\":\n\"\"\"\n        Create a new custom emoji for the guild.\n\n        Args:\n            name: Name of the emoji\n            imagefile: The emoji image. (Supports PNG, JPEG, WebP, GIF)\n            roles: Roles allowed to use this emoji.\n            reason: An optional reason for the audit log.\n\n        Returns:\n            The new custom emoji created.\n\n        \"\"\"\n        data_payload = {\n            \"name\": name,\n            \"image\": to_image_data(imagefile),\n            \"roles\": to_snowflake_list(roles) if roles else MISSING,\n        }\n\n        emoji_data = await self._client.http.create_guild_emoji(data_payload, self.id, reason=reason)\n        return self._client.cache.place_emoji_data(self.id, emoji_data)\n\n    async def create_guild_template(self, name: str, description: Absent[str] = MISSING) -&gt; \"models.GuildTemplate\":\n\"\"\"\n        Create a new guild template based on this guild.\n\n        Args:\n            name: The name of the template (1-100 characters)\n            description: The description for the template (0-120 characters)\n\n        Returns:\n            The new guild template created.\n\n        \"\"\"\n        template = await self._client.http.create_guild_template(self.id, name, description)\n        return GuildTemplate.from_dict(template, self._client)\n\n    async def fetch_guild_templates(self) -&gt; List[\"models.GuildTemplate\"]:\n\"\"\"\n        Fetch all guild templates for this guild.\n\n        Returns:\n            A list of guild template objects.\n\n        \"\"\"\n        templates = await self._client.http.get_guild_templates(self.id)\n        return GuildTemplate.from_list(templates, self._client)\n\n    async def fetch_all_custom_emojis(self) -&gt; List[\"models.CustomEmoji\"]:\n\"\"\"\n        Gets all the custom emoji present for this guild.\n\n        Returns:\n            A list of custom emoji objects.\n\n        \"\"\"\n        emojis_data = await self._client.http.get_all_guild_emoji(self.id)\n        return [self._client.cache.place_emoji_data(self.id, emoji_data) for emoji_data in emojis_data]\n\n    async def fetch_custom_emoji(self, emoji_id: Snowflake_Type) -&gt; Optional[\"models.CustomEmoji\"]:\n\"\"\"\n        Fetches the custom emoji present for this guild, based on the emoji id.\n\n        Args:\n            emoji_id: The target emoji to get data of.\n\n        Returns:\n            The custom emoji object. If the emoji is not found, returns None.\n\n        \"\"\"\n        try:\n            return await self._client.cache.fetch_emoji(self.id, emoji_id)\n        except NotFound:\n            return None\n\n    def get_custom_emoji(self, emoji_id: Snowflake_Type) -&gt; Optional[\"models.CustomEmoji\"]:\n\"\"\"\n        Gets the custom emoji present for this guild, based on the emoji id.\n\n        Args:\n            emoji_id: The target emoji to get data of.\n\n        Returns:\n            The custom emoji object.\n\n        \"\"\"\n        emoji_id = to_snowflake(emoji_id)\n        emoji = self._client.cache.get_emoji(emoji_id)\n        if emoji and emoji._guild_id == self.id:\n            return emoji\n        return None\n\n    async def create_channel(\n        self,\n        channel_type: Union[ChannelTypes, int],\n        name: str,\n        topic: Absent[Optional[str]] = MISSING,\n        position: Absent[Optional[int]] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, \"models.PermissionOverwrite\", List[Union[dict, \"models.PermissionOverwrite\"]]]\n        ] = MISSING,\n        category: Union[Snowflake_Type, \"models.GuildCategory\"] = None,\n        nsfw: bool = False,\n        bitrate: int = 64000,\n        user_limit: int = 0,\n        rate_limit_per_user: int = 0,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"models.TYPE_GUILD_CHANNEL\":\n\"\"\"\n        Create a guild channel, allows for explicit channel type setting.\n\n        Args:\n            channel_type: The type of channel to create\n            name: The name of the channel\n            topic: The topic of the channel\n            position: The position of the channel in the channel list\n            permission_overwrites: Permission overwrites to apply to the channel\n            category: The category this channel should be within\n            nsfw: Should this channel be marked nsfw\n            bitrate: The bitrate of this channel, only for voice\n            user_limit: The max users that can be in this channel, only for voice\n            rate_limit_per_user: The time users must wait between sending messages\n            reason: The reason for creating this channel\n\n        Returns:\n            The newly created channel.\n\n        \"\"\"\n        channel_data = await self._client.http.create_guild_channel(\n            self.id,\n            name,\n            channel_type,\n            topic,\n            position,\n            models.process_permission_overwrites(permission_overwrites),\n            to_optional_snowflake(category),\n            nsfw,\n            bitrate,\n            user_limit,\n            rate_limit_per_user,\n            reason,\n        )\n        return self._client.cache.place_channel_data(channel_data)\n\n    async def create_text_channel(\n        self,\n        name: str,\n        topic: Absent[Optional[str]] = MISSING,\n        position: Absent[Optional[int]] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, \"models.PermissionOverwrite\", List[Union[dict, \"models.PermissionOverwrite\"]]]\n        ] = MISSING,\n        category: Union[Snowflake_Type, \"models.GuildCategory\"] = None,\n        nsfw: bool = False,\n        rate_limit_per_user: int = 0,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"models.GuildText\":\n\"\"\"\n        Create a text channel in this guild.\n\n        Args:\n            name: The name of the channel\n            topic: The topic of the channel\n            position: The position of the channel in the channel list\n            permission_overwrites: Permission overwrites to apply to the channel\n            category: The category this channel should be within\n            nsfw: Should this channel be marked nsfw\n            rate_limit_per_user: The time users must wait between sending messages\n            reason: The reason for creating this channel\n\n        Returns:\n           The newly created text channel.\n\n        \"\"\"\n        return await self.create_channel(\n            channel_type=ChannelTypes.GUILD_TEXT,\n            name=name,\n            topic=topic,\n            position=position,\n            permission_overwrites=permission_overwrites,\n            category=category,\n            nsfw=nsfw,\n            rate_limit_per_user=rate_limit_per_user,\n            reason=reason,\n        )\n\n    async def create_forum_channel(\n        self,\n        name: str,\n        topic: Absent[Optional[str]] = MISSING,\n        position: Absent[Optional[int]] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, \"models.PermissionOverwrite\", List[Union[dict, \"models.PermissionOverwrite\"]]]\n        ] = MISSING,\n        category: Union[Snowflake_Type, \"models.GuildCategory\"] = None,\n        nsfw: bool = False,\n        rate_limit_per_user: int = 0,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"models.GuildForum\":\n\"\"\"\n        Create a forum channel in this guild.\n\n        Args:\n            name: The name of the forum channel\n            topic: The topic of the forum channel\n            position: The position of the forum channel in the channel list\n            permission_overwrites: Permission overwrites to apply to the forum channel\n            category: The category this forum channel should be within\n            nsfw: Should this forum be marked nsfw\n            rate_limit_per_user: The time users must wait between sending messages\n            reason: The reason for creating this channel\n\n        Returns:\n           The newly created forum channel.\n\n        \"\"\"\n        return await self.create_channel(\n            channel_type=ChannelTypes.GUILD_FORUM,\n            name=name,\n            topic=topic,\n            position=position,\n            permission_overwrites=permission_overwrites,\n            category=category,\n            nsfw=nsfw,\n            rate_limit_per_user=rate_limit_per_user,\n            reason=reason,\n        )\n\n    async def create_news_channel(\n        self,\n        name: str,\n        topic: Absent[Optional[str]] = MISSING,\n        position: Absent[Optional[int]] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, \"models.PermissionOverwrite\", List[Union[dict, \"models.PermissionOverwrite\"]]]\n        ] = MISSING,\n        category: Union[Snowflake_Type, \"models.GuildCategory\"] = None,\n        nsfw: bool = False,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"models.GuildNews\":\n\"\"\"\n        Create a news channel in this guild.\n\n        Args:\n            name: The name of the channel\n            topic: The topic of the channel\n            position: The position of the channel in the channel list\n            permission_overwrites: Permission overwrites to apply to the channel\n            category: The category this channel should be within\n            nsfw: Should this channel be marked nsfw\n            reason: The reason for creating this channel\n\n        Returns:\n           The newly created news channel.\n\n        \"\"\"\n        return await self.create_channel(\n            channel_type=ChannelTypes.GUILD_NEWS,\n            name=name,\n            topic=topic,\n            position=position,\n            permission_overwrites=permission_overwrites,\n            category=category,\n            nsfw=nsfw,\n            reason=reason,\n        )\n\n    async def create_voice_channel(\n        self,\n        name: str,\n        topic: Absent[Optional[str]] = MISSING,\n        position: Absent[Optional[int]] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, \"models.PermissionOverwrite\", List[Union[dict, \"models.PermissionOverwrite\"]]]\n        ] = MISSING,\n        category: Union[Snowflake_Type, \"models.GuildCategory\"] = None,\n        nsfw: bool = False,\n        bitrate: int = 64000,\n        user_limit: int = 0,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"models.GuildVoice\":\n\"\"\"\n        Create a guild voice channel.\n\n        Args:\n            name: The name of the channel\n            topic: The topic of the channel\n            position: The position of the channel in the channel list\n            permission_overwrites: Permission overwrites to apply to the channel\n            category: The category this channel should be within\n            nsfw: Should this channel be marked nsfw\n            bitrate: The bitrate of this channel, only for voice\n            user_limit: The max users that can be in this channel, only for voice\n            reason: The reason for creating this channel\n\n        Returns:\n           The newly created voice channel.\n\n        \"\"\"\n        return await self.create_channel(\n            channel_type=ChannelTypes.GUILD_VOICE,\n            name=name,\n            topic=topic,\n            position=position,\n            permission_overwrites=permission_overwrites,\n            category=category,\n            nsfw=nsfw,\n            bitrate=bitrate,\n            user_limit=user_limit,\n            reason=reason,\n        )\n\n    async def create_stage_channel(\n        self,\n        name: str,\n        topic: Absent[Optional[str]] = MISSING,\n        position: Absent[Optional[int]] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, \"models.PermissionOverwrite\", List[Union[dict, \"models.PermissionOverwrite\"]]]\n        ] = MISSING,\n        category: Absent[Union[Snowflake_Type, \"models.GuildCategory\"]] = MISSING,\n        bitrate: int = 64000,\n        user_limit: int = 0,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"models.GuildStageVoice\":\n\"\"\"\n        Create a guild stage channel.\n\n        Args:\n            name: The name of the channel\n            topic: The topic of the channel\n            position: The position of the channel in the channel list\n            permission_overwrites: Permission overwrites to apply to the channel\n            category: The category this channel should be within\n            bitrate: The bitrate of this channel, only for voice\n            user_limit: The max users that can be in this channel, only for voice\n            reason: The reason for creating this channel\n\n        Returns:\n            The newly created stage channel.\n\n        \"\"\"\n        return await self.create_channel(\n            channel_type=ChannelTypes.GUILD_STAGE_VOICE,\n            name=name,\n            topic=topic,\n            position=position,\n            permission_overwrites=permission_overwrites,\n            category=category,\n            bitrate=bitrate,\n            user_limit=user_limit,\n            reason=reason,\n        )\n\n    async def create_category(\n        self,\n        name: str,\n        position: Absent[Optional[int]] = MISSING,\n        permission_overwrites: Absent[\n            Union[dict, \"models.PermissionOverwrite\", List[Union[dict, \"models.PermissionOverwrite\"]]]\n        ] = MISSING,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"models.GuildCategory\":\n\"\"\"\n        Create a category within this guild.\n\n        Args:\n            name: The name of the channel\n            position: The position of the channel in the channel list\n            permission_overwrites: Permission overwrites to apply to the channel\n            reason: The reason for creating this channel\n\n        Returns:\n            The newly created category.\n\n        \"\"\"\n        return await self.create_channel(\n            channel_type=ChannelTypes.GUILD_CATEGORY,\n            name=name,\n            position=position,\n            permission_overwrites=permission_overwrites,\n            reason=reason,\n        )\n\n    async def delete_channel(\n        self, channel: Union[\"models.TYPE_GUILD_CHANNEL\", Snowflake_Type], reason: str = None\n    ) -&gt; None:\n\"\"\"\n        Delete the given channel, can handle either a snowflake or channel object.\n\n        This is effectively just an alias for `channel.delete()`\n\n        Args:\n            channel: The channel to be deleted\n            reason: The reason for this deletion\n\n        \"\"\"\n        if isinstance(channel, (str, int)):\n            channel = await self._client.fetch_channel(channel)\n\n        if not channel:\n            raise ValueError(\"Unable to find requested channel\")\n\n        if channel.id not in self._channel_ids:\n            raise ValueError(\"This guild does not hold the requested channel\")\n\n        await channel.delete(reason)\n\n    async def list_scheduled_events(self, with_user_count: bool = False) -&gt; List[\"models.ScheduledEvent\"]:\n\"\"\"\n        List all scheduled events in this guild.\n\n        Returns:\n            A list of scheduled events.\n\n        \"\"\"\n        scheduled_events_data = await self._client.http.list_schedules_events(self.id, with_user_count)\n        return models.ScheduledEvent.from_list(scheduled_events_data, self._client)\n\n    async def fetch_scheduled_event(\n        self, scheduled_event_id: Snowflake_Type, with_user_count: bool = False\n    ) -&gt; Optional[\"models.ScheduledEvent\"]:\n\"\"\"\n        Get a scheduled event by id.\n\n        Args:\n            scheduled_event_id: The id of the scheduled event.\n            with_user_count: Whether to include the user count in the response.\n\n        Returns:\n            The scheduled event. If the event does not exist, returns None.\n\n        \"\"\"\n        try:\n            scheduled_event_data = await self._client.http.get_scheduled_event(\n                self.id, scheduled_event_id, with_user_count\n            )\n        except NotFound:\n            return None\n        return models.ScheduledEvent.from_dict(scheduled_event_data, self._client)\n\n    async def create_scheduled_event(\n        self,\n        name: str,\n        event_type: ScheduledEventType,\n        start_time: \"models.Timestamp\",\n        end_time: Absent[Optional[\"models.Timestamp\"]] = MISSING,\n        description: Absent[Optional[str]] = MISSING,\n        channel_id: Absent[Optional[Snowflake_Type]] = MISSING,\n        external_location: Absent[Optional[str]] = MISSING,\n        entity_metadata: Optional[dict] = None,\n        privacy_level: ScheduledEventPrivacyLevel = ScheduledEventPrivacyLevel.GUILD_ONLY,\n        cover_image: Absent[UPLOADABLE_TYPE] = MISSING,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"models.ScheduledEvent\":\n\"\"\"\n        Create a scheduled guild event.\n\n        Args:\n            name: event name\n            event_type: event type\n            start_time: `Timestamp` object\n            end_time: `Timestamp` object\n            description: event description\n            channel_id: channel id\n            external_location: event external location (For external events)\n            entity_metadata: event metadata (additional data for the event)\n            privacy_level: event privacy level\n            cover_image: the cover image of the scheduled event\n            reason: reason for creating this scheduled event\n\n        Returns:\n            The newly created ScheduledEvent object\n\n        !!! note\n            For external events, external_location is required\n            For voice/stage events, channel_id is required\n\n        ??? note\n            entity_metadata is the backend dictionary for fluff fields. Where possible, we plan to expose these fields directly.\n            The full list of supported fields is https://discord.com/developers/docs/resources/guild-scheduled-event#guild-scheduled-event-object-guild-scheduled-event-entity-metadata\n            Example: `entity_metadata=dict(location=\"cool place\")`\n\n        \"\"\"\n        if external_location is not MISSING:\n            entity_metadata = {\"location\": external_location}\n\n        if event_type == ScheduledEventType.EXTERNAL:\n            if external_location == MISSING:\n                raise EventLocationNotProvided(\"Location is required for external events\")\n\n        payload = {\n            \"name\": name,\n            \"entity_type\": event_type,\n            \"scheduled_start_time\": start_time.isoformat(),\n            \"scheduled_end_time\": end_time.isoformat() if end_time is not MISSING else end_time,\n            \"description\": description,\n            \"channel_id\": channel_id,\n            \"entity_metadata\": entity_metadata,\n            \"privacy_level\": privacy_level,\n            \"image\": to_image_data(cover_image) if cover_image else MISSING,\n        }\n\n        scheduled_event_data = await self._client.http.create_scheduled_event(self.id, payload, reason)\n        return models.ScheduledEvent.from_dict(scheduled_event_data, self._client)\n\n    async def create_custom_sticker(\n        self,\n        name: str,\n        imagefile: UPLOADABLE_TYPE,\n        description: Absent[Optional[str]] = MISSING,\n        tags: Absent[Optional[str]] = MISSING,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"models.Sticker\":\n\"\"\"\n        Creates a custom sticker for a guild.\n\n        Args:\n            name: The name of the sticker (2-30 characters)\n            imagefile: The sticker file to upload, must be a PNG, APNG, or Lottie JSON file (max 500 KB)\n            description: The description of the sticker (empty or 2-100 characters)\n            tags: Autocomplete/suggestion tags for the sticker (max 200 characters)\n            reason: Reason for creating the sticker\n\n        Returns:\n            New Sticker instance\n\n        \"\"\"\n        payload = {\"name\": name}\n\n        if description:\n            payload[\"description\"] = description\n\n        if tags:\n            payload[\"tags\"] = tags\n\n        sticker_data = await self._client.http.create_guild_sticker(payload, self.id, reason)\n        return models.Sticker.from_dict(sticker_data, self._client)\n\n    async def fetch_all_custom_stickers(self) -&gt; List[\"models.Sticker\"]:\n\"\"\"\n        Fetches all custom stickers for a guild.\n\n        Returns:\n            List of Sticker objects\n\n        \"\"\"\n        stickers_data = await self._client.http.list_guild_stickers(self.id)\n        return models.Sticker.from_list(stickers_data, self._client)\n\n    async def fetch_custom_sticker(self, sticker_id: Snowflake_Type) -&gt; Optional[\"models.Sticker\"]:\n\"\"\"\n        Fetches a specific custom sticker for a guild.\n\n        Args:\n            sticker_id: ID of sticker to get\n\n        Returns:\n            The custom sticker object. If the sticker does not exist, returns None.\n\n        \"\"\"\n        try:\n            sticker_data = await self._client.http.get_guild_sticker(self.id, to_snowflake(sticker_id))\n        except NotFound:\n            return None\n        return models.Sticker.from_dict(sticker_data, self._client)\n\n    async def fetch_active_threads(self) -&gt; \"models.ThreadList\":\n\"\"\"\n        Fetches all active threads in the guild, including public and private threads. Threads are ordered by their id, in descending order.\n\n        Returns:\n            List of active threads and thread member object for each returned thread the bot user has joined.\n\n        \"\"\"\n        threads_data = await self._client.http.list_active_threads(self.id)\n        return models.ThreadList.from_dict(threads_data, self._client)\n\n    async def fetch_role(self, role_id: Snowflake_Type) -&gt; Optional[\"models.Role\"]:\n\"\"\"\n        Fetch the specified role by ID.\n\n        Args:\n            role_id: The ID of the role to get\n\n        Returns:\n            The role object. If the role does not exist, returns None.\n\n        \"\"\"\n        try:\n            return await self._client.cache.fetch_role(self.id, role_id)\n        except NotFound:\n            return None\n\n    def get_role(self, role_id: Snowflake_Type) -&gt; Optional[\"models.Role\"]:\n\"\"\"\n        Get the specified role by ID.\n\n        Args:\n            role_id: The ID of the role to get\n\n        Returns:\n            A role object or None if the role is not found.\n\n        \"\"\"\n        role_id = to_snowflake(role_id)\n        if role_id in self._role_ids:\n            return self._client.cache.get_role(role_id)\n        return None\n\n    async def create_role(\n        self,\n        name: Absent[Optional[str]] = MISSING,\n        permissions: Absent[Optional[Permissions]] = MISSING,\n        colour: Absent[Optional[Union[\"models.Color\", int]]] = MISSING,\n        color: Absent[Optional[Union[\"models.Color\", int]]] = MISSING,\n        hoist: Optional[bool] = False,\n        mentionable: Optional[bool] = False,\n        icon: Absent[Optional[UPLOADABLE_TYPE]] = MISSING,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"models.Role\":\n\"\"\"\n        Create a new role for the guild. You must have the `manage roles` permission.\n\n        Args:\n            name: The name the role should have. `Default: new role`\n            permissions: The permissions the role should have. `Default: @everyone permissions`\n            colour: The colour of the role. Can be either `Color` or an RGB integer. `Default: BrandColors.BLACK`\n            color: Alias for `colour`\n            icon: Can be either a bytes like object or a path to an image, or a unicode emoji which is supported by discord.\n            hoist: Whether the role is shown separately in the members list. `Default: False`\n            mentionable: Whether the role can be mentioned. `Default: False`\n            reason: An optional reason for the audit log.\n\n        Returns:\n            A role object or None if the role is not found.\n\n        \"\"\"\n        payload = {}\n\n        if name:\n            payload.update({\"name\": name})\n\n        if permissions:\n            payload.update({\"permissions\": str(int(permissions))})\n\n        colour = colour or color\n        if colour:\n            payload.update({\"color\": colour.value})\n\n        if hoist:\n            payload.update({\"hoist\": True})\n\n        if mentionable:\n            payload.update({\"mentionable\": True})\n\n        if icon:\n            # test if the icon is probably a unicode emoji (str and len() == 1) or a path / bytes obj\n            if isinstance(icon, str) and len(icon) == 1:\n                payload.update({\"unicode_emoji\": icon})\n\n            else:\n                payload.update({\"icon\": to_image_data(icon)})\n\n        result = await self._client.http.create_guild_role(guild_id=self.id, payload=payload, reason=reason)\n        return self._client.cache.place_role_data(guild_id=self.id, data=[result])[to_snowflake(result[\"id\"])]\n\n    def get_channel(self, channel_id: Snowflake_Type) -&gt; Optional[\"models.TYPE_GUILD_CHANNEL\"]:\n\"\"\"\n        Returns a channel with the given `channel_id`.\n\n        Args:\n            channel_id: The ID of the channel to get\n\n        Returns:\n            Channel object if found, otherwise None\n\n        \"\"\"\n        channel_id = to_snowflake(channel_id)\n        if channel_id in self._channel_ids:\n            # theoretically, this could get any channel the client can see,\n            # but to make it less confusing to new programmers,\n            # i intentionally check that the guild contains the channel first\n            return self._client.cache.get_channel(channel_id)\n        return None\n\n    async def fetch_channel(self, channel_id: Snowflake_Type) -&gt; Optional[\"models.TYPE_GUILD_CHANNEL\"]:\n\"\"\"\n        Returns a channel with the given `channel_id` from the API.\n\n        Args:\n            channel_id: The ID of the channel to get\n\n        Returns:\n            The channel object. If the channel does not exist, returns None.\n\n        \"\"\"\n        channel_id = to_snowflake(channel_id)\n        if channel_id in self._channel_ids or not self._client.gateway_started:\n            # The latter check here is to see if the bot is running with the gateway.\n            # If not, then we need to check the API since only the gateway\n            # populates the channel IDs\n\n            # theoretically, this could get any channel the client can see,\n            # but to make it less confusing to new programmers,\n            # i intentionally check that the guild contains the channel first\n            try:\n                channel = await self._client.fetch_channel(channel_id)\n                if channel._guild_id == self.id:\n                    return channel\n            except (NotFound, AttributeError):\n                return None\n\n        return None\n\n    def get_thread(self, thread_id: Snowflake_Type) -&gt; Optional[\"models.TYPE_THREAD_CHANNEL\"]:\n\"\"\"\n        Returns a Thread with the given `thread_id`.\n\n        Args:\n            thread_id: The ID of the thread to get\n\n        Returns:\n            Thread object if found, otherwise None\n\n        \"\"\"\n        thread_id = to_snowflake(thread_id)\n        if thread_id in self._thread_ids:\n            return self._client.cache.get_channel(thread_id)\n        return None\n\n    async def fetch_thread(self, thread_id: Snowflake_Type) -&gt; Optional[\"models.TYPE_THREAD_CHANNEL\"]:\n\"\"\"\n        Returns a Thread with the given `thread_id` from the API.\n\n        Args:\n            thread_id: The ID of the thread to get\n\n        Returns:\n            Thread object if found, otherwise None\n\n        \"\"\"\n        thread_id = to_snowflake(thread_id)\n        if thread_id in self._thread_ids:\n            try:\n                return await self._client.fetch_channel(thread_id)\n            except NotFound:\n                return None\n        return None\n\n    async def prune_members(\n        self,\n        days: int = 7,\n        roles: Optional[List[Snowflake_Type]] = None,\n        compute_prune_count: bool = True,\n        reason: Absent[str] = MISSING,\n    ) -&gt; Optional[int]:\n\"\"\"\n        Begin a guild prune. Removes members from the guild who who have not interacted for the last `days` days. By default, members with roles are excluded from pruning, to include them, pass their role (or role id) in `roles` Requires `kick members` permission.\n\n        Args:\n            days: number of days to prune (1-30)\n            roles: list of roles to include in the prune\n            compute_prune_count: Whether the number of members pruned should be calculated (disable this for large guilds)\n            reason: The reason for this prune\n\n        Returns:\n            The total number of members pruned, if `compute_prune_count` is set to True, otherwise None\n\n        \"\"\"\n        if roles:\n            roles = [str(to_snowflake(r)) for r in roles]\n\n        resp = await self._client.http.begin_guild_prune(\n            self.id, days, include_roles=roles, compute_prune_count=compute_prune_count, reason=reason\n        )\n        return resp[\"pruned\"]\n\n    async def estimate_prune_members(\n        self, days: int = 7, roles: List[Union[Snowflake_Type, \"models.Role\"]] = MISSING\n    ) -&gt; int:\n\"\"\"\n        Calculate how many members would be pruned, should `guild.prune_members` be used. By default, members with roles are excluded from pruning, to include them, pass their role (or role id) in `roles`.\n\n        Args:\n            days: number of days to prune (1-30)\n            roles: list of roles to include in the prune\n\n        Returns:\n            Total number of members that would be pruned\n\n        \"\"\"\n        if roles is not MISSING:\n            roles = [r.id if isinstance(r, models.Role) else r for r in roles]\n        else:\n            roles = []\n\n        resp = await self._client.http.get_guild_prune_count(self.id, days=days, include_roles=roles)\n        return resp[\"pruned\"]\n\n    async def leave(self) -&gt; None:\n\"\"\"Leave this guild.\"\"\"\n        await self._client.http.leave_guild(self.id)\n\n    async def delete(self) -&gt; None:\n\"\"\"\n        Delete the guild.\n\n        !!! note\n            You must own this guild to do this.\n\n        \"\"\"\n        await self._client.http.delete_guild(self.id)\n\n    async def kick(\n        self, user: Union[\"models.User\", \"models.Member\", Snowflake_Type], reason: Absent[str] = MISSING\n    ) -&gt; None:\n\"\"\"\n        Kick a user from the guild.\n\n        !!! note\n            You must have the `kick members` permission\n\n        Args:\n            user: The user to kick\n            reason: The reason for the kick\n\n        \"\"\"\n        await self._client.http.remove_guild_member(self.id, to_snowflake(user), reason=reason)\n\n    async def ban(\n        self,\n        user: Union[\"models.User\", \"models.Member\", Snowflake_Type],\n        delete_message_days: Absent[int] = MISSING,\n        delete_message_seconds: int = 0,\n        reason: Absent[str] = MISSING,\n    ) -&gt; None:\n\"\"\"\n        Ban a user from the guild.\n\n        !!! note\n            You must have the `ban members` permission\n\n        Args:\n            user: The user to ban\n            delete_message_days: (deprecated) How many days worth of messages to remove\n            delete_message_seconds: How many seconds worth of messages to remove\n            reason: The reason for the ban\n\n        \"\"\"\n        if delete_message_days is not MISSING:\n            warn(\"delete_message_days is deprecated and will be removed in a future update\", DeprecationWarning)\n            delete_message_seconds = delete_message_days * 3600\n        await self._client.http.create_guild_ban(self.id, to_snowflake(user), delete_message_seconds, reason=reason)\n\n    async def fetch_ban(self, user: Union[\"models.User\", \"models.Member\", Snowflake_Type]) -&gt; Optional[GuildBan]:\n\"\"\"\n        Fetches the ban information for the specified user in the guild. You must have the `ban members` permission.\n\n        Args:\n            user: The user to look up.\n\n        Returns:\n            The ban information. If the user is not banned, returns None.\n\n        \"\"\"\n        try:\n            ban_info = await self._client.http.get_guild_ban(self.id, to_snowflake(user))\n        except NotFound:\n            return None\n        return GuildBan(reason=ban_info[\"reason\"], user=self._client.cache.place_user_data(ban_info[\"user\"]))\n\n    async def fetch_bans(\n        self,\n        before: Optional[\"Snowflake_Type\"] = MISSING,\n        after: Optional[\"Snowflake_Type\"] = MISSING,\n        limit: int = 1000,\n    ) -&gt; list[GuildBan]:\n\"\"\"\n        Fetches bans for the guild. You must have the `ban members` permission.\n\n        Args:\n            before: consider only users before given user id\n            after: consider only users after given user id\n            limit: number of users to return (up to maximum 1000)\n\n        Returns:\n            A list containing bans and information about them.\n\n        \"\"\"\n        ban_infos = await self._client.http.get_guild_bans(self.id, before=before, after=after, limit=limit)\n        return [\n            GuildBan(reason=ban_info[\"reason\"], user=self._client.cache.place_user_data(ban_info[\"user\"]))\n            for ban_info in ban_infos\n        ]\n\n    async def create_auto_moderation_rule(\n        self,\n        name: str,\n        *,\n        trigger: BaseTrigger,\n        actions: list[BaseAction],\n        exempt_roles: list[\"Snowflake_Type\"] = MISSING,\n        exempt_channels: list[\"Snowflake_Type\"] = MISSING,\n        enabled: bool = True,\n        event_type: AutoModEvent = AutoModEvent.MESSAGE_SEND,\n    ) -&gt; AutoModRule:\n\"\"\"\n        Create an auto-moderation rule in this guild.\n\n        Args:\n            name: The name of the rule\n            trigger: The trigger for this rule\n            actions: A list of actions to take upon triggering\n            exempt_roles: Roles that ignore this rule\n            exempt_channels: Channels that ignore this role\n            enabled: Is this rule enabled?\n            event_type: The type of event that triggers this rule\n\n        Returns:\n            The created rule\n        \"\"\"\n        rule = AutoModRule(\n            name=name,\n            enabled=enabled,\n            actions=actions,\n            event_type=event_type,\n            trigger=trigger,\n            exempt_channels=exempt_channels if exempt_roles is not MISSING else [],\n            exempt_roles=exempt_roles if exempt_roles is not MISSING else [],\n            client=self._client,\n        )\n        data = await self._client.http.create_auto_moderation_rule(self.id, rule.to_dict())\n        return AutoModRule.from_dict(data, self._client)\n\n    async def fetch_auto_moderation_rules(self) -&gt; List[AutoModRule]:\n\"\"\"\n        Get this guild's auto moderation rules.\n\n        Returns:\n            A list of auto moderation rules\n        \"\"\"\n        data = await self._client.http.get_auto_moderation_rules(self.id)\n        return [AutoModRule.from_dict(d, self._client) for d in data]\n\n    async def delete_auto_moderation_rule(self, rule: \"Snowflake_Type\", reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n        Delete a given auto moderation rule.\n\n        Args:\n            rule: The rule to delete\n            reason: The reason for deleting this rule\n        \"\"\"\n        await self._client.http.delete_auto_moderation_rule(self.id, to_snowflake(rule), reason=reason)\n\n    async def modify_auto_moderation_rule(\n        self,\n        rule: \"Snowflake_Type\",\n        *,\n        name: Absent[str] = MISSING,\n        trigger: Absent[BaseTrigger] = MISSING,\n        trigger_type: Absent[AutoModTriggerType] = MISSING,\n        trigger_metadata: Absent[dict] = MISSING,\n        actions: Absent[list[BaseAction]] = MISSING,\n        exempt_channels: Absent[list[\"Snowflake_Type\"]] = MISSING,\n        exempt_roles: Absent[list[\"Snowflake_Type\"]] = MISSING,\n        event_type: Absent[AutoModEvent] = MISSING,\n        enabled: Absent[bool] = MISSING,\n        reason: Absent[str] = MISSING,\n    ) -&gt; AutoModRule:\n\"\"\"\n        Modify an existing automod rule.\n\n        Args:\n            rule: The rule to modify\n            name: The name of the rule\n            trigger: A trigger for this rule\n            trigger_type: The type trigger for this rule (ignored if trigger specified)\n            trigger_metadata: Metadata for the trigger (ignored if trigger specified)\n            actions: A list of actions to take upon triggering\n            exempt_roles: Roles that ignore this rule\n            exempt_channels: Channels that ignore this role\n            enabled: Is this rule enabled?\n            event_type: The type of event that triggers this rule\n            reason: The reason for this change\n\n        Returns:\n            The updated rule\n        \"\"\"\n        if trigger:\n            _data = trigger.to_dict()\n            trigger_type = _data[\"trigger_type\"]\n            trigger_metadata = _data.get(\"trigger_metadata\", {})\n\n        out = await self._client.http.modify_auto_moderation_rule(\n            self.id,\n            to_snowflake(rule),\n            name=name,\n            trigger_type=trigger_type,\n            trigger_metadata=trigger_metadata,\n            actions=actions,\n            exempt_roles=to_snowflake_list(exempt_roles) if exempt_roles is not MISSING else MISSING,\n            exempt_channels=to_snowflake_list(exempt_channels) if exempt_channels is not MISSING else MISSING,\n            event_type=event_type,\n            enabled=enabled,\n            reason=reason,\n        )\n        return AutoModRule.from_dict(out, self._client)\n\n    async def unban(\n        self, user: Union[\"models.User\", \"models.Member\", Snowflake_Type], reason: Absent[str] = MISSING\n    ) -&gt; None:\n\"\"\"\n        Unban a user from the guild.\n\n        !!! note\n            You must have the `ban members` permission\n\n        Args:\n            user: The user to unban\n            reason: The reason for the ban\n\n        \"\"\"\n        await self._client.http.remove_guild_ban(self.id, to_snowflake(user), reason=reason)\n\n    async def fetch_widget_image(self, style: str = None) -&gt; str:\n\"\"\"\n        Fetch a guilds widget image.\n\n        For a list of styles, look here: https://discord.com/developers/docs/resources/guild#get-guild-widget-image-widget-style-options\n\n        Args:\n            style: The style to use for the widget image\n\n        Returns:\n            The URL of the widget image.\n\n        \"\"\"\n        return await self._client.http.get_guild_widget_image(self.id, style)\n\n    async def fetch_widget_settings(self) -&gt; \"GuildWidgetSettings\":\n\"\"\"\n        Fetches the guilds widget settings.\n\n        Returns:\n            The guilds widget settings object.\n\n        \"\"\"\n        return await GuildWidgetSettings.from_dict(await self._client.http.get_guild_widget_settings(self.id))\n\n    async def fetch_widget(self) -&gt; \"GuildWidget\":\n\"\"\"\n        Fetches the guilds widget.\n\n        Returns:\n            The guilds widget object.\n\n        \"\"\"\n        return GuildWidget.from_dict(await self._client.http.get_guild_widget(self.id), self._client)\n\n    async def modify_widget(\n        self,\n        enabled: Absent[bool] = MISSING,\n        channel: Absent[Union[\"models.TYPE_GUILD_CHANNEL\", Snowflake_Type]] = MISSING,\n        settings: Absent[\"GuildWidgetSettings\"] = MISSING,\n    ) -&gt; \"GuildWidget\":\n\"\"\"\n        Modify the guild's widget.\n\n        Args:\n            enabled: Should the widget be enabled?\n            channel: The channel to use in the widget\n            settings: The settings to use for the widget\n\n        Returns:\n            The updated guilds widget object.\n\n        \"\"\"\n        if isinstance(settings, GuildWidgetSettings):\n            enabled = settings.enabled\n            channel = settings.channel_id\n\n        channel = to_optional_snowflake(channel)\n        return GuildWidget.from_dict(\n            await self._client.http.modify_guild_widget(self.id, enabled, channel), self._client\n        )\n\n    async def fetch_invites(self) -&gt; List[\"models.Invite\"]:\n\"\"\"\n        Fetches all invites for the guild.\n\n        Returns:\n            A list of invites for the guild.\n\n        \"\"\"\n        invites_data = await self._client.http.get_guild_invites(self.id)\n        return models.Invite.from_list(invites_data, self._client)\n\n    async def fetch_guild_integrations(self) -&gt; List[\"models.GuildIntegration\"]:\n\"\"\"\n        Fetches all integrations for the guild.\n\n        Returns:\n            A list of integrations for the guild.\n\n        \"\"\"\n        data = await self._client.http.get_guild_integrations(self.id)\n        return [GuildIntegration.from_dict(d | {\"guild_id\": self.id}, self._client) for d in data]\n\n    async def search_members(self, query: str, limit: int = 1) -&gt; List[\"models.Member\"]:\n\"\"\"\n        Search for members in the guild whose username or nickname starts with a provided string.\n\n        Args:\n            query: Query string to match username(s) and nickname(s) against.\n            limit: Max number of members to return (1-1000)\n\n        Returns:\n            A list of members matching the query.\n\n        \"\"\"\n        data = await self._client.http.search_guild_members(guild_id=self.id, query=query, limit=limit)\n        return [self._client.cache.place_member_data(self.id, _d) for _d in data]\n\n    async def fetch_voice_regions(self) -&gt; List[\"models.VoiceRegion\"]:\n\"\"\"\n        Fetches the voice regions for the guild.\n\n        Unlike the `NAFF.fetch_voice_regions` method, this will returns VIP servers when the guild is VIP-enabled.\n\n        Returns:\n            A list of voice regions.\n\n        \"\"\"\n        regions_data = await self._client.http.get_guild_voice_regions(self.id)\n        regions = models.VoiceRegion.from_list(regions_data)\n        return regions\n\n    @property\n    def gui_sorted_channels(self) -&gt; list[\"models.TYPE_GUILD_CHANNEL\"]:\n\"\"\"Return this guilds channels sorted by their gui positions\"\"\"\n        # create a sorted list of objects by their gui position\n        if not self._channel_gui_positions:\n            self._calculate_gui_channel_positions()\n        return [\n            self._client.get_channel(k)\n            for k, v in sorted(self._channel_gui_positions.items(), key=lambda item: item[1])\n        ]\n\n    def get_channel_gui_position(self, channel_id: \"Snowflake_Type\") -&gt; int:\n\"\"\"\n        Get a given channels gui position.\n\n        Args:\n            channel_id: The ID of the channel to get the gui position for.\n\n        Returns:\n            The gui position of the channel.\n        \"\"\"\n        if not self._channel_gui_positions:\n            self._calculate_gui_channel_positions()\n        return self._channel_gui_positions.get(to_snowflake(channel_id), 0)\n\n    def _calculate_gui_channel_positions(self) -&gt; list[\"models.TYPE_GUILD_CHANNEL\"]:\n\"\"\"\n        Calculates the GUI position for all known channels within this guild.\n\n        Note this is an expensive operation and should only be run when actually required.\n\n        Returns:\n            The list of channels in this guild, sorted by their GUI position.\n        \"\"\"\n        # sorting is based on this https://github.com/discord/discord-api-docs/issues/4613#issuecomment-1059997612\n        sort_map = {\n            ChannelTypes.GUILD_NEWS_THREAD: 1,\n            ChannelTypes.GUILD_PUBLIC_THREAD: 1,\n            ChannelTypes.GUILD_PRIVATE_THREAD: 1,\n            ChannelTypes.GUILD_TEXT: 2,\n            ChannelTypes.GUILD_CATEGORY: 2,\n            ChannelTypes.GUILD_NEWS: 2,\n            ChannelTypes.GUILD_FORUM: 2,  # assumed value\n            ChannelTypes.GUILD_VOICE: 3,\n            ChannelTypes.GUILD_STAGE_VOICE: 3,\n        }\n\n        def channel_sort_func(a, b) -&gt; int:\n            a_sorting = sort_map.get(a.type, 0)\n            b_sorting = sort_map.get(b.type, 0)\n\n            if a_sorting != b_sorting:\n                return a_sorting - b_sorting\n            return a.position - b.position or a.id - b.id\n\n        sorted_channels = sorted(self.channels, key=cmp_to_key(channel_sort_func))\n\n        for channel in sorted_channels[::-1]:\n            if channel.parent_id:\n                # sort channels under their respective categories\n                sorted_channels.remove(channel)\n                parent_index = sorted_channels.index(channel.category)\n                sorted_channels.insert(parent_index + 1, channel)\n            elif channel.type != ChannelTypes.GUILD_CATEGORY:\n                # move non-category channels to the top\n                sorted_channels.remove(channel)\n                sorted_channels.insert(0, channel)\n\n        self._channel_gui_positions = {channel.id: i for i, channel in enumerate(sorted_channels)}\n\n        return sorted_channels\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.unavailable","title":"<code>unavailable: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>True if this guild is unavailable due to an outage.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.afk_channel_id","title":"<code>afk_channel_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The channel id for afk.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.afk_timeout","title":"<code>afk_timeout: Optional[int] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>afk timeout in seconds.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.widget_enabled","title":"<code>widget_enabled: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>True if the server widget is enabled.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.widget_channel_id","title":"<code>widget_channel_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The channel id that the widget will generate an invite to, or None if set to no invite.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.verification_level","title":"<code>verification_level: Union[VerificationLevels, int] = attrs.field(repr=False, default=VerificationLevels.NONE)</code>  <code>class-attribute</code>","text":"<p>The verification level required for the guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.default_message_notifications","title":"<code>default_message_notifications: Union[DefaultNotificationLevels, int] = attrs.field(repr=False, default=DefaultNotificationLevels.ALL_MESSAGES)</code>  <code>class-attribute</code>","text":"<p>The default message notifications level.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.explicit_content_filter","title":"<code>explicit_content_filter: Union[ExplicitContentFilterLevels, int] = attrs.field(repr=False, default=ExplicitContentFilterLevels.DISABLED)</code>  <code>class-attribute</code>","text":"<p>The explicit content filter level.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.mfa_level","title":"<code>mfa_level: Union[MFALevels, int] = attrs.field(repr=False, default=MFALevels.NONE)</code>  <code>class-attribute</code>","text":"<p>The required MFA (Multi Factor Authentication) level for the guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.system_channel_id","title":"<code>system_channel_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The id of the channel where guild notices such as welcome messages and boost events are posted.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.system_channel_flags","title":"<code>system_channel_flags: SystemChannelFlags = attrs.field(repr=False, default=SystemChannelFlags.NONE, converter=SystemChannelFlags)</code>  <code>class-attribute</code>","text":"<p>The system channel flags.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.rules_channel_id","title":"<code>rules_channel_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The id of the channel where Community guilds can display rules and/or guidelines.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.joined_at","title":"<code>joined_at: str = attrs.field(repr=False, default=None, converter=optional(timestamp_converter))</code>  <code>class-attribute</code>","text":"<p>When this guild was joined at.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.large","title":"<code>large: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>True if this is considered a large guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.member_count","title":"<code>member_count: int = attrs.field(repr=False, default=0)</code>  <code>class-attribute</code>","text":"<p>The total number of members in this guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.presences","title":"<code>presences: List[dict] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>The presences of the members in the guild, will only include non-offline members if the size is greater than large threshold.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.max_presences","title":"<code>max_presences: Optional[int] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The maximum number of presences for the guild. (None is always returned, apart from the largest of guilds)</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.max_members","title":"<code>max_members: Optional[int] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The maximum number of members for the guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.vanity_url_code","title":"<code>vanity_url_code: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The vanity url code for the guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.banner","title":"<code>banner: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>Hash for banner image.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.premium_tier","title":"<code>premium_tier: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The premium tier level. (Server Boost level)</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.premium_subscription_count","title":"<code>premium_subscription_count: int = attrs.field(repr=False, default=0)</code>  <code>class-attribute</code>","text":"<p>The number of boosts this guild currently has.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.preferred_locale","title":"<code>preferred_locale: str = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The preferred locale of a Community guild. Used in server discovery and notices from Discord. Defaults to \"en-US\"</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.public_updates_channel_id","title":"<code>public_updates_channel_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The id of the channel where admins and moderators of Community guilds receive notices from Discord.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.max_video_channel_users","title":"<code>max_video_channel_users: int = attrs.field(repr=False, default=0)</code>  <code>class-attribute</code>","text":"<p>The maximum amount of users in a video channel.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.welcome_screen","title":"<code>welcome_screen: Optional[GuildWelcome] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The welcome screen of a Community guild, shown to new members, returned in an Invite's guild object.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.nsfw_level","title":"<code>nsfw_level: Union[NSFWLevels, int] = attrs.field(repr=False, default=NSFWLevels.DEFAULT)</code>  <code>class-attribute</code>","text":"<p>The guild NSFW level.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.stage_instances","title":"<code>stage_instances: List[dict] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>Stage instances in the guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.chunked","title":"<code>chunked = attrs.field(repr=False, factory=asyncio.Event, metadata=no_export_meta)</code>  <code>class-attribute</code>","text":"<p>An event that is fired when this guild has been chunked</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.command_permissions","title":"<code>command_permissions: dict[Snowflake_Type, CommandPermissions] = attrs.field(repr=False, factory=dict, metadata=no_export_meta)</code>  <code>class-attribute</code>","text":"<p>A cache of all command permissions for this guild</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.create","title":"<code>create(name, client, *, icon=MISSING, verification_level=MISSING, default_message_notifications=MISSING, explicit_content_filter=MISSING, roles=MISSING, channels=MISSING, afk_channel_id=MISSING, afk_timeout=MISSING, system_channel_id=MISSING, system_channel_flags=MISSING)</code>  <code>classmethod</code> <code>async</code>","text":"<p>Create a guild.</p> <p>Note</p> <p>This method will only work for bots in less than 10 guilds.</p> Param notes <p>Roles:     - When using the <code>roles</code> parameter, the first member of the array is used to change properties of the guild's <code>@everyone</code> role. If you are trying to bootstrap a guild with additional roles, keep this in mind.     - When using the <code>roles</code> parameter, the required id field within each role object is an integer placeholder, and will be replaced by the API upon consumption. Its purpose is to allow you to overwrite a role's permissions in a channel when also passing in channels with the channels array.</p> <p>Channels:     - When using the <code>channels</code> parameter, the position field is ignored, and none of the default channels are created.     - When using the <code>channels</code> parameter, the id field within each channel object may be set to an integer placeholder, and will be replaced by the API upon consumption. Its purpose is to allow you to create <code>GUILD_CATEGORY</code> channels by setting the <code>parent_id</code> field on any children to the category's id field. Category channels must be listed before any children.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the guild (2-100 characters)</p> required <code>client</code> <code>Client</code> <p>The NAFF client</p> required <code>icon</code> <code>Absent[Optional[UPLOADABLE_TYPE]]</code> <p>An icon for the guild</p> <code>MISSING</code> <code>verification_level</code> <code>Absent[VerificationLevels]</code> <p>The guild's verification level</p> <code>MISSING</code> <code>default_message_notifications</code> <code>Absent[DefaultNotificationLevels]</code> <p>The default message notification level</p> <code>MISSING</code> <code>explicit_content_filter</code> <code>Absent[ExplicitContentFilterLevels]</code> <p>The guild's explicit content filter level</p> <code>MISSING</code> <code>roles</code> <code>Absent[list[dict]]</code> <p>An array of partial role dictionaries</p> <code>MISSING</code> <code>channels</code> <code>Absent[list[dict]]</code> <p>An array of partial channel dictionaries</p> <code>MISSING</code> <code>afk_channel_id</code> <code>Absent[Snowflake_Type]</code> <p>id for afk channel</p> <code>MISSING</code> <code>afk_timeout</code> <code>Absent[int]</code> <p>afk timeout in seconds</p> <code>MISSING</code> <code>system_channel_id</code> <code>Absent[Snowflake_Type]</code> <p>the id of the channel where guild notices should go</p> <code>MISSING</code> <code>system_channel_flags</code> <code>Absent[SystemChannelFlags]</code> <p>flags for the system channel</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Guild</code> <p>The created guild object</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>@classmethod\nasync def create(\n    cls,\n    name: str,\n    client: \"Client\",\n    *,\n    icon: Absent[Optional[UPLOADABLE_TYPE]] = MISSING,\n    verification_level: Absent[\"VerificationLevels\"] = MISSING,\n    default_message_notifications: Absent[\"DefaultNotificationLevels\"] = MISSING,\n    explicit_content_filter: Absent[\"ExplicitContentFilterLevels\"] = MISSING,\n    roles: Absent[list[dict]] = MISSING,\n    channels: Absent[list[dict]] = MISSING,\n    afk_channel_id: Absent[\"Snowflake_Type\"] = MISSING,\n    afk_timeout: Absent[int] = MISSING,\n    system_channel_id: Absent[\"Snowflake_Type\"] = MISSING,\n    system_channel_flags: Absent[\"SystemChannelFlags\"] = MISSING,\n) -&gt; \"Guild\":\n\"\"\"\n    Create a guild.\n\n    !!! note\n        This method will only work for bots in less than 10 guilds.\n\n    ??? note \"Param notes\"\n        Roles:\n            - When using the `roles` parameter, the first member of the array is used to change properties of the guild's `@everyone` role. If you are trying to bootstrap a guild with additional roles, keep this in mind.\n            - When using the `roles` parameter, the required id field within each role object is an integer placeholder, and will be replaced by the API upon consumption. Its purpose is to allow you to overwrite a role's permissions in a channel when also passing in channels with the channels array.\n\n        Channels:\n            - When using the `channels` parameter, the position field is ignored, and none of the default channels are created.\n            - When using the `channels` parameter, the id field within each channel object may be set to an integer placeholder, and will be replaced by the API upon consumption. Its purpose is to allow you to create `GUILD_CATEGORY` channels by setting the `parent_id` field on any children to the category's id field. Category channels must be listed before any children.\n\n    Args:\n        name: name of the guild (2-100 characters)\n        client: The NAFF client\n        icon: An icon for the guild\n        verification_level: The guild's verification level\n        default_message_notifications: The default message notification level\n        explicit_content_filter: The guild's explicit content filter level\n        roles: An array of partial role dictionaries\n        channels: An array of partial channel dictionaries\n        afk_channel_id: id for afk channel\n        afk_timeout: afk timeout in seconds\n        system_channel_id: the id of the channel where guild notices should go\n        system_channel_flags: flags for the system channel\n\n    Returns:\n        The created guild object\n\n    \"\"\"\n    data = await client.http.create_guild(\n        name=name,\n        icon=to_image_data(icon) if icon else MISSING,\n        verification_level=verification_level,\n        default_message_notifications=default_message_notifications,\n        explicit_content_filter=explicit_content_filter,\n        roles=roles,\n        channels=channels,\n        afk_channel_id=afk_channel_id,\n        afk_timeout=afk_timeout,\n        system_channel_id=system_channel_id,\n        system_channel_flags=int(system_channel_flags) if system_channel_flags else MISSING,\n    )\n    return client.cache.place_guild_data(data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.channels","title":"<code>channels: List[models.TYPE_GUILD_CHANNEL]</code>  <code>property</code>","text":"<p>Returns a list of channels associated with this guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.threads","title":"<code>threads: List[models.TYPE_THREAD_CHANNEL]</code>  <code>property</code>","text":"<p>Returns a list of threads associated with this guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.members","title":"<code>members: List[models.Member]</code>  <code>property</code>","text":"<p>Returns a list of all members within this guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.premium_subscribers","title":"<code>premium_subscribers: List[models.Member]</code>  <code>property</code>","text":"<p>Returns a list of all premium subscribers</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.bots","title":"<code>bots: List[models.Member]</code>  <code>property</code>","text":"<p>Returns a list of all bots within this guild</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.humans","title":"<code>humans: List[models.Member]</code>  <code>property</code>","text":"<p>Returns a list of all humans within this guild</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.roles","title":"<code>roles: List[models.Role]</code>  <code>property</code>","text":"<p>Returns a list of roles associated with this guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.me","title":"<code>me: models.Member</code>  <code>property</code>","text":"<p>Returns this bots member object within this guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.system_channel","title":"<code>system_channel: Optional[models.GuildText]</code>  <code>property</code>","text":"<p>Returns the channel this guild uses for system messages.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.rules_channel","title":"<code>rules_channel: Optional[models.GuildText]</code>  <code>property</code>","text":"<p>Returns the channel declared as a rules channel.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.public_updates_channel","title":"<code>public_updates_channel: Optional[models.GuildText]</code>  <code>property</code>","text":"<p>Returns the channel where server staff receive notices from Discord.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.emoji_limit","title":"<code>emoji_limit: int</code>  <code>property</code>","text":"<p>The maximum number of emoji this guild can have.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.sticker_limit","title":"<code>sticker_limit: int</code>  <code>property</code>","text":"<p>The maximum number of stickers this guild can have.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.bitrate_limit","title":"<code>bitrate_limit: int</code>  <code>property</code>","text":"<p>The maximum bitrate for this guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.filesize_limit","title":"<code>filesize_limit: int</code>  <code>property</code>","text":"<p>The maximum filesize that may be uploaded within this guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.default_role","title":"<code>default_role: models.Role</code>  <code>property</code>","text":"<p>The <code>@everyone</code> role in this guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.premium_subscriber_role","title":"<code>premium_subscriber_role: Optional[models.Role]</code>  <code>property</code>","text":"<p>The role given to boosters of this server, if set.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.my_role","title":"<code>my_role: Optional[models.Role]</code>  <code>property</code>","text":"<p>The role associated with this client, if set.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.permissions","title":"<code>permissions: Permissions</code>  <code>property</code>","text":"<p>Alias for me.guild_permissions</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.voice_state","title":"<code>voice_state: Optional[models.VoiceState]</code>  <code>property</code>","text":"<p>Get the bot's voice state for the guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.voice_states","title":"<code>voice_states: List[models.VoiceState]</code>  <code>property</code>","text":"<p>Get a list of the active voice states in this guild.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_member","title":"<code>fetch_member(member_id)</code>  <code>async</code>","text":"<p>Return the Member with the given discord ID, fetching from the API if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>member_id</code> <code>Snowflake_Type</code> <p>The ID of the member.</p> required <p>Returns:</p> Type Description <code>Optional[Member]</code> <p>The member object fetched. If the member is not in this guild, returns None.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_member(self, member_id: Snowflake_Type) -&gt; Optional[\"models.Member\"]:\n\"\"\"\n    Return the Member with the given discord ID, fetching from the API if necessary.\n\n    Args:\n        member_id: The ID of the member.\n\n    Returns:\n        The member object fetched. If the member is not in this guild, returns None.\n\n    \"\"\"\n    try:\n        return await self._client.cache.fetch_member(self.id, member_id)\n    except NotFound:\n        return None\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.get_member","title":"<code>get_member(member_id)</code>","text":"<p>Return the Member with the given discord ID.</p> <p>Parameters:</p> Name Type Description Default <code>member_id</code> <code>Snowflake_Type</code> <p>The ID of the member</p> required <p>Returns:</p> Type Description <code>Optional[Member]</code> <p>Member object or None</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>def get_member(self, member_id: Snowflake_Type) -&gt; Optional[\"models.Member\"]:\n\"\"\"\n    Return the Member with the given discord ID.\n\n    Args:\n        member_id: The ID of the member\n\n    Returns:\n        Member object or None\n\n    \"\"\"\n    return self._client.cache.get_member(self.id, member_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_owner","title":"<code>fetch_owner()</code>  <code>async</code>","text":"<p>Return the Guild owner, fetching from the API if necessary.</p> <p>Returns:</p> Type Description <code>Member</code> <p>Member object or None</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_owner(self) -&gt; \"models.Member\":\n\"\"\"\n    Return the Guild owner, fetching from the API if necessary.\n\n    Returns:\n        Member object or None\n\n    \"\"\"\n    return await self._client.cache.fetch_member(self.id, self._owner_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.get_owner","title":"<code>get_owner()</code>","text":"<p>Return the Guild owner</p> <p>Returns:</p> Type Description <code>Member</code> <p>Member object or None</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>def get_owner(self) -&gt; \"models.Member\":\n\"\"\"\n    Return the Guild owner\n\n    Returns:\n        Member object or None\n\n    \"\"\"\n    return self._client.cache.get_member(self.id, self._owner_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_channels","title":"<code>fetch_channels()</code>  <code>async</code>","text":"<p>Fetch this guild's channels.</p> <p>Returns:</p> Type Description <code>List[TYPE_VOICE_CHANNEL]</code> <p>A list of channels in this guild</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_channels(self) -&gt; List[\"models.TYPE_VOICE_CHANNEL\"]:\n\"\"\"\n    Fetch this guild's channels.\n\n    Returns:\n        A list of channels in this guild\n\n    \"\"\"\n    data = await self._client.http.get_guild_channels(self.id)\n    return [self._client.cache.place_channel_data(channel_data) for channel_data in data]\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_app_cmd_perms","title":"<code>fetch_app_cmd_perms()</code>  <code>async</code>","text":"<p>Fetch the application command permissions for this guild.</p> <p>Returns:</p> Type Description <code>dict[Snowflake_Type, CommandPermissions]</code> <p>The application command permissions for this guild.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_app_cmd_perms(self) -&gt; dict[Snowflake_Type, \"CommandPermissions\"]:\n\"\"\"\n    Fetch the application command permissions for this guild.\n\n    Returns:\n        The application command permissions for this guild.\n\n    \"\"\"\n    data = await self._client.http.batch_get_application_command_permissions(self._client.app.id, self.id)\n\n    for command in data:\n        command_permissions = CommandPermissions(client=self._client, command_id=command[\"id\"], guild=self)\n        perms = [ApplicationCommandPermission.from_dict(perm, self) for perm in command[\"permissions\"]]\n\n        command_permissions.update_permissions(*perms)\n\n        self.command_permissions[int(command[\"id\"])] = command_permissions\n\n    return self.command_permissions\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.is_owner","title":"<code>is_owner(user)</code>","text":"<p>Whether the user is owner of the guild.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Snowflake_Type</code> <p>The user to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the user is the owner of the guild, False otherwise.</p> <p>Note</p> <p>the <code>user</code> argument can be any type that meets <code>Snowflake_Type</code></p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>def is_owner(self, user: Snowflake_Type) -&gt; bool:\n\"\"\"\n    Whether the user is owner of the guild.\n\n    Args:\n        user: The user to check\n\n    Returns:\n        True if the user is the owner of the guild, False otherwise.\n\n    !!! note\n        the `user` argument can be any type that meets `Snowflake_Type`\n\n    \"\"\"\n    return self._owner_id == to_snowflake(user)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.edit_nickname","title":"<code>edit_nickname(new_nickname=MISSING, reason=MISSING)</code>  <code>async</code>","text":"<p>Alias for me.edit_nickname</p> <p>Parameters:</p> Name Type Description Default <code>new_nickname</code> <code>Absent[str]</code> <p>The new nickname to apply</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for this change</p> <code>MISSING</code> <p>Note</p> <p>Leave <code>new_nickname</code> empty to clean user's nickname</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def edit_nickname(self, new_nickname: Absent[str] = MISSING, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n    Alias for me.edit_nickname\n\n    Args:\n        new_nickname: The new nickname to apply\n        reason: The reason for this change\n\n    !!! note\n        Leave `new_nickname` empty to clean user's nickname\n\n    \"\"\"\n    await self.me.edit_nickname(new_nickname, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.http_chunk","title":"<code>http_chunk()</code>  <code>async</code>","text":"<p>Populates all members of this guild using the REST API.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def http_chunk(self) -&gt; None:\n\"\"\"Populates all members of this guild using the REST API.\"\"\"\n    start_time = time.perf_counter()\n\n    iterator = MemberIterator(self)\n    async for member in iterator:\n        self._client.cache.place_member_data(self.id, member)\n\n    self.chunked.set()\n    self.logger.info(\n        f\"Cached {iterator.total_retrieved} members for {self.id} in {time.perf_counter() - start_time:.2f} seconds\"\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.gateway_chunk","title":"<code>gateway_chunk(wait=True, presences=True)</code>  <code>async</code>","text":"<p>Trigger a gateway <code>get_members</code> event, populating this object with members.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <p>Wait for chunking to be completed before continuing</p> <code>True</code> <code>presences</code> <p>Do you need presence data for members?</p> <code>True</code> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def gateway_chunk(self, wait=True, presences=True) -&gt; None:\n\"\"\"\n    Trigger a gateway `get_members` event, populating this object with members.\n\n    Args:\n        wait: Wait for chunking to be completed before continuing\n        presences: Do you need presence data for members?\n    \"\"\"\n    ws = self._client.get_guild_websocket(self.id)\n    await ws.request_member_chunks(self.id, limit=0, presences=presences)\n    if wait:\n        await self.chunked.wait()\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.chunk","title":"<code>chunk()</code>  <code>async</code>","text":"<p>Populates all members of this guild using the REST API.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def chunk(self) -&gt; None:\n\"\"\"Populates all members of this guild using the REST API.\"\"\"\n    await self.http_chunk()\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.chunk_guild","title":"<code>chunk_guild(wait=True, presences=True)</code>  <code>async</code>","text":"<p>Trigger a gateway <code>get_members</code> event, populating this object with members.</p> <p>Depreciation Warning</p> <p>Gateway chunking is deprecated and replaced by http chunking. Use <code>guild.gateway_chunk</code> if you need gateway chunking.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <p>Wait for chunking to be completed before continuing</p> <code>True</code> <code>presences</code> <p>Do you need presence data for members?</p> <code>True</code> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def chunk_guild(self, wait=True, presences=True) -&gt; None:\n\"\"\"\n    Trigger a gateway `get_members` event, populating this object with members.\n\n    !!! warning \"Depreciation Warning\"\n        Gateway chunking is deprecated and replaced by http chunking. Use `guild.gateway_chunk` if you need gateway chunking.\n\n    Args:\n        wait: Wait for chunking to be completed before continuing\n        presences: Do you need presence data for members?\n\n    \"\"\"\n    warn(\n        \"Gateway chunking is deprecated and replaced by http chunking. Use `guild.gateway_chunk` if you need gateway chunking.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    await self.gateway_chunk(wait=wait, presences=presences)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.process_member_chunk","title":"<code>process_member_chunk(chunk)</code>  <code>async</code>","text":"<p>Receive and either cache or process the chunks of members from gateway.</p> <p>Parameters:</p> Name Type Description Default <code>chunk</code> <code>dict</code> <p>A member chunk from discord</p> required Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def process_member_chunk(self, chunk: dict) -&gt; None:\n\"\"\"\n    Receive and either cache or process the chunks of members from gateway.\n\n    Args:\n        chunk: A member chunk from discord\n\n    \"\"\"\n    if self.chunked.is_set():\n        self.chunked.clear()\n\n    if presences := chunk.get(\"presences\"):\n        # combine the presence dict into the members dict\n        for presence in presences:\n            u_id = presence[\"user\"][\"id\"]\n            # find the user this presence is for\n            member_index = next(\n                (index for (index, d) in enumerate(chunk.get(\"members\")) if d[\"user\"][\"id\"] == u_id), None\n            )\n            del presence[\"user\"]\n            chunk[\"members\"][member_index][\"user\"] = chunk[\"members\"][member_index][\"user\"] | presence\n\n    if not self._chunk_cache:\n        self._chunk_cache: List = chunk.get(\"members\")\n    else:\n        self._chunk_cache = self._chunk_cache + chunk.get(\"members\")\n\n    if chunk.get(\"chunk_index\") != chunk.get(\"chunk_count\") - 1:\n        return self.logger.debug(f\"Cached chunk of {len(chunk.get('members'))} members for {self.id}\")\n    else:\n        members = self._chunk_cache\n        self.logger.info(f\"Processing {len(members)} members for {self.id}\")\n\n        s = time.monotonic()\n        start_time = time.perf_counter()\n\n        for member in members:\n            self._client.cache.place_member_data(self.id, member)\n            if (time.monotonic() - s) &gt; 0.05:\n                # look, i get this *could* be a thread, but because it needs to modify data in the main thread,\n                # it is still blocking. So by periodically yielding to the event loop, we can avoid blocking, and still\n                # process this data properly\n                await asyncio.sleep(0)\n                s = time.monotonic()\n\n        total_time = time.perf_counter() - start_time\n        self.chunk_cache = []\n        self.logger.info(f\"Cached members for {self.id} in {total_time:.2f} seconds\")\n        self.chunked.set()\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_audit_log","title":"<code>fetch_audit_log(user_id=MISSING, action_type=MISSING, before=MISSING, after=MISSING, limit=100)</code>  <code>async</code>","text":"<p>Fetch section of the audit log for this guild.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>Optional[Snowflake_Type]</code> <p>The ID of the user to filter by</p> <code>MISSING</code> <code>action_type</code> <code>Optional[AuditLogEventType]</code> <p>The type of action to filter by</p> <code>MISSING</code> <code>before</code> <code>Optional[Snowflake_Type]</code> <p>The ID of the entry to start at</p> <code>MISSING</code> <code>after</code> <code>Optional[Snowflake_Type]</code> <p>The ID of the entry to end at</p> <code>MISSING</code> <code>limit</code> <code>int</code> <p>The number of entries to return</p> <code>100</code> <p>Returns:</p> Type Description <code>AuditLog</code> <p>An AuditLog object</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_audit_log(\n    self,\n    user_id: Optional[\"Snowflake_Type\"] = MISSING,\n    action_type: Optional[\"AuditLogEventType\"] = MISSING,\n    before: Optional[\"Snowflake_Type\"] = MISSING,\n    after: Optional[\"Snowflake_Type\"] = MISSING,\n    limit: int = 100,\n) -&gt; \"AuditLog\":\n\"\"\"\n    Fetch section of the audit log for this guild.\n\n    Args:\n        user_id: The ID of the user to filter by\n        action_type: The type of action to filter by\n        before: The ID of the entry to start at\n        after: The ID of the entry to end at\n        limit: The number of entries to return\n\n    Returns:\n        An AuditLog object\n\n    \"\"\"\n    data = await self._client.http.get_audit_log(self.id, user_id, action_type, before, after, limit)\n    return AuditLog.from_dict(data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.audit_log_history","title":"<code>audit_log_history(user_id=MISSING, action_type=MISSING, before=MISSING, after=MISSING, limit=100)</code>","text":"<p>Get an async iterator for the history of the audit log.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>MISSING</code> <code>action_type</code> <code>MISSING</code> <code>before</code> <code>Optional[Snowflake_Type]</code> <p>get entries before this message ID</p> <code>MISSING</code> <code>after</code> <code>Optional[Snowflake_Type]</code> <p>get entries after this message ID</p> <code>MISSING</code> <code>limit</code> <code>int</code> <p>The maximum number of entries to return (set to 0 for no limit)</p> <code>100</code> Example Usage: <p><pre><code>async for entry in guild.audit_log_history(limit=0):\n    entry: \"AuditLogEntry\"\n    if entry.changes:\n        # ...\n</code></pre> or <pre><code>history = guild.audit_log_history(limit=250)\n# Flatten the async iterator into a list\nentries = await history.flatten()\n</code></pre></p> <p>Returns:</p> Type Description <code>AuditLogHistory</code> <p>AuditLogHistory (AsyncIterator)</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>def audit_log_history(\n    self,\n    user_id: Optional[\"Snowflake_Type\"] = MISSING,\n    action_type: Optional[\"AuditLogEventType\"] = MISSING,\n    before: Optional[\"Snowflake_Type\"] = MISSING,\n    after: Optional[\"Snowflake_Type\"] = MISSING,\n    limit: int = 100,\n) -&gt; \"AuditLogHistory\":\n\"\"\"\n    Get an async iterator for the history of the audit log.\n\n    Args:\n        user_id (:class:`Snowflake_Type`): The user ID to search for.\n        action_type (:class:`AuditLogEventType`): The action type to search for.\n        before: get entries before this message ID\n        after: get entries after this message ID\n        limit: The maximum number of entries to return (set to 0 for no limit)\n\n    ??? Hint \"Example Usage:\"\n        ```python\n        async for entry in guild.audit_log_history(limit=0):\n            entry: \"AuditLogEntry\"\n            if entry.changes:\n                # ...\n        ```\n        or\n        ```python\n        history = guild.audit_log_history(limit=250)\n        # Flatten the async iterator into a list\n        entries = await history.flatten()\n        ```\n\n    Returns:\n        AuditLogHistory (AsyncIterator)\n\n    \"\"\"\n    return AuditLogHistory(self, user_id, action_type, before, after, limit)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.edit","title":"<code>edit(*, name=MISSING, description=MISSING, verification_level=MISSING, default_message_notifications=MISSING, explicit_content_filter=MISSING, afk_channel=MISSING, afk_timeout=MISSING, system_channel=MISSING, system_channel_flags=MISSING, owner=MISSING, icon=MISSING, splash=MISSING, discovery_splash=MISSING, banner=MISSING, rules_channel=MISSING, public_updates_channel=MISSING, preferred_locale=MISSING, features=MISSING, reason=MISSING)</code>  <code>async</code>","text":"<p>Edit the guild.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[Optional[str]]</code> <p>The new name of the guild.</p> <code>MISSING</code> <code>description</code> <code>Absent[Optional[str]]</code> <p>The new description of the guild.</p> <code>MISSING</code> <code>verification_level</code> <code>Absent[Optional[VerificationLevels]]</code> <p>The new verification level for the guild.</p> <code>MISSING</code> <code>default_message_notifications</code> <code>Absent[Optional[DefaultNotificationLevels]]</code> <p>The new notification level for the guild.</p> <code>MISSING</code> <code>explicit_content_filter</code> <code>Absent[Optional[ExplicitContentFilterLevels]]</code> <p>The new explicit content filter level for the guild.</p> <code>MISSING</code> <code>afk_channel</code> <code>Absent[Optional[Union[GuildVoice, Snowflake_Type]]]</code> <p>The voice channel that should be the new AFK channel.</p> <code>MISSING</code> <code>afk_timeout</code> <code>Absent[Optional[int]]</code> <p>How many seconds does a member need to be afk before they get moved to the AFK channel. Must be either <code>60</code>, <code>300</code>, <code>900</code>, <code>1800</code> or <code>3600</code>, otherwise HTTPException will be raised.</p> <code>MISSING</code> <code>icon</code> <code>Absent[Optional[UPLOADABLE_TYPE]]</code> <p>The new icon. Requires a bytes like object or a path to an image.</p> <code>MISSING</code> <code>owner</code> <code>Absent[Optional[Union[Member, Snowflake_Type]]]</code> <p>The new owner of the guild. You, the bot, need to be owner for this to work.</p> <code>MISSING</code> <code>splash</code> <code>Absent[Optional[UPLOADABLE_TYPE]]</code> <p>The new invite splash image. Requires a bytes like object or a path to an image.</p> <code>MISSING</code> <code>discovery_splash</code> <code>Absent[Optional[UPLOADABLE_TYPE]]</code> <p>The new discovery image. Requires a bytes like object or a path to an image.</p> <code>MISSING</code> <code>banner</code> <code>Absent[Optional[UPLOADABLE_TYPE]]</code> <p>The new banner image. Requires a bytes like object or a path to an image.</p> <code>MISSING</code> <code>system_channel</code> <code>Absent[Optional[Union[GuildText, Snowflake_Type]]]</code> <p>The text channel where new system messages should appear. This includes boosts and welcome messages.</p> <code>MISSING</code> <code>system_channel_flags</code> <code>Absent[Union[SystemChannelFlags, int]]</code> <p>The new settings for the system channel.</p> <code>MISSING</code> <code>rules_channel</code> <code>Absent[Optional[Union[GuildText, Snowflake_Type]]]</code> <p>The text channel where your rules and community guidelines are displayed.</p> <code>MISSING</code> <code>public_updates_channel</code> <code>Absent[Optional[Union[GuildText, Snowflake_Type]]]</code> <p>The text channel where updates from discord should appear.</p> <code>MISSING</code> <code>preferred_locale</code> <code>Absent[Optional[str]]</code> <p>The new preferred locale of the guild. Must be an ISO 639 code.</p> <code>MISSING</code> <code>features</code> <code>Absent[Optional[list[str]]]</code> <p>The enabled guild features</p> <code>MISSING</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>An optional reason for the audit log.</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: Absent[Optional[str]] = MISSING,\n    description: Absent[Optional[str]] = MISSING,\n    verification_level: Absent[Optional[\"VerificationLevels\"]] = MISSING,\n    default_message_notifications: Absent[Optional[\"DefaultNotificationLevels\"]] = MISSING,\n    explicit_content_filter: Absent[Optional[\"ExplicitContentFilterLevels\"]] = MISSING,\n    afk_channel: Absent[Optional[Union[\"models.GuildVoice\", Snowflake_Type]]] = MISSING,\n    afk_timeout: Absent[Optional[int]] = MISSING,\n    system_channel: Absent[Optional[Union[\"models.GuildText\", Snowflake_Type]]] = MISSING,\n    system_channel_flags: Absent[Union[SystemChannelFlags, int]] = MISSING,\n    owner: Absent[Optional[Union[\"models.Member\", Snowflake_Type]]] = MISSING,\n    icon: Absent[Optional[UPLOADABLE_TYPE]] = MISSING,\n    splash: Absent[Optional[UPLOADABLE_TYPE]] = MISSING,\n    discovery_splash: Absent[Optional[UPLOADABLE_TYPE]] = MISSING,\n    banner: Absent[Optional[UPLOADABLE_TYPE]] = MISSING,\n    rules_channel: Absent[Optional[Union[\"models.GuildText\", Snowflake_Type]]] = MISSING,\n    public_updates_channel: Absent[Optional[Union[\"models.GuildText\", Snowflake_Type]]] = MISSING,\n    preferred_locale: Absent[Optional[str]] = MISSING,\n    # ToDo: Fill in guild features. No idea how this works - https://discord.com/developers/docs/resources/guild#guild-object-guild-features\n    features: Absent[Optional[list[str]]] = MISSING,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; None:\n\"\"\"\n    Edit the guild.\n\n    Args:\n        name: The new name of the guild.\n        description: The new description of the guild.\n        verification_level: The new verification level for the guild.\n        default_message_notifications: The new notification level for the guild.\n        explicit_content_filter: The new explicit content filter level for the guild.\n        afk_channel: The voice channel that should be the new AFK channel.\n        afk_timeout: How many seconds does a member need to be afk before they get moved to the AFK channel. Must be either `60`, `300`, `900`, `1800` or `3600`, otherwise HTTPException will be raised.\n        icon: The new icon. Requires a bytes like object or a path to an image.\n        owner: The new owner of the guild. You, the bot, need to be owner for this to work.\n        splash: The new invite splash image. Requires a bytes like object or a path to an image.\n        discovery_splash: The new discovery image. Requires a bytes like object or a path to an image.\n        banner: The new banner image. Requires a bytes like object or a path to an image.\n        system_channel: The text channel where new system messages should appear. This includes boosts and welcome messages.\n        system_channel_flags: The new settings for the system channel.\n        rules_channel: The text channel where your rules and community guidelines are displayed.\n        public_updates_channel: The text channel where updates from discord should appear.\n        preferred_locale: The new preferred locale of the guild. Must be an ISO 639 code.\n        features: The enabled guild features\n        reason: An optional reason for the audit log.\n\n    \"\"\"\n    await self._client.http.modify_guild(\n        guild_id=self.id,\n        name=name,\n        description=description,\n        verification_level=int(verification_level) if verification_level else MISSING,\n        default_message_notifications=int(default_message_notifications)\n        if default_message_notifications\n        else MISSING,\n        explicit_content_filter=int(explicit_content_filter) if explicit_content_filter else MISSING,\n        afk_channel_id=to_snowflake(afk_channel) if afk_channel else MISSING,\n        afk_timeout=afk_timeout,\n        icon=to_image_data(icon) if icon else MISSING,\n        owner_id=to_snowflake(owner) if owner else MISSING,\n        splash=to_image_data(splash) if splash else MISSING,\n        discovery_splash=to_image_data(discovery_splash) if discovery_splash else MISSING,\n        banner=to_image_data(banner) if banner else MISSING,\n        system_channel_id=to_snowflake(system_channel) if system_channel else MISSING,\n        system_channel_flags=int(system_channel_flags) if system_channel_flags else MISSING,\n        rules_channel_id=to_snowflake(rules_channel) if rules_channel else MISSING,\n        public_updates_channel_id=to_snowflake(public_updates_channel) if public_updates_channel else MISSING,\n        preferred_locale=preferred_locale,\n        features=features,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.create_custom_emoji","title":"<code>create_custom_emoji(name, imagefile, roles=MISSING, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a new custom emoji for the guild.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the emoji</p> required <code>imagefile</code> <code>UPLOADABLE_TYPE</code> <p>The emoji image. (Supports PNG, JPEG, WebP, GIF)</p> required <code>roles</code> <code>Absent[List[Union[Snowflake_Type, Role]]]</code> <p>Roles allowed to use this emoji.</p> <code>MISSING</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>An optional reason for the audit log.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>CustomEmoji</code> <p>The new custom emoji created.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def create_custom_emoji(\n    self,\n    name: str,\n    imagefile: UPLOADABLE_TYPE,\n    roles: Absent[List[Union[Snowflake_Type, \"models.Role\"]]] = MISSING,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"models.CustomEmoji\":\n\"\"\"\n    Create a new custom emoji for the guild.\n\n    Args:\n        name: Name of the emoji\n        imagefile: The emoji image. (Supports PNG, JPEG, WebP, GIF)\n        roles: Roles allowed to use this emoji.\n        reason: An optional reason for the audit log.\n\n    Returns:\n        The new custom emoji created.\n\n    \"\"\"\n    data_payload = {\n        \"name\": name,\n        \"image\": to_image_data(imagefile),\n        \"roles\": to_snowflake_list(roles) if roles else MISSING,\n    }\n\n    emoji_data = await self._client.http.create_guild_emoji(data_payload, self.id, reason=reason)\n    return self._client.cache.place_emoji_data(self.id, emoji_data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.create_guild_template","title":"<code>create_guild_template(name, description=MISSING)</code>  <code>async</code>","text":"<p>Create a new guild template based on this guild.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the template (1-100 characters)</p> required <code>description</code> <code>Absent[str]</code> <p>The description for the template (0-120 characters)</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildTemplate</code> <p>The new guild template created.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def create_guild_template(self, name: str, description: Absent[str] = MISSING) -&gt; \"models.GuildTemplate\":\n\"\"\"\n    Create a new guild template based on this guild.\n\n    Args:\n        name: The name of the template (1-100 characters)\n        description: The description for the template (0-120 characters)\n\n    Returns:\n        The new guild template created.\n\n    \"\"\"\n    template = await self._client.http.create_guild_template(self.id, name, description)\n    return GuildTemplate.from_dict(template, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_guild_templates","title":"<code>fetch_guild_templates()</code>  <code>async</code>","text":"<p>Fetch all guild templates for this guild.</p> <p>Returns:</p> Type Description <code>List[GuildTemplate]</code> <p>A list of guild template objects.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_guild_templates(self) -&gt; List[\"models.GuildTemplate\"]:\n\"\"\"\n    Fetch all guild templates for this guild.\n\n    Returns:\n        A list of guild template objects.\n\n    \"\"\"\n    templates = await self._client.http.get_guild_templates(self.id)\n    return GuildTemplate.from_list(templates, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_all_custom_emojis","title":"<code>fetch_all_custom_emojis()</code>  <code>async</code>","text":"<p>Gets all the custom emoji present for this guild.</p> <p>Returns:</p> Type Description <code>List[CustomEmoji]</code> <p>A list of custom emoji objects.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_all_custom_emojis(self) -&gt; List[\"models.CustomEmoji\"]:\n\"\"\"\n    Gets all the custom emoji present for this guild.\n\n    Returns:\n        A list of custom emoji objects.\n\n    \"\"\"\n    emojis_data = await self._client.http.get_all_guild_emoji(self.id)\n    return [self._client.cache.place_emoji_data(self.id, emoji_data) for emoji_data in emojis_data]\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_custom_emoji","title":"<code>fetch_custom_emoji(emoji_id)</code>  <code>async</code>","text":"<p>Fetches the custom emoji present for this guild, based on the emoji id.</p> <p>Parameters:</p> Name Type Description Default <code>emoji_id</code> <code>Snowflake_Type</code> <p>The target emoji to get data of.</p> required <p>Returns:</p> Type Description <code>Optional[CustomEmoji]</code> <p>The custom emoji object. If the emoji is not found, returns None.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_custom_emoji(self, emoji_id: Snowflake_Type) -&gt; Optional[\"models.CustomEmoji\"]:\n\"\"\"\n    Fetches the custom emoji present for this guild, based on the emoji id.\n\n    Args:\n        emoji_id: The target emoji to get data of.\n\n    Returns:\n        The custom emoji object. If the emoji is not found, returns None.\n\n    \"\"\"\n    try:\n        return await self._client.cache.fetch_emoji(self.id, emoji_id)\n    except NotFound:\n        return None\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.get_custom_emoji","title":"<code>get_custom_emoji(emoji_id)</code>","text":"<p>Gets the custom emoji present for this guild, based on the emoji id.</p> <p>Parameters:</p> Name Type Description Default <code>emoji_id</code> <code>Snowflake_Type</code> <p>The target emoji to get data of.</p> required <p>Returns:</p> Type Description <code>Optional[CustomEmoji]</code> <p>The custom emoji object.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>def get_custom_emoji(self, emoji_id: Snowflake_Type) -&gt; Optional[\"models.CustomEmoji\"]:\n\"\"\"\n    Gets the custom emoji present for this guild, based on the emoji id.\n\n    Args:\n        emoji_id: The target emoji to get data of.\n\n    Returns:\n        The custom emoji object.\n\n    \"\"\"\n    emoji_id = to_snowflake(emoji_id)\n    emoji = self._client.cache.get_emoji(emoji_id)\n    if emoji and emoji._guild_id == self.id:\n        return emoji\n    return None\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.create_channel","title":"<code>create_channel(channel_type, name, topic=MISSING, position=MISSING, permission_overwrites=MISSING, category=None, nsfw=False, bitrate=64000, user_limit=0, rate_limit_per_user=0, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a guild channel, allows for explicit channel type setting.</p> <p>Parameters:</p> Name Type Description Default <code>channel_type</code> <code>Union[ChannelTypes, int]</code> <p>The type of channel to create</p> required <code>name</code> <code>str</code> <p>The name of the channel</p> required <code>topic</code> <code>Absent[Optional[str]]</code> <p>The topic of the channel</p> <code>MISSING</code> <code>position</code> <code>Absent[Optional[int]]</code> <p>The position of the channel in the channel list</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>Permission overwrites to apply to the channel</p> <code>MISSING</code> <code>category</code> <code>Union[Snowflake_Type, GuildCategory]</code> <p>The category this channel should be within</p> <code>None</code> <code>nsfw</code> <code>bool</code> <p>Should this channel be marked nsfw</p> <code>False</code> <code>bitrate</code> <code>int</code> <p>The bitrate of this channel, only for voice</p> <code>64000</code> <code>user_limit</code> <code>int</code> <p>The max users that can be in this channel, only for voice</p> <code>0</code> <code>rate_limit_per_user</code> <code>int</code> <p>The time users must wait between sending messages</p> <code>0</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for creating this channel</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>TYPE_GUILD_CHANNEL</code> <p>The newly created channel.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def create_channel(\n    self,\n    channel_type: Union[ChannelTypes, int],\n    name: str,\n    topic: Absent[Optional[str]] = MISSING,\n    position: Absent[Optional[int]] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, \"models.PermissionOverwrite\", List[Union[dict, \"models.PermissionOverwrite\"]]]\n    ] = MISSING,\n    category: Union[Snowflake_Type, \"models.GuildCategory\"] = None,\n    nsfw: bool = False,\n    bitrate: int = 64000,\n    user_limit: int = 0,\n    rate_limit_per_user: int = 0,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"models.TYPE_GUILD_CHANNEL\":\n\"\"\"\n    Create a guild channel, allows for explicit channel type setting.\n\n    Args:\n        channel_type: The type of channel to create\n        name: The name of the channel\n        topic: The topic of the channel\n        position: The position of the channel in the channel list\n        permission_overwrites: Permission overwrites to apply to the channel\n        category: The category this channel should be within\n        nsfw: Should this channel be marked nsfw\n        bitrate: The bitrate of this channel, only for voice\n        user_limit: The max users that can be in this channel, only for voice\n        rate_limit_per_user: The time users must wait between sending messages\n        reason: The reason for creating this channel\n\n    Returns:\n        The newly created channel.\n\n    \"\"\"\n    channel_data = await self._client.http.create_guild_channel(\n        self.id,\n        name,\n        channel_type,\n        topic,\n        position,\n        models.process_permission_overwrites(permission_overwrites),\n        to_optional_snowflake(category),\n        nsfw,\n        bitrate,\n        user_limit,\n        rate_limit_per_user,\n        reason,\n    )\n    return self._client.cache.place_channel_data(channel_data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.create_text_channel","title":"<code>create_text_channel(name, topic=MISSING, position=MISSING, permission_overwrites=MISSING, category=None, nsfw=False, rate_limit_per_user=0, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a text channel in this guild.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the channel</p> required <code>topic</code> <code>Absent[Optional[str]]</code> <p>The topic of the channel</p> <code>MISSING</code> <code>position</code> <code>Absent[Optional[int]]</code> <p>The position of the channel in the channel list</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>Permission overwrites to apply to the channel</p> <code>MISSING</code> <code>category</code> <code>Union[Snowflake_Type, GuildCategory]</code> <p>The category this channel should be within</p> <code>None</code> <code>nsfw</code> <code>bool</code> <p>Should this channel be marked nsfw</p> <code>False</code> <code>rate_limit_per_user</code> <code>int</code> <p>The time users must wait between sending messages</p> <code>0</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for creating this channel</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildText</code> <p>The newly created text channel.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def create_text_channel(\n    self,\n    name: str,\n    topic: Absent[Optional[str]] = MISSING,\n    position: Absent[Optional[int]] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, \"models.PermissionOverwrite\", List[Union[dict, \"models.PermissionOverwrite\"]]]\n    ] = MISSING,\n    category: Union[Snowflake_Type, \"models.GuildCategory\"] = None,\n    nsfw: bool = False,\n    rate_limit_per_user: int = 0,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"models.GuildText\":\n\"\"\"\n    Create a text channel in this guild.\n\n    Args:\n        name: The name of the channel\n        topic: The topic of the channel\n        position: The position of the channel in the channel list\n        permission_overwrites: Permission overwrites to apply to the channel\n        category: The category this channel should be within\n        nsfw: Should this channel be marked nsfw\n        rate_limit_per_user: The time users must wait between sending messages\n        reason: The reason for creating this channel\n\n    Returns:\n       The newly created text channel.\n\n    \"\"\"\n    return await self.create_channel(\n        channel_type=ChannelTypes.GUILD_TEXT,\n        name=name,\n        topic=topic,\n        position=position,\n        permission_overwrites=permission_overwrites,\n        category=category,\n        nsfw=nsfw,\n        rate_limit_per_user=rate_limit_per_user,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.create_forum_channel","title":"<code>create_forum_channel(name, topic=MISSING, position=MISSING, permission_overwrites=MISSING, category=None, nsfw=False, rate_limit_per_user=0, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a forum channel in this guild.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the forum channel</p> required <code>topic</code> <code>Absent[Optional[str]]</code> <p>The topic of the forum channel</p> <code>MISSING</code> <code>position</code> <code>Absent[Optional[int]]</code> <p>The position of the forum channel in the channel list</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>Permission overwrites to apply to the forum channel</p> <code>MISSING</code> <code>category</code> <code>Union[Snowflake_Type, GuildCategory]</code> <p>The category this forum channel should be within</p> <code>None</code> <code>nsfw</code> <code>bool</code> <p>Should this forum be marked nsfw</p> <code>False</code> <code>rate_limit_per_user</code> <code>int</code> <p>The time users must wait between sending messages</p> <code>0</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for creating this channel</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildForum</code> <p>The newly created forum channel.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def create_forum_channel(\n    self,\n    name: str,\n    topic: Absent[Optional[str]] = MISSING,\n    position: Absent[Optional[int]] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, \"models.PermissionOverwrite\", List[Union[dict, \"models.PermissionOverwrite\"]]]\n    ] = MISSING,\n    category: Union[Snowflake_Type, \"models.GuildCategory\"] = None,\n    nsfw: bool = False,\n    rate_limit_per_user: int = 0,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"models.GuildForum\":\n\"\"\"\n    Create a forum channel in this guild.\n\n    Args:\n        name: The name of the forum channel\n        topic: The topic of the forum channel\n        position: The position of the forum channel in the channel list\n        permission_overwrites: Permission overwrites to apply to the forum channel\n        category: The category this forum channel should be within\n        nsfw: Should this forum be marked nsfw\n        rate_limit_per_user: The time users must wait between sending messages\n        reason: The reason for creating this channel\n\n    Returns:\n       The newly created forum channel.\n\n    \"\"\"\n    return await self.create_channel(\n        channel_type=ChannelTypes.GUILD_FORUM,\n        name=name,\n        topic=topic,\n        position=position,\n        permission_overwrites=permission_overwrites,\n        category=category,\n        nsfw=nsfw,\n        rate_limit_per_user=rate_limit_per_user,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.create_news_channel","title":"<code>create_news_channel(name, topic=MISSING, position=MISSING, permission_overwrites=MISSING, category=None, nsfw=False, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a news channel in this guild.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the channel</p> required <code>topic</code> <code>Absent[Optional[str]]</code> <p>The topic of the channel</p> <code>MISSING</code> <code>position</code> <code>Absent[Optional[int]]</code> <p>The position of the channel in the channel list</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>Permission overwrites to apply to the channel</p> <code>MISSING</code> <code>category</code> <code>Union[Snowflake_Type, GuildCategory]</code> <p>The category this channel should be within</p> <code>None</code> <code>nsfw</code> <code>bool</code> <p>Should this channel be marked nsfw</p> <code>False</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for creating this channel</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildNews</code> <p>The newly created news channel.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def create_news_channel(\n    self,\n    name: str,\n    topic: Absent[Optional[str]] = MISSING,\n    position: Absent[Optional[int]] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, \"models.PermissionOverwrite\", List[Union[dict, \"models.PermissionOverwrite\"]]]\n    ] = MISSING,\n    category: Union[Snowflake_Type, \"models.GuildCategory\"] = None,\n    nsfw: bool = False,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"models.GuildNews\":\n\"\"\"\n    Create a news channel in this guild.\n\n    Args:\n        name: The name of the channel\n        topic: The topic of the channel\n        position: The position of the channel in the channel list\n        permission_overwrites: Permission overwrites to apply to the channel\n        category: The category this channel should be within\n        nsfw: Should this channel be marked nsfw\n        reason: The reason for creating this channel\n\n    Returns:\n       The newly created news channel.\n\n    \"\"\"\n    return await self.create_channel(\n        channel_type=ChannelTypes.GUILD_NEWS,\n        name=name,\n        topic=topic,\n        position=position,\n        permission_overwrites=permission_overwrites,\n        category=category,\n        nsfw=nsfw,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.create_voice_channel","title":"<code>create_voice_channel(name, topic=MISSING, position=MISSING, permission_overwrites=MISSING, category=None, nsfw=False, bitrate=64000, user_limit=0, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a guild voice channel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the channel</p> required <code>topic</code> <code>Absent[Optional[str]]</code> <p>The topic of the channel</p> <code>MISSING</code> <code>position</code> <code>Absent[Optional[int]]</code> <p>The position of the channel in the channel list</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>Permission overwrites to apply to the channel</p> <code>MISSING</code> <code>category</code> <code>Union[Snowflake_Type, GuildCategory]</code> <p>The category this channel should be within</p> <code>None</code> <code>nsfw</code> <code>bool</code> <p>Should this channel be marked nsfw</p> <code>False</code> <code>bitrate</code> <code>int</code> <p>The bitrate of this channel, only for voice</p> <code>64000</code> <code>user_limit</code> <code>int</code> <p>The max users that can be in this channel, only for voice</p> <code>0</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for creating this channel</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildVoice</code> <p>The newly created voice channel.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def create_voice_channel(\n    self,\n    name: str,\n    topic: Absent[Optional[str]] = MISSING,\n    position: Absent[Optional[int]] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, \"models.PermissionOverwrite\", List[Union[dict, \"models.PermissionOverwrite\"]]]\n    ] = MISSING,\n    category: Union[Snowflake_Type, \"models.GuildCategory\"] = None,\n    nsfw: bool = False,\n    bitrate: int = 64000,\n    user_limit: int = 0,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"models.GuildVoice\":\n\"\"\"\n    Create a guild voice channel.\n\n    Args:\n        name: The name of the channel\n        topic: The topic of the channel\n        position: The position of the channel in the channel list\n        permission_overwrites: Permission overwrites to apply to the channel\n        category: The category this channel should be within\n        nsfw: Should this channel be marked nsfw\n        bitrate: The bitrate of this channel, only for voice\n        user_limit: The max users that can be in this channel, only for voice\n        reason: The reason for creating this channel\n\n    Returns:\n       The newly created voice channel.\n\n    \"\"\"\n    return await self.create_channel(\n        channel_type=ChannelTypes.GUILD_VOICE,\n        name=name,\n        topic=topic,\n        position=position,\n        permission_overwrites=permission_overwrites,\n        category=category,\n        nsfw=nsfw,\n        bitrate=bitrate,\n        user_limit=user_limit,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.create_stage_channel","title":"<code>create_stage_channel(name, topic=MISSING, position=MISSING, permission_overwrites=MISSING, category=MISSING, bitrate=64000, user_limit=0, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a guild stage channel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the channel</p> required <code>topic</code> <code>Absent[Optional[str]]</code> <p>The topic of the channel</p> <code>MISSING</code> <code>position</code> <code>Absent[Optional[int]]</code> <p>The position of the channel in the channel list</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>Permission overwrites to apply to the channel</p> <code>MISSING</code> <code>category</code> <code>Absent[Union[Snowflake_Type, GuildCategory]]</code> <p>The category this channel should be within</p> <code>MISSING</code> <code>bitrate</code> <code>int</code> <p>The bitrate of this channel, only for voice</p> <code>64000</code> <code>user_limit</code> <code>int</code> <p>The max users that can be in this channel, only for voice</p> <code>0</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for creating this channel</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildStageVoice</code> <p>The newly created stage channel.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def create_stage_channel(\n    self,\n    name: str,\n    topic: Absent[Optional[str]] = MISSING,\n    position: Absent[Optional[int]] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, \"models.PermissionOverwrite\", List[Union[dict, \"models.PermissionOverwrite\"]]]\n    ] = MISSING,\n    category: Absent[Union[Snowflake_Type, \"models.GuildCategory\"]] = MISSING,\n    bitrate: int = 64000,\n    user_limit: int = 0,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"models.GuildStageVoice\":\n\"\"\"\n    Create a guild stage channel.\n\n    Args:\n        name: The name of the channel\n        topic: The topic of the channel\n        position: The position of the channel in the channel list\n        permission_overwrites: Permission overwrites to apply to the channel\n        category: The category this channel should be within\n        bitrate: The bitrate of this channel, only for voice\n        user_limit: The max users that can be in this channel, only for voice\n        reason: The reason for creating this channel\n\n    Returns:\n        The newly created stage channel.\n\n    \"\"\"\n    return await self.create_channel(\n        channel_type=ChannelTypes.GUILD_STAGE_VOICE,\n        name=name,\n        topic=topic,\n        position=position,\n        permission_overwrites=permission_overwrites,\n        category=category,\n        bitrate=bitrate,\n        user_limit=user_limit,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.create_category","title":"<code>create_category(name, position=MISSING, permission_overwrites=MISSING, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a category within this guild.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the channel</p> required <code>position</code> <code>Absent[Optional[int]]</code> <p>The position of the channel in the channel list</p> <code>MISSING</code> <code>permission_overwrites</code> <code>Absent[Union[dict, PermissionOverwrite, List[Union[dict, PermissionOverwrite]]]]</code> <p>Permission overwrites to apply to the channel</p> <code>MISSING</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for creating this channel</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildCategory</code> <p>The newly created category.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def create_category(\n    self,\n    name: str,\n    position: Absent[Optional[int]] = MISSING,\n    permission_overwrites: Absent[\n        Union[dict, \"models.PermissionOverwrite\", List[Union[dict, \"models.PermissionOverwrite\"]]]\n    ] = MISSING,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"models.GuildCategory\":\n\"\"\"\n    Create a category within this guild.\n\n    Args:\n        name: The name of the channel\n        position: The position of the channel in the channel list\n        permission_overwrites: Permission overwrites to apply to the channel\n        reason: The reason for creating this channel\n\n    Returns:\n        The newly created category.\n\n    \"\"\"\n    return await self.create_channel(\n        channel_type=ChannelTypes.GUILD_CATEGORY,\n        name=name,\n        position=position,\n        permission_overwrites=permission_overwrites,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.delete_channel","title":"<code>delete_channel(channel, reason=None)</code>  <code>async</code>","text":"<p>Delete the given channel, can handle either a snowflake or channel object.</p> <p>This is effectively just an alias for <code>channel.delete()</code></p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Union[TYPE_GUILD_CHANNEL, Snowflake_Type]</code> <p>The channel to be deleted</p> required <code>reason</code> <code>str</code> <p>The reason for this deletion</p> <code>None</code> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def delete_channel(\n    self, channel: Union[\"models.TYPE_GUILD_CHANNEL\", Snowflake_Type], reason: str = None\n) -&gt; None:\n\"\"\"\n    Delete the given channel, can handle either a snowflake or channel object.\n\n    This is effectively just an alias for `channel.delete()`\n\n    Args:\n        channel: The channel to be deleted\n        reason: The reason for this deletion\n\n    \"\"\"\n    if isinstance(channel, (str, int)):\n        channel = await self._client.fetch_channel(channel)\n\n    if not channel:\n        raise ValueError(\"Unable to find requested channel\")\n\n    if channel.id not in self._channel_ids:\n        raise ValueError(\"This guild does not hold the requested channel\")\n\n    await channel.delete(reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.list_scheduled_events","title":"<code>list_scheduled_events(with_user_count=False)</code>  <code>async</code>","text":"<p>List all scheduled events in this guild.</p> <p>Returns:</p> Type Description <code>List[ScheduledEvent]</code> <p>A list of scheduled events.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def list_scheduled_events(self, with_user_count: bool = False) -&gt; List[\"models.ScheduledEvent\"]:\n\"\"\"\n    List all scheduled events in this guild.\n\n    Returns:\n        A list of scheduled events.\n\n    \"\"\"\n    scheduled_events_data = await self._client.http.list_schedules_events(self.id, with_user_count)\n    return models.ScheduledEvent.from_list(scheduled_events_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_scheduled_event","title":"<code>fetch_scheduled_event(scheduled_event_id, with_user_count=False)</code>  <code>async</code>","text":"<p>Get a scheduled event by id.</p> <p>Parameters:</p> Name Type Description Default <code>scheduled_event_id</code> <code>Snowflake_Type</code> <p>The id of the scheduled event.</p> required <code>with_user_count</code> <code>bool</code> <p>Whether to include the user count in the response.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[ScheduledEvent]</code> <p>The scheduled event. If the event does not exist, returns None.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_scheduled_event(\n    self, scheduled_event_id: Snowflake_Type, with_user_count: bool = False\n) -&gt; Optional[\"models.ScheduledEvent\"]:\n\"\"\"\n    Get a scheduled event by id.\n\n    Args:\n        scheduled_event_id: The id of the scheduled event.\n        with_user_count: Whether to include the user count in the response.\n\n    Returns:\n        The scheduled event. If the event does not exist, returns None.\n\n    \"\"\"\n    try:\n        scheduled_event_data = await self._client.http.get_scheduled_event(\n            self.id, scheduled_event_id, with_user_count\n        )\n    except NotFound:\n        return None\n    return models.ScheduledEvent.from_dict(scheduled_event_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.create_scheduled_event","title":"<code>create_scheduled_event(name, event_type, start_time, end_time=MISSING, description=MISSING, channel_id=MISSING, external_location=MISSING, entity_metadata=None, privacy_level=ScheduledEventPrivacyLevel.GUILD_ONLY, cover_image=MISSING, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a scheduled guild event.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>event name</p> required <code>event_type</code> <code>ScheduledEventType</code> <p>event type</p> required <code>start_time</code> <code>Timestamp</code> <p><code>Timestamp</code> object</p> required <code>end_time</code> <code>Absent[Optional[Timestamp]]</code> <p><code>Timestamp</code> object</p> <code>MISSING</code> <code>description</code> <code>Absent[Optional[str]]</code> <p>event description</p> <code>MISSING</code> <code>channel_id</code> <code>Absent[Optional[Snowflake_Type]]</code> <p>channel id</p> <code>MISSING</code> <code>external_location</code> <code>Absent[Optional[str]]</code> <p>event external location (For external events)</p> <code>MISSING</code> <code>entity_metadata</code> <code>Optional[dict]</code> <p>event metadata (additional data for the event)</p> <code>None</code> <code>privacy_level</code> <code>ScheduledEventPrivacyLevel</code> <p>event privacy level</p> <code>ScheduledEventPrivacyLevel.GUILD_ONLY</code> <code>cover_image</code> <code>Absent[UPLOADABLE_TYPE]</code> <p>the cover image of the scheduled event</p> <code>MISSING</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>reason for creating this scheduled event</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>ScheduledEvent</code> <p>The newly created ScheduledEvent object</p> <p>Note</p> <p>For external events, external_location is required For voice/stage events, channel_id is required</p> Note <p>entity_metadata is the backend dictionary for fluff fields. Where possible, we plan to expose these fields directly. The full list of supported fields is https://discord.com/developers/docs/resources/guild-scheduled-event#guild-scheduled-event-object-guild-scheduled-event-entity-metadata Example: <code>entity_metadata=dict(location=\"cool place\")</code></p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def create_scheduled_event(\n    self,\n    name: str,\n    event_type: ScheduledEventType,\n    start_time: \"models.Timestamp\",\n    end_time: Absent[Optional[\"models.Timestamp\"]] = MISSING,\n    description: Absent[Optional[str]] = MISSING,\n    channel_id: Absent[Optional[Snowflake_Type]] = MISSING,\n    external_location: Absent[Optional[str]] = MISSING,\n    entity_metadata: Optional[dict] = None,\n    privacy_level: ScheduledEventPrivacyLevel = ScheduledEventPrivacyLevel.GUILD_ONLY,\n    cover_image: Absent[UPLOADABLE_TYPE] = MISSING,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"models.ScheduledEvent\":\n\"\"\"\n    Create a scheduled guild event.\n\n    Args:\n        name: event name\n        event_type: event type\n        start_time: `Timestamp` object\n        end_time: `Timestamp` object\n        description: event description\n        channel_id: channel id\n        external_location: event external location (For external events)\n        entity_metadata: event metadata (additional data for the event)\n        privacy_level: event privacy level\n        cover_image: the cover image of the scheduled event\n        reason: reason for creating this scheduled event\n\n    Returns:\n        The newly created ScheduledEvent object\n\n    !!! note\n        For external events, external_location is required\n        For voice/stage events, channel_id is required\n\n    ??? note\n        entity_metadata is the backend dictionary for fluff fields. Where possible, we plan to expose these fields directly.\n        The full list of supported fields is https://discord.com/developers/docs/resources/guild-scheduled-event#guild-scheduled-event-object-guild-scheduled-event-entity-metadata\n        Example: `entity_metadata=dict(location=\"cool place\")`\n\n    \"\"\"\n    if external_location is not MISSING:\n        entity_metadata = {\"location\": external_location}\n\n    if event_type == ScheduledEventType.EXTERNAL:\n        if external_location == MISSING:\n            raise EventLocationNotProvided(\"Location is required for external events\")\n\n    payload = {\n        \"name\": name,\n        \"entity_type\": event_type,\n        \"scheduled_start_time\": start_time.isoformat(),\n        \"scheduled_end_time\": end_time.isoformat() if end_time is not MISSING else end_time,\n        \"description\": description,\n        \"channel_id\": channel_id,\n        \"entity_metadata\": entity_metadata,\n        \"privacy_level\": privacy_level,\n        \"image\": to_image_data(cover_image) if cover_image else MISSING,\n    }\n\n    scheduled_event_data = await self._client.http.create_scheduled_event(self.id, payload, reason)\n    return models.ScheduledEvent.from_dict(scheduled_event_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.create_custom_sticker","title":"<code>create_custom_sticker(name, imagefile, description=MISSING, tags=MISSING, reason=MISSING)</code>  <code>async</code>","text":"<p>Creates a custom sticker for a guild.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the sticker (2-30 characters)</p> required <code>imagefile</code> <code>UPLOADABLE_TYPE</code> <p>The sticker file to upload, must be a PNG, APNG, or Lottie JSON file (max 500 KB)</p> required <code>description</code> <code>Absent[Optional[str]]</code> <p>The description of the sticker (empty or 2-100 characters)</p> <code>MISSING</code> <code>tags</code> <code>Absent[Optional[str]]</code> <p>Autocomplete/suggestion tags for the sticker (max 200 characters)</p> <code>MISSING</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>Reason for creating the sticker</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Sticker</code> <p>New Sticker instance</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def create_custom_sticker(\n    self,\n    name: str,\n    imagefile: UPLOADABLE_TYPE,\n    description: Absent[Optional[str]] = MISSING,\n    tags: Absent[Optional[str]] = MISSING,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"models.Sticker\":\n\"\"\"\n    Creates a custom sticker for a guild.\n\n    Args:\n        name: The name of the sticker (2-30 characters)\n        imagefile: The sticker file to upload, must be a PNG, APNG, or Lottie JSON file (max 500 KB)\n        description: The description of the sticker (empty or 2-100 characters)\n        tags: Autocomplete/suggestion tags for the sticker (max 200 characters)\n        reason: Reason for creating the sticker\n\n    Returns:\n        New Sticker instance\n\n    \"\"\"\n    payload = {\"name\": name}\n\n    if description:\n        payload[\"description\"] = description\n\n    if tags:\n        payload[\"tags\"] = tags\n\n    sticker_data = await self._client.http.create_guild_sticker(payload, self.id, reason)\n    return models.Sticker.from_dict(sticker_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_all_custom_stickers","title":"<code>fetch_all_custom_stickers()</code>  <code>async</code>","text":"<p>Fetches all custom stickers for a guild.</p> <p>Returns:</p> Type Description <code>List[Sticker]</code> <p>List of Sticker objects</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_all_custom_stickers(self) -&gt; List[\"models.Sticker\"]:\n\"\"\"\n    Fetches all custom stickers for a guild.\n\n    Returns:\n        List of Sticker objects\n\n    \"\"\"\n    stickers_data = await self._client.http.list_guild_stickers(self.id)\n    return models.Sticker.from_list(stickers_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_custom_sticker","title":"<code>fetch_custom_sticker(sticker_id)</code>  <code>async</code>","text":"<p>Fetches a specific custom sticker for a guild.</p> <p>Parameters:</p> Name Type Description Default <code>sticker_id</code> <code>Snowflake_Type</code> <p>ID of sticker to get</p> required <p>Returns:</p> Type Description <code>Optional[Sticker]</code> <p>The custom sticker object. If the sticker does not exist, returns None.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_custom_sticker(self, sticker_id: Snowflake_Type) -&gt; Optional[\"models.Sticker\"]:\n\"\"\"\n    Fetches a specific custom sticker for a guild.\n\n    Args:\n        sticker_id: ID of sticker to get\n\n    Returns:\n        The custom sticker object. If the sticker does not exist, returns None.\n\n    \"\"\"\n    try:\n        sticker_data = await self._client.http.get_guild_sticker(self.id, to_snowflake(sticker_id))\n    except NotFound:\n        return None\n    return models.Sticker.from_dict(sticker_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_active_threads","title":"<code>fetch_active_threads()</code>  <code>async</code>","text":"<p>Fetches all active threads in the guild, including public and private threads. Threads are ordered by their id, in descending order.</p> <p>Returns:</p> Type Description <code>ThreadList</code> <p>List of active threads and thread member object for each returned thread the bot user has joined.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_active_threads(self) -&gt; \"models.ThreadList\":\n\"\"\"\n    Fetches all active threads in the guild, including public and private threads. Threads are ordered by their id, in descending order.\n\n    Returns:\n        List of active threads and thread member object for each returned thread the bot user has joined.\n\n    \"\"\"\n    threads_data = await self._client.http.list_active_threads(self.id)\n    return models.ThreadList.from_dict(threads_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_role","title":"<code>fetch_role(role_id)</code>  <code>async</code>","text":"<p>Fetch the specified role by ID.</p> <p>Parameters:</p> Name Type Description Default <code>role_id</code> <code>Snowflake_Type</code> <p>The ID of the role to get</p> required <p>Returns:</p> Type Description <code>Optional[Role]</code> <p>The role object. If the role does not exist, returns None.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_role(self, role_id: Snowflake_Type) -&gt; Optional[\"models.Role\"]:\n\"\"\"\n    Fetch the specified role by ID.\n\n    Args:\n        role_id: The ID of the role to get\n\n    Returns:\n        The role object. If the role does not exist, returns None.\n\n    \"\"\"\n    try:\n        return await self._client.cache.fetch_role(self.id, role_id)\n    except NotFound:\n        return None\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.get_role","title":"<code>get_role(role_id)</code>","text":"<p>Get the specified role by ID.</p> <p>Parameters:</p> Name Type Description Default <code>role_id</code> <code>Snowflake_Type</code> <p>The ID of the role to get</p> required <p>Returns:</p> Type Description <code>Optional[Role]</code> <p>A role object or None if the role is not found.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>def get_role(self, role_id: Snowflake_Type) -&gt; Optional[\"models.Role\"]:\n\"\"\"\n    Get the specified role by ID.\n\n    Args:\n        role_id: The ID of the role to get\n\n    Returns:\n        A role object or None if the role is not found.\n\n    \"\"\"\n    role_id = to_snowflake(role_id)\n    if role_id in self._role_ids:\n        return self._client.cache.get_role(role_id)\n    return None\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.create_role","title":"<code>create_role(name=MISSING, permissions=MISSING, colour=MISSING, color=MISSING, hoist=False, mentionable=False, icon=MISSING, reason=MISSING)</code>  <code>async</code>","text":"<p>Create a new role for the guild. You must have the <code>manage roles</code> permission.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[Optional[str]]</code> <p>The name the role should have. <code>Default: new role</code></p> <code>MISSING</code> <code>permissions</code> <code>Absent[Optional[Permissions]]</code> <p>The permissions the role should have. <code>Default: @everyone permissions</code></p> <code>MISSING</code> <code>colour</code> <code>Absent[Optional[Union[Color, int]]]</code> <p>The colour of the role. Can be either <code>Color</code> or an RGB integer. <code>Default: BrandColors.BLACK</code></p> <code>MISSING</code> <code>color</code> <code>Absent[Optional[Union[Color, int]]]</code> <p>Alias for <code>colour</code></p> <code>MISSING</code> <code>icon</code> <code>Absent[Optional[UPLOADABLE_TYPE]]</code> <p>Can be either a bytes like object or a path to an image, or a unicode emoji which is supported by discord.</p> <code>MISSING</code> <code>hoist</code> <code>Optional[bool]</code> <p>Whether the role is shown separately in the members list. <code>Default: False</code></p> <code>False</code> <code>mentionable</code> <code>Optional[bool]</code> <p>Whether the role can be mentioned. <code>Default: False</code></p> <code>False</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>An optional reason for the audit log.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Role</code> <p>A role object or None if the role is not found.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def create_role(\n    self,\n    name: Absent[Optional[str]] = MISSING,\n    permissions: Absent[Optional[Permissions]] = MISSING,\n    colour: Absent[Optional[Union[\"models.Color\", int]]] = MISSING,\n    color: Absent[Optional[Union[\"models.Color\", int]]] = MISSING,\n    hoist: Optional[bool] = False,\n    mentionable: Optional[bool] = False,\n    icon: Absent[Optional[UPLOADABLE_TYPE]] = MISSING,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"models.Role\":\n\"\"\"\n    Create a new role for the guild. You must have the `manage roles` permission.\n\n    Args:\n        name: The name the role should have. `Default: new role`\n        permissions: The permissions the role should have. `Default: @everyone permissions`\n        colour: The colour of the role. Can be either `Color` or an RGB integer. `Default: BrandColors.BLACK`\n        color: Alias for `colour`\n        icon: Can be either a bytes like object or a path to an image, or a unicode emoji which is supported by discord.\n        hoist: Whether the role is shown separately in the members list. `Default: False`\n        mentionable: Whether the role can be mentioned. `Default: False`\n        reason: An optional reason for the audit log.\n\n    Returns:\n        A role object or None if the role is not found.\n\n    \"\"\"\n    payload = {}\n\n    if name:\n        payload.update({\"name\": name})\n\n    if permissions:\n        payload.update({\"permissions\": str(int(permissions))})\n\n    colour = colour or color\n    if colour:\n        payload.update({\"color\": colour.value})\n\n    if hoist:\n        payload.update({\"hoist\": True})\n\n    if mentionable:\n        payload.update({\"mentionable\": True})\n\n    if icon:\n        # test if the icon is probably a unicode emoji (str and len() == 1) or a path / bytes obj\n        if isinstance(icon, str) and len(icon) == 1:\n            payload.update({\"unicode_emoji\": icon})\n\n        else:\n            payload.update({\"icon\": to_image_data(icon)})\n\n    result = await self._client.http.create_guild_role(guild_id=self.id, payload=payload, reason=reason)\n    return self._client.cache.place_role_data(guild_id=self.id, data=[result])[to_snowflake(result[\"id\"])]\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.get_channel","title":"<code>get_channel(channel_id)</code>","text":"<p>Returns a channel with the given <code>channel_id</code>.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel to get</p> required <p>Returns:</p> Type Description <code>Optional[TYPE_GUILD_CHANNEL]</code> <p>Channel object if found, otherwise None</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>def get_channel(self, channel_id: Snowflake_Type) -&gt; Optional[\"models.TYPE_GUILD_CHANNEL\"]:\n\"\"\"\n    Returns a channel with the given `channel_id`.\n\n    Args:\n        channel_id: The ID of the channel to get\n\n    Returns:\n        Channel object if found, otherwise None\n\n    \"\"\"\n    channel_id = to_snowflake(channel_id)\n    if channel_id in self._channel_ids:\n        # theoretically, this could get any channel the client can see,\n        # but to make it less confusing to new programmers,\n        # i intentionally check that the guild contains the channel first\n        return self._client.cache.get_channel(channel_id)\n    return None\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_channel","title":"<code>fetch_channel(channel_id)</code>  <code>async</code>","text":"<p>Returns a channel with the given <code>channel_id</code> from the API.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel to get</p> required <p>Returns:</p> Type Description <code>Optional[TYPE_GUILD_CHANNEL]</code> <p>The channel object. If the channel does not exist, returns None.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_channel(self, channel_id: Snowflake_Type) -&gt; Optional[\"models.TYPE_GUILD_CHANNEL\"]:\n\"\"\"\n    Returns a channel with the given `channel_id` from the API.\n\n    Args:\n        channel_id: The ID of the channel to get\n\n    Returns:\n        The channel object. If the channel does not exist, returns None.\n\n    \"\"\"\n    channel_id = to_snowflake(channel_id)\n    if channel_id in self._channel_ids or not self._client.gateway_started:\n        # The latter check here is to see if the bot is running with the gateway.\n        # If not, then we need to check the API since only the gateway\n        # populates the channel IDs\n\n        # theoretically, this could get any channel the client can see,\n        # but to make it less confusing to new programmers,\n        # i intentionally check that the guild contains the channel first\n        try:\n            channel = await self._client.fetch_channel(channel_id)\n            if channel._guild_id == self.id:\n                return channel\n        except (NotFound, AttributeError):\n            return None\n\n    return None\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.get_thread","title":"<code>get_thread(thread_id)</code>","text":"<p>Returns a Thread with the given <code>thread_id</code>.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>Snowflake_Type</code> <p>The ID of the thread to get</p> required <p>Returns:</p> Type Description <code>Optional[TYPE_THREAD_CHANNEL]</code> <p>Thread object if found, otherwise None</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>def get_thread(self, thread_id: Snowflake_Type) -&gt; Optional[\"models.TYPE_THREAD_CHANNEL\"]:\n\"\"\"\n    Returns a Thread with the given `thread_id`.\n\n    Args:\n        thread_id: The ID of the thread to get\n\n    Returns:\n        Thread object if found, otherwise None\n\n    \"\"\"\n    thread_id = to_snowflake(thread_id)\n    if thread_id in self._thread_ids:\n        return self._client.cache.get_channel(thread_id)\n    return None\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_thread","title":"<code>fetch_thread(thread_id)</code>  <code>async</code>","text":"<p>Returns a Thread with the given <code>thread_id</code> from the API.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>Snowflake_Type</code> <p>The ID of the thread to get</p> required <p>Returns:</p> Type Description <code>Optional[TYPE_THREAD_CHANNEL]</code> <p>Thread object if found, otherwise None</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_thread(self, thread_id: Snowflake_Type) -&gt; Optional[\"models.TYPE_THREAD_CHANNEL\"]:\n\"\"\"\n    Returns a Thread with the given `thread_id` from the API.\n\n    Args:\n        thread_id: The ID of the thread to get\n\n    Returns:\n        Thread object if found, otherwise None\n\n    \"\"\"\n    thread_id = to_snowflake(thread_id)\n    if thread_id in self._thread_ids:\n        try:\n            return await self._client.fetch_channel(thread_id)\n        except NotFound:\n            return None\n    return None\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.prune_members","title":"<code>prune_members(days=7, roles=None, compute_prune_count=True, reason=MISSING)</code>  <code>async</code>","text":"<p>Begin a guild prune. Removes members from the guild who who have not interacted for the last <code>days</code> days. By default, members with roles are excluded from pruning, to include them, pass their role (or role id) in <code>roles</code> Requires <code>kick members</code> permission.</p> <p>Parameters:</p> Name Type Description Default <code>days</code> <code>int</code> <p>number of days to prune (1-30)</p> <code>7</code> <code>roles</code> <code>Optional[List[Snowflake_Type]]</code> <p>list of roles to include in the prune</p> <code>None</code> <code>compute_prune_count</code> <code>bool</code> <p>Whether the number of members pruned should be calculated (disable this for large guilds)</p> <code>True</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for this prune</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>The total number of members pruned, if <code>compute_prune_count</code> is set to True, otherwise None</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def prune_members(\n    self,\n    days: int = 7,\n    roles: Optional[List[Snowflake_Type]] = None,\n    compute_prune_count: bool = True,\n    reason: Absent[str] = MISSING,\n) -&gt; Optional[int]:\n\"\"\"\n    Begin a guild prune. Removes members from the guild who who have not interacted for the last `days` days. By default, members with roles are excluded from pruning, to include them, pass their role (or role id) in `roles` Requires `kick members` permission.\n\n    Args:\n        days: number of days to prune (1-30)\n        roles: list of roles to include in the prune\n        compute_prune_count: Whether the number of members pruned should be calculated (disable this for large guilds)\n        reason: The reason for this prune\n\n    Returns:\n        The total number of members pruned, if `compute_prune_count` is set to True, otherwise None\n\n    \"\"\"\n    if roles:\n        roles = [str(to_snowflake(r)) for r in roles]\n\n    resp = await self._client.http.begin_guild_prune(\n        self.id, days, include_roles=roles, compute_prune_count=compute_prune_count, reason=reason\n    )\n    return resp[\"pruned\"]\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.estimate_prune_members","title":"<code>estimate_prune_members(days=7, roles=MISSING)</code>  <code>async</code>","text":"<p>Calculate how many members would be pruned, should <code>guild.prune_members</code> be used. By default, members with roles are excluded from pruning, to include them, pass their role (or role id) in <code>roles</code>.</p> <p>Parameters:</p> Name Type Description Default <code>days</code> <code>int</code> <p>number of days to prune (1-30)</p> <code>7</code> <code>roles</code> <code>List[Union[Snowflake_Type, Role]]</code> <p>list of roles to include in the prune</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>int</code> <p>Total number of members that would be pruned</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def estimate_prune_members(\n    self, days: int = 7, roles: List[Union[Snowflake_Type, \"models.Role\"]] = MISSING\n) -&gt; int:\n\"\"\"\n    Calculate how many members would be pruned, should `guild.prune_members` be used. By default, members with roles are excluded from pruning, to include them, pass their role (or role id) in `roles`.\n\n    Args:\n        days: number of days to prune (1-30)\n        roles: list of roles to include in the prune\n\n    Returns:\n        Total number of members that would be pruned\n\n    \"\"\"\n    if roles is not MISSING:\n        roles = [r.id if isinstance(r, models.Role) else r for r in roles]\n    else:\n        roles = []\n\n    resp = await self._client.http.get_guild_prune_count(self.id, days=days, include_roles=roles)\n    return resp[\"pruned\"]\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.leave","title":"<code>leave()</code>  <code>async</code>","text":"<p>Leave this guild.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def leave(self) -&gt; None:\n\"\"\"Leave this guild.\"\"\"\n    await self._client.http.leave_guild(self.id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.delete","title":"<code>delete()</code>  <code>async</code>","text":"<p>Delete the guild.</p> <p>Note</p> <p>You must own this guild to do this.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def delete(self) -&gt; None:\n\"\"\"\n    Delete the guild.\n\n    !!! note\n        You must own this guild to do this.\n\n    \"\"\"\n    await self._client.http.delete_guild(self.id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.kick","title":"<code>kick(user, reason=MISSING)</code>  <code>async</code>","text":"<p>Kick a user from the guild.</p> <p>Note</p> <p>You must have the <code>kick members</code> permission</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Union[User, Member, Snowflake_Type]</code> <p>The user to kick</p> required <code>reason</code> <code>Absent[str]</code> <p>The reason for the kick</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def kick(\n    self, user: Union[\"models.User\", \"models.Member\", Snowflake_Type], reason: Absent[str] = MISSING\n) -&gt; None:\n\"\"\"\n    Kick a user from the guild.\n\n    !!! note\n        You must have the `kick members` permission\n\n    Args:\n        user: The user to kick\n        reason: The reason for the kick\n\n    \"\"\"\n    await self._client.http.remove_guild_member(self.id, to_snowflake(user), reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.ban","title":"<code>ban(user, delete_message_days=MISSING, delete_message_seconds=0, reason=MISSING)</code>  <code>async</code>","text":"<p>Ban a user from the guild.</p> <p>Note</p> <p>You must have the <code>ban members</code> permission</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Union[User, Member, Snowflake_Type]</code> <p>The user to ban</p> required <code>delete_message_days</code> <code>Absent[int]</code> <p>(deprecated) How many days worth of messages to remove</p> <code>MISSING</code> <code>delete_message_seconds</code> <code>int</code> <p>How many seconds worth of messages to remove</p> <code>0</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for the ban</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def ban(\n    self,\n    user: Union[\"models.User\", \"models.Member\", Snowflake_Type],\n    delete_message_days: Absent[int] = MISSING,\n    delete_message_seconds: int = 0,\n    reason: Absent[str] = MISSING,\n) -&gt; None:\n\"\"\"\n    Ban a user from the guild.\n\n    !!! note\n        You must have the `ban members` permission\n\n    Args:\n        user: The user to ban\n        delete_message_days: (deprecated) How many days worth of messages to remove\n        delete_message_seconds: How many seconds worth of messages to remove\n        reason: The reason for the ban\n\n    \"\"\"\n    if delete_message_days is not MISSING:\n        warn(\"delete_message_days is deprecated and will be removed in a future update\", DeprecationWarning)\n        delete_message_seconds = delete_message_days * 3600\n    await self._client.http.create_guild_ban(self.id, to_snowflake(user), delete_message_seconds, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_ban","title":"<code>fetch_ban(user)</code>  <code>async</code>","text":"<p>Fetches the ban information for the specified user in the guild. You must have the <code>ban members</code> permission.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Union[User, Member, Snowflake_Type]</code> <p>The user to look up.</p> required <p>Returns:</p> Type Description <code>Optional[GuildBan]</code> <p>The ban information. If the user is not banned, returns None.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_ban(self, user: Union[\"models.User\", \"models.Member\", Snowflake_Type]) -&gt; Optional[GuildBan]:\n\"\"\"\n    Fetches the ban information for the specified user in the guild. You must have the `ban members` permission.\n\n    Args:\n        user: The user to look up.\n\n    Returns:\n        The ban information. If the user is not banned, returns None.\n\n    \"\"\"\n    try:\n        ban_info = await self._client.http.get_guild_ban(self.id, to_snowflake(user))\n    except NotFound:\n        return None\n    return GuildBan(reason=ban_info[\"reason\"], user=self._client.cache.place_user_data(ban_info[\"user\"]))\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_bans","title":"<code>fetch_bans(before=MISSING, after=MISSING, limit=1000)</code>  <code>async</code>","text":"<p>Fetches bans for the guild. You must have the <code>ban members</code> permission.</p> <p>Parameters:</p> Name Type Description Default <code>before</code> <code>Optional[Snowflake_Type]</code> <p>consider only users before given user id</p> <code>MISSING</code> <code>after</code> <code>Optional[Snowflake_Type]</code> <p>consider only users after given user id</p> <code>MISSING</code> <code>limit</code> <code>int</code> <p>number of users to return (up to maximum 1000)</p> <code>1000</code> <p>Returns:</p> Type Description <code>list[GuildBan]</code> <p>A list containing bans and information about them.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_bans(\n    self,\n    before: Optional[\"Snowflake_Type\"] = MISSING,\n    after: Optional[\"Snowflake_Type\"] = MISSING,\n    limit: int = 1000,\n) -&gt; list[GuildBan]:\n\"\"\"\n    Fetches bans for the guild. You must have the `ban members` permission.\n\n    Args:\n        before: consider only users before given user id\n        after: consider only users after given user id\n        limit: number of users to return (up to maximum 1000)\n\n    Returns:\n        A list containing bans and information about them.\n\n    \"\"\"\n    ban_infos = await self._client.http.get_guild_bans(self.id, before=before, after=after, limit=limit)\n    return [\n        GuildBan(reason=ban_info[\"reason\"], user=self._client.cache.place_user_data(ban_info[\"user\"]))\n        for ban_info in ban_infos\n    ]\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.create_auto_moderation_rule","title":"<code>create_auto_moderation_rule(name, *, trigger, actions, exempt_roles=MISSING, exempt_channels=MISSING, enabled=True, event_type=AutoModEvent.MESSAGE_SEND)</code>  <code>async</code>","text":"<p>Create an auto-moderation rule in this guild.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the rule</p> required <code>trigger</code> <code>BaseTrigger</code> <p>The trigger for this rule</p> required <code>actions</code> <code>list[BaseAction]</code> <p>A list of actions to take upon triggering</p> required <code>exempt_roles</code> <code>list[Snowflake_Type]</code> <p>Roles that ignore this rule</p> <code>MISSING</code> <code>exempt_channels</code> <code>list[Snowflake_Type]</code> <p>Channels that ignore this role</p> <code>MISSING</code> <code>enabled</code> <code>bool</code> <p>Is this rule enabled?</p> <code>True</code> <code>event_type</code> <code>AutoModEvent</code> <p>The type of event that triggers this rule</p> <code>AutoModEvent.MESSAGE_SEND</code> <p>Returns:</p> Type Description <code>AutoModRule</code> <p>The created rule</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def create_auto_moderation_rule(\n    self,\n    name: str,\n    *,\n    trigger: BaseTrigger,\n    actions: list[BaseAction],\n    exempt_roles: list[\"Snowflake_Type\"] = MISSING,\n    exempt_channels: list[\"Snowflake_Type\"] = MISSING,\n    enabled: bool = True,\n    event_type: AutoModEvent = AutoModEvent.MESSAGE_SEND,\n) -&gt; AutoModRule:\n\"\"\"\n    Create an auto-moderation rule in this guild.\n\n    Args:\n        name: The name of the rule\n        trigger: The trigger for this rule\n        actions: A list of actions to take upon triggering\n        exempt_roles: Roles that ignore this rule\n        exempt_channels: Channels that ignore this role\n        enabled: Is this rule enabled?\n        event_type: The type of event that triggers this rule\n\n    Returns:\n        The created rule\n    \"\"\"\n    rule = AutoModRule(\n        name=name,\n        enabled=enabled,\n        actions=actions,\n        event_type=event_type,\n        trigger=trigger,\n        exempt_channels=exempt_channels if exempt_roles is not MISSING else [],\n        exempt_roles=exempt_roles if exempt_roles is not MISSING else [],\n        client=self._client,\n    )\n    data = await self._client.http.create_auto_moderation_rule(self.id, rule.to_dict())\n    return AutoModRule.from_dict(data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_auto_moderation_rules","title":"<code>fetch_auto_moderation_rules()</code>  <code>async</code>","text":"<p>Get this guild's auto moderation rules.</p> <p>Returns:</p> Type Description <code>List[AutoModRule]</code> <p>A list of auto moderation rules</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_auto_moderation_rules(self) -&gt; List[AutoModRule]:\n\"\"\"\n    Get this guild's auto moderation rules.\n\n    Returns:\n        A list of auto moderation rules\n    \"\"\"\n    data = await self._client.http.get_auto_moderation_rules(self.id)\n    return [AutoModRule.from_dict(d, self._client) for d in data]\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.delete_auto_moderation_rule","title":"<code>delete_auto_moderation_rule(rule, reason=MISSING)</code>  <code>async</code>","text":"<p>Delete a given auto moderation rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>Snowflake_Type</code> <p>The rule to delete</p> required <code>reason</code> <code>Absent[str]</code> <p>The reason for deleting this rule</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def delete_auto_moderation_rule(self, rule: \"Snowflake_Type\", reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n    Delete a given auto moderation rule.\n\n    Args:\n        rule: The rule to delete\n        reason: The reason for deleting this rule\n    \"\"\"\n    await self._client.http.delete_auto_moderation_rule(self.id, to_snowflake(rule), reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.modify_auto_moderation_rule","title":"<code>modify_auto_moderation_rule(rule, *, name=MISSING, trigger=MISSING, trigger_type=MISSING, trigger_metadata=MISSING, actions=MISSING, exempt_channels=MISSING, exempt_roles=MISSING, event_type=MISSING, enabled=MISSING, reason=MISSING)</code>  <code>async</code>","text":"<p>Modify an existing automod rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>Snowflake_Type</code> <p>The rule to modify</p> required <code>name</code> <code>Absent[str]</code> <p>The name of the rule</p> <code>MISSING</code> <code>trigger</code> <code>Absent[BaseTrigger]</code> <p>A trigger for this rule</p> <code>MISSING</code> <code>trigger_type</code> <code>Absent[AutoModTriggerType]</code> <p>The type trigger for this rule (ignored if trigger specified)</p> <code>MISSING</code> <code>trigger_metadata</code> <code>Absent[dict]</code> <p>Metadata for the trigger (ignored if trigger specified)</p> <code>MISSING</code> <code>actions</code> <code>Absent[list[BaseAction]]</code> <p>A list of actions to take upon triggering</p> <code>MISSING</code> <code>exempt_roles</code> <code>Absent[list[Snowflake_Type]]</code> <p>Roles that ignore this rule</p> <code>MISSING</code> <code>exempt_channels</code> <code>Absent[list[Snowflake_Type]]</code> <p>Channels that ignore this role</p> <code>MISSING</code> <code>enabled</code> <code>Absent[bool]</code> <p>Is this rule enabled?</p> <code>MISSING</code> <code>event_type</code> <code>Absent[AutoModEvent]</code> <p>The type of event that triggers this rule</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for this change</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>AutoModRule</code> <p>The updated rule</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def modify_auto_moderation_rule(\n    self,\n    rule: \"Snowflake_Type\",\n    *,\n    name: Absent[str] = MISSING,\n    trigger: Absent[BaseTrigger] = MISSING,\n    trigger_type: Absent[AutoModTriggerType] = MISSING,\n    trigger_metadata: Absent[dict] = MISSING,\n    actions: Absent[list[BaseAction]] = MISSING,\n    exempt_channels: Absent[list[\"Snowflake_Type\"]] = MISSING,\n    exempt_roles: Absent[list[\"Snowflake_Type\"]] = MISSING,\n    event_type: Absent[AutoModEvent] = MISSING,\n    enabled: Absent[bool] = MISSING,\n    reason: Absent[str] = MISSING,\n) -&gt; AutoModRule:\n\"\"\"\n    Modify an existing automod rule.\n\n    Args:\n        rule: The rule to modify\n        name: The name of the rule\n        trigger: A trigger for this rule\n        trigger_type: The type trigger for this rule (ignored if trigger specified)\n        trigger_metadata: Metadata for the trigger (ignored if trigger specified)\n        actions: A list of actions to take upon triggering\n        exempt_roles: Roles that ignore this rule\n        exempt_channels: Channels that ignore this role\n        enabled: Is this rule enabled?\n        event_type: The type of event that triggers this rule\n        reason: The reason for this change\n\n    Returns:\n        The updated rule\n    \"\"\"\n    if trigger:\n        _data = trigger.to_dict()\n        trigger_type = _data[\"trigger_type\"]\n        trigger_metadata = _data.get(\"trigger_metadata\", {})\n\n    out = await self._client.http.modify_auto_moderation_rule(\n        self.id,\n        to_snowflake(rule),\n        name=name,\n        trigger_type=trigger_type,\n        trigger_metadata=trigger_metadata,\n        actions=actions,\n        exempt_roles=to_snowflake_list(exempt_roles) if exempt_roles is not MISSING else MISSING,\n        exempt_channels=to_snowflake_list(exempt_channels) if exempt_channels is not MISSING else MISSING,\n        event_type=event_type,\n        enabled=enabled,\n        reason=reason,\n    )\n    return AutoModRule.from_dict(out, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.unban","title":"<code>unban(user, reason=MISSING)</code>  <code>async</code>","text":"<p>Unban a user from the guild.</p> <p>Note</p> <p>You must have the <code>ban members</code> permission</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Union[User, Member, Snowflake_Type]</code> <p>The user to unban</p> required <code>reason</code> <code>Absent[str]</code> <p>The reason for the ban</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def unban(\n    self, user: Union[\"models.User\", \"models.Member\", Snowflake_Type], reason: Absent[str] = MISSING\n) -&gt; None:\n\"\"\"\n    Unban a user from the guild.\n\n    !!! note\n        You must have the `ban members` permission\n\n    Args:\n        user: The user to unban\n        reason: The reason for the ban\n\n    \"\"\"\n    await self._client.http.remove_guild_ban(self.id, to_snowflake(user), reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_widget_image","title":"<code>fetch_widget_image(style=None)</code>  <code>async</code>","text":"<p>Fetch a guilds widget image.</p> <p>For a list of styles, look here: https://discord.com/developers/docs/resources/guild#get-guild-widget-image-widget-style-options</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>str</code> <p>The style to use for the widget image</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The URL of the widget image.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_widget_image(self, style: str = None) -&gt; str:\n\"\"\"\n    Fetch a guilds widget image.\n\n    For a list of styles, look here: https://discord.com/developers/docs/resources/guild#get-guild-widget-image-widget-style-options\n\n    Args:\n        style: The style to use for the widget image\n\n    Returns:\n        The URL of the widget image.\n\n    \"\"\"\n    return await self._client.http.get_guild_widget_image(self.id, style)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_widget_settings","title":"<code>fetch_widget_settings()</code>  <code>async</code>","text":"<p>Fetches the guilds widget settings.</p> <p>Returns:</p> Type Description <code>GuildWidgetSettings</code> <p>The guilds widget settings object.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_widget_settings(self) -&gt; \"GuildWidgetSettings\":\n\"\"\"\n    Fetches the guilds widget settings.\n\n    Returns:\n        The guilds widget settings object.\n\n    \"\"\"\n    return await GuildWidgetSettings.from_dict(await self._client.http.get_guild_widget_settings(self.id))\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_widget","title":"<code>fetch_widget()</code>  <code>async</code>","text":"<p>Fetches the guilds widget.</p> <p>Returns:</p> Type Description <code>GuildWidget</code> <p>The guilds widget object.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_widget(self) -&gt; \"GuildWidget\":\n\"\"\"\n    Fetches the guilds widget.\n\n    Returns:\n        The guilds widget object.\n\n    \"\"\"\n    return GuildWidget.from_dict(await self._client.http.get_guild_widget(self.id), self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.modify_widget","title":"<code>modify_widget(enabled=MISSING, channel=MISSING, settings=MISSING)</code>  <code>async</code>","text":"<p>Modify the guild's widget.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>Absent[bool]</code> <p>Should the widget be enabled?</p> <code>MISSING</code> <code>channel</code> <code>Absent[Union[TYPE_GUILD_CHANNEL, Snowflake_Type]]</code> <p>The channel to use in the widget</p> <code>MISSING</code> <code>settings</code> <code>Absent[GuildWidgetSettings]</code> <p>The settings to use for the widget</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildWidget</code> <p>The updated guilds widget object.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def modify_widget(\n    self,\n    enabled: Absent[bool] = MISSING,\n    channel: Absent[Union[\"models.TYPE_GUILD_CHANNEL\", Snowflake_Type]] = MISSING,\n    settings: Absent[\"GuildWidgetSettings\"] = MISSING,\n) -&gt; \"GuildWidget\":\n\"\"\"\n    Modify the guild's widget.\n\n    Args:\n        enabled: Should the widget be enabled?\n        channel: The channel to use in the widget\n        settings: The settings to use for the widget\n\n    Returns:\n        The updated guilds widget object.\n\n    \"\"\"\n    if isinstance(settings, GuildWidgetSettings):\n        enabled = settings.enabled\n        channel = settings.channel_id\n\n    channel = to_optional_snowflake(channel)\n    return GuildWidget.from_dict(\n        await self._client.http.modify_guild_widget(self.id, enabled, channel), self._client\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_invites","title":"<code>fetch_invites()</code>  <code>async</code>","text":"<p>Fetches all invites for the guild.</p> <p>Returns:</p> Type Description <code>List[Invite]</code> <p>A list of invites for the guild.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_invites(self) -&gt; List[\"models.Invite\"]:\n\"\"\"\n    Fetches all invites for the guild.\n\n    Returns:\n        A list of invites for the guild.\n\n    \"\"\"\n    invites_data = await self._client.http.get_guild_invites(self.id)\n    return models.Invite.from_list(invites_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_guild_integrations","title":"<code>fetch_guild_integrations()</code>  <code>async</code>","text":"<p>Fetches all integrations for the guild.</p> <p>Returns:</p> Type Description <code>List[GuildIntegration]</code> <p>A list of integrations for the guild.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_guild_integrations(self) -&gt; List[\"models.GuildIntegration\"]:\n\"\"\"\n    Fetches all integrations for the guild.\n\n    Returns:\n        A list of integrations for the guild.\n\n    \"\"\"\n    data = await self._client.http.get_guild_integrations(self.id)\n    return [GuildIntegration.from_dict(d | {\"guild_id\": self.id}, self._client) for d in data]\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.search_members","title":"<code>search_members(query, limit=1)</code>  <code>async</code>","text":"<p>Search for members in the guild whose username or nickname starts with a provided string.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Query string to match username(s) and nickname(s) against.</p> required <code>limit</code> <code>int</code> <p>Max number of members to return (1-1000)</p> <code>1</code> <p>Returns:</p> Type Description <code>List[Member]</code> <p>A list of members matching the query.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def search_members(self, query: str, limit: int = 1) -&gt; List[\"models.Member\"]:\n\"\"\"\n    Search for members in the guild whose username or nickname starts with a provided string.\n\n    Args:\n        query: Query string to match username(s) and nickname(s) against.\n        limit: Max number of members to return (1-1000)\n\n    Returns:\n        A list of members matching the query.\n\n    \"\"\"\n    data = await self._client.http.search_guild_members(guild_id=self.id, query=query, limit=limit)\n    return [self._client.cache.place_member_data(self.id, _d) for _d in data]\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.fetch_voice_regions","title":"<code>fetch_voice_regions()</code>  <code>async</code>","text":"<p>Fetches the voice regions for the guild.</p> <p>Unlike the <code>NAFF.fetch_voice_regions</code> method, this will returns VIP servers when the guild is VIP-enabled.</p> <p>Returns:</p> Type Description <code>List[VoiceRegion]</code> <p>A list of voice regions.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_voice_regions(self) -&gt; List[\"models.VoiceRegion\"]:\n\"\"\"\n    Fetches the voice regions for the guild.\n\n    Unlike the `NAFF.fetch_voice_regions` method, this will returns VIP servers when the guild is VIP-enabled.\n\n    Returns:\n        A list of voice regions.\n\n    \"\"\"\n    regions_data = await self._client.http.get_guild_voice_regions(self.id)\n    regions = models.VoiceRegion.from_list(regions_data)\n    return regions\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.gui_sorted_channels","title":"<code>gui_sorted_channels: list[models.TYPE_GUILD_CHANNEL]</code>  <code>property</code>","text":"<p>Return this guilds channels sorted by their gui positions</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.Guild.get_channel_gui_position","title":"<code>get_channel_gui_position(channel_id)</code>","text":"<p>Get a given channels gui position.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The ID of the channel to get the gui position for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The gui position of the channel.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>def get_channel_gui_position(self, channel_id: \"Snowflake_Type\") -&gt; int:\n\"\"\"\n    Get a given channels gui position.\n\n    Args:\n        channel_id: The ID of the channel to get the gui position for.\n\n    Returns:\n        The gui position of the channel.\n    \"\"\"\n    if not self._channel_gui_positions:\n        self._calculate_gui_channel_positions()\n    return self._channel_gui_positions.get(to_snowflake(channel_id), 0)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildTemplate","title":"<code>GuildTemplate</code>","text":"<p>         Bases: <code>ClientObject</code></p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass GuildTemplate(ClientObject):\n    code: str = attrs.field(repr=True, metadata=docs(\"the template code (unique ID)\"))\n    name: str = attrs.field(repr=True, metadata=docs(\"the name\"))\n    description: Optional[str] = attrs.field(repr=False, default=None, metadata=docs(\"the description\"))\n\n    usage_count: int = attrs.field(repr=False, default=0, metadata=docs(\"number of times this template has been used\"))\n\n    creator_id: Snowflake_Type = attrs.field(repr=False, metadata=docs(\"The ID of the user who created this template\"))\n    creator: Optional[\"models.User\"] = attrs.field(\n        repr=False, default=None, metadata=docs(\"the user who created this template\")\n    )\n\n    created_at: \"models.Timestamp\" = attrs.field(repr=False, metadata=docs(\"When this template was created\"))\n    updated_at: \"models.Timestamp\" = attrs.field(\n        repr=False, metadata=docs(\"When this template was last synced to the source guild\")\n    )\n\n    source_guild_id: Snowflake_Type = attrs.field(\n        repr=False, metadata=docs(\"The ID of the guild this template is based on\")\n    )\n    guild_snapshot: \"models.Guild\" = attrs.field(\n        repr=False, metadata=docs(\"A snapshot of the guild this template contains\")\n    )\n\n    is_dirty: bool = attrs.field(\n        repr=False, default=False, metadata=docs(\"Whether this template has un-synced changes\")\n    )\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        data[\"creator\"] = client.cache.place_user_data(data[\"creator\"])\n\n        # todo: partial guild obj that **isn't** cached\n        data[\"guild_snapshot\"] = data.pop(\"serialized_source_guild\")\n        return data\n\n    async def synchronise(self) -&gt; \"models.GuildTemplate\":\n\"\"\"Synchronise the template to the source guild's current state.\"\"\"\n        data = await self._client.http.sync_guild_template(self.source_guild_id, self.code)\n        self.update_from_dict(data)\n        return self\n\n    async def modify(self, name: Absent[str] = MISSING, description: Absent[str] = MISSING) -&gt; \"models.GuildTemplate\":\n\"\"\"\n        Modify the template's metadata.\n\n        Args:\n            name: The name for the template\n            description: The description for the template\n\n        Returns:\n            The modified template object.\n\n        \"\"\"\n        data = await self._client.http.modify_guild_template(\n            self.source_guild_id, self.code, name=name, description=description\n        )\n        self.update_from_dict(data)\n        return self\n\n    async def delete(self) -&gt; None:\n\"\"\"Delete the guild template.\"\"\"\n        await self._client.http.delete_guild_template(self.source_guild_id, self.code)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildTemplate.synchronise","title":"<code>synchronise()</code>  <code>async</code>","text":"<p>Synchronise the template to the source guild's current state.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def synchronise(self) -&gt; \"models.GuildTemplate\":\n\"\"\"Synchronise the template to the source guild's current state.\"\"\"\n    data = await self._client.http.sync_guild_template(self.source_guild_id, self.code)\n    self.update_from_dict(data)\n    return self\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildTemplate.modify","title":"<code>modify(name=MISSING, description=MISSING)</code>  <code>async</code>","text":"<p>Modify the template's metadata.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[str]</code> <p>The name for the template</p> <code>MISSING</code> <code>description</code> <code>Absent[str]</code> <p>The description for the template</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>GuildTemplate</code> <p>The modified template object.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def modify(self, name: Absent[str] = MISSING, description: Absent[str] = MISSING) -&gt; \"models.GuildTemplate\":\n\"\"\"\n    Modify the template's metadata.\n\n    Args:\n        name: The name for the template\n        description: The description for the template\n\n    Returns:\n        The modified template object.\n\n    \"\"\"\n    data = await self._client.http.modify_guild_template(\n        self.source_guild_id, self.code, name=name, description=description\n    )\n    self.update_from_dict(data)\n    return self\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildTemplate.delete","title":"<code>delete()</code>  <code>async</code>","text":"<p>Delete the guild template.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def delete(self) -&gt; None:\n\"\"\"Delete the guild template.\"\"\"\n    await self._client.http.delete_guild_template(self.source_guild_id, self.code)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration","title":"<code>GuildIntegration</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>class GuildIntegration(DiscordObject):\n    name: str = attrs.field(repr=True)\n\"\"\"The name of the integration\"\"\"\n    type: str = attrs.field(repr=True)\n\"\"\"integration type (twitch, youtube, or discord)\"\"\"\n    enabled: bool = attrs.field(repr=True)\n\"\"\"is this integration enabled\"\"\"\n    account: dict = attrs.field(\n        repr=False,\n    )\n\"\"\"integration account information\"\"\"\n    application: Optional[\"models.Application\"] = attrs.field(repr=False, default=None)\n\"\"\"The bot/OAuth2 application for discord integrations\"\"\"\n    _guild_id: Snowflake_Type = attrs.field(\n        repr=False,\n    )\n\n    syncing: Optional[bool] = attrs.field(repr=False, default=MISSING)\n\"\"\"is this integration syncing\"\"\"\n    role_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=MISSING)\n\"\"\"id that this integration uses for \"subscribers\\\"\"\"\"\n    enable_emoticons: bool = attrs.field(repr=False, default=MISSING)\n\"\"\"whether emoticons should be synced for this integration (twitch only currently)\"\"\"\n    expire_behavior: IntegrationExpireBehaviour = attrs.field(\n        repr=False, default=MISSING, converter=optional(IntegrationExpireBehaviour)\n    )\n\"\"\"the behavior of expiring subscribers\"\"\"\n    expire_grace_period: int = attrs.field(repr=False, default=MISSING)\n\"\"\"the grace period (in days) before expiring subscribers\"\"\"\n    user: \"models.BaseUser\" = attrs.field(repr=False, default=MISSING)\n\"\"\"user for this integration\"\"\"\n    synced_at: \"models.Timestamp\" = attrs.field(repr=False, default=MISSING, converter=optional(timestamp_converter))\n\"\"\"when this integration was last synced\"\"\"\n    subscriber_count: int = attrs.field(repr=False, default=MISSING)\n\"\"\"how many subscribers this integration has\"\"\"\n    revoked: bool = attrs.field(repr=False, default=MISSING)\n\"\"\"has this integration been revoked\"\"\"\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        if app := data.get(\"application\", None):\n            data[\"application\"] = models.Application.from_dict(app, client)\n        if user := data.get(\"user\", None):\n            data[\"user\"] = client.cache.place_user_data(user)\n\n        return data\n\n    async def delete(self, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"Delete this guild integration.\"\"\"\n        await self._client.http.delete_guild_integration(self._guild_id, self.id, reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration.name","title":"<code>name: str = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>The name of the integration</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration.type","title":"<code>type: str = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>integration type (twitch, youtube, or discord)</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration.enabled","title":"<code>enabled: bool = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>is this integration enabled</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration.account","title":"<code>account: dict = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>integration account information</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration.application","title":"<code>application: Optional[models.Application] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The bot/OAuth2 application for discord integrations</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration.syncing","title":"<code>syncing: Optional[bool] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>is this integration syncing</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration.role_id","title":"<code>role_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>id that this integration uses for \"subscribers\"</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration.enable_emoticons","title":"<code>enable_emoticons: bool = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>whether emoticons should be synced for this integration (twitch only currently)</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration.expire_behavior","title":"<code>expire_behavior: IntegrationExpireBehaviour = attrs.field(repr=False, default=MISSING, converter=optional(IntegrationExpireBehaviour))</code>  <code>class-attribute</code>","text":"<p>the behavior of expiring subscribers</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration.expire_grace_period","title":"<code>expire_grace_period: int = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>the grace period (in days) before expiring subscribers</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration.user","title":"<code>user: models.BaseUser = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>user for this integration</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration.synced_at","title":"<code>synced_at: models.Timestamp = attrs.field(repr=False, default=MISSING, converter=optional(timestamp_converter))</code>  <code>class-attribute</code>","text":"<p>when this integration was last synced</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration.subscriber_count","title":"<code>subscriber_count: int = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>how many subscribers this integration has</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration.revoked","title":"<code>revoked: bool = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>has this integration been revoked</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildIntegration.delete","title":"<code>delete(reason=MISSING)</code>  <code>async</code>","text":"<p>Delete this guild integration.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def delete(self, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"Delete this guild integration.\"\"\"\n    await self._client.http.delete_guild_integration(self._guild_id, self.id, reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildWidgetSettings","title":"<code>GuildWidgetSettings</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>class GuildWidgetSettings(DictSerializationMixin):\n    enabled: bool = attrs.field(repr=True, default=False)\n\"\"\"Whether the widget is enabled.\"\"\"\n    channel_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=True, default=None, converter=to_optional_snowflake)\n\"\"\"The widget channel id. None if widget is not enabled.\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildWidgetSettings.enabled","title":"<code>enabled: bool = attrs.field(repr=True, default=False)</code>  <code>class-attribute</code>","text":"<p>Whether the widget is enabled.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildWidgetSettings.channel_id","title":"<code>channel_id: Optional[Snowflake_Type] = attrs.field(repr=True, default=None, converter=to_optional_snowflake)</code>  <code>class-attribute</code>","text":"<p>The widget channel id. None if widget is not enabled.</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildWidget","title":"<code>GuildWidget</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>class GuildWidget(DiscordObject):\n    name: str = attrs.field(repr=True)\n\"\"\"Guild name (2-100 characters)\"\"\"\n    instant_invite: str = attrs.field(repr=True, default=None)\n\"\"\"Instant invite for the guilds specified widget invite channel\"\"\"\n    presence_count: int = attrs.field(repr=True, default=0)\n\"\"\"Number of online members in this guild\"\"\"\n\n    _channel_ids: List[\"Snowflake_Type\"] = attrs.field(repr=False, default=[])\n\"\"\"Voice and stage channels which are accessible by @everyone\"\"\"\n    _member_ids: List[\"Snowflake_Type\"] = attrs.field(repr=False, default=[])\n\"\"\"Special widget user objects that includes users presence (Limit 100)\"\"\"\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        if channels := data.get(\"channels\"):\n            data[\"channel_ids\"] = [channel[\"id\"] for channel in channels]\n        if members := data.get(\"members\"):\n            data[\"member_ids\"] = [member[\"id\"] for member in members]\n        return data\n\n    def get_channels(self) -&gt; List[\"models.TYPE_VOICE_CHANNEL\"]:\n\"\"\"\n        Gets voice and stage channels which are accessible by @everyone\n\n        Returns:\n            List of channels\n\n        \"\"\"\n        return [self._client.get_channel(channel_id) for channel_id in self._channel_ids]\n\n    async def fetch_channels(self) -&gt; List[\"models.TYPE_VOICE_CHANNEL\"]:\n\"\"\"\n        Gets voice and stage channels which are accessible by @everyone. Fetches the channels from API if they are not cached.\n\n        Returns:\n            List of channels\n\n        \"\"\"\n        return [await self._client.fetch_channel(channel_id) for channel_id in self._channel_ids]\n\n    def get_members(self) -&gt; List[\"models.User\"]:\n\"\"\"\n        Gets special widget user objects that includes users presence (Limit 100)\n\n        Returns:\n            List of users\n\n        \"\"\"\n        return [self._client.get_user(member_id) for member_id in self._member_ids]\n\n    async def fetch_members(self) -&gt; List[\"models.User\"]:\n\"\"\"\n        Gets special widget user objects that includes users presence (Limit 100). Fetches the users from API if they are not cached.\n\n        Returns:\n            List of users\n\n        \"\"\"\n        return [await self._client.fetch_user(member_id) for member_id in self._member_ids]\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildWidget.name","title":"<code>name: str = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>Guild name (2-100 characters)</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildWidget.instant_invite","title":"<code>instant_invite: str = attrs.field(repr=True, default=None)</code>  <code>class-attribute</code>","text":"<p>Instant invite for the guilds specified widget invite channel</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildWidget.presence_count","title":"<code>presence_count: int = attrs.field(repr=True, default=0)</code>  <code>class-attribute</code>","text":"<p>Number of online members in this guild</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildWidget.get_channels","title":"<code>get_channels()</code>","text":"<p>Gets voice and stage channels which are accessible by @everyone</p> <p>Returns:</p> Type Description <code>List[TYPE_VOICE_CHANNEL]</code> <p>List of channels</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>def get_channels(self) -&gt; List[\"models.TYPE_VOICE_CHANNEL\"]:\n\"\"\"\n    Gets voice and stage channels which are accessible by @everyone\n\n    Returns:\n        List of channels\n\n    \"\"\"\n    return [self._client.get_channel(channel_id) for channel_id in self._channel_ids]\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildWidget.fetch_channels","title":"<code>fetch_channels()</code>  <code>async</code>","text":"<p>Gets voice and stage channels which are accessible by @everyone. Fetches the channels from API if they are not cached.</p> <p>Returns:</p> Type Description <code>List[TYPE_VOICE_CHANNEL]</code> <p>List of channels</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_channels(self) -&gt; List[\"models.TYPE_VOICE_CHANNEL\"]:\n\"\"\"\n    Gets voice and stage channels which are accessible by @everyone. Fetches the channels from API if they are not cached.\n\n    Returns:\n        List of channels\n\n    \"\"\"\n    return [await self._client.fetch_channel(channel_id) for channel_id in self._channel_ids]\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildWidget.get_members","title":"<code>get_members()</code>","text":"<p>Gets special widget user objects that includes users presence (Limit 100)</p> <p>Returns:</p> Type Description <code>List[User]</code> <p>List of users</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>def get_members(self) -&gt; List[\"models.User\"]:\n\"\"\"\n    Gets special widget user objects that includes users presence (Limit 100)\n\n    Returns:\n        List of users\n\n    \"\"\"\n    return [self._client.get_user(member_id) for member_id in self._member_ids]\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.GuildWidget.fetch_members","title":"<code>fetch_members()</code>  <code>async</code>","text":"<p>Gets special widget user objects that includes users presence (Limit 100). Fetches the users from API if they are not cached.</p> <p>Returns:</p> Type Description <code>List[User]</code> <p>List of users</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch_members(self) -&gt; List[\"models.User\"]:\n\"\"\"\n    Gets special widget user objects that includes users presence (Limit 100). Fetches the users from API if they are not cached.\n\n    Returns:\n        List of users\n\n    \"\"\"\n    return [await self._client.fetch_user(member_id) for member_id in self._member_ids]\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLogChange","title":"<code>AuditLogChange</code>","text":"<p>         Bases: <code>ClientObject</code></p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass AuditLogChange(ClientObject):\n    key: str = attrs.field(repr=True)\n\"\"\"name of audit log change key\"\"\"\n    new_value: Optional[Union[list, str, int, bool, \"Snowflake_Type\"]] = attrs.field(repr=False, default=MISSING)\n\"\"\"new value of the key\"\"\"\n    old_value: Optional[Union[list, str, int, bool, \"Snowflake_Type\"]] = attrs.field(repr=False, default=MISSING)\n\"\"\"old value of the key\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLogChange.key","title":"<code>key: str = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>name of audit log change key</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLogChange.new_value","title":"<code>new_value: Optional[Union[list, str, int, bool, Snowflake_Type]] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>new value of the key</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLogChange.old_value","title":"<code>old_value: Optional[Union[list, str, int, bool, Snowflake_Type]] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>old value of the key</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLogEntry","title":"<code>AuditLogEntry</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass AuditLogEntry(DiscordObject):\n    target_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, converter=optional(to_snowflake))\n\"\"\"id of the affected entity (webhook, user, role, etc.)\"\"\"\n    user_id: \"Snowflake_Type\" = attrs.field(repr=False, converter=optional(to_snowflake))\n\"\"\"the user who made the changes\"\"\"\n    action_type: \"AuditLogEventType\" = attrs.field(repr=False, converter=AuditLogEventType)\n\"\"\"type of action that occurred\"\"\"\n    changes: Optional[List[AuditLogChange]] = attrs.field(repr=False, default=MISSING)\n\"\"\"changes made to the target_id\"\"\"\n    options: Optional[Union[\"Snowflake_Type\", str]] = attrs.field(repr=False, default=MISSING)\n\"\"\"additional info for certain action types\"\"\"\n    reason: Optional[str] = attrs.field(repr=False, default=MISSING)\n\"\"\"the reason for the change (0-512 characters)\"\"\"\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        if changes := data.get(\"changes\", None):\n            data[\"changes\"] = AuditLogChange.from_list(changes, client)\n\n        return data\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLogEntry.target_id","title":"<code>target_id: Optional[Snowflake_Type] = attrs.field(repr=False, converter=optional(to_snowflake))</code>  <code>class-attribute</code>","text":"<p>id of the affected entity (webhook, user, role, etc.)</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLogEntry.user_id","title":"<code>user_id: Snowflake_Type = attrs.field(repr=False, converter=optional(to_snowflake))</code>  <code>class-attribute</code>","text":"<p>the user who made the changes</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLogEntry.action_type","title":"<code>action_type: AuditLogEventType = attrs.field(repr=False, converter=AuditLogEventType)</code>  <code>class-attribute</code>","text":"<p>type of action that occurred</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLogEntry.changes","title":"<code>changes: Optional[List[AuditLogChange]] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>changes made to the target_id</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLogEntry.options","title":"<code>options: Optional[Union[Snowflake_Type, str]] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>additional info for certain action types</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLogEntry.reason","title":"<code>reason: Optional[str] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>the reason for the change (0-512 characters)</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLog","title":"<code>AuditLog</code>","text":"<p>         Bases: <code>ClientObject</code></p> <p>Contains entries and other data given from selected</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass AuditLog(ClientObject):\n\"\"\"Contains entries and other data given from selected\"\"\"\n\n    application_commands: list[\"InteractionCommand\"] = attrs.field(\n        repr=False, factory=list, converter=optional(deserialize_app_cmds)\n    )\n\"\"\"list of application commands that have had their permissions updated\"\"\"\n    entries: Optional[List[\"AuditLogEntry\"]] = attrs.field(repr=False, default=MISSING)\n\"\"\"list of audit log entries\"\"\"\n    scheduled_events: Optional[List[\"models.ScheduledEvent\"]] = attrs.field(repr=False, default=MISSING)\n\"\"\"list of guild scheduled events found in the audit log\"\"\"\n    integrations: Optional[List[\"GuildIntegration\"]] = attrs.field(repr=False, default=MISSING)\n\"\"\"list of partial integration objects\"\"\"\n    threads: Optional[List[\"models.ThreadChannel\"]] = attrs.field(repr=False, default=MISSING)\n\"\"\"list of threads found in the audit log\"\"\"\n    users: Optional[List[\"models.User\"]] = attrs.field(repr=False, default=MISSING)\n\"\"\"list of users found in the audit log\"\"\"\n    webhooks: Optional[List[\"models.Webhook\"]] = attrs.field(repr=False, default=MISSING)\n\"\"\"list of webhooks found in the audit log\"\"\"\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        if entries := data.get(\"audit_log_entries\", None):\n            data[\"entries\"] = AuditLogEntry.from_list(entries, client)\n        if scheduled_events := data.get(\"guild_scheduled_events\", None):\n            data[\"scheduled_events\"] = models.ScheduledEvent.from_list(scheduled_events, client)\n        if integrations := data.get(\"integrations\", None):\n            data[\"integrations\"] = GuildIntegration.from_list(integrations, client)\n        if threads := data.get(\"threads\", None):\n            data[\"threads\"] = models.ThreadChannel.from_list(threads, client)\n        if users := data.get(\"users\", None):\n            data[\"users\"] = models.User.from_list(users, client)\n        if webhooks := data.get(\"webhooks\", None):\n            data[\"webhooks\"] = models.Webhook.from_list(webhooks, client)\n\n        return data\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLog.application_commands","title":"<code>application_commands: list[InteractionCommand] = attrs.field(repr=False, factory=list, converter=optional(deserialize_app_cmds))</code>  <code>class-attribute</code>","text":"<p>list of application commands that have had their permissions updated</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLog.entries","title":"<code>entries: Optional[List[AuditLogEntry]] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>list of audit log entries</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLog.scheduled_events","title":"<code>scheduled_events: Optional[List[models.ScheduledEvent]] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>list of guild scheduled events found in the audit log</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLog.integrations","title":"<code>integrations: Optional[List[GuildIntegration]] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>list of partial integration objects</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLog.threads","title":"<code>threads: Optional[List[models.ThreadChannel]] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>list of threads found in the audit log</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLog.users","title":"<code>users: Optional[List[models.User]] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>list of users found in the audit log</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLog.webhooks","title":"<code>webhooks: Optional[List[models.Webhook]] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>list of webhooks found in the audit log</p>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLogHistory","title":"<code>AuditLogHistory</code>","text":"<p>         Bases: <code>AsyncIterator</code></p> <p>An async iterator for searching through a audit log's entry history.</p> <p>Attributes:</p> Name Type Description <code>guild</code> <code>user_id</code> <code>action_type</code> <code>before</code> <code>Snowflake_Type</code> <p>get messages before this message ID</p> <code>after</code> <code>Snowflake_Type</code> <p>get messages after this message ID</p> <code>limit</code> <code>Snowflake_Type</code> <p>The maximum number of entries to return (set to 0 for no limit)</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>class AuditLogHistory(AsyncIterator):\n\"\"\"\n    An async iterator for searching through a audit log's entry history.\n\n    Attributes:\n        guild (:class:`Guild`): The guild to search through.\n        user_id (:class:`Snowflake_Type`): The user ID to search for.\n        action_type (:class:`AuditLogEventType`): The action type to search for.\n        before: get messages before this message ID\n        after: get messages after this message ID\n        limit: The maximum number of entries to return (set to 0 for no limit)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        guild: \"Guild\",\n        user_id: Snowflake_Type = None,\n        action_type: \"AuditLogEventType\" = None,\n        before: Snowflake_Type = None,\n        after: Snowflake_Type = None,\n        limit: int = 50,\n    ) -&gt; None:\n        self.guild: \"Guild\" = guild\n        self.user_id: Snowflake_Type = user_id\n        self.action_type: \"AuditLogEventType\" = action_type\n        self.before: Snowflake_Type = before\n        self.after: Snowflake_Type = after\n        super().__init__(limit)\n\n    async def fetch(self) -&gt; List[\"AuditLog\"]:\n\"\"\"\n        Retrieves the audit log entries from discord API.\n\n        Returns:\n            The list of audit log entries.\n\n        \"\"\"\n        if self.after:\n            if not self.last:\n                self.last = namedtuple(\"temp\", \"id\")\n                self.last.id = self.after\n            log = await self.guild.fetch_audit_log(limit=self.get_limit, after=self.last.id)\n            entries = log.entries if log.entries else []\n\n        else:\n            if self.before and not self.last:\n                self.last = namedtuple(\"temp\", \"id\")\n                self.last.id = self.before\n\n            log = await self.guild.fetch_audit_log(limit=self.get_limit, before=self.last.id)\n            entries = log.entries if log.entries else []\n        return entries\n</code></pre>"},{"location":"API%20Reference/models/Discord/guild/#naff.models.discord.guild.AuditLogHistory.fetch","title":"<code>fetch()</code>  <code>async</code>","text":"<p>Retrieves the audit log entries from discord API.</p> <p>Returns:</p> Type Description <code>List[AuditLog]</code> <p>The list of audit log entries.</p> Source code in <code>naff\\models\\discord\\guild.py</code> <pre><code>async def fetch(self) -&gt; List[\"AuditLog\"]:\n\"\"\"\n    Retrieves the audit log entries from discord API.\n\n    Returns:\n        The list of audit log entries.\n\n    \"\"\"\n    if self.after:\n        if not self.last:\n            self.last = namedtuple(\"temp\", \"id\")\n            self.last.id = self.after\n        log = await self.guild.fetch_audit_log(limit=self.get_limit, after=self.last.id)\n        entries = log.entries if log.entries else []\n\n    else:\n        if self.before and not self.last:\n            self.last = namedtuple(\"temp\", \"id\")\n            self.last.id = self.before\n\n        log = await self.guild.fetch_audit_log(limit=self.get_limit, before=self.last.id)\n        entries = log.entries if log.entries else []\n    return entries\n</code></pre>"},{"location":"API%20Reference/models/Discord/invite/","title":"Invite","text":""},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite","title":"<code>Invite</code>","text":"<p>         Bases: <code>ClientObject</code></p> Source code in <code>naff\\models\\discord\\invite.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass Invite(ClientObject):\n    code: str = attrs.field(repr=True)\n\"\"\"the invite code (unique ID)\"\"\"\n\n    # metadata\n    uses: int = attrs.field(default=0, repr=True)\n\"\"\"the guild this invite is for\"\"\"\n    max_uses: int = attrs.field(repr=False, default=0)\n\"\"\"max number of times this invite can be used\"\"\"\n    max_age: int = attrs.field(repr=False, default=0)\n\"\"\"duration (in seconds) after which the invite expires\"\"\"\n    created_at: Timestamp = attrs.field(default=MISSING, converter=optional_c(timestamp_converter), repr=True)\n\"\"\"when this invite was created\"\"\"\n    temporary: bool = attrs.field(default=False, repr=True)\n\"\"\"whether this invite only grants temporary membership\"\"\"\n\n    # target data\n    target_type: Optional[Union[InviteTargetTypes, int]] = attrs.field(\n        default=None, converter=optional_c(InviteTargetTypes), repr=True\n    )\n\"\"\"the type of target for this voice channel invite\"\"\"\n    approximate_presence_count: Optional[int] = attrs.field(repr=False, default=MISSING)\n\"\"\"approximate count of online members, returned from the `GET /invites/&lt;code&gt;` endpoint when `with_counts` is `True`\"\"\"\n    approximate_member_count: Optional[int] = attrs.field(repr=False, default=MISSING)\n\"\"\"approximate count of total members, returned from the `GET /invites/&lt;code&gt;` endpoint when `with_counts` is `True`\"\"\"\n    scheduled_event: Optional[\"Snowflake_Type\"] = attrs.field(\n        default=None, converter=optional_c(to_snowflake), repr=True\n    )\n\"\"\"guild scheduled event data, only included if `guild_scheduled_event_id` contains a valid guild scheduled event id\"\"\"\n    expires_at: Optional[Timestamp] = attrs.field(default=None, converter=optional_c(timestamp_converter), repr=True)\n\"\"\"the expiration date of this invite, returned from the `GET /invites/&lt;code&gt;` endpoint when `with_expiration` is `True`\"\"\"\n    stage_instance: Optional[StageInstance] = attrs.field(repr=False, default=None)\n\"\"\"stage instance data if there is a public Stage instance in the Stage channel this invite is for (deprecated)\"\"\"\n    target_application: Optional[dict] = attrs.field(repr=False, default=None)\n\"\"\"the embedded application to open for this voice channel embedded application invite\"\"\"\n    guild_preview: Optional[GuildPreview] = attrs.field(repr=False, default=MISSING)\n\"\"\"the guild this invite is for\"\"\"\n\n    # internal for props\n    _channel_id: \"Snowflake_Type\" = attrs.field(converter=to_snowflake, repr=True)\n    _inviter_id: Optional[\"Snowflake_Type\"] = attrs.field(default=None, converter=optional_c(to_snowflake), repr=True)\n    _target_user_id: Optional[\"Snowflake_Type\"] = attrs.field(\n        repr=False, default=None, converter=optional_c(to_snowflake)\n    )\n\n    @property\n    def channel(self) -&gt; \"TYPE_GUILD_CHANNEL\":\n\"\"\"The channel the invite is for.\"\"\"\n        return self._client.cache.get_channel(self._channel_id)\n\n    @property\n    def inviter(self) -&gt; Optional[\"User\"]:\n\"\"\"The user that created the invite or None.\"\"\"\n        return self._client.cache.get_user(self._inviter_id) if self._inviter_id else None\n\n    @property\n    def target_user(self) -&gt; Optional[\"User\"]:\n\"\"\"The user whose stream to display for this voice channel stream invite or None.\"\"\"\n        return self._client.cache.get_user(self._target_user_id) if self._target_user_id else None\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        if \"stage_instance\" in data:\n            data[\"stage_instance\"] = StageInstance.from_dict(data, client)\n\n        if \"target_application\" in data:\n            data[\"target_application\"] = Application.from_dict(data, client)\n\n        if \"target_event_id\" in data:\n            data[\"scheduled_event\"] = data[\"target_event_id\"]\n\n        if channel := data.pop(\"channel\", None):\n            # invite metadata does not contain enough info to create a channel object\n            data[\"channel_id\"] = channel[\"id\"]\n\n        if guild := data.pop(\"guild\", None):\n            data[\"guild_preview\"] = GuildPreview.from_dict(guild, client)\n\n        if inviter := data.pop(\"inviter\", None):\n            inviter = client.cache.place_user_data(inviter)\n            data[\"inviter_id\"] = inviter.id\n\n        return data\n\n    def __str__(self) -&gt; str:\n        return self.link\n\n    @property\n    def link(self) -&gt; str:\n\"\"\"The invite link.\"\"\"\n        if self.scheduled_event:\n            return f\"https://discord.gg/{self.code}?event={self.scheduled_event}\"\n        return f\"https://discord.gg/{self.code}\"\n\n    async def delete(self, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n        Delete this invite.\n\n        !!! note\n            You must have the `manage_channels` permission on the channel this invite belongs to.\n\n        !!! note\n            With `manage_guild` permission, you can delete any invite across the guild.\n\n        Args:\n            reason: The reason for the deletion of invite.\n\n        \"\"\"\n        await self._client.http.delete_invite(self.code, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.code","title":"<code>code: str = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>the invite code (unique ID)</p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.uses","title":"<code>uses: int = attrs.field(default=0, repr=True)</code>  <code>class-attribute</code>","text":"<p>the guild this invite is for</p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.max_uses","title":"<code>max_uses: int = attrs.field(repr=False, default=0)</code>  <code>class-attribute</code>","text":"<p>max number of times this invite can be used</p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.max_age","title":"<code>max_age: int = attrs.field(repr=False, default=0)</code>  <code>class-attribute</code>","text":"<p>duration (in seconds) after which the invite expires</p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.created_at","title":"<code>created_at: Timestamp = attrs.field(default=MISSING, converter=optional_c(timestamp_converter), repr=True)</code>  <code>class-attribute</code>","text":"<p>when this invite was created</p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.temporary","title":"<code>temporary: bool = attrs.field(default=False, repr=True)</code>  <code>class-attribute</code>","text":"<p>whether this invite only grants temporary membership</p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.target_type","title":"<code>target_type: Optional[Union[InviteTargetTypes, int]] = attrs.field(default=None, converter=optional_c(InviteTargetTypes), repr=True)</code>  <code>class-attribute</code>","text":"<p>the type of target for this voice channel invite</p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.approximate_presence_count","title":"<code>approximate_presence_count: Optional[int] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>approximate count of online members, returned from the <code>GET /invites/&lt;code&gt;</code> endpoint when <code>with_counts</code> is <code>True</code></p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.approximate_member_count","title":"<code>approximate_member_count: Optional[int] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>approximate count of total members, returned from the <code>GET /invites/&lt;code&gt;</code> endpoint when <code>with_counts</code> is <code>True</code></p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.scheduled_event","title":"<code>scheduled_event: Optional[Snowflake_Type] = attrs.field(default=None, converter=optional_c(to_snowflake), repr=True)</code>  <code>class-attribute</code>","text":"<p>guild scheduled event data, only included if <code>guild_scheduled_event_id</code> contains a valid guild scheduled event id</p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.expires_at","title":"<code>expires_at: Optional[Timestamp] = attrs.field(default=None, converter=optional_c(timestamp_converter), repr=True)</code>  <code>class-attribute</code>","text":"<p>the expiration date of this invite, returned from the <code>GET /invites/&lt;code&gt;</code> endpoint when <code>with_expiration</code> is <code>True</code></p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.stage_instance","title":"<code>stage_instance: Optional[StageInstance] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>stage instance data if there is a public Stage instance in the Stage channel this invite is for (deprecated)</p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.target_application","title":"<code>target_application: Optional[dict] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>the embedded application to open for this voice channel embedded application invite</p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.guild_preview","title":"<code>guild_preview: Optional[GuildPreview] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>the guild this invite is for</p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.channel","title":"<code>channel: TYPE_GUILD_CHANNEL</code>  <code>property</code>","text":"<p>The channel the invite is for.</p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.inviter","title":"<code>inviter: Optional[User]</code>  <code>property</code>","text":"<p>The user that created the invite or None.</p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.target_user","title":"<code>target_user: Optional[User]</code>  <code>property</code>","text":"<p>The user whose stream to display for this voice channel stream invite or None.</p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.link","title":"<code>link: str</code>  <code>property</code>","text":"<p>The invite link.</p>"},{"location":"API%20Reference/models/Discord/invite/#naff.models.discord.invite.Invite.delete","title":"<code>delete(reason=MISSING)</code>  <code>async</code>","text":"<p>Delete this invite.</p> <p>Note</p> <p>You must have the <code>manage_channels</code> permission on the channel this invite belongs to.</p> <p>Note</p> <p>With <code>manage_guild</code> permission, you can delete any invite across the guild.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Absent[str]</code> <p>The reason for the deletion of invite.</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\invite.py</code> <pre><code>async def delete(self, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n    Delete this invite.\n\n    !!! note\n        You must have the `manage_channels` permission on the channel this invite belongs to.\n\n    !!! note\n        With `manage_guild` permission, you can delete any invite across the guild.\n\n    Args:\n        reason: The reason for the deletion of invite.\n\n    \"\"\"\n    await self._client.http.delete_invite(self.code, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/","title":"Message","text":""},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Attachment","title":"<code>Attachment</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass Attachment(DiscordObject):\n    filename: str = attrs.field(\n        repr=False,\n    )\n\"\"\"name of file attached\"\"\"\n    description: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"description for the file\"\"\"\n    content_type: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"the attachment's media type\"\"\"\n    size: int = attrs.field(\n        repr=False,\n    )\n\"\"\"size of file in bytes\"\"\"\n    url: str = attrs.field(\n        repr=False,\n    )\n\"\"\"source url of file\"\"\"\n    proxy_url: str = attrs.field(\n        repr=False,\n    )\n\"\"\"a proxied url of file\"\"\"\n    height: Optional[int] = attrs.field(repr=False, default=None)\n\"\"\"height of file (if image)\"\"\"\n    width: Optional[int] = attrs.field(repr=False, default=None)\n\"\"\"width of file (if image)\"\"\"\n    ephemeral: bool = attrs.field(repr=False, default=False)\n\"\"\"whether this attachment is ephemeral\"\"\"\n\n    @property\n    def resolution(self) -&gt; tuple[Optional[int], Optional[int]]:\n\"\"\"Returns the image resolution of the attachment file\"\"\"\n        return self.height, self.width\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Attachment.filename","title":"<code>filename: str = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>name of file attached</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Attachment.description","title":"<code>description: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>description for the file</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Attachment.content_type","title":"<code>content_type: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>the attachment's media type</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Attachment.size","title":"<code>size: int = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>size of file in bytes</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Attachment.url","title":"<code>url: str = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>source url of file</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Attachment.proxy_url","title":"<code>proxy_url: str = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>a proxied url of file</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Attachment.height","title":"<code>height: Optional[int] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>height of file (if image)</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Attachment.width","title":"<code>width: Optional[int] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>width of file (if image)</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Attachment.ephemeral","title":"<code>ephemeral: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>whether this attachment is ephemeral</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Attachment.resolution","title":"<code>resolution: tuple[Optional[int], Optional[int]]</code>  <code>property</code>","text":"<p>Returns the image resolution of the attachment file</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.ChannelMention","title":"<code>ChannelMention</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ChannelMention(DiscordObject):\n    guild_id: \"Snowflake_Type\" = attrs.field(\n        repr=False,\n    )\n\"\"\"id of the guild containing the channel\"\"\"\n    type: ChannelTypes = attrs.field(repr=False, converter=ChannelTypes)\n\"\"\"the type of channel\"\"\"\n    name: str = attrs.field(\n        repr=False,\n    )\n\"\"\"the name of the channel\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.ChannelMention.guild_id","title":"<code>guild_id: Snowflake_Type = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>id of the guild containing the channel</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.ChannelMention.type","title":"<code>type: ChannelTypes = attrs.field(repr=False, converter=ChannelTypes)</code>  <code>class-attribute</code>","text":"<p>the type of channel</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.ChannelMention.name","title":"<code>name: str = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>the name of the channel</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.MessageActivity","title":"<code>MessageActivity</code>  <code>dataclass</code>","text":"Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>@dataclass\nclass MessageActivity:\n    type: MessageActivityTypes\n\"\"\"type of message activity\"\"\"\n    party_id: str = None\n\"\"\"party_id from a Rich Presence event\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.MessageActivity.type","title":"<code>type: MessageActivityTypes</code>  <code>class-attribute</code>","text":"<p>type of message activity</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.MessageActivity.party_id","title":"<code>party_id: str = None</code>  <code>class-attribute</code>","text":"<p>party_id from a Rich Presence event</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.MessageReference","title":"<code>MessageReference</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> <p>Reference to an originating message.</p> <p>Can be used for replies.</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass MessageReference(DictSerializationMixin):\n\"\"\"\n    Reference to an originating message.\n\n    Can be used for replies.\n\n    \"\"\"\n\n    message_id: int = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))\n\"\"\"id of the originating message.\"\"\"\n    channel_id: Optional[int] = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))\n\"\"\"id of the originating message's channel.\"\"\"\n    guild_id: Optional[int] = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))\n\"\"\"id of the originating message's guild.\"\"\"\n    fail_if_not_exists: bool = attrs.field(repr=False, default=True)\n\"\"\"When sending a message, whether to error if the referenced message doesn't exist instead of sending as a normal (non-reply) message, default true.\"\"\"\n\n    @classmethod\n    def for_message(cls, message: \"Message\", fail_if_not_exists: bool = True) -&gt; \"MessageReference\":\n\"\"\"\n        Creates a reference to a message.\n\n        parameters\n            message: The target message to reference.\n            fail_if_not_exists: Whether to error if the referenced message doesn't exist instead of sending as a normal (non-reply) message\n\n        Returns:\n            A MessageReference object.\n\n        \"\"\"\n        return cls(\n            message_id=message.id,\n            channel_id=message._channel_id,\n            guild_id=message._guild_id,\n            fail_if_not_exists=fail_if_not_exists,\n        )\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.MessageReference.message_id","title":"<code>message_id: int = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))</code>  <code>class-attribute</code>","text":"<p>id of the originating message.</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.MessageReference.channel_id","title":"<code>channel_id: Optional[int] = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))</code>  <code>class-attribute</code>","text":"<p>id of the originating message's channel.</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.MessageReference.guild_id","title":"<code>guild_id: Optional[int] = attrs.field(repr=False, default=None, converter=optional_c(to_snowflake))</code>  <code>class-attribute</code>","text":"<p>id of the originating message's guild.</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.MessageReference.fail_if_not_exists","title":"<code>fail_if_not_exists: bool = attrs.field(repr=False, default=True)</code>  <code>class-attribute</code>","text":"<p>When sending a message, whether to error if the referenced message doesn't exist instead of sending as a normal (non-reply) message, default true.</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.MessageReference.for_message","title":"<code>for_message(message, fail_if_not_exists=True)</code>  <code>classmethod</code>","text":"<p>Creates a reference to a message.</p> <p>parameters     message: The target message to reference.     fail_if_not_exists: Whether to error if the referenced message doesn't exist instead of sending as a normal (non-reply) message</p> <p>Returns:</p> Type Description <code>MessageReference</code> <p>A MessageReference object.</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>@classmethod\ndef for_message(cls, message: \"Message\", fail_if_not_exists: bool = True) -&gt; \"MessageReference\":\n\"\"\"\n    Creates a reference to a message.\n\n    parameters\n        message: The target message to reference.\n        fail_if_not_exists: Whether to error if the referenced message doesn't exist instead of sending as a normal (non-reply) message\n\n    Returns:\n        A MessageReference object.\n\n    \"\"\"\n    return cls(\n        message_id=message.id,\n        channel_id=message._channel_id,\n        guild_id=message._guild_id,\n        fail_if_not_exists=fail_if_not_exists,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.MessageInteraction","title":"<code>MessageInteraction</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass MessageInteraction(DiscordObject):\n    type: InteractionTypes = attrs.field(repr=False, converter=InteractionTypes)\n\"\"\"the type of interaction\"\"\"\n    name: str = attrs.field(\n        repr=False,\n    )\n\"\"\"the name of the application command\"\"\"\n\n    _user_id: \"Snowflake_Type\" = attrs.field(\n        repr=False,\n    )\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        user_data = data[\"user\"]\n        data[\"user_id\"] = client.cache.place_user_data(user_data).id\n        return data\n\n    async def user(self) -&gt; \"models.User\":\n\"\"\"Get the user associated with this interaction.\"\"\"\n        return await self.get_user(self._user_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.MessageInteraction.type","title":"<code>type: InteractionTypes = attrs.field(repr=False, converter=InteractionTypes)</code>  <code>class-attribute</code>","text":"<p>the type of interaction</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.MessageInteraction.name","title":"<code>name: str = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>the name of the application command</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.MessageInteraction.user","title":"<code>user()</code>  <code>async</code>","text":"<p>Get the user associated with this interaction.</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>async def user(self) -&gt; \"models.User\":\n\"\"\"Get the user associated with this interaction.\"\"\"\n    return await self.get_user(self._user_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.AllowedMentions","title":"<code>AllowedMentions</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> <p>The allowed mention field allows for more granular control over mentions without various hacks to the message content.</p> <p>This will always validate against message content to avoid phantom pings, and check against user/bot permissions.</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass AllowedMentions(DictSerializationMixin):\n\"\"\"\n    The allowed mention field allows for more granular control over mentions without various hacks to the message content.\n\n    This will always validate against message content to avoid phantom\n    pings, and check against user/bot permissions.\n\n    \"\"\"\n\n    parse: Optional[List[str]] = attrs.field(repr=False, factory=list)\n\"\"\"An array of allowed mention types to parse from the content.\"\"\"\n    roles: Optional[List[\"Snowflake_Type\"]] = attrs.field(repr=False, factory=list, converter=to_snowflake_list)\n\"\"\"Array of role_ids to mention. (Max size of 100)\"\"\"\n    users: Optional[List[\"Snowflake_Type\"]] = attrs.field(repr=False, factory=list, converter=to_snowflake_list)\n\"\"\"Array of user_ids to mention. (Max size of 100)\"\"\"\n    replied_user = attrs.field(repr=False, default=False)\n\"\"\"For replies, whether to mention the author of the message being replied to. (default false)\"\"\"\n\n    def add_parse(self, *mention_types: Union[\"MentionTypes\", str]) -&gt; None:\n\"\"\"\n        Add a mention type to the list of allowed mentions to parse.\n\n        Args:\n            *mention_types: The types of mentions to add\n\n        \"\"\"\n        for mention_type in mention_types:\n            if not isinstance(mention_type, MentionTypes) and mention_type not in MentionTypes.__members__.values():\n                raise ValueError(f\"Invalid mention type: {mention_type}\")\n            self.parse.append(mention_type)\n\n    def add_roles(self, *roles: Union[\"models.Role\", \"Snowflake_Type\"]) -&gt; None:\n\"\"\"\n        Add roles that are allowed to be mentioned.\n\n        Args:\n            *roles: The roles to add\n\n        \"\"\"\n        for role in roles:\n            self.roles.append(to_snowflake(role))\n\n    def add_users(self, *users: Union[\"models.Member\", \"models.BaseUser\", \"Snowflake_Type\"]) -&gt; None:\n\"\"\"\n        Add users that are allowed to be mentioned.\n\n        Args:\n            *users: The users to add\n\n        \"\"\"\n        for user in users:\n            self.users.append(to_snowflake(user))\n\n    @classmethod\n    def all(cls) -&gt; \"AllowedMentions\":\n\"\"\"\n        Allows every user and role to be mentioned.\n\n        Returns:\n            An AllowedMentions object\n\n        \"\"\"\n        return cls(parse=list(MentionTypes.__members__.values()), replied_user=True)\n\n    @classmethod\n    def none(cls) -&gt; \"AllowedMentions\":\n\"\"\"\n        Disallows any user or role to be mentioned.\n\n        Returns:\n            An AllowedMentions object\n\n        \"\"\"\n        return cls()\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.AllowedMentions.parse","title":"<code>parse: Optional[List[str]] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>An array of allowed mention types to parse from the content.</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.AllowedMentions.roles","title":"<code>roles: Optional[List[Snowflake_Type]] = attrs.field(repr=False, factory=list, converter=to_snowflake_list)</code>  <code>class-attribute</code>","text":"<p>Array of role_ids to mention. (Max size of 100)</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.AllowedMentions.users","title":"<code>users: Optional[List[Snowflake_Type]] = attrs.field(repr=False, factory=list, converter=to_snowflake_list)</code>  <code>class-attribute</code>","text":"<p>Array of user_ids to mention. (Max size of 100)</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.AllowedMentions.replied_user","title":"<code>replied_user = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>For replies, whether to mention the author of the message being replied to. (default false)</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.AllowedMentions.add_parse","title":"<code>add_parse(*mention_types)</code>","text":"<p>Add a mention type to the list of allowed mentions to parse.</p> <p>Parameters:</p> Name Type Description Default <code>*mention_types</code> <code>Union[MentionTypes, str]</code> <p>The types of mentions to add</p> <code>()</code> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>def add_parse(self, *mention_types: Union[\"MentionTypes\", str]) -&gt; None:\n\"\"\"\n    Add a mention type to the list of allowed mentions to parse.\n\n    Args:\n        *mention_types: The types of mentions to add\n\n    \"\"\"\n    for mention_type in mention_types:\n        if not isinstance(mention_type, MentionTypes) and mention_type not in MentionTypes.__members__.values():\n            raise ValueError(f\"Invalid mention type: {mention_type}\")\n        self.parse.append(mention_type)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.AllowedMentions.add_roles","title":"<code>add_roles(*roles)</code>","text":"<p>Add roles that are allowed to be mentioned.</p> <p>Parameters:</p> Name Type Description Default <code>*roles</code> <code>Union[Role, Snowflake_Type]</code> <p>The roles to add</p> <code>()</code> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>def add_roles(self, *roles: Union[\"models.Role\", \"Snowflake_Type\"]) -&gt; None:\n\"\"\"\n    Add roles that are allowed to be mentioned.\n\n    Args:\n        *roles: The roles to add\n\n    \"\"\"\n    for role in roles:\n        self.roles.append(to_snowflake(role))\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.AllowedMentions.add_users","title":"<code>add_users(*users)</code>","text":"<p>Add users that are allowed to be mentioned.</p> <p>Parameters:</p> Name Type Description Default <code>*users</code> <code>Union[Member, BaseUser, Snowflake_Type]</code> <p>The users to add</p> <code>()</code> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>def add_users(self, *users: Union[\"models.Member\", \"models.BaseUser\", \"Snowflake_Type\"]) -&gt; None:\n\"\"\"\n    Add users that are allowed to be mentioned.\n\n    Args:\n        *users: The users to add\n\n    \"\"\"\n    for user in users:\n        self.users.append(to_snowflake(user))\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.AllowedMentions.all","title":"<code>all()</code>  <code>classmethod</code>","text":"<p>Allows every user and role to be mentioned.</p> <p>Returns:</p> Type Description <code>AllowedMentions</code> <p>An AllowedMentions object</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>@classmethod\ndef all(cls) -&gt; \"AllowedMentions\":\n\"\"\"\n    Allows every user and role to be mentioned.\n\n    Returns:\n        An AllowedMentions object\n\n    \"\"\"\n    return cls(parse=list(MentionTypes.__members__.values()), replied_user=True)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.AllowedMentions.none","title":"<code>none()</code>  <code>classmethod</code>","text":"<p>Disallows any user or role to be mentioned.</p> <p>Returns:</p> Type Description <code>AllowedMentions</code> <p>An AllowedMentions object</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>@classmethod\ndef none(cls) -&gt; \"AllowedMentions\":\n\"\"\"\n    Disallows any user or role to be mentioned.\n\n    Returns:\n        An AllowedMentions object\n\n    \"\"\"\n    return cls()\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.BaseMessage","title":"<code>BaseMessage</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass BaseMessage(DiscordObject):\n    _channel_id: \"Snowflake_Type\" = attrs.field(repr=False, default=MISSING, converter=to_optional_snowflake)\n    _thread_channel_id: Optional[\"Snowflake_Type\"] = attrs.field(\n        repr=False, default=None, converter=to_optional_snowflake\n    )\n    _guild_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None, converter=to_optional_snowflake)\n    _author_id: \"Snowflake_Type\" = attrs.field(repr=False, default=MISSING, converter=to_optional_snowflake)\n\n    @property\n    def guild(self) -&gt; \"models.Guild\":\n\"\"\"The guild the message was sent in\"\"\"\n        return self._client.cache.get_guild(self._guild_id)\n\n    @property\n    def channel(self) -&gt; \"models.TYPE_MESSAGEABLE_CHANNEL\":\n\"\"\"The channel the message was sent in\"\"\"\n        channel = self._client.cache.get_channel(self._channel_id)\n\n        if not self._guild_id and not channel:\n            # allow dm operations without fetching a dm channel from API\n            channel = BaseChannel.from_dict_factory({\"id\": self._channel_id, \"type\": ChannelTypes.DM}, self._client)\n            if self.author:\n                channel.recipients = [self.author]\n        return channel\n\n    @property\n    def thread(self) -&gt; \"models.TYPE_THREAD_CHANNEL\":\n\"\"\"The thread that was started from this message, includes thread member object\"\"\"\n        return self._client.cache.get_channel(self._thread_channel_id)\n\n    @property\n    def author(self) -&gt; Union[\"models.Member\", \"models.User\"]:\n\"\"\"The author of this message. Only a valid user in the case where the message is generated by a user or bot user.\"\"\"\n        if self._author_id:\n            member = None\n            if self._guild_id:\n                member = self._client.cache.get_member(self._guild_id, self._author_id)\n            return member or self._client.cache.get_user(self._author_id)\n        return MISSING\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.BaseMessage.guild","title":"<code>guild: models.Guild</code>  <code>property</code>","text":"<p>The guild the message was sent in</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.BaseMessage.channel","title":"<code>channel: models.TYPE_MESSAGEABLE_CHANNEL</code>  <code>property</code>","text":"<p>The channel the message was sent in</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.BaseMessage.thread","title":"<code>thread: models.TYPE_THREAD_CHANNEL</code>  <code>property</code>","text":"<p>The thread that was started from this message, includes thread member object</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.BaseMessage.author","title":"<code>author: Union[models.Member, models.User]</code>  <code>property</code>","text":"<p>The author of this message. Only a valid user in the case where the message is generated by a user or bot user.</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message","title":"<code>Message</code>","text":"<p>         Bases: <code>BaseMessage</code></p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass Message(BaseMessage):\n    content: str = attrs.field(repr=False, default=MISSING)\n\"\"\"Contents of the message\"\"\"\n    timestamp: \"models.Timestamp\" = attrs.field(repr=False, default=MISSING, converter=optional_c(timestamp_converter))\n\"\"\"When this message was sent\"\"\"\n    edited_timestamp: Optional[\"models.Timestamp\"] = attrs.field(\n        repr=False, default=None, converter=optional_c(timestamp_converter)\n    )\n\"\"\"When this message was edited (or `None` if never)\"\"\"\n    tts: bool = attrs.field(repr=False, default=False)\n\"\"\"Whether this was a TTS message\"\"\"\n    mention_everyone: bool = attrs.field(repr=False, default=False)\n\"\"\"Whether this message mentions everyone\"\"\"\n    mention_channels: List[ChannelMention] = attrs.field(repr=False, factory=list)\n\"\"\"Channels specifically mentioned in this message\"\"\"\n    attachments: List[Attachment] = attrs.field(repr=False, factory=list)\n\"\"\"Any attached files\"\"\"\n    embeds: List[\"models.Embed\"] = attrs.field(repr=False, factory=list)\n\"\"\"Any embedded content\"\"\"\n    reactions: List[\"models.Reaction\"] = attrs.field(repr=False, factory=list)\n\"\"\"Reactions to the message\"\"\"\n    nonce: Optional[Union[int, str]] = attrs.field(repr=False, default=None)\n\"\"\"Used for validating a message was sent\"\"\"\n    pinned: bool = attrs.field(repr=False, default=False)\n\"\"\"Whether this message is pinned\"\"\"\n    webhook_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None, converter=to_optional_snowflake)\n\"\"\"If the message is generated by a webhook, this is the webhook's id\"\"\"\n    type: MessageTypes = attrs.field(repr=False, default=MISSING, converter=optional_c(MessageTypes))\n\"\"\"Type of message\"\"\"\n    activity: Optional[MessageActivity] = attrs.field(repr=False, default=None, converter=optional_c(MessageActivity))\n\"\"\"Activity sent with Rich Presence-related chat embeds\"\"\"\n    application: Optional[\"models.Application\"] = attrs.field(repr=False, default=None)  # TODO: partial application\n\"\"\"Application sent with Rich Presence-related chat embeds\"\"\"\n    application_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None, converter=to_optional_snowflake)\n\"\"\"If the message is an Interaction or application-owned webhook, this is the id of the application\"\"\"\n    message_reference: Optional[MessageReference] = attrs.field(\n        repr=False, default=None, converter=optional_c(MessageReference.from_dict)\n    )\n\"\"\"Data showing the source of a crosspost, channel follow add, pin, or reply message\"\"\"\n    flags: MessageFlags = attrs.field(repr=False, default=MessageFlags.NONE, converter=MessageFlags)\n\"\"\"Message flags combined as a bitfield\"\"\"\n    interaction: Optional[\"MessageInteraction\"] = attrs.field(repr=False, default=None)\n\"\"\"Sent if the message is a response to an Interaction\"\"\"\n    components: Optional[List[\"models.ActionRow\"]] = attrs.field(repr=False, default=None)\n\"\"\"Sent if the message contains components like buttons, action rows, or other interactive components\"\"\"\n    sticker_items: Optional[List[\"models.StickerItem\"]] = attrs.field(repr=False, default=None)\n\"\"\"Sent if the message contains stickers\"\"\"\n    _mention_ids: List[\"Snowflake_Type\"] = attrs.field(repr=False, factory=list)\n    _mention_roles: List[\"Snowflake_Type\"] = attrs.field(repr=False, factory=list)\n    _referenced_message_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None)\n\n    @property\n    async def mention_users(self) -&gt; AsyncGenerator[\"models.Member\", None]:\n\"\"\"A generator of users mentioned in this message\"\"\"\n        for u_id in self._mention_ids:\n            yield await self._client.cache.fetch_member(self._guild_id, u_id)\n\n    @property\n    async def mention_roles(self) -&gt; AsyncGenerator[\"models.Role\", None]:\n\"\"\"A generator of roles mentioned in this message\"\"\"\n        for r_id in self._mention_roles:\n            yield await self._client.cache.fetch_role(self._guild_id, r_id)\n\n    @property\n    def thread(self) -&gt; \"models.TYPE_THREAD_CHANNEL\":\n\"\"\"The thread that was started from this message, if any\"\"\"\n        return self._client.cache.get_channel(self.id)\n\n    async def fetch_referenced_message(self) -&gt; Optional[\"Message\"]:\n\"\"\"\n        Fetch the message this message is referencing, if any.\n\n        Returns:\n            The referenced message, if found\n\n        \"\"\"\n        if self._referenced_message_id is None:\n            return None\n        return await self._client.cache.fetch_message(self._channel_id, self._referenced_message_id)\n\n    def get_referenced_message(self) -&gt; Optional[\"Message\"]:\n\"\"\"\n        Get the message this message is referencing, if any.\n\n        Returns:\n            The referenced message, if found\n\n        \"\"\"\n        if self._referenced_message_id is None:\n            return None\n        return self._client.cache.get_message(self._channel_id, self._referenced_message_id)\n\n    def contains_mention(\n        self,\n        query: \"str | re.Pattern[str] | models.BaseUser | models.BaseChannel | models.Role\",\n        *,\n        tag_as_mention: bool = False,\n    ) -&gt; bool:\n\"\"\"\n        Check whether the message contains the query or not.\n\n        Args:\n            query: The query to search for\n            tag_as_mention: Should `BaseUser.tag` be checked *(only if query is an instance of BaseUser)*\n\n        Returns:\n            A boolean indicating whether the query could be found or not\n        \"\"\"\n        return mentions(text=self.content or self.system_content, query=query, tag_as_mention=tag_as_mention)\n\n    @classmethod\n    def _process_dict(cls, data: dict, client: \"Client\") -&gt; dict:\n        if author_data := data.pop(\"author\", None):\n            if \"guild_id\" in data and \"member\" in data:\n                author_data[\"member\"] = data.pop(\"member\")\n                data[\"author_id\"] = client.cache.place_member_data(data[\"guild_id\"], author_data).id\n            else:\n                data[\"author_id\"] = client.cache.place_user_data(author_data).id\n\n        if mentions_data := data.pop(\"mentions\", None):\n            mention_ids = []\n            for user_data in mentions_data:\n                if \"guild_id\" in data and \"member\" in user_data:\n                    mention_ids.append(client.cache.place_member_data(data[\"guild_id\"], user_data).id)\n                else:\n                    mention_ids.append(client.cache.place_user_data(user_data).id)\n            data[\"mention_ids\"] = mention_ids\n\n        found_ids = []\n        mention_channels = []\n        if \"mention_channels\" in data:\n            for channel_data in data[\"mention_channels\"]:\n                mention_channels.append(ChannelMention.from_dict(channel_data, client))\n                found_ids.append(channel_data[\"id\"])\n        if \"content\" in data:\n            for channel_id in channel_mention.findall(data[\"content\"]):\n                if channel_id not in found_ids and (channel := client.get_channel(channel_id)):\n                    channel_data = {\n                        \"id\": channel.id,\n                        \"guild_id\": channel._guild_id,\n                        \"type\": channel.type,\n                        \"name\": channel.name,\n                    }\n                    mention_channels.append(ChannelMention.from_dict(channel_data, client))\n        if len(mention_channels) &gt; 0:\n            data[\"mention_channels\"] = mention_channels\n\n        if \"attachments\" in data:\n            data[\"attachments\"] = Attachment.from_list(data.get(\"attachments\"), client)\n\n        if \"embeds\" in data:\n            data[\"embeds\"] = models.Embed.from_list(data.get(\"embeds\"))\n\n        if \"reactions\" in data:\n            reactions = []\n            for reaction_data in data[\"reactions\"]:\n                reactions.append(\n                    models.Reaction.from_dict(\n                        reaction_data | {\"message_id\": data[\"id\"], \"channel_id\": data[\"channel_id\"]}, client\n                    )\n                )\n            data[\"reactions\"] = reactions\n\n        # TODO: Convert to application object\n\n        if ref_message_data := data.pop(\"referenced_message\", None):\n            if not ref_message_data.get(\"guild_id\"):\n                ref_message_data[\"guild_id\"] = data.get(\"guild_id\")\n            _m = client.cache.place_message_data(ref_message_data)\n            data[\"referenced_message_id\"] = _m.id\n\n        if \"interaction\" in data:\n            data[\"interaction\"] = MessageInteraction.from_dict(data[\"interaction\"], client)\n\n        if thread_data := data.pop(\"thread\", None):\n            data[\"thread_channel_id\"] = client.cache.place_channel_data(thread_data).id\n\n        if \"components\" in data:\n            components = []\n            for component_data in data[\"components\"]:\n                components.append(models.BaseComponent.from_dict_factory(component_data))\n            data[\"components\"] = components\n\n        if \"sticker_items\" in data:\n            data[\"sticker_items\"] = models.StickerItem.from_list(data[\"sticker_items\"], client)\n\n        return data\n\n    @property\n    def system_content(self) -&gt; Optional[str]:\n\"\"\"Content for system messages. (boosts, welcomes, etc)\"\"\"\n        match self.type:\n            case MessageTypes.USER_PREMIUM_GUILD_SUBSCRIPTION:\n                return f\"{self.author.mention} just boosted the server!\"\n            case MessageTypes.USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1:\n                return f\"{self.author.mention} just boosted the server! {self.guild.name} has achieved **Level 1!**\"\n            case MessageTypes.USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2:\n                return f\"{self.author.mention} just boosted the server! {self.guild.name} has achieved **Level 2!**\"\n            case MessageTypes.USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3:\n                return f\"{self.author.mention} just boosted the server! {self.guild.name} has achieved **Level 3!**\"\n            case MessageTypes.GUILD_MEMBER_JOIN:\n                return GUILD_WELCOME_MESSAGES[\n                    int(self.timestamp.timestamp() * 1000)\n                    % len(GUILD_WELCOME_MESSAGES)\n                    # This is how Discord calculates the welcome message.\n                ].format(self.author.mention)\n            case MessageTypes.THREAD_CREATED:\n                return f\"{self.author.mention} started a thread: {self.thread.mention}. See all **threads**.\"\n            case MessageTypes.CHANNEL_FOLLOW_ADD:\n                return f\"{self.author.mention} has added **{self.content}** to this channel. Its most important updates will show up here.\"\n            case MessageTypes.RECIPIENT_ADD:\n                return f\"{self.author.mention} added &lt;@{self._mention_ids[0]}&gt; to the thread.\"\n            case MessageTypes.RECIPIENT_REMOVE:\n                return f\"{self.author.mention} removed &lt;@{self._mention_ids[0]}&gt; from the thread.\"\n            case MessageTypes.CHANNEL_NAME_CHANGE:\n                return f\"{self.author.mention} changed the channel name: **{self.content}**.\"\n            case MessageTypes.CHANNEL_PINNED_MESSAGE:\n                return f\"{self.author.mention} pinned a message. See all pinned messages\"\n            case MessageTypes.GUILD_DISCOVERY_DISQUALIFIED:\n                return \"This server has been removed from Server Discovery because it no longer passes all the requirements. Check Server Settings for more details.\"\n            case MessageTypes.GUILD_DISCOVERY_REQUALIFIED:\n                return \"This server is eligible for Server Discovery again and has been automatically relisted!\"\n            case MessageTypes.GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING:\n                return \"This server has failed Discovery activity requirements for 1 week. If this server fails for 4 weeks in a row, it will be automatically removed from Discovery.\"\n            case MessageTypes.GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING:\n                return \"This server has failed Discovery activity requirements for 3 weeks in a row. If this server fails for 1 more week, it will be removed from Discovery.\"\n            case MessageTypes.GUILD_INVITE_REMINDER:\n                return \"**Invite your friends**\\nThe best way to setup a server is with your buddies!\"\n            case MessageTypes.THREAD_STARTER_MESSAGE:\n                if referenced_message := self.get_referenced_message():\n                    return referenced_message.content\n                return \"Sorry, we couldn't load the first message in this thread\"\n            case MessageTypes.AUTO_MODERATION_ACTION:\n                keyword_matched_content = self.embeds[0].fields[4].value  # The words that triggered the action\n                message_content = self.embeds[0].description.replace(\n                    keyword_matched_content, f\"**{keyword_matched_content}**\"\n                )\n                rule = self.embeds[0].fields[0].value  # What rule was triggered\n                channel = self.embeds[0].fields[1].value  # Channel that the action took place in\n                return f'AutoMod has blocked a message in &lt;#{channel}&gt;. \"{message_content}\" from {self.author.mention}. Rule: {rule}.'\n            case _:\n                return None\n\n    @property\n    def jump_url(self) -&gt; str:\n\"\"\"A url that allows the client to *jump* to this message.\"\"\"\n        return f\"https://discord.com/channels/{self._guild_id or '@me'}/{self._channel_id}/{self.id}\"\n\n    @property\n    def proto_url(self) -&gt; str:\n\"\"\"A URL like `jump_url` that uses protocols.\"\"\"\n        return f\"discord://-/channels/{self._guild_id or '@me'}/{self._channel_id}/{self.id}\"\n\n    async def edit(\n        self,\n        *,\n        content: Optional[str] = None,\n        embeds: Optional[Union[Sequence[Union[\"models.Embed\", dict]], Union[\"models.Embed\", dict]]] = None,\n        embed: Optional[Union[\"models.Embed\", dict]] = None,\n        components: Optional[\n            Union[\n                Sequence[Sequence[Union[\"models.BaseComponent\", dict]]],\n                Sequence[Union[\"models.BaseComponent\", dict]],\n                \"models.BaseComponent\",\n                dict,\n            ]\n        ] = None,\n        allowed_mentions: Optional[Union[AllowedMentions, dict]] = None,\n        attachments: Optional[Optional[Sequence[Union[Attachment, dict]]]] = None,\n        files: Optional[Union[UPLOADABLE_TYPE, Sequence[UPLOADABLE_TYPE]]] = None,\n        file: Optional[UPLOADABLE_TYPE] = None,\n        tts: bool = False,\n        flags: Optional[Union[int, MessageFlags]] = None,\n        context: \"InteractionContext | None\" = None,\n    ) -&gt; \"Message\":\n\"\"\"\n        Edits the message.\n\n        Args:\n            content: Message text content.\n            embeds: Embedded rich content (up to 6000 characters).\n            embed: Embedded rich content (up to 6000 characters).\n            components: The components to include with the message.\n            allowed_mentions: Allowed mentions for the message.\n            attachments: The attachments to keep, only used when editing message.\n            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n            tts: Should this message use Text To Speech.\n            flags: Message flags to apply.\n            context: The interaction context to use for the edit\n\n        Returns:\n            New message object with edits applied\n\n        \"\"\"\n        if context:\n            return await context.edit(\n                self,\n                content=content,\n                embeds=embeds,\n                embed=embed,\n                components=components,\n                allowed_mentions=allowed_mentions,\n                attachments=attachments,\n                files=files,\n                file=file,\n                tts=tts,\n            )\n        else:\n            if self.flags == MessageFlags.EPHEMERAL:\n                raise EphemeralEditException\n            message_payload = process_message_payload(\n                content=content,\n                embeds=embeds or embed,\n                components=components,\n                allowed_mentions=allowed_mentions,\n                attachments=attachments,\n                tts=tts,\n                flags=flags,\n            )\n            if file:\n                if files:\n                    files = [file, *files]\n                else:\n                    files = [file]\n\n            message_data = await self._client.http.edit_message(message_payload, self._channel_id, self.id, files=files)\n            if message_data:\n                return self._client.cache.place_message_data(message_data)\n\n    async def delete(self, delay: int = 0, *, context: \"InteractionContext | None\" = None) -&gt; None:\n\"\"\"\n        Delete message.\n\n        Args:\n            delay: Seconds to wait before deleting message.\n            context: An optional interaction context to delete ephemeral messages.\n\n        \"\"\"\n\n        async def _delete() -&gt; None:\n            if delay:\n                await asyncio.sleep(delay)\n\n            if MessageFlags.EPHEMERAL in self.flags:\n                if not context:\n                    raise ValueError(\"Cannot delete ephemeral message without interaction context parameter\")\n                await context.delete(self.id)\n            else:\n                await self._client.http.delete_message(self._channel_id, self.id)\n\n        if delay:\n            asyncio.create_task(_delete())\n        else:\n            return await _delete()\n\n    async def reply(\n        self,\n        content: Optional[str] = None,\n        embeds: Optional[Union[List[Union[\"models.Embed\", dict]], Union[\"models.Embed\", dict]]] = None,\n        embed: Optional[Union[\"models.Embed\", dict]] = None,\n        **kwargs: Mapping[str, Any],\n    ) -&gt; \"Message\":\n\"\"\"\n        Reply to this message, takes all the same attributes as `send`.\n\n        Args:\n            content: Message text content.\n            embeds: Embedded rich content (up to 6000 characters).\n            embed: Embedded rich content (up to 6000 characters).\n            **kwargs: Additional options to pass to `send`.\n\n        Returns:\n            New message object.\n\n        \"\"\"\n        return await self.channel.send(content=content, reply_to=self, embeds=embeds or embed, **kwargs)\n\n    async def create_thread(\n        self,\n        name: str,\n        auto_archive_duration: Union[AutoArchiveDuration, int] = AutoArchiveDuration.ONE_DAY,\n        reason: Optional[str] = None,\n    ) -&gt; \"models.TYPE_THREAD_CHANNEL\":\n\"\"\"\n        Create a thread from this message.\n\n        Args:\n            name: The name of this thread\n            auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\n            reason: The optional reason for creating this thread\n\n        Returns:\n            The created thread object\n\n        Raises:\n            ThreadOutsideOfGuild: if this is invoked on a message outside of a guild\n\n        \"\"\"\n        if self.channel.type not in (ChannelTypes.GUILD_TEXT, ChannelTypes.GUILD_NEWS):\n            raise ThreadOutsideOfGuild\n\n        thread_data = await self._client.http.create_thread(\n            channel_id=self._channel_id,\n            name=name,\n            auto_archive_duration=auto_archive_duration,\n            message_id=self.id,\n            reason=reason,\n        )\n        return self._client.cache.place_channel_data(thread_data)\n\n    async def suppress_embeds(self) -&gt; \"Message\":\n\"\"\"\n        Suppress embeds for this message.\n\n        !!! note\n            Requires the `Permissions.MANAGE_MESSAGES` permission.\n\n        \"\"\"\n        message_data = await self._client.http.edit_message(\n            {\"flags\": MessageFlags.SUPPRESS_EMBEDS}, self._channel_id, self.id\n        )\n        if message_data:\n            return self._client.cache.place_message_data(message_data)\n\n    async def fetch_reaction(\n        self,\n        emoji: Union[\"models.PartialEmoji\", dict, str],\n        limit: Absent[int] = MISSING,\n        after: Absent[\"Snowflake_Type\"] = MISSING,\n    ) -&gt; List[\"models.User\"]:\n\"\"\"\n        Fetches reactions of a specific emoji from this message.\n\n        Args:\n            emoji: The emoji to get\n            limit: Max number of users to return (1-100)\n            after: Get users after this user ID\n\n        Returns:\n            list of users who have reacted with that emoji\n\n        \"\"\"\n        reaction_data = await self._client.http.get_reactions(\n            self._channel_id, self.id, emoji, limit, to_optional_snowflake(after)\n        )\n        return [self._client.cache.place_user_data(user_data) for user_data in reaction_data]\n\n    async def add_reaction(self, emoji: Union[\"models.PartialEmoji\", dict, str]) -&gt; None:\n\"\"\"\n        Add a reaction to this message.\n\n        Args:\n            emoji: the emoji to react with\n\n        \"\"\"\n        emoji = models.process_emoji_req_format(emoji)\n        await self._client.http.create_reaction(self._channel_id, self.id, emoji)\n\n    async def remove_reaction(\n        self,\n        emoji: Union[\"models.PartialEmoji\", dict, str],\n        member: Optional[Union[\"models.Member\", \"models.User\", \"Snowflake_Type\"]] = MISSING,\n    ) -&gt; None:\n\"\"\"\n        Remove a specific reaction that a user reacted with.\n\n        Args:\n            emoji: Emoji to remove\n            member: Member to remove reaction of. Default's to NAFF bot user.\n\n        \"\"\"\n        emoji_str = models.process_emoji_req_format(emoji)\n        if not member:\n            member = self._client.user\n        user_id = to_snowflake(member)\n        if user_id == self._client.user.id:\n            await self._client.http.remove_self_reaction(self._channel_id, self.id, emoji_str)\n        else:\n            await self._client.http.remove_user_reaction(self._channel_id, self.id, emoji_str, user_id)\n\n    async def clear_reactions(self, emoji: Union[\"models.PartialEmoji\", dict, str]) -&gt; None:\n\"\"\"\n        Clear a specific reaction from message.\n\n        Args:\n            emoji: The emoji to clear\n\n        \"\"\"\n        emoji = models.process_emoji_req_format(emoji)\n        await self._client.http.clear_reaction(self._channel_id, self.id, emoji)\n\n    async def clear_all_reactions(self) -&gt; None:\n\"\"\"Clear all emojis from a message.\"\"\"\n        await self._client.http.clear_reactions(self._channel_id, self.id)\n\n    async def pin(self) -&gt; None:\n\"\"\"Pin message.\"\"\"\n        await self._client.http.pin_message(self._channel_id, self.id)\n        self.pinned = True\n\n    async def unpin(self) -&gt; None:\n\"\"\"Unpin message.\"\"\"\n        await self._client.http.unpin_message(self._channel_id, self.id)\n        self.pinned = False\n\n    async def publish(self) -&gt; None:\n\"\"\"\n        Publish this message.\n\n        (Discord api calls it \"crosspost\")\n\n        \"\"\"\n        await self._client.http.crosspost_message(self._channel_id, self.id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.content","title":"<code>content: str = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>Contents of the message</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.timestamp","title":"<code>timestamp: models.Timestamp = attrs.field(repr=False, default=MISSING, converter=optional_c(timestamp_converter))</code>  <code>class-attribute</code>","text":"<p>When this message was sent</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.edited_timestamp","title":"<code>edited_timestamp: Optional[models.Timestamp] = attrs.field(repr=False, default=None, converter=optional_c(timestamp_converter))</code>  <code>class-attribute</code>","text":"<p>When this message was edited (or <code>None</code> if never)</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.tts","title":"<code>tts: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>Whether this was a TTS message</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.mention_everyone","title":"<code>mention_everyone: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>Whether this message mentions everyone</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.mention_channels","title":"<code>mention_channels: List[ChannelMention] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>Channels specifically mentioned in this message</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.attachments","title":"<code>attachments: List[Attachment] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>Any attached files</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.embeds","title":"<code>embeds: List[models.Embed] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>Any embedded content</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.reactions","title":"<code>reactions: List[models.Reaction] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>Reactions to the message</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.nonce","title":"<code>nonce: Optional[Union[int, str]] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>Used for validating a message was sent</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.pinned","title":"<code>pinned: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>Whether this message is pinned</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.webhook_id","title":"<code>webhook_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None, converter=to_optional_snowflake)</code>  <code>class-attribute</code>","text":"<p>If the message is generated by a webhook, this is the webhook's id</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.type","title":"<code>type: MessageTypes = attrs.field(repr=False, default=MISSING, converter=optional_c(MessageTypes))</code>  <code>class-attribute</code>","text":"<p>Type of message</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.activity","title":"<code>activity: Optional[MessageActivity] = attrs.field(repr=False, default=None, converter=optional_c(MessageActivity))</code>  <code>class-attribute</code>","text":"<p>Activity sent with Rich Presence-related chat embeds</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.application","title":"<code>application: Optional[models.Application] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>Application sent with Rich Presence-related chat embeds</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.application_id","title":"<code>application_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None, converter=to_optional_snowflake)</code>  <code>class-attribute</code>","text":"<p>If the message is an Interaction or application-owned webhook, this is the id of the application</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.message_reference","title":"<code>message_reference: Optional[MessageReference] = attrs.field(repr=False, default=None, converter=optional_c(MessageReference.from_dict))</code>  <code>class-attribute</code>","text":"<p>Data showing the source of a crosspost, channel follow add, pin, or reply message</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.flags","title":"<code>flags: MessageFlags = attrs.field(repr=False, default=MessageFlags.NONE, converter=MessageFlags)</code>  <code>class-attribute</code>","text":"<p>Message flags combined as a bitfield</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.interaction","title":"<code>interaction: Optional[MessageInteraction] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>Sent if the message is a response to an Interaction</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.components","title":"<code>components: Optional[List[models.ActionRow]] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>Sent if the message contains components like buttons, action rows, or other interactive components</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.sticker_items","title":"<code>sticker_items: Optional[List[models.StickerItem]] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>Sent if the message contains stickers</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.mention_users","title":"<code>mention_users: AsyncGenerator[models.Member, None]</code>  <code>async</code> <code>property</code>","text":"<p>A generator of users mentioned in this message</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.mention_roles","title":"<code>mention_roles: AsyncGenerator[models.Role, None]</code>  <code>async</code> <code>property</code>","text":"<p>A generator of roles mentioned in this message</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.thread","title":"<code>thread: models.TYPE_THREAD_CHANNEL</code>  <code>property</code>","text":"<p>The thread that was started from this message, if any</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.fetch_referenced_message","title":"<code>fetch_referenced_message()</code>  <code>async</code>","text":"<p>Fetch the message this message is referencing, if any.</p> <p>Returns:</p> Type Description <code>Optional[Message]</code> <p>The referenced message, if found</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>async def fetch_referenced_message(self) -&gt; Optional[\"Message\"]:\n\"\"\"\n    Fetch the message this message is referencing, if any.\n\n    Returns:\n        The referenced message, if found\n\n    \"\"\"\n    if self._referenced_message_id is None:\n        return None\n    return await self._client.cache.fetch_message(self._channel_id, self._referenced_message_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.get_referenced_message","title":"<code>get_referenced_message()</code>","text":"<p>Get the message this message is referencing, if any.</p> <p>Returns:</p> Type Description <code>Optional[Message]</code> <p>The referenced message, if found</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>def get_referenced_message(self) -&gt; Optional[\"Message\"]:\n\"\"\"\n    Get the message this message is referencing, if any.\n\n    Returns:\n        The referenced message, if found\n\n    \"\"\"\n    if self._referenced_message_id is None:\n        return None\n    return self._client.cache.get_message(self._channel_id, self._referenced_message_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.contains_mention","title":"<code>contains_mention(query, *, tag_as_mention=False)</code>","text":"<p>Check whether the message contains the query or not.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Role</code> <p>The query to search for</p> required <code>tag_as_mention</code> <code>bool</code> <p>Should <code>BaseUser.tag</code> be checked (only if query is an instance of BaseUser)</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating whether the query could be found or not</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>def contains_mention(\n    self,\n    query: \"str | re.Pattern[str] | models.BaseUser | models.BaseChannel | models.Role\",\n    *,\n    tag_as_mention: bool = False,\n) -&gt; bool:\n\"\"\"\n    Check whether the message contains the query or not.\n\n    Args:\n        query: The query to search for\n        tag_as_mention: Should `BaseUser.tag` be checked *(only if query is an instance of BaseUser)*\n\n    Returns:\n        A boolean indicating whether the query could be found or not\n    \"\"\"\n    return mentions(text=self.content or self.system_content, query=query, tag_as_mention=tag_as_mention)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.system_content","title":"<code>system_content: Optional[str]</code>  <code>property</code>","text":"<p>Content for system messages. (boosts, welcomes, etc)</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.jump_url","title":"<code>jump_url: str</code>  <code>property</code>","text":"<p>A url that allows the client to jump to this message.</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.proto_url","title":"<code>proto_url: str</code>  <code>property</code>","text":"<p>A URL like <code>jump_url</code> that uses protocols.</p>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.edit","title":"<code>edit(*, content=None, embeds=None, embed=None, components=None, allowed_mentions=None, attachments=None, files=None, file=None, tts=False, flags=None, context=None)</code>  <code>async</code>","text":"<p>Edits the message.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>Optional[str]</code> <p>Message text content.</p> <code>None</code> <code>embeds</code> <code>Optional[Union[Sequence[Union[Embed, dict]], Union[Embed, dict]]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>embed</code> <code>Optional[Union[Embed, dict]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>components</code> <code>Optional[Union[Sequence[Sequence[Union[BaseComponent, dict]]], Sequence[Union[BaseComponent, dict]], BaseComponent, dict]]</code> <p>The components to include with the message.</p> <code>None</code> <code>allowed_mentions</code> <code>Optional[Union[AllowedMentions, dict]]</code> <p>Allowed mentions for the message.</p> <code>None</code> <code>attachments</code> <code>Optional[Optional[Sequence[Union[Attachment, dict]]]]</code> <p>The attachments to keep, only used when editing message.</p> <code>None</code> <code>files</code> <code>Optional[Union[UPLOADABLE_TYPE, Sequence[UPLOADABLE_TYPE]]]</code> <p>Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.</p> <code>None</code> <code>file</code> <code>Optional[UPLOADABLE_TYPE]</code> <p>Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.</p> <code>None</code> <code>tts</code> <code>bool</code> <p>Should this message use Text To Speech.</p> <code>False</code> <code>flags</code> <code>Optional[Union[int, MessageFlags]]</code> <p>Message flags to apply.</p> <code>None</code> <code>context</code> <code>InteractionContext | None</code> <p>The interaction context to use for the edit</p> <code>None</code> <p>Returns:</p> Type Description <code>Message</code> <p>New message object with edits applied</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>async def edit(\n    self,\n    *,\n    content: Optional[str] = None,\n    embeds: Optional[Union[Sequence[Union[\"models.Embed\", dict]], Union[\"models.Embed\", dict]]] = None,\n    embed: Optional[Union[\"models.Embed\", dict]] = None,\n    components: Optional[\n        Union[\n            Sequence[Sequence[Union[\"models.BaseComponent\", dict]]],\n            Sequence[Union[\"models.BaseComponent\", dict]],\n            \"models.BaseComponent\",\n            dict,\n        ]\n    ] = None,\n    allowed_mentions: Optional[Union[AllowedMentions, dict]] = None,\n    attachments: Optional[Optional[Sequence[Union[Attachment, dict]]]] = None,\n    files: Optional[Union[UPLOADABLE_TYPE, Sequence[UPLOADABLE_TYPE]]] = None,\n    file: Optional[UPLOADABLE_TYPE] = None,\n    tts: bool = False,\n    flags: Optional[Union[int, MessageFlags]] = None,\n    context: \"InteractionContext | None\" = None,\n) -&gt; \"Message\":\n\"\"\"\n    Edits the message.\n\n    Args:\n        content: Message text content.\n        embeds: Embedded rich content (up to 6000 characters).\n        embed: Embedded rich content (up to 6000 characters).\n        components: The components to include with the message.\n        allowed_mentions: Allowed mentions for the message.\n        attachments: The attachments to keep, only used when editing message.\n        files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n        file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n        tts: Should this message use Text To Speech.\n        flags: Message flags to apply.\n        context: The interaction context to use for the edit\n\n    Returns:\n        New message object with edits applied\n\n    \"\"\"\n    if context:\n        return await context.edit(\n            self,\n            content=content,\n            embeds=embeds,\n            embed=embed,\n            components=components,\n            allowed_mentions=allowed_mentions,\n            attachments=attachments,\n            files=files,\n            file=file,\n            tts=tts,\n        )\n    else:\n        if self.flags == MessageFlags.EPHEMERAL:\n            raise EphemeralEditException\n        message_payload = process_message_payload(\n            content=content,\n            embeds=embeds or embed,\n            components=components,\n            allowed_mentions=allowed_mentions,\n            attachments=attachments,\n            tts=tts,\n            flags=flags,\n        )\n        if file:\n            if files:\n                files = [file, *files]\n            else:\n                files = [file]\n\n        message_data = await self._client.http.edit_message(message_payload, self._channel_id, self.id, files=files)\n        if message_data:\n            return self._client.cache.place_message_data(message_data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.delete","title":"<code>delete(delay=0, *, context=None)</code>  <code>async</code>","text":"<p>Delete message.</p> <p>Parameters:</p> Name Type Description Default <code>delay</code> <code>int</code> <p>Seconds to wait before deleting message.</p> <code>0</code> <code>context</code> <code>InteractionContext | None</code> <p>An optional interaction context to delete ephemeral messages.</p> <code>None</code> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>async def delete(self, delay: int = 0, *, context: \"InteractionContext | None\" = None) -&gt; None:\n\"\"\"\n    Delete message.\n\n    Args:\n        delay: Seconds to wait before deleting message.\n        context: An optional interaction context to delete ephemeral messages.\n\n    \"\"\"\n\n    async def _delete() -&gt; None:\n        if delay:\n            await asyncio.sleep(delay)\n\n        if MessageFlags.EPHEMERAL in self.flags:\n            if not context:\n                raise ValueError(\"Cannot delete ephemeral message without interaction context parameter\")\n            await context.delete(self.id)\n        else:\n            await self._client.http.delete_message(self._channel_id, self.id)\n\n    if delay:\n        asyncio.create_task(_delete())\n    else:\n        return await _delete()\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.reply","title":"<code>reply(content=None, embeds=None, embed=None, **kwargs)</code>  <code>async</code>","text":"<p>Reply to this message, takes all the same attributes as <code>send</code>.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>Optional[str]</code> <p>Message text content.</p> <code>None</code> <code>embeds</code> <code>Optional[Union[List[Union[Embed, dict]], Union[Embed, dict]]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>embed</code> <code>Optional[Union[Embed, dict]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>**kwargs</code> <code>Mapping[str, Any]</code> <p>Additional options to pass to <code>send</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Message</code> <p>New message object.</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>async def reply(\n    self,\n    content: Optional[str] = None,\n    embeds: Optional[Union[List[Union[\"models.Embed\", dict]], Union[\"models.Embed\", dict]]] = None,\n    embed: Optional[Union[\"models.Embed\", dict]] = None,\n    **kwargs: Mapping[str, Any],\n) -&gt; \"Message\":\n\"\"\"\n    Reply to this message, takes all the same attributes as `send`.\n\n    Args:\n        content: Message text content.\n        embeds: Embedded rich content (up to 6000 characters).\n        embed: Embedded rich content (up to 6000 characters).\n        **kwargs: Additional options to pass to `send`.\n\n    Returns:\n        New message object.\n\n    \"\"\"\n    return await self.channel.send(content=content, reply_to=self, embeds=embeds or embed, **kwargs)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.create_thread","title":"<code>create_thread(name, auto_archive_duration=AutoArchiveDuration.ONE_DAY, reason=None)</code>  <code>async</code>","text":"<p>Create a thread from this message.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of this thread</p> required <code>auto_archive_duration</code> <code>Union[AutoArchiveDuration, int]</code> <p>duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080</p> <code>AutoArchiveDuration.ONE_DAY</code> <code>reason</code> <code>Optional[str]</code> <p>The optional reason for creating this thread</p> <code>None</code> <p>Returns:</p> Type Description <code>TYPE_THREAD_CHANNEL</code> <p>The created thread object</p> <p>Raises:</p> Type Description <code>ThreadOutsideOfGuild</code> <p>if this is invoked on a message outside of a guild</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>async def create_thread(\n    self,\n    name: str,\n    auto_archive_duration: Union[AutoArchiveDuration, int] = AutoArchiveDuration.ONE_DAY,\n    reason: Optional[str] = None,\n) -&gt; \"models.TYPE_THREAD_CHANNEL\":\n\"\"\"\n    Create a thread from this message.\n\n    Args:\n        name: The name of this thread\n        auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\n        reason: The optional reason for creating this thread\n\n    Returns:\n        The created thread object\n\n    Raises:\n        ThreadOutsideOfGuild: if this is invoked on a message outside of a guild\n\n    \"\"\"\n    if self.channel.type not in (ChannelTypes.GUILD_TEXT, ChannelTypes.GUILD_NEWS):\n        raise ThreadOutsideOfGuild\n\n    thread_data = await self._client.http.create_thread(\n        channel_id=self._channel_id,\n        name=name,\n        auto_archive_duration=auto_archive_duration,\n        message_id=self.id,\n        reason=reason,\n    )\n    return self._client.cache.place_channel_data(thread_data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.suppress_embeds","title":"<code>suppress_embeds()</code>  <code>async</code>","text":"<p>Suppress embeds for this message.</p> <p>Note</p> <p>Requires the <code>Permissions.MANAGE_MESSAGES</code> permission.</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>async def suppress_embeds(self) -&gt; \"Message\":\n\"\"\"\n    Suppress embeds for this message.\n\n    !!! note\n        Requires the `Permissions.MANAGE_MESSAGES` permission.\n\n    \"\"\"\n    message_data = await self._client.http.edit_message(\n        {\"flags\": MessageFlags.SUPPRESS_EMBEDS}, self._channel_id, self.id\n    )\n    if message_data:\n        return self._client.cache.place_message_data(message_data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.fetch_reaction","title":"<code>fetch_reaction(emoji, limit=MISSING, after=MISSING)</code>  <code>async</code>","text":"<p>Fetches reactions of a specific emoji from this message.</p> <p>Parameters:</p> Name Type Description Default <code>emoji</code> <code>Union[PartialEmoji, dict, str]</code> <p>The emoji to get</p> required <code>limit</code> <code>Absent[int]</code> <p>Max number of users to return (1-100)</p> <code>MISSING</code> <code>after</code> <code>Absent[Snowflake_Type]</code> <p>Get users after this user ID</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>List[User]</code> <p>list of users who have reacted with that emoji</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>async def fetch_reaction(\n    self,\n    emoji: Union[\"models.PartialEmoji\", dict, str],\n    limit: Absent[int] = MISSING,\n    after: Absent[\"Snowflake_Type\"] = MISSING,\n) -&gt; List[\"models.User\"]:\n\"\"\"\n    Fetches reactions of a specific emoji from this message.\n\n    Args:\n        emoji: The emoji to get\n        limit: Max number of users to return (1-100)\n        after: Get users after this user ID\n\n    Returns:\n        list of users who have reacted with that emoji\n\n    \"\"\"\n    reaction_data = await self._client.http.get_reactions(\n        self._channel_id, self.id, emoji, limit, to_optional_snowflake(after)\n    )\n    return [self._client.cache.place_user_data(user_data) for user_data in reaction_data]\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.add_reaction","title":"<code>add_reaction(emoji)</code>  <code>async</code>","text":"<p>Add a reaction to this message.</p> <p>Parameters:</p> Name Type Description Default <code>emoji</code> <code>Union[PartialEmoji, dict, str]</code> <p>the emoji to react with</p> required Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>async def add_reaction(self, emoji: Union[\"models.PartialEmoji\", dict, str]) -&gt; None:\n\"\"\"\n    Add a reaction to this message.\n\n    Args:\n        emoji: the emoji to react with\n\n    \"\"\"\n    emoji = models.process_emoji_req_format(emoji)\n    await self._client.http.create_reaction(self._channel_id, self.id, emoji)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.remove_reaction","title":"<code>remove_reaction(emoji, member=MISSING)</code>  <code>async</code>","text":"<p>Remove a specific reaction that a user reacted with.</p> <p>Parameters:</p> Name Type Description Default <code>emoji</code> <code>Union[PartialEmoji, dict, str]</code> <p>Emoji to remove</p> required <code>member</code> <code>Optional[Union[Member, User, Snowflake_Type]]</code> <p>Member to remove reaction of. Default's to NAFF bot user.</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>async def remove_reaction(\n    self,\n    emoji: Union[\"models.PartialEmoji\", dict, str],\n    member: Optional[Union[\"models.Member\", \"models.User\", \"Snowflake_Type\"]] = MISSING,\n) -&gt; None:\n\"\"\"\n    Remove a specific reaction that a user reacted with.\n\n    Args:\n        emoji: Emoji to remove\n        member: Member to remove reaction of. Default's to NAFF bot user.\n\n    \"\"\"\n    emoji_str = models.process_emoji_req_format(emoji)\n    if not member:\n        member = self._client.user\n    user_id = to_snowflake(member)\n    if user_id == self._client.user.id:\n        await self._client.http.remove_self_reaction(self._channel_id, self.id, emoji_str)\n    else:\n        await self._client.http.remove_user_reaction(self._channel_id, self.id, emoji_str, user_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.clear_reactions","title":"<code>clear_reactions(emoji)</code>  <code>async</code>","text":"<p>Clear a specific reaction from message.</p> <p>Parameters:</p> Name Type Description Default <code>emoji</code> <code>Union[PartialEmoji, dict, str]</code> <p>The emoji to clear</p> required Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>async def clear_reactions(self, emoji: Union[\"models.PartialEmoji\", dict, str]) -&gt; None:\n\"\"\"\n    Clear a specific reaction from message.\n\n    Args:\n        emoji: The emoji to clear\n\n    \"\"\"\n    emoji = models.process_emoji_req_format(emoji)\n    await self._client.http.clear_reaction(self._channel_id, self.id, emoji)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.clear_all_reactions","title":"<code>clear_all_reactions()</code>  <code>async</code>","text":"<p>Clear all emojis from a message.</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>async def clear_all_reactions(self) -&gt; None:\n\"\"\"Clear all emojis from a message.\"\"\"\n    await self._client.http.clear_reactions(self._channel_id, self.id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.pin","title":"<code>pin()</code>  <code>async</code>","text":"<p>Pin message.</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>async def pin(self) -&gt; None:\n\"\"\"Pin message.\"\"\"\n    await self._client.http.pin_message(self._channel_id, self.id)\n    self.pinned = True\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.unpin","title":"<code>unpin()</code>  <code>async</code>","text":"<p>Unpin message.</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>async def unpin(self) -&gt; None:\n\"\"\"Unpin message.\"\"\"\n    await self._client.http.unpin_message(self._channel_id, self.id)\n    self.pinned = False\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.Message.publish","title":"<code>publish()</code>  <code>async</code>","text":"<p>Publish this message.</p> <p>(Discord api calls it \"crosspost\")</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>async def publish(self) -&gt; None:\n\"\"\"\n    Publish this message.\n\n    (Discord api calls it \"crosspost\")\n\n    \"\"\"\n    await self._client.http.crosspost_message(self._channel_id, self.id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.MessageTypes","title":"<code>MessageTypes</code>","text":"<p>         Bases: <code>CursedIntEnum</code></p> <p>Types of message.</p> Source code in <code>naff\\models\\discord\\enums.py</code> <pre><code>class MessageTypes(CursedIntEnum):\n\"\"\"Types of message.\"\"\"\n\n    DEFAULT = 0\n    RECIPIENT_ADD = 1\n    RECIPIENT_REMOVE = 2\n    CALL = 3\n    CHANNEL_NAME_CHANGE = 4\n    CHANNEL_ICON_CHANGE = 5\n    CHANNEL_PINNED_MESSAGE = 6\n    GUILD_MEMBER_JOIN = 7\n    USER_PREMIUM_GUILD_SUBSCRIPTION = 8\n    USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1 = 9\n    USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2 = 10\n    USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3 = 11\n    CHANNEL_FOLLOW_ADD = 12\n    GUILD_DISCOVERY_DISQUALIFIED = 14\n    GUILD_DISCOVERY_REQUALIFIED = 15\n    GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING = 16\n    GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING = 17\n    THREAD_CREATED = 18\n    REPLY = 19\n    APPLICATION_COMMAND = 20\n    THREAD_STARTER_MESSAGE = 21\n    GUILD_INVITE_REMINDER = 22\n    CONTEXT_MENU_COMMAND = 23\n    AUTO_MODERATION_ACTION = 24\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.process_allowed_mentions","title":"<code>process_allowed_mentions(allowed_mentions)</code>","text":"<p>Process allowed mentions into a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>allowed_mentions</code> <code>Optional[Union[AllowedMentions, dict]]</code> <p>Allowed mentions object or dictionary</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Dictionary of allowed mentions</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid allowed mentions</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>def process_allowed_mentions(allowed_mentions: Optional[Union[AllowedMentions, dict]]) -&gt; Optional[dict]:\n\"\"\"\n    Process allowed mentions into a dictionary.\n\n    Args:\n        allowed_mentions: Allowed mentions object or dictionary\n\n    Returns:\n        Dictionary of allowed mentions\n\n    Raises:\n        ValueError: Invalid allowed mentions\n\n    \"\"\"\n    if not allowed_mentions:\n        return allowed_mentions\n\n    if isinstance(allowed_mentions, dict):\n        return allowed_mentions\n\n    if isinstance(allowed_mentions, AllowedMentions):\n        return allowed_mentions.to_dict()\n\n    raise ValueError(f\"Invalid allowed mentions: {allowed_mentions}\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.process_message_reference","title":"<code>process_message_reference(message_reference)</code>","text":"<p>Process mention references into a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>message_reference</code> <code>Optional[Union[MessageReference, Message, dict, Snowflake_Type]]</code> <p>Message reference object</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Message reference dictionary</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid message reference</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>def process_message_reference(\n    message_reference: Optional[Union[MessageReference, Message, dict, \"Snowflake_Type\"]]\n) -&gt; Optional[dict]:\n\"\"\"\n    Process mention references into a dictionary.\n\n    Args:\n        message_reference: Message reference object\n\n    Returns:\n        Message reference dictionary\n\n    Raises:\n        ValueError: Invalid message reference\n\n    \"\"\"\n    if not message_reference:\n        return message_reference\n\n    if isinstance(message_reference, dict):\n        return message_reference\n\n    if isinstance(message_reference, (str, int)):\n        message_reference = MessageReference(message_id=message_reference)\n\n    if isinstance(message_reference, Message):\n        message_reference = MessageReference.for_message(message_reference)\n\n    if isinstance(message_reference, MessageReference):\n        return message_reference.to_dict()\n\n    raise ValueError(f\"Invalid message reference: {message_reference}\")\n</code></pre>"},{"location":"API%20Reference/models/Discord/message/#naff.models.discord.message.process_message_payload","title":"<code>process_message_payload(content=None, embeds=None, components=None, stickers=None, allowed_mentions=None, reply_to=None, attachments=None, tts=False, flags=None, **kwargs)</code>","text":"<p>Format message content for it to be ready to send discord.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>Optional[str]</code> <p>Message text content.</p> <code>None</code> <code>embeds</code> <code>Optional[Union[List[Union[Embed, dict]], Union[Embed, dict]]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>components</code> <code>Optional[Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict]]</code> <p>The components to include with the message.</p> <code>None</code> <code>stickers</code> <code>Optional[Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type]]</code> <p>IDs of up to 3 stickers in the server to send in the message.</p> <code>None</code> <code>allowed_mentions</code> <code>Optional[Union[AllowedMentions, dict]]</code> <p>Allowed mentions for the message.</p> <code>None</code> <code>reply_to</code> <code>Optional[Union[MessageReference, Message, dict, Snowflake_Type]]</code> <p>Message to reference, must be from the same channel.</p> <code>None</code> <code>attachments</code> <code>Optional[List[Union[Attachment, dict]]]</code> <p>The attachments to keep, only used when editing message.</p> <code>None</code> <code>tts</code> <code>bool</code> <p>Should this message use Text To Speech.</p> <code>False</code> <code>flags</code> <code>Optional[Union[int, MessageFlags]]</code> <p>Message flags to apply.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary</p> Source code in <code>naff\\models\\discord\\message.py</code> <pre><code>def process_message_payload(\n    content: Optional[str] = None,\n    embeds: Optional[Union[List[Union[\"models.Embed\", dict]], Union[\"models.Embed\", dict]]] = None,\n    components: Optional[\n        Union[\n            List[List[Union[\"models.BaseComponent\", dict]]],\n            List[Union[\"models.BaseComponent\", dict]],\n            \"models.BaseComponent\",\n            dict,\n        ]\n    ] = None,\n    stickers: Optional[\n        Union[List[Union[\"models.Sticker\", \"Snowflake_Type\"]], \"models.Sticker\", \"Snowflake_Type\"]\n    ] = None,\n    allowed_mentions: Optional[Union[AllowedMentions, dict]] = None,\n    reply_to: Optional[Union[MessageReference, Message, dict, \"Snowflake_Type\"]] = None,\n    attachments: Optional[List[Union[Attachment, dict]]] = None,\n    tts: bool = False,\n    flags: Optional[Union[int, MessageFlags]] = None,\n    **kwargs,\n) -&gt; dict:\n\"\"\"\n    Format message content for it to be ready to send discord.\n\n    Args:\n        content: Message text content.\n        embeds: Embedded rich content (up to 6000 characters).\n        components: The components to include with the message.\n        stickers: IDs of up to 3 stickers in the server to send in the message.\n        allowed_mentions: Allowed mentions for the message.\n        reply_to: Message to reference, must be from the same channel.\n        attachments: The attachments to keep, only used when editing message.\n        tts: Should this message use Text To Speech.\n        flags: Message flags to apply.\n\n    Returns:\n        Dictionary\n\n    \"\"\"\n    embeds = models.process_embeds(embeds)\n    if isinstance(embeds, list):\n        embeds = embeds if all(e is not None for e in embeds) else None\n\n    components = models.process_components(components)\n    if stickers:\n        stickers = [to_snowflake(sticker) for sticker in stickers]\n    allowed_mentions = process_allowed_mentions(allowed_mentions)\n    message_reference = process_message_reference(reply_to)\n    if attachments:\n        attachments = [attachment.to_dict() for attachment in attachments]\n\n    return dict_filter_none(\n        {\n            \"content\": content,\n            \"embeds\": embeds,\n            \"components\": components,\n            \"sticker_ids\": stickers,\n            \"allowed_mentions\": allowed_mentions,\n            \"message_reference\": message_reference,\n            \"attachments\": attachments,\n            \"tts\": tts,\n            \"flags\": flags,\n            **kwargs,\n        }\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/modals/","title":"Modals","text":""},{"location":"API%20Reference/models/Discord/modals/#naff.models.discord.modal.InputText","title":"<code>InputText</code>","text":"<p>         Bases: <code>InteractiveComponent</code></p> <p>An input component for modals</p> Source code in <code>naff\\models\\discord\\modal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass InputText(InteractiveComponent):\n\"\"\"An input component for modals\"\"\"\n\n    type: Union[ComponentTypes, int] = attrs.field(\n        repr=False, default=ComponentTypes.INPUT_TEXT, init=False, on_setattr=attrs.setters.frozen\n    )\n\n    label: str = attrs.field(repr=False, validator=str_validator)\n\"\"\"the label for this component\"\"\"\n    style: Union[TextStyles, int] = attrs.field(\n        repr=False,\n    )\n\"\"\"the Text Input Style for single or multiple lines input\"\"\"\n\n    custom_id: Optional[str] = attrs.field(repr=False, factory=lambda: str(uuid.uuid4()), validator=str_validator)\n\"\"\"a developer-defined identifier for the input, max 100 characters\"\"\"\n\n    placeholder: Optional[str] = attrs.field(repr=False, default=MISSING, validator=str_validator, kw_only=True)\n\"\"\"custom placeholder text if the input is empty, max 100 characters\"\"\"\n    value: Optional[str] = attrs.field(repr=False, default=MISSING, validator=str_validator, kw_only=True)\n\"\"\"a pre-filled value for this component, max 4000 characters\"\"\"\n\n    required: bool = attrs.field(repr=False, default=True, kw_only=True)\n\"\"\"whether this component is required to be filled, default true\"\"\"\n    min_length: Optional[int] = attrs.field(repr=False, default=MISSING, kw_only=True)\n\"\"\"the minimum input length for a text input, min 0, max 4000\"\"\"\n    max_length: Optional[int] = attrs.field(repr=False, default=MISSING, kw_only=True)\n\"\"\"the maximum input length for a text input, min 1, max 4000. Must be more than min_length.\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/modals/#naff.models.discord.modal.InputText.label","title":"<code>label: str = attrs.field(repr=False, validator=str_validator)</code>  <code>class-attribute</code>","text":"<p>the label for this component</p>"},{"location":"API%20Reference/models/Discord/modals/#naff.models.discord.modal.InputText.style","title":"<code>style: Union[TextStyles, int] = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>the Text Input Style for single or multiple lines input</p>"},{"location":"API%20Reference/models/Discord/modals/#naff.models.discord.modal.InputText.custom_id","title":"<code>custom_id: Optional[str] = attrs.field(repr=False, factory=lambda : str(uuid.uuid4()), validator=str_validator)</code>  <code>class-attribute</code>","text":"<p>a developer-defined identifier for the input, max 100 characters</p>"},{"location":"API%20Reference/models/Discord/modals/#naff.models.discord.modal.InputText.placeholder","title":"<code>placeholder: Optional[str] = attrs.field(repr=False, default=MISSING, validator=str_validator, kw_only=True)</code>  <code>class-attribute</code>","text":"<p>custom placeholder text if the input is empty, max 100 characters</p>"},{"location":"API%20Reference/models/Discord/modals/#naff.models.discord.modal.InputText.value","title":"<code>value: Optional[str] = attrs.field(repr=False, default=MISSING, validator=str_validator, kw_only=True)</code>  <code>class-attribute</code>","text":"<p>a pre-filled value for this component, max 4000 characters</p>"},{"location":"API%20Reference/models/Discord/modals/#naff.models.discord.modal.InputText.required","title":"<code>required: bool = attrs.field(repr=False, default=True, kw_only=True)</code>  <code>class-attribute</code>","text":"<p>whether this component is required to be filled, default true</p>"},{"location":"API%20Reference/models/Discord/modals/#naff.models.discord.modal.InputText.min_length","title":"<code>min_length: Optional[int] = attrs.field(repr=False, default=MISSING, kw_only=True)</code>  <code>class-attribute</code>","text":"<p>the minimum input length for a text input, min 0, max 4000</p>"},{"location":"API%20Reference/models/Discord/modals/#naff.models.discord.modal.InputText.max_length","title":"<code>max_length: Optional[int] = attrs.field(repr=False, default=MISSING, kw_only=True)</code>  <code>class-attribute</code>","text":"<p>the maximum input length for a text input, min 1, max 4000. Must be more than min_length.</p>"},{"location":"API%20Reference/models/Discord/modals/#naff.models.discord.modal.ShortText","title":"<code>ShortText</code>","text":"<p>         Bases: <code>InputText</code></p> <p>A single line input component for modals</p> Source code in <code>naff\\models\\discord\\modal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ShortText(InputText):\n\"\"\"A single line input component for modals\"\"\"\n\n    style: Union[TextStyles, int] = attrs.field(repr=False, default=TextStyles.SHORT, kw_only=True)\n</code></pre>"},{"location":"API%20Reference/models/Discord/modals/#naff.models.discord.modal.ParagraphText","title":"<code>ParagraphText</code>","text":"<p>         Bases: <code>InputText</code></p> <p>A multi line input component for modals</p> Source code in <code>naff\\models\\discord\\modal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass ParagraphText(InputText):\n\"\"\"A multi line input component for modals\"\"\"\n\n    style: Union[TextStyles, int] = attrs.field(repr=False, default=TextStyles.PARAGRAPH, kw_only=True)\n</code></pre>"},{"location":"API%20Reference/models/Discord/modals/#naff.models.discord.modal.Modal","title":"<code>Modal</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> <p>Form submission style component on discord</p> Source code in <code>naff\\models\\discord\\modal.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass Modal(DictSerializationMixin):\n\"\"\"Form submission style component on discord\"\"\"\n\n    type: Union[CallbackTypes, int] = attrs.field(\n        repr=False, default=CallbackTypes.MODAL, init=False, on_setattr=attrs.setters.frozen\n    )\n    title: str = attrs.field(repr=False, validator=str_validator)\n\"\"\"the title of the popup modal, max 45 characters\"\"\"\n    components: List[InputText] = attrs.field(\n        repr=False,\n    )\n\"\"\"between 1 and 5 (inclusive) components that make up the modal\"\"\"\n    custom_id: Optional[str] = attrs.field(repr=False, factory=lambda: str(uuid.uuid4()), validator=str_validator)\n\"\"\"a developer-defined identifier for the component, max 100 characters\"\"\"\n\n    def __attrs_post_init__(self) -&gt; None:\n        if self.custom_id is MISSING:\n            self.custom_id = str(uuid.uuid4())\n\n    def to_dict(self) -&gt; dict:\n        data = super().to_dict()\n        components = [{\"type\": ComponentTypes.ACTION_ROW, \"components\": [c]} for c in data.get(\"components\", [])]\n        return {\n            \"type\": data[\"type\"],\n            \"data\": {\"custom_id\": data[\"custom_id\"], \"title\": data[\"title\"], \"components\": components},\n        }\n</code></pre>"},{"location":"API%20Reference/models/Discord/modals/#naff.models.discord.modal.Modal.title","title":"<code>title: str = attrs.field(repr=False, validator=str_validator)</code>  <code>class-attribute</code>","text":"<p>the title of the popup modal, max 45 characters</p>"},{"location":"API%20Reference/models/Discord/modals/#naff.models.discord.modal.Modal.components","title":"<code>components: List[InputText] = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>between 1 and 5 (inclusive) components that make up the modal</p>"},{"location":"API%20Reference/models/Discord/modals/#naff.models.discord.modal.Modal.custom_id","title":"<code>custom_id: Optional[str] = attrs.field(repr=False, factory=lambda : str(uuid.uuid4()), validator=str_validator)</code>  <code>class-attribute</code>","text":"<p>a developer-defined identifier for the component, max 100 characters</p>"},{"location":"API%20Reference/models/Discord/reaction/","title":"Reaction","text":""},{"location":"API%20Reference/models/Discord/reaction/#naff.models.discord.reaction.ReactionUsers","title":"<code>ReactionUsers</code>","text":"<p>         Bases: <code>AsyncIterator</code></p> <p>An async iterator for searching through a channel's history.</p> <p>Attributes:</p> Name Type Description <code>reaction</code> <code>Reaction</code> <p>The reaction to search through</p> <code>limit</code> <code>Reaction</code> <p>The maximum number of users to return (set to 0 for no limit)</p> <code>after</code> <code>Snowflake_Type</code> <p>get users after this message ID</p> Source code in <code>naff\\models\\discord\\reaction.py</code> <pre><code>class ReactionUsers(AsyncIterator):\n\"\"\"\n    An async iterator for searching through a channel's history.\n\n    Attributes:\n        reaction: The reaction to search through\n        limit: The maximum number of users to return (set to 0 for no limit)\n        after: get users after this message ID\n\n    \"\"\"\n\n    def __init__(self, reaction: \"Reaction\", limit: int = 50, after: Optional[\"Snowflake_Type\"] = None) -&gt; None:\n        self.reaction: \"Reaction\" = reaction\n        self.after: \"Snowflake_Type\" = after\n        self._more = True\n        super().__init__(limit)\n\n    async def fetch(self) -&gt; List[\"User\"]:\n\"\"\"\n        Gets all the users who reacted to the message. Requests user data from discord API if not cached.\n\n        Returns:\n            A list of users who reacted to the message.\n\n        \"\"\"\n        if self._more:\n            expected = self.get_limit\n\n            if self.after and not self.last:\n                self.last = namedtuple(\"temp\", \"id\")\n                self.last.id = self.after\n\n            users = await self.reaction._client.http.get_reactions(\n                self.reaction._channel_id,\n                self.reaction._message_id,\n                self.reaction.emoji.req_format,\n                limit=expected,\n                after=self.last.id or MISSING,\n            )\n            if not users:\n                raise QueueEmpty\n            self._more = len(users) == expected\n            return [self.reaction._client.cache.place_user_data(u) for u in users]\n        else:\n            raise QueueEmpty\n</code></pre>"},{"location":"API%20Reference/models/Discord/reaction/#naff.models.discord.reaction.ReactionUsers.fetch","title":"<code>fetch()</code>  <code>async</code>","text":"<p>Gets all the users who reacted to the message. Requests user data from discord API if not cached.</p> <p>Returns:</p> Type Description <code>List[User]</code> <p>A list of users who reacted to the message.</p> Source code in <code>naff\\models\\discord\\reaction.py</code> <pre><code>async def fetch(self) -&gt; List[\"User\"]:\n\"\"\"\n    Gets all the users who reacted to the message. Requests user data from discord API if not cached.\n\n    Returns:\n        A list of users who reacted to the message.\n\n    \"\"\"\n    if self._more:\n        expected = self.get_limit\n\n        if self.after and not self.last:\n            self.last = namedtuple(\"temp\", \"id\")\n            self.last.id = self.after\n\n        users = await self.reaction._client.http.get_reactions(\n            self.reaction._channel_id,\n            self.reaction._message_id,\n            self.reaction.emoji.req_format,\n            limit=expected,\n            after=self.last.id or MISSING,\n        )\n        if not users:\n            raise QueueEmpty\n        self._more = len(users) == expected\n        return [self.reaction._client.cache.place_user_data(u) for u in users]\n    else:\n        raise QueueEmpty\n</code></pre>"},{"location":"API%20Reference/models/Discord/reaction/#naff.models.discord.reaction.Reaction","title":"<code>Reaction</code>","text":"<p>         Bases: <code>ClientObject</code></p> Source code in <code>naff\\models\\discord\\reaction.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass Reaction(ClientObject):\n    count: int = attrs.field(\n        repr=False,\n    )\n\"\"\"times this emoji has been used to react\"\"\"\n    me: bool = attrs.field(repr=False, default=False)\n\"\"\"whether the current user reacted using this emoji\"\"\"\n    emoji: \"PartialEmoji\" = attrs.field(repr=False, converter=PartialEmoji.from_dict)\n\"\"\"emoji information\"\"\"\n\n    _channel_id: \"Snowflake_Type\" = attrs.field(repr=False, converter=to_snowflake)\n    _message_id: \"Snowflake_Type\" = attrs.field(repr=False, converter=to_snowflake)\n\n    def users(self, limit: int = 0, after: \"Snowflake_Type\" = None) -&gt; ReactionUsers:\n\"\"\"Users who reacted using this emoji.\"\"\"\n        return ReactionUsers(self, limit, after)\n\n    @property\n    def message(self) -&gt; \"Message\":\n\"\"\"The message this reaction is on.\"\"\"\n        return self._client.cache.get_message(self._channel_id, self._message_id)\n\n    @property\n    def channel(self) -&gt; \"TYPE_ALL_CHANNEL\":\n\"\"\"The channel this reaction is on.\"\"\"\n        return self._client.cache.get_channel(self._channel_id)\n\n    async def remove(self) -&gt; None:\n\"\"\"Remove all this emoji's reactions from the message.\"\"\"\n        await self._client.http.clear_reaction(self._channel_id, self._message_id, self.emoji.req_format)\n</code></pre>"},{"location":"API%20Reference/models/Discord/reaction/#naff.models.discord.reaction.Reaction.count","title":"<code>count: int = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>times this emoji has been used to react</p>"},{"location":"API%20Reference/models/Discord/reaction/#naff.models.discord.reaction.Reaction.me","title":"<code>me: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>whether the current user reacted using this emoji</p>"},{"location":"API%20Reference/models/Discord/reaction/#naff.models.discord.reaction.Reaction.emoji","title":"<code>emoji: PartialEmoji = attrs.field(repr=False, converter=PartialEmoji.from_dict)</code>  <code>class-attribute</code>","text":"<p>emoji information</p>"},{"location":"API%20Reference/models/Discord/reaction/#naff.models.discord.reaction.Reaction.users","title":"<code>users(limit=0, after=None)</code>","text":"<p>Users who reacted using this emoji.</p> Source code in <code>naff\\models\\discord\\reaction.py</code> <pre><code>def users(self, limit: int = 0, after: \"Snowflake_Type\" = None) -&gt; ReactionUsers:\n\"\"\"Users who reacted using this emoji.\"\"\"\n    return ReactionUsers(self, limit, after)\n</code></pre>"},{"location":"API%20Reference/models/Discord/reaction/#naff.models.discord.reaction.Reaction.message","title":"<code>message: Message</code>  <code>property</code>","text":"<p>The message this reaction is on.</p>"},{"location":"API%20Reference/models/Discord/reaction/#naff.models.discord.reaction.Reaction.channel","title":"<code>channel: TYPE_ALL_CHANNEL</code>  <code>property</code>","text":"<p>The channel this reaction is on.</p>"},{"location":"API%20Reference/models/Discord/reaction/#naff.models.discord.reaction.Reaction.remove","title":"<code>remove()</code>  <code>async</code>","text":"<p>Remove all this emoji's reactions from the message.</p> Source code in <code>naff\\models\\discord\\reaction.py</code> <pre><code>async def remove(self) -&gt; None:\n\"\"\"Remove all this emoji's reactions from the message.\"\"\"\n    await self._client.http.clear_reaction(self._channel_id, self._message_id, self.emoji.req_format)\n</code></pre>"},{"location":"API%20Reference/models/Discord/role/","title":"Role","text":""},{"location":"API%20Reference/models/Discord/role/#naff.models.discord.role.Role","title":"<code>Role</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\role.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\n@total_ordering\nclass Role(DiscordObject):\n    _sentinel = object()\n\n    name: str = attrs.field(repr=True)\n    color: \"Color\" = attrs.field(repr=False, converter=Color)\n    hoist: bool = attrs.field(repr=False, default=False)\n    position: int = attrs.field(repr=True)\n    permissions: \"Permissions\" = attrs.field(repr=False, converter=Permissions)\n    managed: bool = attrs.field(repr=False, default=False)\n    mentionable: bool = attrs.field(repr=False, default=True)\n    premium_subscriber: bool = attrs.field(\n        repr=False, default=_sentinel, converter=partial(sentinel_converter, sentinel=_sentinel)\n    )\n    _icon: Asset | None = attrs.field(repr=False, default=None)\n    _unicode_emoji: PartialEmoji | None = attrs.field(\n        repr=False, default=None, converter=optional_c(PartialEmoji.from_str)\n    )\n    _guild_id: \"Snowflake_Type\" = attrs.field(\n        repr=False,\n    )\n    _bot_id: \"Snowflake_Type | None\" = attrs.field(repr=False, default=None)\n    _integration_id: \"Snowflake_Type | None\" = attrs.field(repr=False, default=None)  # todo integration object?\n\n    def __lt__(self: \"Role\", other: \"Role\") -&gt; bool:\n        if not isinstance(self, Role) or not isinstance(other, Role):\n            return NotImplemented\n\n        if self._guild_id != other._guild_id:\n            raise RuntimeError(\"Unable to compare Roles from different guilds.\")\n\n        if self.id == self._guild_id:  # everyone role\n            # everyone role is on the bottom, so check if the other role is, well, not it\n            # because then it must be higher than it\n            return other.id != self.id\n\n        if self.position &lt; other.position:\n            return True\n\n        if self.position == other.position:\n            # if two roles have the same position, which can happen thanks to discord, then\n            # we can thankfully use their ids to determine which one is lower\n            return self.id &lt; other.id\n\n        return False\n\n    @classmethod\n    def _process_dict(cls, data: dict[str, Any], client: \"Client\") -&gt; dict[str, Any]:\n        data.update(data.pop(\"tags\", {}))\n\n        if icon_hash := data.get(\"icon\"):\n            data[\"icon\"] = Asset.from_path_hash(client, f\"role-icons/{data['id']}/{{}}\", icon_hash)\n\n        return data\n\n    async def fetch_bot(self) -&gt; \"Member | None\":\n\"\"\"\n        Fetch the bot associated with this role if any.\n\n        Returns:\n            Member object if any\n\n        \"\"\"\n        if self._bot_id is None:\n            return None\n        return await self._client.cache.fetch_member(self._guild_id, self._bot_id)\n\n    def get_bot(self) -&gt; \"Member | None\":\n\"\"\"\n        Get the bot associated with this role if any.\n\n        Returns:\n            Member object if any\n\n        \"\"\"\n        if self._bot_id is None:\n            return None\n        return self._client.cache.get_member(self._guild_id, self._bot_id)\n\n    @property\n    def guild(self) -&gt; \"Guild\":\n\"\"\"The guild object this role is from.\"\"\"\n        return self._client.cache.get_guild(self._guild_id)  # pyright: ignore [reportGeneralTypeIssues]\n\n    @property\n    def default(self) -&gt; bool:\n\"\"\"Is this the `@everyone` role.\"\"\"\n        return self.id == self._guild_id\n\n    @property\n    def bot_managed(self) -&gt; bool:\n\"\"\"Is this role owned/managed by a bot.\"\"\"\n        return self._bot_id is not None\n\n    @property\n    def mention(self) -&gt; str:\n\"\"\"Returns a string that would mention the role.\"\"\"\n        return f\"&lt;@&amp;{self.id}&gt;\" if self.id != self._guild_id else \"@everyone\"\n\n    @property\n    def integration(self) -&gt; bool:\n\"\"\"Is this role owned/managed by an integration.\"\"\"\n        return self._integration_id is not None\n\n    @property\n    def members(self) -&gt; list[\"Member\"]:\n\"\"\"List of members with this role\"\"\"\n        return [member for member in self.guild.members if member.has_role(self)]\n\n    @property\n    def icon(self) -&gt; Asset | PartialEmoji | None:\n\"\"\"\n        The icon of this role\n\n        !!! note\n            You have to use this method instead of the `_icon` attribute, because the first does account for unicode emojis\n        \"\"\"\n        return self._icon or self._unicode_emoji\n\n    @property\n    def is_assignable(self) -&gt; bool:\n\"\"\"\n        Can this role be assigned or removed by this bot?\n\n        !!! note\n            This does not account for permissions, only the role hierarchy\n\n        \"\"\"\n        return (self.default or self.guild.me.top_role &gt; self) and not self.managed\n\n    async def delete(self, reason: str | Missing = MISSING) -&gt; None:\n\"\"\"\n        Delete this role.\n\n        Args:\n            reason: An optional reason for this deletion\n\n        \"\"\"\n        await self._client.http.delete_guild_role(self._guild_id, self.id, reason)\n\n    async def edit(\n        self,\n        *,\n        name: str | None = None,\n        permissions: str | None = None,\n        color: Color | COLOR_TYPES | None = None,\n        hoist: bool | None = None,\n        mentionable: bool | None = None,\n    ) -&gt; \"Role\":\n\"\"\"\n        Edit this role, all arguments are optional.\n\n        Args:\n            name: name of the role\n            permissions: New permissions to use\n            color: The color of the role\n            hoist: whether the role should be displayed separately in the sidebar\n            mentionable: whether the role should be mentionable\n\n        Returns:\n            Role with updated information\n\n        \"\"\"\n        color = process_color(color)\n\n        payload = dict_filter(\n            {\"name\": name, \"permissions\": permissions, \"color\": color, \"hoist\": hoist, \"mentionable\": mentionable}\n        )\n\n        r_data = await self._client.http.modify_guild_role(self._guild_id, self.id, payload)\n        r_data = dict(r_data)  # to convert typed dict to regular dict\n        r_data[\"guild_id\"] = self._guild_id\n        return self.from_dict(r_data, self._client)\n\n    async def move(self, position: int, reason: str | Missing = MISSING) -&gt; \"Role\":\n\"\"\"\n        Move this role to a new position.\n\n        Args:\n            position: The new position of the role\n            reason: An optional reason for this move\n\n        Returns:\n            The role object\n\n        \"\"\"\n        await self._client.http.modify_guild_role_positions(\n            self._guild_id, [{\"id\": self.id, \"position\": position}], reason\n        )\n        return self\n</code></pre>"},{"location":"API%20Reference/models/Discord/role/#naff.models.discord.role.Role.fetch_bot","title":"<code>fetch_bot()</code>  <code>async</code>","text":"<p>Fetch the bot associated with this role if any.</p> <p>Returns:</p> Type Description <code>Member | None</code> <p>Member object if any</p> Source code in <code>naff\\models\\discord\\role.py</code> <pre><code>async def fetch_bot(self) -&gt; \"Member | None\":\n\"\"\"\n    Fetch the bot associated with this role if any.\n\n    Returns:\n        Member object if any\n\n    \"\"\"\n    if self._bot_id is None:\n        return None\n    return await self._client.cache.fetch_member(self._guild_id, self._bot_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/role/#naff.models.discord.role.Role.get_bot","title":"<code>get_bot()</code>","text":"<p>Get the bot associated with this role if any.</p> <p>Returns:</p> Type Description <code>Member | None</code> <p>Member object if any</p> Source code in <code>naff\\models\\discord\\role.py</code> <pre><code>def get_bot(self) -&gt; \"Member | None\":\n\"\"\"\n    Get the bot associated with this role if any.\n\n    Returns:\n        Member object if any\n\n    \"\"\"\n    if self._bot_id is None:\n        return None\n    return self._client.cache.get_member(self._guild_id, self._bot_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/role/#naff.models.discord.role.Role.guild","title":"<code>guild: Guild</code>  <code>property</code>","text":"<p>The guild object this role is from.</p>"},{"location":"API%20Reference/models/Discord/role/#naff.models.discord.role.Role.default","title":"<code>default: bool</code>  <code>property</code>","text":"<p>Is this the <code>@everyone</code> role.</p>"},{"location":"API%20Reference/models/Discord/role/#naff.models.discord.role.Role.bot_managed","title":"<code>bot_managed: bool</code>  <code>property</code>","text":"<p>Is this role owned/managed by a bot.</p>"},{"location":"API%20Reference/models/Discord/role/#naff.models.discord.role.Role.mention","title":"<code>mention: str</code>  <code>property</code>","text":"<p>Returns a string that would mention the role.</p>"},{"location":"API%20Reference/models/Discord/role/#naff.models.discord.role.Role.integration","title":"<code>integration: bool</code>  <code>property</code>","text":"<p>Is this role owned/managed by an integration.</p>"},{"location":"API%20Reference/models/Discord/role/#naff.models.discord.role.Role.members","title":"<code>members: list[Member]</code>  <code>property</code>","text":"<p>List of members with this role</p>"},{"location":"API%20Reference/models/Discord/role/#naff.models.discord.role.Role.icon","title":"<code>icon: Asset | PartialEmoji | None</code>  <code>property</code>","text":"<p>The icon of this role</p> <p>Note</p> <p>You have to use this method instead of the <code>_icon</code> attribute, because the first does account for unicode emojis</p>"},{"location":"API%20Reference/models/Discord/role/#naff.models.discord.role.Role.is_assignable","title":"<code>is_assignable: bool</code>  <code>property</code>","text":"<p>Can this role be assigned or removed by this bot?</p> <p>Note</p> <p>This does not account for permissions, only the role hierarchy</p>"},{"location":"API%20Reference/models/Discord/role/#naff.models.discord.role.Role.delete","title":"<code>delete(reason=MISSING)</code>  <code>async</code>","text":"<p>Delete this role.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>str | Missing</code> <p>An optional reason for this deletion</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\role.py</code> <pre><code>async def delete(self, reason: str | Missing = MISSING) -&gt; None:\n\"\"\"\n    Delete this role.\n\n    Args:\n        reason: An optional reason for this deletion\n\n    \"\"\"\n    await self._client.http.delete_guild_role(self._guild_id, self.id, reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/role/#naff.models.discord.role.Role.edit","title":"<code>edit(*, name=None, permissions=None, color=None, hoist=None, mentionable=None)</code>  <code>async</code>","text":"<p>Edit this role, all arguments are optional.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>name of the role</p> <code>None</code> <code>permissions</code> <code>str | None</code> <p>New permissions to use</p> <code>None</code> <code>color</code> <code>Color | COLOR_TYPES | None</code> <p>The color of the role</p> <code>None</code> <code>hoist</code> <code>bool | None</code> <p>whether the role should be displayed separately in the sidebar</p> <code>None</code> <code>mentionable</code> <code>bool | None</code> <p>whether the role should be mentionable</p> <code>None</code> <p>Returns:</p> Type Description <code>Role</code> <p>Role with updated information</p> Source code in <code>naff\\models\\discord\\role.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: str | None = None,\n    permissions: str | None = None,\n    color: Color | COLOR_TYPES | None = None,\n    hoist: bool | None = None,\n    mentionable: bool | None = None,\n) -&gt; \"Role\":\n\"\"\"\n    Edit this role, all arguments are optional.\n\n    Args:\n        name: name of the role\n        permissions: New permissions to use\n        color: The color of the role\n        hoist: whether the role should be displayed separately in the sidebar\n        mentionable: whether the role should be mentionable\n\n    Returns:\n        Role with updated information\n\n    \"\"\"\n    color = process_color(color)\n\n    payload = dict_filter(\n        {\"name\": name, \"permissions\": permissions, \"color\": color, \"hoist\": hoist, \"mentionable\": mentionable}\n    )\n\n    r_data = await self._client.http.modify_guild_role(self._guild_id, self.id, payload)\n    r_data = dict(r_data)  # to convert typed dict to regular dict\n    r_data[\"guild_id\"] = self._guild_id\n    return self.from_dict(r_data, self._client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/role/#naff.models.discord.role.Role.move","title":"<code>move(position, reason=MISSING)</code>  <code>async</code>","text":"<p>Move this role to a new position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int</code> <p>The new position of the role</p> required <code>reason</code> <code>str | Missing</code> <p>An optional reason for this move</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Role</code> <p>The role object</p> Source code in <code>naff\\models\\discord\\role.py</code> <pre><code>async def move(self, position: int, reason: str | Missing = MISSING) -&gt; \"Role\":\n\"\"\"\n    Move this role to a new position.\n\n    Args:\n        position: The new position of the role\n        reason: An optional reason for this move\n\n    Returns:\n        The role object\n\n    \"\"\"\n    await self._client.http.modify_guild_role_positions(\n        self._guild_id, [{\"id\": self.id, \"position\": position}], reason\n    )\n    return self\n</code></pre>"},{"location":"API%20Reference/models/Discord/scheduled_event/","title":"Scheduled event","text":""},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent","title":"<code>ScheduledEvent</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\scheduled_event.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ScheduledEvent(DiscordObject):\n    name: str = attrs.field(repr=True)\n    description: str = attrs.field(repr=False, default=MISSING)\n    entity_type: Union[ScheduledEventType, int] = attrs.field(repr=False, converter=ScheduledEventType)\n\"\"\"The type of the scheduled event\"\"\"\n    start_time: Timestamp = attrs.field(repr=False, converter=timestamp_converter)\n\"\"\"A Timestamp object representing the scheduled start time of the event \"\"\"\n    end_time: Optional[Timestamp] = attrs.field(repr=False, default=None, converter=optional(timestamp_converter))\n\"\"\"Optional Timstamp object representing the scheduled end time, required if entity_type is EXTERNAL\"\"\"\n    privacy_level: Union[ScheduledEventPrivacyLevel, int] = attrs.field(\n        repr=False, converter=ScheduledEventPrivacyLevel\n    )\n\"\"\"\n    Privacy level of the scheduled event\n\n    ??? note\n        Discord only has `GUILD_ONLY` at the momment.\n    \"\"\"\n    status: Union[ScheduledEventStatus, int] = attrs.field(repr=False, converter=ScheduledEventStatus)\n\"\"\"Current status of the scheduled event\"\"\"\n    entity_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=MISSING, converter=optional(to_snowflake))\n\"\"\"The id of an entity associated with a guild scheduled event\"\"\"\n    entity_metadata: Optional[Dict[str, Any]] = attrs.field(repr=False, default=MISSING)  # TODO make this\n\"\"\"The metadata associated with the entity_type\"\"\"\n    user_count: int = attrs.field(repr=False, default=MISSING)\n\"\"\"Amount of users subscribed to the scheduled event\"\"\"\n    cover: Asset | None = attrs.field(repr=False, default=None)\n\"\"\"The cover image of this event\"\"\"\n\n    _guild_id: \"Snowflake_Type\" = attrs.field(repr=False, converter=to_snowflake)\n    _creator: Optional[\"User\"] = attrs.field(repr=False, default=MISSING)\n    _creator_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=MISSING, converter=optional(to_snowflake))\n    _channel_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))\n\n    @property\n    async def creator(self) -&gt; Optional[\"User\"]:\n\"\"\"\n        Returns the user who created this event.\n\n        !!! note\n            Events made before October 25th, 2021 will not have a creator.\n\n        \"\"\"\n        return await self._client.cache.fetch_user(self._creator_id) if self._creator_id else None\n\n    @property\n    def guild(self) -&gt; \"Guild\":\n        return self._client.cache.get_guild(self._guild_id)\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        if data.get(\"creator\"):\n            data[\"creator\"] = client.cache.place_user_data(data[\"creator\"])\n\n        if data.get(\"channel_id\"):\n            data[\"channel\"] = client.cache.get_channel(data[\"channel_id\"])\n\n        data[\"start_time\"] = data.get(\"scheduled_start_time\")\n\n        if end_time := data.get(\"scheduled_end_time\"):\n            data[\"end_time\"] = end_time\n        else:\n            data[\"end_time\"] = None\n\n        if image := data.get(\"image\"):\n            data[\"cover\"] = Asset.from_path_hash(client, f\"guild-events/{data['id']}/{{}}\", image)\n\n        data = super()._process_dict(data, client)\n        return data\n\n    @property\n    def location(self) -&gt; Optional[str]:\n\"\"\"Returns the external locatian of this event.\"\"\"\n        if self.entity_type == ScheduledEventType.EXTERNAL:\n            return self.entity_metadata[\"location\"]\n        return None\n\n    async def fetch_channel(self) -&gt; Optional[Union[\"GuildVoice\", \"GuildStageVoice\"]]:\n\"\"\"Returns the channel this event is scheduled in if it is scheduled in a channel.\"\"\"\n        if self._channel_id:\n            return await self._client.cache.fetch_channel(self._channel_id)\n        return None\n\n    def get_channel(self) -&gt; Optional[Union[\"GuildVoice\", \"GuildStageVoice\"]]:\n\"\"\"Returns the channel this event is scheduled in if it is scheduled in a channel.\"\"\"\n        if self._channel_id:\n            channel = self._client.cache.get_channel(self._channel_id)\n            return channel\n        return None\n\n    async def fetch_event_users(\n        self,\n        limit: Optional[int] = 100,\n        with_member_data: bool = False,\n        before: Absent[Optional[\"Snowflake_Type\"]] = MISSING,\n        after: Absent[Optional[\"Snowflake_Type\"]] = MISSING,\n    ) -&gt; List[Union[\"Member\", \"User\"]]:\n\"\"\"\n        Fetch event users.\n\n        Args:\n            limit: Discord defualts to 100\n            with_member_data: Whether to include guild member data\n            before: Snowflake of a user to get before\n            after: Snowflake of a user to get after\n\n        !!! note\n            This method is paginated\n\n        \"\"\"\n        event_users = await self._client.http.get_scheduled_event_users(\n            self._guild_id, self.id, limit, with_member_data, before, after\n        )\n        participants = []\n        for u in event_users:\n            if member := u.get(\"member\"):\n                u[\"member\"][\"user\"] = u[\"user\"]\n                participants.append(self._client.cache.place_member_data(self._guild_id, member))\n            else:\n                participants.append(self._client.cache.place_user_data(u[\"user\"]))\n\n        return participants\n\n    async def delete(self, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n        Deletes this event.\n\n        Args:\n            reason: The reason for deleting this event\n\n        \"\"\"\n        await self._client.http.delete_scheduled_event(self._guild_id, self.id, reason)\n\n    async def edit(\n        self,\n        *,\n        name: Absent[str] = MISSING,\n        start_time: Absent[\"Timestamp\"] = MISSING,\n        end_time: Absent[\"Timestamp\"] = MISSING,\n        status: Absent[ScheduledEventStatus] = MISSING,\n        description: Absent[str] = MISSING,\n        channel_id: Absent[Optional[\"Snowflake_Type\"]] = MISSING,\n        event_type: Absent[ScheduledEventType] = MISSING,\n        external_location: Absent[Optional[str]] = MISSING,\n        entity_metadata: Absent[dict] = MISSING,\n        privacy_level: Absent[ScheduledEventPrivacyLevel] = MISSING,\n        cover_image: Absent[UPLOADABLE_TYPE] = MISSING,\n        reason: Absent[str] = MISSING,\n    ) -&gt; None:\n\"\"\"\n        Edits this event.\n\n        Args:\n            name: The name of the event\n            description: The description of the event\n            channel_id: The channel id of the event\n            event_type: The type of the event\n            start_time: The scheduled start time of the event\n            end_time: The scheduled end time of the event\n            status: The status of the event\n            entity_metadata: The metadata of the event\n            privacy_level: The privacy level of the event\n            cover_image: the cover image of the scheduled event\n            reason: The reason for editing the event\n\n        !!! note\n            If updating event_type to EXTERNAL:\n                `channel_id` is required and must be set to null\n\n                `external_location` or `entity_metadata` with a location field must be provided\n\n                `end_time` must be provided\n\n        \"\"\"\n        if external_location is not MISSING:\n            entity_metadata = {\"location\": external_location}\n\n        if event_type == ScheduledEventType.EXTERNAL:\n            channel_id = None\n            if external_location == MISSING:\n                raise EventLocationNotProvided(\"Location is required for external events\")\n\n        payload = {\n            \"name\": name,\n            \"description\": description,\n            \"channel_id\": channel_id,\n            \"entity_type\": event_type,\n            \"scheduled_start_time\": start_time.isoformat() if start_time else MISSING,\n            \"scheduled_end_time\": end_time.isoformat() if end_time else MISSING,\n            \"status\": status,\n            \"entity_metadata\": entity_metadata,\n            \"privacy_level\": privacy_level,\n            \"image\": to_image_data(cover_image) if cover_image else MISSING,\n        }\n        await self._client.http.modify_scheduled_event(self._guild_id, self.id, payload, reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.entity_type","title":"<code>entity_type: Union[ScheduledEventType, int] = attrs.field(repr=False, converter=ScheduledEventType)</code>  <code>class-attribute</code>","text":"<p>The type of the scheduled event</p>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.start_time","title":"<code>start_time: Timestamp = attrs.field(repr=False, converter=timestamp_converter)</code>  <code>class-attribute</code>","text":"<p>A Timestamp object representing the scheduled start time of the event</p>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.end_time","title":"<code>end_time: Optional[Timestamp] = attrs.field(repr=False, default=None, converter=optional(timestamp_converter))</code>  <code>class-attribute</code>","text":"<p>Optional Timstamp object representing the scheduled end time, required if entity_type is EXTERNAL</p>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.privacy_level","title":"<code>privacy_level: Union[ScheduledEventPrivacyLevel, int] = attrs.field(repr=False, converter=ScheduledEventPrivacyLevel)</code>  <code>class-attribute</code>","text":"<p>Privacy level of the scheduled event</p> Note <p>Discord only has <code>GUILD_ONLY</code> at the momment.</p>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.status","title":"<code>status: Union[ScheduledEventStatus, int] = attrs.field(repr=False, converter=ScheduledEventStatus)</code>  <code>class-attribute</code>","text":"<p>Current status of the scheduled event</p>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.entity_id","title":"<code>entity_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=MISSING, converter=optional(to_snowflake))</code>  <code>class-attribute</code>","text":"<p>The id of an entity associated with a guild scheduled event</p>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.entity_metadata","title":"<code>entity_metadata: Optional[Dict[str, Any]] = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>The metadata associated with the entity_type</p>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.user_count","title":"<code>user_count: int = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>Amount of users subscribed to the scheduled event</p>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.cover","title":"<code>cover: Asset | None = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The cover image of this event</p>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.creator","title":"<code>creator: Optional[User]</code>  <code>async</code> <code>property</code>","text":"<p>Returns the user who created this event.</p> <p>Note</p> <p>Events made before October 25th, 2021 will not have a creator.</p>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.location","title":"<code>location: Optional[str]</code>  <code>property</code>","text":"<p>Returns the external locatian of this event.</p>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.fetch_channel","title":"<code>fetch_channel()</code>  <code>async</code>","text":"<p>Returns the channel this event is scheduled in if it is scheduled in a channel.</p> Source code in <code>naff\\models\\discord\\scheduled_event.py</code> <pre><code>async def fetch_channel(self) -&gt; Optional[Union[\"GuildVoice\", \"GuildStageVoice\"]]:\n\"\"\"Returns the channel this event is scheduled in if it is scheduled in a channel.\"\"\"\n    if self._channel_id:\n        return await self._client.cache.fetch_channel(self._channel_id)\n    return None\n</code></pre>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.get_channel","title":"<code>get_channel()</code>","text":"<p>Returns the channel this event is scheduled in if it is scheduled in a channel.</p> Source code in <code>naff\\models\\discord\\scheduled_event.py</code> <pre><code>def get_channel(self) -&gt; Optional[Union[\"GuildVoice\", \"GuildStageVoice\"]]:\n\"\"\"Returns the channel this event is scheduled in if it is scheduled in a channel.\"\"\"\n    if self._channel_id:\n        channel = self._client.cache.get_channel(self._channel_id)\n        return channel\n    return None\n</code></pre>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.fetch_event_users","title":"<code>fetch_event_users(limit=100, with_member_data=False, before=MISSING, after=MISSING)</code>  <code>async</code>","text":"<p>Fetch event users.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>Optional[int]</code> <p>Discord defualts to 100</p> <code>100</code> <code>with_member_data</code> <code>bool</code> <p>Whether to include guild member data</p> <code>False</code> <code>before</code> <code>Absent[Optional[Snowflake_Type]]</code> <p>Snowflake of a user to get before</p> <code>MISSING</code> <code>after</code> <code>Absent[Optional[Snowflake_Type]]</code> <p>Snowflake of a user to get after</p> <code>MISSING</code> <p>Note</p> <p>This method is paginated</p> Source code in <code>naff\\models\\discord\\scheduled_event.py</code> <pre><code>async def fetch_event_users(\n    self,\n    limit: Optional[int] = 100,\n    with_member_data: bool = False,\n    before: Absent[Optional[\"Snowflake_Type\"]] = MISSING,\n    after: Absent[Optional[\"Snowflake_Type\"]] = MISSING,\n) -&gt; List[Union[\"Member\", \"User\"]]:\n\"\"\"\n    Fetch event users.\n\n    Args:\n        limit: Discord defualts to 100\n        with_member_data: Whether to include guild member data\n        before: Snowflake of a user to get before\n        after: Snowflake of a user to get after\n\n    !!! note\n        This method is paginated\n\n    \"\"\"\n    event_users = await self._client.http.get_scheduled_event_users(\n        self._guild_id, self.id, limit, with_member_data, before, after\n    )\n    participants = []\n    for u in event_users:\n        if member := u.get(\"member\"):\n            u[\"member\"][\"user\"] = u[\"user\"]\n            participants.append(self._client.cache.place_member_data(self._guild_id, member))\n        else:\n            participants.append(self._client.cache.place_user_data(u[\"user\"]))\n\n    return participants\n</code></pre>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.delete","title":"<code>delete(reason=MISSING)</code>  <code>async</code>","text":"<p>Deletes this event.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Absent[str]</code> <p>The reason for deleting this event</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\scheduled_event.py</code> <pre><code>async def delete(self, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n    Deletes this event.\n\n    Args:\n        reason: The reason for deleting this event\n\n    \"\"\"\n    await self._client.http.delete_scheduled_event(self._guild_id, self.id, reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/scheduled_event/#naff.models.discord.scheduled_event.ScheduledEvent.edit","title":"<code>edit(*, name=MISSING, start_time=MISSING, end_time=MISSING, status=MISSING, description=MISSING, channel_id=MISSING, event_type=MISSING, external_location=MISSING, entity_metadata=MISSING, privacy_level=MISSING, cover_image=MISSING, reason=MISSING)</code>  <code>async</code>","text":"<p>Edits this event.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[str]</code> <p>The name of the event</p> <code>MISSING</code> <code>description</code> <code>Absent[str]</code> <p>The description of the event</p> <code>MISSING</code> <code>channel_id</code> <code>Absent[Optional[Snowflake_Type]]</code> <p>The channel id of the event</p> <code>MISSING</code> <code>event_type</code> <code>Absent[ScheduledEventType]</code> <p>The type of the event</p> <code>MISSING</code> <code>start_time</code> <code>Absent[Timestamp]</code> <p>The scheduled start time of the event</p> <code>MISSING</code> <code>end_time</code> <code>Absent[Timestamp]</code> <p>The scheduled end time of the event</p> <code>MISSING</code> <code>status</code> <code>Absent[ScheduledEventStatus]</code> <p>The status of the event</p> <code>MISSING</code> <code>entity_metadata</code> <code>Absent[dict]</code> <p>The metadata of the event</p> <code>MISSING</code> <code>privacy_level</code> <code>Absent[ScheduledEventPrivacyLevel]</code> <p>The privacy level of the event</p> <code>MISSING</code> <code>cover_image</code> <code>Absent[UPLOADABLE_TYPE]</code> <p>the cover image of the scheduled event</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for editing the event</p> <code>MISSING</code> <p>Note</p> <p>If updating event_type to EXTERNAL:     <code>channel_id</code> is required and must be set to null</p> <pre><code>`external_location` or `entity_metadata` with a location field must be provided\n\n`end_time` must be provided\n</code></pre> Source code in <code>naff\\models\\discord\\scheduled_event.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: Absent[str] = MISSING,\n    start_time: Absent[\"Timestamp\"] = MISSING,\n    end_time: Absent[\"Timestamp\"] = MISSING,\n    status: Absent[ScheduledEventStatus] = MISSING,\n    description: Absent[str] = MISSING,\n    channel_id: Absent[Optional[\"Snowflake_Type\"]] = MISSING,\n    event_type: Absent[ScheduledEventType] = MISSING,\n    external_location: Absent[Optional[str]] = MISSING,\n    entity_metadata: Absent[dict] = MISSING,\n    privacy_level: Absent[ScheduledEventPrivacyLevel] = MISSING,\n    cover_image: Absent[UPLOADABLE_TYPE] = MISSING,\n    reason: Absent[str] = MISSING,\n) -&gt; None:\n\"\"\"\n    Edits this event.\n\n    Args:\n        name: The name of the event\n        description: The description of the event\n        channel_id: The channel id of the event\n        event_type: The type of the event\n        start_time: The scheduled start time of the event\n        end_time: The scheduled end time of the event\n        status: The status of the event\n        entity_metadata: The metadata of the event\n        privacy_level: The privacy level of the event\n        cover_image: the cover image of the scheduled event\n        reason: The reason for editing the event\n\n    !!! note\n        If updating event_type to EXTERNAL:\n            `channel_id` is required and must be set to null\n\n            `external_location` or `entity_metadata` with a location field must be provided\n\n            `end_time` must be provided\n\n    \"\"\"\n    if external_location is not MISSING:\n        entity_metadata = {\"location\": external_location}\n\n    if event_type == ScheduledEventType.EXTERNAL:\n        channel_id = None\n        if external_location == MISSING:\n            raise EventLocationNotProvided(\"Location is required for external events\")\n\n    payload = {\n        \"name\": name,\n        \"description\": description,\n        \"channel_id\": channel_id,\n        \"entity_type\": event_type,\n        \"scheduled_start_time\": start_time.isoformat() if start_time else MISSING,\n        \"scheduled_end_time\": end_time.isoformat() if end_time else MISSING,\n        \"status\": status,\n        \"entity_metadata\": entity_metadata,\n        \"privacy_level\": privacy_level,\n        \"image\": to_image_data(cover_image) if cover_image else MISSING,\n    }\n    await self._client.http.modify_scheduled_event(self._guild_id, self.id, payload, reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/snowflake/","title":"Snowflake","text":""},{"location":"API%20Reference/models/Discord/snowflake/#naff.models.discord.snowflake.to_snowflake","title":"<code>to_snowflake(snowflake)</code>","text":"<p>Helper function to convert something into correct Discord snowflake int, gives more helpful errors Use internally to sanitize user input or in user- facing APIs (a must).</p> <p>For Discord-API - facing code, just int() is sufficient</p> Source code in <code>naff\\models\\discord\\snowflake.py</code> <pre><code>def to_snowflake(snowflake: Snowflake_Type) -&gt; int:\n\"\"\"\n    Helper function to convert something into correct Discord snowflake int, gives more helpful errors Use internally to sanitize user input or in user- facing APIs (a must).\n\n    For Discord-API - facing code, just int() is sufficient\n\n    \"\"\"\n    try:\n        snowflake = int(snowflake)\n    except TypeError as e:\n        raise TypeError(\n            f\"ID (snowflake) should be instance of int, str, SnowflakeObject, or support __int__. \"\n            f\"Got '{snowflake}' ({type(snowflake)}) instead.\"\n        ) from e\n    except ValueError as e:\n        raise ValueError(f\"ID (snowflake) should represent int. Got '{snowflake}' ({type(snowflake)}) instead.\") from e\n\n    if 22 &gt; snowflake.bit_length() &gt; 64:\n        raise ValueError(\n            f\"ID (snowflake) is not in correct Discord format! Bit length of int should be from 22 to 64 \"\n            f\"Got '{snowflake}' (bit length {snowflake.bit_length()})\"\n        )\n\n    return snowflake\n</code></pre>"},{"location":"API%20Reference/models/Discord/snowflake/#naff.models.discord.snowflake.SnowflakeObject","title":"<code>SnowflakeObject</code>","text":"Source code in <code>naff\\models\\discord\\snowflake.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, slots=False)\nclass SnowflakeObject:\n    id: int = attrs.field(repr=True, converter=to_snowflake, metadata={\"docs\": \"Discord unique snowflake ID\"})\n\n    def __eq__(self, other: \"SnowflakeObject\") -&gt; bool:\n        if hasattr(other, \"id\"):\n            other = other.id\n        return self.id == other\n\n    def __ne__(self, other: \"SnowflakeObject\") -&gt; bool:\n        return not self.__eq__(other)\n\n    def __hash__(self) -&gt; int:\n        return self.id &lt;&lt; 32\n\n    def __int__(self) -&gt; int:\n        return self.id\n\n    @property\n    def created_at(self) -&gt; \"models.Timestamp\":\n\"\"\"\n        Returns a timestamp representing the date-time this discord object was created.\n\n        :Returns:\n\n        \"\"\"\n        return models.Timestamp.from_snowflake(self.id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/snowflake/#naff.models.discord.snowflake.SnowflakeObject.created_at","title":"<code>created_at: models.Timestamp</code>  <code>property</code>","text":"<p>Returns a timestamp representing the date-time this discord object was created.</p> <p>:Returns:</p>"},{"location":"API%20Reference/models/Discord/stage_instance/","title":"Stage instance","text":""},{"location":"API%20Reference/models/Discord/stage_instance/#naff.models.discord.stage_instance.StageInstance","title":"<code>StageInstance</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\stage_instance.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass StageInstance(DiscordObject):\n    topic: str = attrs.field(\n        repr=False,\n    )\n    privacy_level: StagePrivacyLevel = attrs.field(\n        repr=False,\n    )\n    discoverable_disabled: bool = attrs.field(\n        repr=False,\n    )\n\n    _guild_id: \"Snowflake_Type\" = attrs.field(repr=False, converter=to_snowflake)\n    _channel_id: \"Snowflake_Type\" = attrs.field(repr=False, converter=to_snowflake)\n\n    @property\n    def guild(self) -&gt; \"Guild\":\n        return self._client.cache.get_guild(self._guild_id)\n\n    @property\n    def channel(self) -&gt; \"GuildStageVoice\":\n        return self._client.cache.get_channel(self._channel_id)\n\n    async def delete(self, reason: Absent[Optional[str]] = MISSING) -&gt; None:\n\"\"\"\n        Delete this stage instance. Effectively closes the stage.\n\n        Args:\n            reason: The reason for this deletion, for the audit log\n\n        \"\"\"\n        await self._client.http.delete_stage_instance(self._channel_id, reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/stage_instance/#naff.models.discord.stage_instance.StageInstance.delete","title":"<code>delete(reason=MISSING)</code>  <code>async</code>","text":"<p>Delete this stage instance. Effectively closes the stage.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Absent[Optional[str]]</code> <p>The reason for this deletion, for the audit log</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\stage_instance.py</code> <pre><code>async def delete(self, reason: Absent[Optional[str]] = MISSING) -&gt; None:\n\"\"\"\n    Delete this stage instance. Effectively closes the stage.\n\n    Args:\n        reason: The reason for this deletion, for the audit log\n\n    \"\"\"\n    await self._client.http.delete_stage_instance(self._channel_id, reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/sticker/","title":"Sticker","text":""},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.StickerTypes","title":"<code>StickerTypes</code>","text":"<p>         Bases: <code>IntEnum</code></p> <p>Types of sticker.</p> Source code in <code>naff\\models\\discord\\sticker.py</code> <pre><code>class StickerTypes(IntEnum):\n\"\"\"Types of sticker.\"\"\"\n\n    STANDARD = 1\n\"\"\"An official sticker in a pack, part of Nitro or in a removed purchasable pack.\"\"\"\n    GUILD = 2\n\"\"\"A sticker uploaded to a Boosted guild for the guild's members.\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.StickerTypes.STANDARD","title":"<code>STANDARD = 1</code>  <code>class-attribute</code>","text":"<p>An official sticker in a pack, part of Nitro or in a removed purchasable pack.</p>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.StickerTypes.GUILD","title":"<code>GUILD = 2</code>  <code>class-attribute</code>","text":"<p>A sticker uploaded to a Boosted guild for the guild's members.</p>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.StickerFormatTypes","title":"<code>StickerFormatTypes</code>","text":"<p>         Bases: <code>IntEnum</code></p> <p>File formats for stickers.</p> Source code in <code>naff\\models\\discord\\sticker.py</code> <pre><code>class StickerFormatTypes(IntEnum):\n\"\"\"File formats for stickers.\"\"\"\n\n    PNG = 1\n    APNG = 2\n    LOTTIE = 3\n</code></pre>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.StickerItem","title":"<code>StickerItem</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\sticker.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass StickerItem(DiscordObject):\n    name: str = attrs.field(repr=True)\n\"\"\"Name of the sticker.\"\"\"\n    format_type: StickerFormatTypes = attrs.field(repr=True, converter=StickerFormatTypes)\n\"\"\"Type of sticker image format.\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.StickerItem.name","title":"<code>name: str = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>Name of the sticker.</p>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.StickerItem.format_type","title":"<code>format_type: StickerFormatTypes = attrs.field(repr=True, converter=StickerFormatTypes)</code>  <code>class-attribute</code>","text":"<p>Type of sticker image format.</p>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.Sticker","title":"<code>Sticker</code>","text":"<p>         Bases: <code>StickerItem</code></p> <p>Represents a sticker that can be sent in messages.</p> Source code in <code>naff\\models\\discord\\sticker.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass Sticker(StickerItem):\n\"\"\"Represents a sticker that can be sent in messages.\"\"\"\n\n    pack_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))\n\"\"\"For standard stickers, id of the pack the sticker is from.\"\"\"\n    description: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"Description of the sticker.\"\"\"\n    tags: str = attrs.field(repr=False)\n\"\"\"autocomplete/suggestion tags for the sticker (max 200 characters)\"\"\"\n    type: Union[StickerTypes, int] = attrs.field(repr=False, converter=StickerTypes)\n\"\"\"Type of sticker.\"\"\"\n    available: Optional[bool] = attrs.field(repr=False, default=True)\n\"\"\"Whether this guild sticker can be used, may be false due to loss of Server Boosts.\"\"\"\n    sort_value: Optional[int] = attrs.field(repr=False, default=None)\n\"\"\"The standard sticker's sort order within its pack.\"\"\"\n\n    _user_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))\n    _guild_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))\n\n    async def fetch_creator(self) -&gt; \"User\":\n\"\"\"\n        Fetch the user who created this emoji.\n\n        Returns:\n            User object\n\n        \"\"\"\n        return await self._client.cache.fetch_user(self._user_id)\n\n    def get_creator(self) -&gt; \"User\":\n\"\"\"\n        Get the user who created this emoji.\n\n        Returns:\n            User object\n\n        \"\"\"\n        return self._client.cache.get_user(self._user_id)\n\n    async def fetch_guild(self) -&gt; \"Guild\":\n\"\"\"\n        Fetch the guild associated with this emoji.\n\n        Returns:\n            Guild object\n\n        \"\"\"\n        return await self._client.cache.fetch_guild(self._guild_id)\n\n    def get_guild(self) -&gt; \"Guild\":\n\"\"\"\n        Get the guild associated with this emoji.\n\n        Returns:\n            Guild object\n\n        \"\"\"\n        return self._client.cache.get_guild(self._guild_id)\n\n    async def edit(\n        self,\n        *,\n        name: Absent[Optional[str]] = MISSING,\n        description: Absent[Optional[str]] = MISSING,\n        tags: Absent[Optional[str]] = MISSING,\n        reason: Absent[Optional[str]] = MISSING,\n    ) -&gt; \"Sticker\":\n\"\"\"\n        Edit a sticker.\n\n        Args:\n            name: New name of the sticker\n            description: New description of the sticker\n            tags: New tags of the sticker\n            reason: Reason for the edit\n\n        Returns:\n            The updated sticker instance\n\n        \"\"\"\n        if not self._guild_id:\n            raise ValueError(\"You can only edit guild stickers.\")\n\n        payload = dict_filter_none({\"name\": name, \"description\": description, \"tags\": tags})\n        sticker_data = await self._client.http.modify_guild_sticker(payload, self._guild_id, self.id, reason)\n        return self.update_from_dict(sticker_data)\n\n    async def delete(self, reason: Optional[str] = MISSING) -&gt; None:\n\"\"\"\n        Delete a sticker.\n\n        Args:\n            reason: Reason for the deletion\n\n        Raises:\n            ValueError: If you attempt to delete a non-guild sticker\n\n        \"\"\"\n        if not self._guild_id:\n            raise ValueError(\"You can only delete guild stickers.\")\n\n        await self._client.http.delete_guild_sticker(self._guild_id, self.id, reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.Sticker.pack_id","title":"<code>pack_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))</code>  <code>class-attribute</code>","text":"<p>For standard stickers, id of the pack the sticker is from.</p>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.Sticker.description","title":"<code>description: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>Description of the sticker.</p>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.Sticker.tags","title":"<code>tags: str = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>autocomplete/suggestion tags for the sticker (max 200 characters)</p>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.Sticker.type","title":"<code>type: Union[StickerTypes, int] = attrs.field(repr=False, converter=StickerTypes)</code>  <code>class-attribute</code>","text":"<p>Type of sticker.</p>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.Sticker.available","title":"<code>available: Optional[bool] = attrs.field(repr=False, default=True)</code>  <code>class-attribute</code>","text":"<p>Whether this guild sticker can be used, may be false due to loss of Server Boosts.</p>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.Sticker.sort_value","title":"<code>sort_value: Optional[int] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The standard sticker's sort order within its pack.</p>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.Sticker.fetch_creator","title":"<code>fetch_creator()</code>  <code>async</code>","text":"<p>Fetch the user who created this emoji.</p> <p>Returns:</p> Type Description <code>User</code> <p>User object</p> Source code in <code>naff\\models\\discord\\sticker.py</code> <pre><code>async def fetch_creator(self) -&gt; \"User\":\n\"\"\"\n    Fetch the user who created this emoji.\n\n    Returns:\n        User object\n\n    \"\"\"\n    return await self._client.cache.fetch_user(self._user_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.Sticker.get_creator","title":"<code>get_creator()</code>","text":"<p>Get the user who created this emoji.</p> <p>Returns:</p> Type Description <code>User</code> <p>User object</p> Source code in <code>naff\\models\\discord\\sticker.py</code> <pre><code>def get_creator(self) -&gt; \"User\":\n\"\"\"\n    Get the user who created this emoji.\n\n    Returns:\n        User object\n\n    \"\"\"\n    return self._client.cache.get_user(self._user_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.Sticker.fetch_guild","title":"<code>fetch_guild()</code>  <code>async</code>","text":"<p>Fetch the guild associated with this emoji.</p> <p>Returns:</p> Type Description <code>Guild</code> <p>Guild object</p> Source code in <code>naff\\models\\discord\\sticker.py</code> <pre><code>async def fetch_guild(self) -&gt; \"Guild\":\n\"\"\"\n    Fetch the guild associated with this emoji.\n\n    Returns:\n        Guild object\n\n    \"\"\"\n    return await self._client.cache.fetch_guild(self._guild_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.Sticker.get_guild","title":"<code>get_guild()</code>","text":"<p>Get the guild associated with this emoji.</p> <p>Returns:</p> Type Description <code>Guild</code> <p>Guild object</p> Source code in <code>naff\\models\\discord\\sticker.py</code> <pre><code>def get_guild(self) -&gt; \"Guild\":\n\"\"\"\n    Get the guild associated with this emoji.\n\n    Returns:\n        Guild object\n\n    \"\"\"\n    return self._client.cache.get_guild(self._guild_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.Sticker.edit","title":"<code>edit(*, name=MISSING, description=MISSING, tags=MISSING, reason=MISSING)</code>  <code>async</code>","text":"<p>Edit a sticker.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[Optional[str]]</code> <p>New name of the sticker</p> <code>MISSING</code> <code>description</code> <code>Absent[Optional[str]]</code> <p>New description of the sticker</p> <code>MISSING</code> <code>tags</code> <code>Absent[Optional[str]]</code> <p>New tags of the sticker</p> <code>MISSING</code> <code>reason</code> <code>Absent[Optional[str]]</code> <p>Reason for the edit</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Sticker</code> <p>The updated sticker instance</p> Source code in <code>naff\\models\\discord\\sticker.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: Absent[Optional[str]] = MISSING,\n    description: Absent[Optional[str]] = MISSING,\n    tags: Absent[Optional[str]] = MISSING,\n    reason: Absent[Optional[str]] = MISSING,\n) -&gt; \"Sticker\":\n\"\"\"\n    Edit a sticker.\n\n    Args:\n        name: New name of the sticker\n        description: New description of the sticker\n        tags: New tags of the sticker\n        reason: Reason for the edit\n\n    Returns:\n        The updated sticker instance\n\n    \"\"\"\n    if not self._guild_id:\n        raise ValueError(\"You can only edit guild stickers.\")\n\n    payload = dict_filter_none({\"name\": name, \"description\": description, \"tags\": tags})\n    sticker_data = await self._client.http.modify_guild_sticker(payload, self._guild_id, self.id, reason)\n    return self.update_from_dict(sticker_data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.Sticker.delete","title":"<code>delete(reason=MISSING)</code>  <code>async</code>","text":"<p>Delete a sticker.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Optional[str]</code> <p>Reason for the deletion</p> <code>MISSING</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If you attempt to delete a non-guild sticker</p> Source code in <code>naff\\models\\discord\\sticker.py</code> <pre><code>async def delete(self, reason: Optional[str] = MISSING) -&gt; None:\n\"\"\"\n    Delete a sticker.\n\n    Args:\n        reason: Reason for the deletion\n\n    Raises:\n        ValueError: If you attempt to delete a non-guild sticker\n\n    \"\"\"\n    if not self._guild_id:\n        raise ValueError(\"You can only delete guild stickers.\")\n\n    await self._client.http.delete_guild_sticker(self._guild_id, self.id, reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.StickerPack","title":"<code>StickerPack</code>","text":"<p>         Bases: <code>DiscordObject</code></p> <p>Represents a pack of standard stickers.</p> Source code in <code>naff\\models\\discord\\sticker.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass StickerPack(DiscordObject):\n\"\"\"Represents a pack of standard stickers.\"\"\"\n\n    stickers: List[\"Sticker\"] = attrs.field(repr=False, factory=list)\n\"\"\"The stickers in the pack.\"\"\"\n    name: str = attrs.field(repr=True)\n\"\"\"Name of the sticker pack.\"\"\"\n    sku_id: \"Snowflake_Type\" = attrs.field(repr=True)\n\"\"\"id of the pack's SKU.\"\"\"\n    cover_sticker_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None)\n\"\"\"id of a sticker in the pack which is shown as the pack's icon.\"\"\"\n    description: str = attrs.field(repr=False)\n\"\"\"Description of the sticker pack.\"\"\"\n    banner_asset_id: \"Snowflake_Type\" = attrs.field(repr=False)  # TODO CDN Asset\n\"\"\"id of the sticker pack's banner image.\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.StickerPack.stickers","title":"<code>stickers: List[Sticker] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>The stickers in the pack.</p>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.StickerPack.name","title":"<code>name: str = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>Name of the sticker pack.</p>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.StickerPack.sku_id","title":"<code>sku_id: Snowflake_Type = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>id of the pack's SKU.</p>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.StickerPack.cover_sticker_id","title":"<code>cover_sticker_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>id of a sticker in the pack which is shown as the pack's icon.</p>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.StickerPack.description","title":"<code>description: str = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>Description of the sticker pack.</p>"},{"location":"API%20Reference/models/Discord/sticker/#naff.models.discord.sticker.StickerPack.banner_asset_id","title":"<code>banner_asset_id: Snowflake_Type = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>id of the sticker pack's banner image.</p>"},{"location":"API%20Reference/models/Discord/team/","title":"Team","text":""},{"location":"API%20Reference/models/Discord/team/#naff.models.discord.team.TeamMember","title":"<code>TeamMember</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\team.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass TeamMember(DiscordObject):\n    membership_state: TeamMembershipState = attrs.field(repr=False, converter=TeamMembershipState)\n\"\"\"Rhe user's membership state on the team\"\"\"\n    # permissions: List[str] = attrs.field(repr=False, default=[\"*\"])  # disabled until discord adds more team roles\n    team_id: \"Snowflake_Type\" = attrs.field(repr=True)\n\"\"\"Rhe id of the parent team of which they are a member\"\"\"\n    user: \"User\" = attrs.field(\n        repr=False,\n    )  # TODO: cache partial user (avatar, discrim, id, username)\n\"\"\"Rhe avatar, discriminator, id, and username of the user\"\"\"\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        data[\"user\"] = client.cache.place_user_data(data[\"user\"])\n        data[\"id\"] = data[\"user\"].id\n        return data\n</code></pre>"},{"location":"API%20Reference/models/Discord/team/#naff.models.discord.team.TeamMember.membership_state","title":"<code>membership_state: TeamMembershipState = attrs.field(repr=False, converter=TeamMembershipState)</code>  <code>class-attribute</code>","text":"<p>Rhe user's membership state on the team</p>"},{"location":"API%20Reference/models/Discord/team/#naff.models.discord.team.TeamMember.team_id","title":"<code>team_id: Snowflake_Type = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>Rhe id of the parent team of which they are a member</p>"},{"location":"API%20Reference/models/Discord/team/#naff.models.discord.team.TeamMember.user","title":"<code>user: User = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>Rhe avatar, discriminator, id, and username of the user</p>"},{"location":"API%20Reference/models/Discord/team/#naff.models.discord.team.Team","title":"<code>Team</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\team.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass Team(DiscordObject):\n    icon: Optional[Asset] = attrs.field(repr=False, default=None)\n\"\"\"A hash of the image of the team's icon\"\"\"\n    members: List[TeamMember] = attrs.field(repr=False, factory=list)\n\"\"\"The members of the team\"\"\"\n    name: str = attrs.field(repr=True)\n\"\"\"The name of the team\"\"\"\n    owner_user_id: \"Snowflake_Type\" = attrs.field(repr=False, converter=to_snowflake)\n\"\"\"The user id of the current team owner\"\"\"\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        data[\"members\"] = TeamMember.from_list(data[\"members\"], client)\n        if data[\"icon\"]:\n            data[\"icon\"] = Asset.from_path_hash(client, f\"team-icons/{data['id']}/{{}}\", data[\"icon\"])\n        return data\n\n    @property\n    def owner(self) -&gt; \"User\":\n\"\"\"The owner of the team\"\"\"\n        return self._client.cache.get_user(self.owner_user_id)\n\n    def is_in_team(self, user: Union[\"SnowflakeObject\", \"Snowflake_Type\"]) -&gt; bool:\n\"\"\"\n        Returns True if the passed user or ID is a member within the team.\n\n        Args:\n            user: The user or user ID to check\n\n        Returns:\n            Boolean indicating whether the user is in the team\n        \"\"\"\n        return to_snowflake(user) in [m.id for m in self.members]\n</code></pre>"},{"location":"API%20Reference/models/Discord/team/#naff.models.discord.team.Team.icon","title":"<code>icon: Optional[Asset] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>A hash of the image of the team's icon</p>"},{"location":"API%20Reference/models/Discord/team/#naff.models.discord.team.Team.members","title":"<code>members: List[TeamMember] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>The members of the team</p>"},{"location":"API%20Reference/models/Discord/team/#naff.models.discord.team.Team.name","title":"<code>name: str = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>The name of the team</p>"},{"location":"API%20Reference/models/Discord/team/#naff.models.discord.team.Team.owner_user_id","title":"<code>owner_user_id: Snowflake_Type = attrs.field(repr=False, converter=to_snowflake)</code>  <code>class-attribute</code>","text":"<p>The user id of the current team owner</p>"},{"location":"API%20Reference/models/Discord/team/#naff.models.discord.team.Team.owner","title":"<code>owner: User</code>  <code>property</code>","text":"<p>The owner of the team</p>"},{"location":"API%20Reference/models/Discord/team/#naff.models.discord.team.Team.is_in_team","title":"<code>is_in_team(user)</code>","text":"<p>Returns True if the passed user or ID is a member within the team.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Union[SnowflakeObject, Snowflake_Type]</code> <p>The user or user ID to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Boolean indicating whether the user is in the team</p> Source code in <code>naff\\models\\discord\\team.py</code> <pre><code>def is_in_team(self, user: Union[\"SnowflakeObject\", \"Snowflake_Type\"]) -&gt; bool:\n\"\"\"\n    Returns True if the passed user or ID is a member within the team.\n\n    Args:\n        user: The user or user ID to check\n\n    Returns:\n        Boolean indicating whether the user is in the team\n    \"\"\"\n    return to_snowflake(user) in [m.id for m in self.members]\n</code></pre>"},{"location":"API%20Reference/models/Discord/thread/","title":"Thread","text":""},{"location":"API%20Reference/models/Discord/thread/#naff.models.discord.thread.ThreadMember","title":"<code>ThreadMember</code>","text":"<p>         Bases: <code>DiscordObject</code>, <code>SendMixin</code></p> <p>A thread member is used to indicate whether a user has joined a thread or not.</p> Source code in <code>naff\\models\\discord\\thread.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ThreadMember(DiscordObject, SendMixin):\n\"\"\"A thread member is used to indicate whether a user has joined a thread or not.\"\"\"\n\n    join_timestamp: Timestamp = attrs.field(repr=False, converter=timestamp_converter)\n\"\"\"The time the current user last joined the thread.\"\"\"\n    flags: int = attrs.field(\n        repr=False,\n    )\n\"\"\"Any user-thread settings, currently only used for notifications.\"\"\"\n\n    _user_id: \"Snowflake_Type\" = attrs.field(repr=False, converter=optional(to_snowflake))\n\n    async def fetch_thread(self) -&gt; \"TYPE_THREAD_CHANNEL\":\n\"\"\"\n        Fetches the thread associated with with this member.\n\n        Returns:\n            The thread in question\n\n        \"\"\"\n        return await self._client.cache.fetch_channel(self.id)\n\n    def get_thread(self) -&gt; \"TYPE_THREAD_CHANNEL\":\n\"\"\"\n        Gets the thread associated with with this member.\n\n        Returns:\n            The thread in question\n\n        \"\"\"\n        return self._client.cache.get_channel(self.id)\n\n    async def fetch_user(self) -&gt; \"User\":\n\"\"\"\n        Fetch the user associated with this thread member.\n\n        Returns:\n            The user object\n\n        \"\"\"\n        return await self._client.cache.fetch_user(self._user_id)\n\n    def get_user(self) -&gt; \"User\":\n\"\"\"\n        Get the user associated with this thread member.\n\n        Returns:\n            The user object\n\n        \"\"\"\n        return self._client.cache.get_user(self._user_id)\n\n    async def _send_http_request(\n        self, message_payload: Union[dict, \"FormData\"], files: list[\"UPLOADABLE_TYPE\"] | None = None\n    ) -&gt; dict:\n        dm_id = await self._client.cache.fetch_dm_channel_id(self._user_id)\n        return await self._client.http.create_message(message_payload, dm_id, files=files)\n</code></pre>"},{"location":"API%20Reference/models/Discord/thread/#naff.models.discord.thread.ThreadMember.join_timestamp","title":"<code>join_timestamp: Timestamp = attrs.field(repr=False, converter=timestamp_converter)</code>  <code>class-attribute</code>","text":"<p>The time the current user last joined the thread.</p>"},{"location":"API%20Reference/models/Discord/thread/#naff.models.discord.thread.ThreadMember.flags","title":"<code>flags: int = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>Any user-thread settings, currently only used for notifications.</p>"},{"location":"API%20Reference/models/Discord/thread/#naff.models.discord.thread.ThreadMember.fetch_thread","title":"<code>fetch_thread()</code>  <code>async</code>","text":"<p>Fetches the thread associated with with this member.</p> <p>Returns:</p> Type Description <code>TYPE_THREAD_CHANNEL</code> <p>The thread in question</p> Source code in <code>naff\\models\\discord\\thread.py</code> <pre><code>async def fetch_thread(self) -&gt; \"TYPE_THREAD_CHANNEL\":\n\"\"\"\n    Fetches the thread associated with with this member.\n\n    Returns:\n        The thread in question\n\n    \"\"\"\n    return await self._client.cache.fetch_channel(self.id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/thread/#naff.models.discord.thread.ThreadMember.get_thread","title":"<code>get_thread()</code>","text":"<p>Gets the thread associated with with this member.</p> <p>Returns:</p> Type Description <code>TYPE_THREAD_CHANNEL</code> <p>The thread in question</p> Source code in <code>naff\\models\\discord\\thread.py</code> <pre><code>def get_thread(self) -&gt; \"TYPE_THREAD_CHANNEL\":\n\"\"\"\n    Gets the thread associated with with this member.\n\n    Returns:\n        The thread in question\n\n    \"\"\"\n    return self._client.cache.get_channel(self.id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/thread/#naff.models.discord.thread.ThreadMember.fetch_user","title":"<code>fetch_user()</code>  <code>async</code>","text":"<p>Fetch the user associated with this thread member.</p> <p>Returns:</p> Type Description <code>User</code> <p>The user object</p> Source code in <code>naff\\models\\discord\\thread.py</code> <pre><code>async def fetch_user(self) -&gt; \"User\":\n\"\"\"\n    Fetch the user associated with this thread member.\n\n    Returns:\n        The user object\n\n    \"\"\"\n    return await self._client.cache.fetch_user(self._user_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/thread/#naff.models.discord.thread.ThreadMember.get_user","title":"<code>get_user()</code>","text":"<p>Get the user associated with this thread member.</p> <p>Returns:</p> Type Description <code>User</code> <p>The user object</p> Source code in <code>naff\\models\\discord\\thread.py</code> <pre><code>def get_user(self) -&gt; \"User\":\n\"\"\"\n    Get the user associated with this thread member.\n\n    Returns:\n        The user object\n\n    \"\"\"\n    return self._client.cache.get_user(self._user_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/thread/#naff.models.discord.thread.ThreadList","title":"<code>ThreadList</code>","text":"<p>         Bases: <code>ClientObject</code></p> <p>Represents a list of one or more threads.</p> Source code in <code>naff\\models\\discord\\thread.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ThreadList(ClientObject):\n\"\"\"Represents a list of one or more threads.\"\"\"\n\n    threads: List[\"TYPE_THREAD_CHANNEL\"] = attrs.field(\n        repr=False, factory=list\n    )  # TODO Reference the cache or store actual object?\n\"\"\"The active threads.\"\"\"\n    members: List[ThreadMember] = attrs.field(repr=False, factory=list)\n\"\"\"A thread member object for each returned thread the current user has joined.\"\"\"\n    has_more: bool = attrs.field(repr=False, default=False)\n\"\"\"Whether there are potentially additional threads that could be returned on a subsequent call.\"\"\"\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        threads = []\n        for thread_data in data[\"threads\"]:\n            threads.append(client.cache.place_channel_data(thread_data))\n        data[\"threads\"] = threads\n\n        data[\"members\"] = ThreadMember.from_list(data[\"members\"], client)\n\n        return data\n</code></pre>"},{"location":"API%20Reference/models/Discord/thread/#naff.models.discord.thread.ThreadList.threads","title":"<code>threads: List[TYPE_THREAD_CHANNEL] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>The active threads.</p>"},{"location":"API%20Reference/models/Discord/thread/#naff.models.discord.thread.ThreadList.members","title":"<code>members: List[ThreadMember] = attrs.field(repr=False, factory=list)</code>  <code>class-attribute</code>","text":"<p>A thread member object for each returned thread the current user has joined.</p>"},{"location":"API%20Reference/models/Discord/thread/#naff.models.discord.thread.ThreadList.has_more","title":"<code>has_more: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>Whether there are potentially additional threads that could be returned on a subsequent call.</p>"},{"location":"API%20Reference/models/Discord/thread/#naff.models.discord.thread.ThreadTag","title":"<code>ThreadTag</code>","text":"<p>         Bases: <code>DiscordObject</code></p> Source code in <code>naff\\models\\discord\\thread.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ThreadTag(DiscordObject):\n    name: str = attrs.field(\n        repr=False,\n    )\n    emoji_id: \"Snowflake_Type\" = attrs.field(repr=False, default=None)\n    emoji_name: str | None = attrs.field(repr=False, default=None)\n\n    _parent_channel_id: \"Snowflake_Type\" = attrs.field(repr=False, default=MISSING)\n\n    @property\n    def parent_channel(self) -&gt; \"GuildForum\":\n\"\"\"The parent forum for this tag.\"\"\"\n        return self._client.get_channel(self._parent_channel_id)\n\n    async def edit(\n        self, *, name: Optional[str] = None, emoji: Union[\"models.PartialEmoji\", dict, str, None] = None\n    ) -&gt; \"ThreadTag\":\n\"\"\"\n        Edit this tag\n\n        Args:\n            name: The name for this tag\n            emoji: The emoji for this tag\n\n        Returns:\n            This object\n        \"\"\"\n        if isinstance(emoji, str):\n            emoji = PartialEmoji.from_str(emoji)\n        elif isinstance(emoji, dict):\n            emoji = PartialEmoji.from_dict(emoji)\n\n        if emoji.id:\n            data = await self._client.http.edit_tag(self._parent_channel_id, self.id, name, emoji_id=emoji.id)\n        else:\n            data = await self._client.http.edit_tag(self._parent_channel_id, self.id, name, emoji_name=emoji.name)\n\n        self._client.cache.place_channel_data(data)\n\n        for tag in data[\"available_tags\"]:\n            if tag.id == self.id:\n                self.name = tag.name\n                self.emoji_id = tag.emoji_id\n                self.emoji_name = tag.emoji_name\n                break\n\n        return self\n\n    async def delete(self) -&gt; None:\n\"\"\"Delete this tag.\"\"\"\n        data = await self._client.http.delete_tag(self._parent_channel_id, self.id)\n        self._client.cache.place_channel_data(data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/thread/#naff.models.discord.thread.ThreadTag.parent_channel","title":"<code>parent_channel: GuildForum</code>  <code>property</code>","text":"<p>The parent forum for this tag.</p>"},{"location":"API%20Reference/models/Discord/thread/#naff.models.discord.thread.ThreadTag.edit","title":"<code>edit(*, name=None, emoji=None)</code>  <code>async</code>","text":"<p>Edit this tag</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name for this tag</p> <code>None</code> <code>emoji</code> <code>Union[PartialEmoji, dict, str, None]</code> <p>The emoji for this tag</p> <code>None</code> <p>Returns:</p> Type Description <code>ThreadTag</code> <p>This object</p> Source code in <code>naff\\models\\discord\\thread.py</code> <pre><code>async def edit(\n    self, *, name: Optional[str] = None, emoji: Union[\"models.PartialEmoji\", dict, str, None] = None\n) -&gt; \"ThreadTag\":\n\"\"\"\n    Edit this tag\n\n    Args:\n        name: The name for this tag\n        emoji: The emoji for this tag\n\n    Returns:\n        This object\n    \"\"\"\n    if isinstance(emoji, str):\n        emoji = PartialEmoji.from_str(emoji)\n    elif isinstance(emoji, dict):\n        emoji = PartialEmoji.from_dict(emoji)\n\n    if emoji.id:\n        data = await self._client.http.edit_tag(self._parent_channel_id, self.id, name, emoji_id=emoji.id)\n    else:\n        data = await self._client.http.edit_tag(self._parent_channel_id, self.id, name, emoji_name=emoji.name)\n\n    self._client.cache.place_channel_data(data)\n\n    for tag in data[\"available_tags\"]:\n        if tag.id == self.id:\n            self.name = tag.name\n            self.emoji_id = tag.emoji_id\n            self.emoji_name = tag.emoji_name\n            break\n\n    return self\n</code></pre>"},{"location":"API%20Reference/models/Discord/thread/#naff.models.discord.thread.ThreadTag.delete","title":"<code>delete()</code>  <code>async</code>","text":"<p>Delete this tag.</p> Source code in <code>naff\\models\\discord\\thread.py</code> <pre><code>async def delete(self) -&gt; None:\n\"\"\"Delete this tag.\"\"\"\n    data = await self._client.http.delete_tag(self._parent_channel_id, self.id)\n    self._client.cache.place_channel_data(data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/timestamp/","title":"Timestamp","text":""},{"location":"API%20Reference/models/Discord/timestamp/#naff.models.discord.timestamp.Timestamp","title":"<code>Timestamp</code>","text":"<p>         Bases: <code>datetime</code></p> <p>A special class that represents Discord timestamps.</p> <p>Assumes that all naive datetimes are based on local timezone.</p> Source code in <code>naff\\models\\discord\\timestamp.py</code> <pre><code>class Timestamp(datetime):\n\"\"\"\n    A special class that represents Discord timestamps.\n\n    Assumes that all naive datetimes are based on local timezone.\n\n    \"\"\"\n\n    @classmethod\n    def fromdatetime(cls, dt: datetime) -&gt; \"Timestamp\":\n\"\"\"Construct a timezone-aware UTC datetime from a datetime object.\"\"\"\n        timestamp = cls.fromtimestamp(dt.timestamp(), tz=dt.tzinfo)\n\n        if timestamp.tzinfo is None:  # assume naive datetimes are based on local timezone\n            return timestamp.astimezone()\n        return timestamp\n\n    @classmethod\n    def utcfromtimestamp(cls, t: float) -&gt; \"Timestamp\":\n\"\"\"Construct a timezone-aware UTC datetime from a POSIX timestamp.\"\"\"\n        return super().utcfromtimestamp(t).replace(tzinfo=timezone.utc)\n\n    @classmethod\n    def fromisoformat(cls, date_string: str) -&gt; \"Timestamp\":\n        timestamp = super().fromisoformat(date_string)\n\n        if timestamp.tzinfo is None:  # assume naive datetimes are based on local timezone\n            return timestamp.astimezone()\n        return timestamp\n\n    @classmethod\n    def fromisocalendar(cls, year: int, week: int, day: int) -&gt; \"Timestamp\":\n        return super().fromisocalendar(year, week, day).astimezone()\n\n    @classmethod\n    def fromtimestamp(cls, t: float, tz=None) -&gt; \"Timestamp\":\n        try:\n            timestamp = super().fromtimestamp(t, tz=tz)\n        except Exception:\n            # May be in milliseconds instead of seconds\n            timestamp = super().fromtimestamp(t / 1000, tz=tz)\n\n        if timestamp.tzinfo is None:  # assume naive datetimes are based on local timezone\n            return timestamp.astimezone()\n        return timestamp\n\n    @classmethod\n    def fromordinal(cls, n: int) -&gt; \"Timestamp\":\n        return super().fromordinal(n).astimezone()\n\n    @classmethod\n    def now(cls, tz=None) -&gt; \"Timestamp\":\n\"\"\"\n        Construct a datetime from time.time() and optional time zone info.\n\n        If no timezone is provided, the time is assumed to be from the computer's\n        local timezone.\n        \"\"\"\n        t = time.time()\n        return cls.fromtimestamp(t, tz)\n\n    @classmethod\n    def utcnow(cls) -&gt; \"Timestamp\":\n\"\"\"Construct a timezone-aware UTC datetime from time.time().\"\"\"\n        t = time.time()\n        return cls.utcfromtimestamp(t)\n\n    def to_snowflake(self, high: bool = False) -&gt; Union[str, int]:\n\"\"\"\n        Returns a numeric snowflake pretending to be created at the given date.\n\n        When using as the lower end of a range, use ``tosnowflake(high=False) - 1``\n        to be inclusive, ``high=True`` to be exclusive.\n        When using as the higher end of a range, use ``tosnowflake(high=True) + 1``\n        to be inclusive, ``high=False`` to be exclusive\n\n        \"\"\"\n        discord_millis = int(self.timestamp() * 1000 - DISCORD_EPOCH)\n        return (discord_millis &lt;&lt; 22) + (2**22 - 1 if high else 0)\n\n    @classmethod\n    def from_snowflake(cls, snowflake: \"Snowflake_Type\") -&gt; \"Timestamp\":\n\"\"\"\n        Construct a timezone-aware UTC datetime from a snowflake.\n\n        Args:\n            snowflake: The snowflake to convert.\n\n        Returns:\n            A timezone-aware UTC datetime.\n\n        ??? Info\n            https://discord.com/developers/docs/reference#convert-snowflake-to-datetime\n\n        \"\"\"\n        if isinstance(snowflake, str):\n            snowflake = int(snowflake)\n\n        timestamp = ((snowflake &gt;&gt; 22) + DISCORD_EPOCH) / 1000\n        return cls.utcfromtimestamp(timestamp)\n\n    def format(self, style: Optional[Union[TimestampStyles, str]] = None) -&gt; str:\n\"\"\"\n        Format the timestamp for discord client to display.\n\n        Args:\n            style: The style to format the timestamp with.\n\n        Returns:\n            The formatted timestamp.\n\n        \"\"\"\n        if not style:\n            return f\"&lt;t:{self.timestamp():.0f}&gt;\"\n        else:\n            return f\"&lt;t:{self.timestamp():.0f}:{style}&gt;\"\n\n    def __str__(self) -&gt; str:\n        return self.format()\n</code></pre>"},{"location":"API%20Reference/models/Discord/timestamp/#naff.models.discord.timestamp.Timestamp.fromdatetime","title":"<code>fromdatetime(dt)</code>  <code>classmethod</code>","text":"<p>Construct a timezone-aware UTC datetime from a datetime object.</p> Source code in <code>naff\\models\\discord\\timestamp.py</code> <pre><code>@classmethod\ndef fromdatetime(cls, dt: datetime) -&gt; \"Timestamp\":\n\"\"\"Construct a timezone-aware UTC datetime from a datetime object.\"\"\"\n    timestamp = cls.fromtimestamp(dt.timestamp(), tz=dt.tzinfo)\n\n    if timestamp.tzinfo is None:  # assume naive datetimes are based on local timezone\n        return timestamp.astimezone()\n    return timestamp\n</code></pre>"},{"location":"API%20Reference/models/Discord/timestamp/#naff.models.discord.timestamp.Timestamp.utcfromtimestamp","title":"<code>utcfromtimestamp(t)</code>  <code>classmethod</code>","text":"<p>Construct a timezone-aware UTC datetime from a POSIX timestamp.</p> Source code in <code>naff\\models\\discord\\timestamp.py</code> <pre><code>@classmethod\ndef utcfromtimestamp(cls, t: float) -&gt; \"Timestamp\":\n\"\"\"Construct a timezone-aware UTC datetime from a POSIX timestamp.\"\"\"\n    return super().utcfromtimestamp(t).replace(tzinfo=timezone.utc)\n</code></pre>"},{"location":"API%20Reference/models/Discord/timestamp/#naff.models.discord.timestamp.Timestamp.now","title":"<code>now(tz=None)</code>  <code>classmethod</code>","text":"<p>Construct a datetime from time.time() and optional time zone info.</p> <p>If no timezone is provided, the time is assumed to be from the computer's local timezone.</p> Source code in <code>naff\\models\\discord\\timestamp.py</code> <pre><code>@classmethod\ndef now(cls, tz=None) -&gt; \"Timestamp\":\n\"\"\"\n    Construct a datetime from time.time() and optional time zone info.\n\n    If no timezone is provided, the time is assumed to be from the computer's\n    local timezone.\n    \"\"\"\n    t = time.time()\n    return cls.fromtimestamp(t, tz)\n</code></pre>"},{"location":"API%20Reference/models/Discord/timestamp/#naff.models.discord.timestamp.Timestamp.utcnow","title":"<code>utcnow()</code>  <code>classmethod</code>","text":"<p>Construct a timezone-aware UTC datetime from time.time().</p> Source code in <code>naff\\models\\discord\\timestamp.py</code> <pre><code>@classmethod\ndef utcnow(cls) -&gt; \"Timestamp\":\n\"\"\"Construct a timezone-aware UTC datetime from time.time().\"\"\"\n    t = time.time()\n    return cls.utcfromtimestamp(t)\n</code></pre>"},{"location":"API%20Reference/models/Discord/timestamp/#naff.models.discord.timestamp.Timestamp.to_snowflake","title":"<code>to_snowflake(high=False)</code>","text":"<p>Returns a numeric snowflake pretending to be created at the given date.</p> <p>When using as the lower end of a range, use <code>tosnowflake(high=False) - 1</code> to be inclusive, <code>high=True</code> to be exclusive. When using as the higher end of a range, use <code>tosnowflake(high=True) + 1</code> to be inclusive, <code>high=False</code> to be exclusive</p> Source code in <code>naff\\models\\discord\\timestamp.py</code> <pre><code>def to_snowflake(self, high: bool = False) -&gt; Union[str, int]:\n\"\"\"\n    Returns a numeric snowflake pretending to be created at the given date.\n\n    When using as the lower end of a range, use ``tosnowflake(high=False) - 1``\n    to be inclusive, ``high=True`` to be exclusive.\n    When using as the higher end of a range, use ``tosnowflake(high=True) + 1``\n    to be inclusive, ``high=False`` to be exclusive\n\n    \"\"\"\n    discord_millis = int(self.timestamp() * 1000 - DISCORD_EPOCH)\n    return (discord_millis &lt;&lt; 22) + (2**22 - 1 if high else 0)\n</code></pre>"},{"location":"API%20Reference/models/Discord/timestamp/#naff.models.discord.timestamp.Timestamp.from_snowflake","title":"<code>from_snowflake(snowflake)</code>  <code>classmethod</code>","text":"<p>Construct a timezone-aware UTC datetime from a snowflake.</p> <p>Parameters:</p> Name Type Description Default <code>snowflake</code> <code>Snowflake_Type</code> <p>The snowflake to convert.</p> required <p>Returns:</p> Type Description <code>Timestamp</code> <p>A timezone-aware UTC datetime.</p> Info <p>https://discord.com/developers/docs/reference#convert-snowflake-to-datetime</p> Source code in <code>naff\\models\\discord\\timestamp.py</code> <pre><code>@classmethod\ndef from_snowflake(cls, snowflake: \"Snowflake_Type\") -&gt; \"Timestamp\":\n\"\"\"\n    Construct a timezone-aware UTC datetime from a snowflake.\n\n    Args:\n        snowflake: The snowflake to convert.\n\n    Returns:\n        A timezone-aware UTC datetime.\n\n    ??? Info\n        https://discord.com/developers/docs/reference#convert-snowflake-to-datetime\n\n    \"\"\"\n    if isinstance(snowflake, str):\n        snowflake = int(snowflake)\n\n    timestamp = ((snowflake &gt;&gt; 22) + DISCORD_EPOCH) / 1000\n    return cls.utcfromtimestamp(timestamp)\n</code></pre>"},{"location":"API%20Reference/models/Discord/timestamp/#naff.models.discord.timestamp.Timestamp.format","title":"<code>format(style=None)</code>","text":"<p>Format the timestamp for discord client to display.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>Optional[Union[TimestampStyles, str]]</code> <p>The style to format the timestamp with.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The formatted timestamp.</p> Source code in <code>naff\\models\\discord\\timestamp.py</code> <pre><code>def format(self, style: Optional[Union[TimestampStyles, str]] = None) -&gt; str:\n\"\"\"\n    Format the timestamp for discord client to display.\n\n    Args:\n        style: The style to format the timestamp with.\n\n    Returns:\n        The formatted timestamp.\n\n    \"\"\"\n    if not style:\n        return f\"&lt;t:{self.timestamp():.0f}&gt;\"\n    else:\n        return f\"&lt;t:{self.timestamp():.0f}:{style}&gt;\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/","title":"User","text":""},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.BaseUser","title":"<code>BaseUser</code>","text":"<p>         Bases: <code>DiscordObject</code>, <code>_SendDMMixin</code></p> <p>Base class for User, essentially partial user discord model.</p> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass BaseUser(DiscordObject, _SendDMMixin):\n\"\"\"Base class for User, essentially partial user discord model.\"\"\"\n\n    username: str = attrs.field(repr=True, metadata=docs(\"The user's username, not unique across the platform\"))\n    discriminator: int = attrs.field(repr=True, metadata=docs(\"The user's 4-digit discord-tag\"))\n    avatar: \"Asset\" = attrs.field(repr=False, metadata=docs(\"The user's default avatar\"))\n\n    def __str__(self) -&gt; str:\n        return self.tag\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        if not isinstance(data[\"avatar\"], Asset):\n            if data[\"avatar\"]:\n                data[\"avatar\"] = Asset.from_path_hash(client, f\"avatars/{data['id']}/{{}}\", data[\"avatar\"])\n            else:\n                data[\"avatar\"] = Asset(client, f\"{Asset.BASE}/embed/avatars/{int(data['discriminator']) % 5}\")\n        return data\n\n    @property\n    def tag(self) -&gt; str:\n\"\"\"Returns the user's Discord tag.\"\"\"\n        return f\"{self.username}#{self.discriminator}\"\n\n    @property\n    def mention(self) -&gt; str:\n\"\"\"Returns a string that would mention the user.\"\"\"\n        return f\"&lt;@{self.id}&gt;\"\n\n    @property\n    def display_name(self) -&gt; str:\n\"\"\"The users display name, will return nickname if one is set, otherwise will return username.\"\"\"\n        return self.username  # for duck-typing compatibility with Member\n\n    @property\n    def display_avatar(self) -&gt; \"Asset\":\n\"\"\"The users displayed avatar, will return `guild_avatar` if one is set, otherwise will return user avatar.\"\"\"\n        return self.avatar\n\n    async def fetch_dm(self) -&gt; \"DM\":\n\"\"\"Fetch the DM channel associated with this user.\"\"\"\n        return await self._client.cache.fetch_dm_channel(self.id)  # noqa\n\n    def get_dm(self) -&gt; Optional[\"DM\"]:\n\"\"\"Get the DM channel associated with this user.\"\"\"\n        return self._client.cache.get_dm_channel(self.id)  # noqa\n\n    @property\n    def mutual_guilds(self) -&gt; List[\"Guild\"]:\n\"\"\"\n        Get a list of mutual guilds shared between this user and the client.\n\n        !!! note\n            This will only be accurate if the guild members are cached internally\n        \"\"\"\n        return [\n            guild for guild in self._client.guilds if self._client.cache.get_member(guild_id=guild.id, user_id=self.id)\n        ]\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.BaseUser.tag","title":"<code>tag: str</code>  <code>property</code>","text":"<p>Returns the user's Discord tag.</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.BaseUser.mention","title":"<code>mention: str</code>  <code>property</code>","text":"<p>Returns a string that would mention the user.</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.BaseUser.display_name","title":"<code>display_name: str</code>  <code>property</code>","text":"<p>The users display name, will return nickname if one is set, otherwise will return username.</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.BaseUser.display_avatar","title":"<code>display_avatar: Asset</code>  <code>property</code>","text":"<p>The users displayed avatar, will return <code>guild_avatar</code> if one is set, otherwise will return user avatar.</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.BaseUser.fetch_dm","title":"<code>fetch_dm()</code>  <code>async</code>","text":"<p>Fetch the DM channel associated with this user.</p> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>async def fetch_dm(self) -&gt; \"DM\":\n\"\"\"Fetch the DM channel associated with this user.\"\"\"\n    return await self._client.cache.fetch_dm_channel(self.id)  # noqa\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.BaseUser.get_dm","title":"<code>get_dm()</code>","text":"<p>Get the DM channel associated with this user.</p> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>def get_dm(self) -&gt; Optional[\"DM\"]:\n\"\"\"Get the DM channel associated with this user.\"\"\"\n    return self._client.cache.get_dm_channel(self.id)  # noqa\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.BaseUser.mutual_guilds","title":"<code>mutual_guilds: List[Guild]</code>  <code>property</code>","text":"<p>Get a list of mutual guilds shared between this user and the client.</p> <p>Note</p> <p>This will only be accurate if the guild members are cached internally</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.User","title":"<code>User</code>","text":"<p>         Bases: <code>BaseUser</code></p> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass User(BaseUser):\n    bot: bool = attrs.field(repr=True, default=False, metadata=docs(\"Is this user a bot?\"))\n    system: bool = attrs.field(\n        default=False,\n        metadata=docs(\"whether the user is an Official Discord System user (part of the urgent message system)\"),\n    )\n    public_flags: \"UserFlags\" = attrs.field(\n        repr=True, default=0, converter=UserFlags, metadata=docs(\"The flags associated with this user\")\n    )\n    premium_type: \"PremiumTypes\" = attrs.field(\n        repr=False,\n        default=0,\n        converter=PremiumTypes,\n        metadata=docs(\"The type of nitro subscription on a user's account\"),\n    )\n\n    banner: Optional[\"Asset\"] = attrs.field(repr=False, default=None, metadata=docs(\"The user's banner\"))\n    accent_color: Optional[\"Color\"] = attrs.field(\n        default=None,\n        converter=optional_c(Color),\n        metadata=docs(\"The user's banner color\"),\n    )\n    activities: list[Activity] = attrs.field(\n        factory=list,\n        converter=list_converter(optional(Activity.from_dict)),\n        metadata=docs(\"A list of activities the user is in\"),\n    )\n    status: Absent[Status] = attrs.field(\n        repr=False, default=MISSING, metadata=docs(\"The user's status\"), converter=optional(Status)\n    )\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        data = super()._process_dict(data, client)\n        if \"banner\" in data:\n            data[\"banner\"] = Asset.from_path_hash(client, f\"banners/{data['id']}/{{}}\", data[\"banner\"])\n\n        if data.get(\"premium_type\", None) is None:\n            data[\"premium_type\"] = 0\n\n        return data\n\n    @property\n    def member_instances(self) -&gt; List[\"Member\"]:\n\"\"\"\n        Returns the member object for all guilds both the bot and the user are in.\n\n        !!! note\n            This will only be accurate if the guild members are cached internally\n        \"\"\"\n        member_objs = [\n            self._client.cache.get_member(guild_id=guild.id, user_id=self.id) for guild in self._client.guilds\n        ]\n        return [member for member in member_objs if member]\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.User.member_instances","title":"<code>member_instances: List[Member]</code>  <code>property</code>","text":"<p>Returns the member object for all guilds both the bot and the user are in.</p> <p>Note</p> <p>This will only be accurate if the guild members are cached internally</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.NaffUser","title":"<code>NaffUser</code>","text":"<p>         Bases: <code>User</code></p> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass NaffUser(User):\n    verified: bool = attrs.field(repr=True, metadata={\"docs\": \"Whether the email on this account has been verified\"})\n    mfa_enabled: bool = attrs.field(\n        repr=False, default=False, metadata={\"docs\": \"Whether the user has two factor enabled on their account\"}\n    )\n    email: Optional[str] = attrs.field(\n        repr=False, default=None, metadata={\"docs\": \"the user's email\"}\n    )  # needs special permissions?\n    locale: Optional[str] = attrs.field(\n        repr=False, default=None, metadata={\"docs\": \"the user's chosen language option\"}\n    )\n    bio: Optional[str] = attrs.field(repr=False, default=None, metadata={\"docs\": \"\"})\n    flags: \"UserFlags\" = attrs.field(\n        repr=False, default=0, converter=UserFlags, metadata={\"docs\": \"the flags on a user's account\"}\n    )\n\n    _guild_ids: Set[\"Snowflake_Type\"] = attrs.field(\n        repr=False, factory=set, metadata={\"docs\": \"All the guilds the user is in\"}\n    )\n\n    def _add_guilds(self, guild_ids: Set[\"Snowflake_Type\"]) -&gt; None:\n\"\"\"\n        Add the guilds that the user is in to the internal reference.\n\n        Args:\n            guild_ids: The guild ids to add\n\n        \"\"\"\n        self._guild_ids |= guild_ids\n\n    @property\n    def guilds(self) -&gt; List[\"Guild\"]:\n\"\"\"The guilds the user is in.\"\"\"\n        return [self._client.cache.get_guild(g_id) for g_id in self._guild_ids]\n\n    async def edit(self, *, username: Absent[str] = MISSING, avatar: Absent[UPLOADABLE_TYPE] = MISSING) -&gt; None:\n\"\"\"\n        Edit the client's user.\n\n        You can either change the username, or avatar, or both at once.\n        `avatar` may be set to `None` to remove your bot's avatar\n\n        ??? Hint \"Example Usage:\"\n            ```python\n            await self.user.edit(avatar=\"path_to_file\")\n            ```\n            or\n            ```python\n            await self.user.edit(username=\"hello world\")\n            ```\n\n        Args:\n            username: The username you want to use\n            avatar: The avatar to use. Can be a image file, path, or `bytes` (see example)\n\n        Raises:\n            TooManyChanges: If you change the profile too many times\n\n        \"\"\"\n        payload = {}\n        if username:\n            payload[\"username\"] = username\n        if avatar:\n            payload[\"avatar\"] = to_image_data(avatar)\n        elif avatar is None:\n            payload[\"avatar\"] = None\n\n        try:\n            resp = await self._client.http.modify_client_user(payload)\n        except HTTPException:\n            raise TooManyChanges(\n                \"You have changed your profile too frequently, you need to wait a while before trying again.\"\n            ) from None\n        if resp:\n            self._client.cache.place_user_data(resp)\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.NaffUser.guilds","title":"<code>guilds: List[Guild]</code>  <code>property</code>","text":"<p>The guilds the user is in.</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.NaffUser.edit","title":"<code>edit(*, username=MISSING, avatar=MISSING)</code>  <code>async</code>","text":"<p>Edit the client's user.</p> <p>You can either change the username, or avatar, or both at once. <code>avatar</code> may be set to <code>None</code> to remove your bot's avatar</p> Example Usage: <p><pre><code>await self.user.edit(avatar=\"path_to_file\")\n</code></pre> or <pre><code>await self.user.edit(username=\"hello world\")\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>Absent[str]</code> <p>The username you want to use</p> <code>MISSING</code> <code>avatar</code> <code>Absent[UPLOADABLE_TYPE]</code> <p>The avatar to use. Can be a image file, path, or <code>bytes</code> (see example)</p> <code>MISSING</code> <p>Raises:</p> Type Description <code>TooManyChanges</code> <p>If you change the profile too many times</p> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>async def edit(self, *, username: Absent[str] = MISSING, avatar: Absent[UPLOADABLE_TYPE] = MISSING) -&gt; None:\n\"\"\"\n    Edit the client's user.\n\n    You can either change the username, or avatar, or both at once.\n    `avatar` may be set to `None` to remove your bot's avatar\n\n    ??? Hint \"Example Usage:\"\n        ```python\n        await self.user.edit(avatar=\"path_to_file\")\n        ```\n        or\n        ```python\n        await self.user.edit(username=\"hello world\")\n        ```\n\n    Args:\n        username: The username you want to use\n        avatar: The avatar to use. Can be a image file, path, or `bytes` (see example)\n\n    Raises:\n        TooManyChanges: If you change the profile too many times\n\n    \"\"\"\n    payload = {}\n    if username:\n        payload[\"username\"] = username\n    if avatar:\n        payload[\"avatar\"] = to_image_data(avatar)\n    elif avatar is None:\n        payload[\"avatar\"] = None\n\n    try:\n        resp = await self._client.http.modify_client_user(payload)\n    except HTTPException:\n        raise TooManyChanges(\n            \"You have changed your profile too frequently, you need to wait a while before trying again.\"\n        ) from None\n    if resp:\n        self._client.cache.place_user_data(resp)\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member","title":"<code>Member</code>","text":"<p>         Bases: <code>DiscordObject</code>, <code>_SendDMMixin</code></p> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass Member(DiscordObject, _SendDMMixin):\n    bot: bool = attrs.field(repr=True, default=False, metadata=docs(\"Is this user a bot?\"))\n    nick: Optional[str] = attrs.field(repr=True, default=None, metadata=docs(\"The user's nickname in this guild'\"))\n    deaf: bool = attrs.field(repr=False, default=False, metadata=docs(\"Has this user been deafened in voice channels?\"))\n    mute: bool = attrs.field(repr=False, default=False, metadata=docs(\"Has this user been muted in voice channels?\"))\n    joined_at: \"Timestamp\" = attrs.field(\n        repr=False,\n        default=MISSING,\n        converter=optional(timestamp_converter),\n        metadata=docs(\"When the user joined this guild\"),\n    )\n    premium_since: Optional[\"Timestamp\"] = attrs.field(\n        default=None,\n        converter=optional_c(timestamp_converter),\n        metadata=docs(\"When the user started boosting the guild\"),\n    )\n    pending: Optional[bool] = attrs.field(\n        repr=False,\n        default=None,\n        metadata=docs(\"Whether the user has **not** passed guild's membership screening requirements\"),\n    )\n    guild_avatar: \"Asset\" = attrs.field(repr=False, default=None, metadata=docs(\"The user's guild avatar\"))\n    communication_disabled_until: Optional[\"Timestamp\"] = attrs.field(\n        default=None,\n        converter=optional_c(timestamp_converter),\n        metadata=docs(\"When a member's timeout will expire, `None` or a time in the past if the user is not timed out\"),\n    )\n\n    _guild_id: \"Snowflake_Type\" = attrs.field(repr=True, metadata=docs(\"The ID of the guild\"))\n    _role_ids: List[\"Snowflake_Type\"] = attrs.field(\n        repr=False, factory=list, converter=list_converter(to_snowflake), metadata=docs(\"The roles IDs this user has\")\n    )\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        if \"user\" in data:\n            user_data = data.pop(\"user\")\n            client.cache.place_user_data(user_data)\n            data[\"id\"] = user_data[\"id\"]\n            data[\"bot\"] = user_data.get(\"bot\", False)\n        elif \"member\" in data:\n            member_data = data.pop(\"member\")\n            client.cache.place_user_data(data)\n            member_data[\"id\"] = data[\"id\"]\n            member_data[\"bot\"] = data.get(\"bot\", False)\n            if \"guild_id\" not in member_data:\n                member_data[\"guild_id\"] = data.get(\"guild_id\")\n            data = member_data\n        if data.get(\"avatar\"):\n            try:\n                data[\"guild_avatar\"] = Asset.from_path_hash(\n                    client, f\"guilds/{data['guild_id']}/users/{data['id']}/avatars/{{}}\", data.pop(\"avatar\", None)\n                )\n            except Exception as e:\n                client.logger.warning(\n                    f\"[DEBUG NEEDED - REPORT THIS] Incomplete dictionary has been passed to member object: {e}\"\n                )\n                raise\n\n        data[\"role_ids\"] = data.pop(\"roles\", [])\n\n        return data\n\n    def update_from_dict(self, data) -&gt; None:\n        if \"guild_id\" not in data:\n            data[\"guild_id\"] = self._guild_id\n        data[\"_role_ids\"] = data.pop(\"roles\", [])\n        return super().update_from_dict(data)\n\n    @property\n    def user(self) -&gt; \"User\":\n\"\"\"Returns this member's user object.\"\"\"\n        return self._client.cache.get_user(self.id)\n\n    def __str__(self) -&gt; str:\n        return self.user.tag\n\n    def __getattr__(self, name: str) -&gt; Any:\n        # this allows for transparent access to user attributes\n        try:\n            return getattr(self.user, name)\n        except AttributeError as e:\n            raise AttributeError(f\"Neither `User` or `Member` have attribute {name}\") from e\n\n    @property\n    def nickname(self) -&gt; str:\n\"\"\"Alias for nick.\"\"\"\n        return self.nick\n\n    @nickname.setter\n    def nickname(self, nickname: str) -&gt; None:\n\"\"\"Sets the member's nickname.\"\"\"\n        self.nick = nickname\n\n    @property\n    def guild(self) -&gt; \"Guild\":\n\"\"\"The guild object this member is from.\"\"\"\n        return self._client.cache.get_guild(self._guild_id)\n\n    @property\n    def roles(self) -&gt; List[\"Role\"]:\n\"\"\"The roles this member has.\"\"\"\n        return [r for r in self.guild.roles if r.id in self._role_ids]\n\n    @property\n    def top_role(self) -&gt; \"Role\":\n\"\"\"The member's top most role.\"\"\"\n        return max(self.roles, key=lambda x: x.position) if self.roles else self.guild.default_role\n\n    @property\n    def display_name(self) -&gt; str:\n\"\"\"The users display name, will return nickname if one is set, otherwise will return username.\"\"\"\n        return self.nickname or self.username\n\n    @property\n    def display_avatar(self) -&gt; \"Asset\":\n\"\"\"The users displayed avatar, will return `guild_avatar` if one is set, otherwise will return user avatar.\"\"\"\n        return self.guild_avatar or self.user.avatar\n\n    @property\n    def premium(self) -&gt; bool:\n\"\"\"Is this member a server booster?\"\"\"\n        return self.premium_since is not None\n\n    @property\n    def guild_permissions(self) -&gt; Permissions:\n\"\"\"\n        Returns the permissions this member has in the guild.\n\n        Returns:\n            Permission data\n\n        \"\"\"\n        guild = self.guild\n        if guild.is_owner(self):\n            return Permissions.ALL\n\n        permissions = guild.default_role.permissions  # get @everyone role\n\n        for role in self.roles:\n            permissions |= role.permissions\n\n        if Permissions.ADMINISTRATOR in permissions:\n            return Permissions.ALL\n\n        return permissions\n\n    @property\n    def voice(self) -&gt; Optional[\"VoiceState\"]:\n\"\"\"Returns the voice state of this user if any.\"\"\"\n        return self._client.cache.get_voice_state(self.id)\n\n    def has_permission(self, *permissions: Permissions) -&gt; bool:\n\"\"\"\n        Checks if the member has all the given permission(s).\n\n        ??? Hint \"Example Usage:\"\n            Two different styles can be used to call this method.\n\n            ```python\n            member.has_permission(Permissions.KICK_MEMBERS, Permissions.BAN_MEMBERS)\n            ```\n            or\n            ```python\n            member.has_permission(Permissions.KICK_MEMBERS | Permissions.BAN_MEMBERS)\n            ```\n\n            If `member` has both permissions, `True` gets returned.\n\n        Args:\n            *permissions: The permission(s) to check whether the user has it.\n\n        \"\"\"\n        # Get the user's permissions\n        guild_permissions = self.guild_permissions\n\n        # Check all permissions separately\n        for permission in permissions:\n            if permission not in guild_permissions:\n                return False\n        return True\n\n    def channel_permissions(self, channel: \"TYPE_GUILD_CHANNEL\") -&gt; Permissions:\n\"\"\"\n        Returns the permissions this member has in a channel.\n\n        Args:\n            channel: The channel in question\n\n        Returns:\n            Permissions data\n\n        ??? note\n            This method is used in `Channel.permissions_for`\n\n        \"\"\"\n        permissions = self.guild_permissions\n\n        if Permissions.ADMINISTRATOR in permissions:\n            return Permissions.ALL\n\n        overwrites = tuple(\n            filter(\n                lambda overwrite: overwrite.id in (self._guild_id, self.id, *self._role_ids),\n                channel.permission_overwrites,\n            )\n        )\n\n        for everyone_overwrite in filter(lambda overwrite: overwrite.id == self._guild_id, overwrites):\n            permissions &amp;= ~everyone_overwrite.deny\n            permissions |= everyone_overwrite.allow\n\n        for role_overwrite in filter(lambda overwrite: overwrite.id not in (self._guild_id, self.id), overwrites):\n            permissions &amp;= ~role_overwrite.deny\n            permissions |= role_overwrite.allow\n\n        for member_overwrite in filter(lambda overwrite: overwrite.id == self.id, overwrites):\n            permissions &amp;= ~member_overwrite.deny\n            permissions |= member_overwrite.allow\n\n        return permissions\n\n    async def edit_nickname(self, new_nickname: Absent[str] = MISSING, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n        Change the user's nickname.\n\n        Args:\n            new_nickname: The new nickname to apply\n            reason: The reason for this change\n\n        !!! note\n            Leave `new_nickname` empty to clean user's nickname\n\n        \"\"\"\n        if self.id == self._client.user.id:\n            await self._client.http.modify_current_member(self._guild_id, nickname=new_nickname, reason=reason)\n        else:\n            await self._client.http.modify_guild_member(self._guild_id, self.id, nickname=new_nickname, reason=reason)\n\n    async def add_role(self, role: Union[Snowflake_Type, Role], reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n        Add a role to this member.\n\n        Args:\n            role: The role to add\n            reason: The reason for adding this role\n\n        \"\"\"\n        role = to_snowflake(role)\n        await self._client.http.add_guild_member_role(self._guild_id, self.id, role, reason=reason)\n        self._role_ids.append(role)\n\n    async def add_roles(self, roles: Iterable[Union[Snowflake_Type, Role]], reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n        Atomically add multiple roles to this member.\n\n        Args:\n            roles: The roles to add\n            reason: The reason for adding the roles\n\n        \"\"\"\n        new_roles = set(self._role_ids) | {to_snowflake(r) for r in roles}\n        await self.edit(roles=new_roles, reason=reason)\n\n    async def remove_role(self, role: Union[Snowflake_Type, Role], reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n        Remove a role from this user.\n\n        Args:\n            role: The role to remove\n            reason: The reason for this removal\n\n        \"\"\"\n        role = to_snowflake(role)\n        await self._client.http.remove_guild_member_role(self._guild_id, self.id, role, reason=reason)\n        try:\n            self._role_ids.remove(role)\n        except ValueError:\n            pass\n\n    async def remove_roles(self, roles: Iterable[Union[Snowflake_Type, Role]], reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n        Atomically remove multiple roles from this member.\n\n        Args:\n            roles: The roles to remove\n            reason: The reason for removing the roles\n\n        \"\"\"\n        new_roles = set(self._role_ids) - {to_snowflake(r) for r in roles}\n        await self.edit(roles=new_roles, reason=reason)\n\n    def has_role(self, *roles: Union[Snowflake_Type, Role]) -&gt; bool:\n\"\"\"\n        Checks if the user has the given role(s).\n\n        Args:\n            *roles: The role(s) to check whether the user has it.\n\n        \"\"\"\n        return all(to_snowflake(role) in self._role_ids for role in roles)\n\n    async def timeout(\n        self,\n        communication_disabled_until: Union[\"Timestamp\", datetime, int, float, str, None],\n        reason: Absent[str] = MISSING,\n    ) -&gt; dict:\n\"\"\"\n        Disable a members communication for a given time.\n\n        Args:\n            communication_disabled_until: The time until the user can communicate again\n            reason: The reason for this timeout\n\n        \"\"\"\n        if isinstance(communication_disabled_until, (datetime, int, float, str)):\n            communication_disabled_until = timestamp_converter(communication_disabled_until)\n\n        self.communication_disabled_until = communication_disabled_until\n\n        return await self._client.http.modify_guild_member(\n            self._guild_id,\n            self.id,\n            communication_disabled_until=communication_disabled_until,\n            reason=reason,\n        )\n\n    async def move(self, channel_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n        Moves the member to a different voice channel.\n\n        Args:\n            channel_id: The voice channel to move the member to\n\n        \"\"\"\n        await self._client.http.modify_guild_member(self._guild_id, self.id, channel_id=channel_id)\n\n    async def edit(\n        self,\n        *,\n        nickname: Absent[str] = MISSING,\n        roles: Absent[Iterable[\"Snowflake_Type\"]] = MISSING,\n        mute: Absent[bool] = MISSING,\n        deaf: Absent[bool] = MISSING,\n        channel_id: Absent[\"Snowflake_Type\"] = MISSING,\n        communication_disabled_until: Absent[Union[\"Timestamp\", None]] = MISSING,\n        reason: Absent[str] = MISSING,\n    ) -&gt; None:\n\"\"\"\n        Modify attrbutes of this guild member.\n\n        Args:\n            nickname: Value to set users nickname to\n            roles: Array of role ids the member is assigned\n            mute: Whether the user is muted in voice channels. Will throw a 400 if the user is not in a voice channel\n            deaf: Whether the user is deafened in voice channels\n            channel_id: id of channel to move user to (if they are connected to voice)\n            communication_disabled_until: \twhen the user's timeout will expire and the user will be able to communicate in the guild again\n            reason: An optional reason for the audit log\n        \"\"\"\n        await self._client.http.modify_guild_member(\n            self._guild_id,\n            self.id,\n            nickname=nickname,\n            roles=roles,\n            mute=mute,\n            deaf=deaf,\n            channel_id=channel_id,\n            communication_disabled_until=communication_disabled_until,\n            reason=reason,\n        )\n\n    async def kick(self, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n        Remove a member from the guild.\n\n        Args:\n            reason: The reason for this removal\n\n        \"\"\"\n        await self._client.http.remove_guild_member(self._guild_id, self.id, reason=reason)\n\n    async def ban(\n        self, delete_message_days: Absent[int] = MISSING, delete_message_seconds: int = 0, reason: Absent[str] = MISSING\n    ) -&gt; None:\n\"\"\"\n        Ban a member from the guild.\n\n        Args:\n            delete_message_days: (deprecated) The number of days of messages to delete\n            delete_message_seconds: The number of seconds of messages to delete\n            reason: The reason for this ban\n\n        \"\"\"\n        if delete_message_days is not MISSING:\n            warn(\"delete_message_days  is deprecated and will be removed in a future update\", DeprecationWarning)\n            delete_message_seconds = delete_message_days * 3600\n        await self._client.http.create_guild_ban(self._guild_id, self.id, delete_message_seconds, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.user","title":"<code>user: User</code>  <code>property</code>","text":"<p>Returns this member's user object.</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.nickname","title":"<code>nickname: str</code>  <code>property</code> <code>writable</code>","text":"<p>Alias for nick.</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.guild","title":"<code>guild: Guild</code>  <code>property</code>","text":"<p>The guild object this member is from.</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.roles","title":"<code>roles: List[Role]</code>  <code>property</code>","text":"<p>The roles this member has.</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.top_role","title":"<code>top_role: Role</code>  <code>property</code>","text":"<p>The member's top most role.</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.display_name","title":"<code>display_name: str</code>  <code>property</code>","text":"<p>The users display name, will return nickname if one is set, otherwise will return username.</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.display_avatar","title":"<code>display_avatar: Asset</code>  <code>property</code>","text":"<p>The users displayed avatar, will return <code>guild_avatar</code> if one is set, otherwise will return user avatar.</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.premium","title":"<code>premium: bool</code>  <code>property</code>","text":"<p>Is this member a server booster?</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.guild_permissions","title":"<code>guild_permissions: Permissions</code>  <code>property</code>","text":"<p>Returns the permissions this member has in the guild.</p> <p>Returns:</p> Type Description <code>Permissions</code> <p>Permission data</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.voice","title":"<code>voice: Optional[VoiceState]</code>  <code>property</code>","text":"<p>Returns the voice state of this user if any.</p>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.has_permission","title":"<code>has_permission(*permissions)</code>","text":"<p>Checks if the member has all the given permission(s).</p> Example Usage: <p>Two different styles can be used to call this method.</p> <p><pre><code>member.has_permission(Permissions.KICK_MEMBERS, Permissions.BAN_MEMBERS)\n</code></pre> or <pre><code>member.has_permission(Permissions.KICK_MEMBERS | Permissions.BAN_MEMBERS)\n</code></pre></p> <p>If <code>member</code> has both permissions, <code>True</code> gets returned.</p> <p>Parameters:</p> Name Type Description Default <code>*permissions</code> <code>Permissions</code> <p>The permission(s) to check whether the user has it.</p> <code>()</code> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>def has_permission(self, *permissions: Permissions) -&gt; bool:\n\"\"\"\n    Checks if the member has all the given permission(s).\n\n    ??? Hint \"Example Usage:\"\n        Two different styles can be used to call this method.\n\n        ```python\n        member.has_permission(Permissions.KICK_MEMBERS, Permissions.BAN_MEMBERS)\n        ```\n        or\n        ```python\n        member.has_permission(Permissions.KICK_MEMBERS | Permissions.BAN_MEMBERS)\n        ```\n\n        If `member` has both permissions, `True` gets returned.\n\n    Args:\n        *permissions: The permission(s) to check whether the user has it.\n\n    \"\"\"\n    # Get the user's permissions\n    guild_permissions = self.guild_permissions\n\n    # Check all permissions separately\n    for permission in permissions:\n        if permission not in guild_permissions:\n            return False\n    return True\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.channel_permissions","title":"<code>channel_permissions(channel)</code>","text":"<p>Returns the permissions this member has in a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>TYPE_GUILD_CHANNEL</code> <p>The channel in question</p> required <p>Returns:</p> Type Description <code>Permissions</code> <p>Permissions data</p> Note <p>This method is used in <code>Channel.permissions_for</code></p> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>def channel_permissions(self, channel: \"TYPE_GUILD_CHANNEL\") -&gt; Permissions:\n\"\"\"\n    Returns the permissions this member has in a channel.\n\n    Args:\n        channel: The channel in question\n\n    Returns:\n        Permissions data\n\n    ??? note\n        This method is used in `Channel.permissions_for`\n\n    \"\"\"\n    permissions = self.guild_permissions\n\n    if Permissions.ADMINISTRATOR in permissions:\n        return Permissions.ALL\n\n    overwrites = tuple(\n        filter(\n            lambda overwrite: overwrite.id in (self._guild_id, self.id, *self._role_ids),\n            channel.permission_overwrites,\n        )\n    )\n\n    for everyone_overwrite in filter(lambda overwrite: overwrite.id == self._guild_id, overwrites):\n        permissions &amp;= ~everyone_overwrite.deny\n        permissions |= everyone_overwrite.allow\n\n    for role_overwrite in filter(lambda overwrite: overwrite.id not in (self._guild_id, self.id), overwrites):\n        permissions &amp;= ~role_overwrite.deny\n        permissions |= role_overwrite.allow\n\n    for member_overwrite in filter(lambda overwrite: overwrite.id == self.id, overwrites):\n        permissions &amp;= ~member_overwrite.deny\n        permissions |= member_overwrite.allow\n\n    return permissions\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.edit_nickname","title":"<code>edit_nickname(new_nickname=MISSING, reason=MISSING)</code>  <code>async</code>","text":"<p>Change the user's nickname.</p> <p>Parameters:</p> Name Type Description Default <code>new_nickname</code> <code>Absent[str]</code> <p>The new nickname to apply</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for this change</p> <code>MISSING</code> <p>Note</p> <p>Leave <code>new_nickname</code> empty to clean user's nickname</p> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>async def edit_nickname(self, new_nickname: Absent[str] = MISSING, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n    Change the user's nickname.\n\n    Args:\n        new_nickname: The new nickname to apply\n        reason: The reason for this change\n\n    !!! note\n        Leave `new_nickname` empty to clean user's nickname\n\n    \"\"\"\n    if self.id == self._client.user.id:\n        await self._client.http.modify_current_member(self._guild_id, nickname=new_nickname, reason=reason)\n    else:\n        await self._client.http.modify_guild_member(self._guild_id, self.id, nickname=new_nickname, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.add_role","title":"<code>add_role(role, reason=MISSING)</code>  <code>async</code>","text":"<p>Add a role to this member.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>Union[Snowflake_Type, Role]</code> <p>The role to add</p> required <code>reason</code> <code>Absent[str]</code> <p>The reason for adding this role</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>async def add_role(self, role: Union[Snowflake_Type, Role], reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n    Add a role to this member.\n\n    Args:\n        role: The role to add\n        reason: The reason for adding this role\n\n    \"\"\"\n    role = to_snowflake(role)\n    await self._client.http.add_guild_member_role(self._guild_id, self.id, role, reason=reason)\n    self._role_ids.append(role)\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.add_roles","title":"<code>add_roles(roles, reason=MISSING)</code>  <code>async</code>","text":"<p>Atomically add multiple roles to this member.</p> <p>Parameters:</p> Name Type Description Default <code>roles</code> <code>Iterable[Union[Snowflake_Type, Role]]</code> <p>The roles to add</p> required <code>reason</code> <code>Absent[str]</code> <p>The reason for adding the roles</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>async def add_roles(self, roles: Iterable[Union[Snowflake_Type, Role]], reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n    Atomically add multiple roles to this member.\n\n    Args:\n        roles: The roles to add\n        reason: The reason for adding the roles\n\n    \"\"\"\n    new_roles = set(self._role_ids) | {to_snowflake(r) for r in roles}\n    await self.edit(roles=new_roles, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.remove_role","title":"<code>remove_role(role, reason=MISSING)</code>  <code>async</code>","text":"<p>Remove a role from this user.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>Union[Snowflake_Type, Role]</code> <p>The role to remove</p> required <code>reason</code> <code>Absent[str]</code> <p>The reason for this removal</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>async def remove_role(self, role: Union[Snowflake_Type, Role], reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n    Remove a role from this user.\n\n    Args:\n        role: The role to remove\n        reason: The reason for this removal\n\n    \"\"\"\n    role = to_snowflake(role)\n    await self._client.http.remove_guild_member_role(self._guild_id, self.id, role, reason=reason)\n    try:\n        self._role_ids.remove(role)\n    except ValueError:\n        pass\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.remove_roles","title":"<code>remove_roles(roles, reason=MISSING)</code>  <code>async</code>","text":"<p>Atomically remove multiple roles from this member.</p> <p>Parameters:</p> Name Type Description Default <code>roles</code> <code>Iterable[Union[Snowflake_Type, Role]]</code> <p>The roles to remove</p> required <code>reason</code> <code>Absent[str]</code> <p>The reason for removing the roles</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>async def remove_roles(self, roles: Iterable[Union[Snowflake_Type, Role]], reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n    Atomically remove multiple roles from this member.\n\n    Args:\n        roles: The roles to remove\n        reason: The reason for removing the roles\n\n    \"\"\"\n    new_roles = set(self._role_ids) - {to_snowflake(r) for r in roles}\n    await self.edit(roles=new_roles, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.has_role","title":"<code>has_role(*roles)</code>","text":"<p>Checks if the user has the given role(s).</p> <p>Parameters:</p> Name Type Description Default <code>*roles</code> <code>Union[Snowflake_Type, Role]</code> <p>The role(s) to check whether the user has it.</p> <code>()</code> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>def has_role(self, *roles: Union[Snowflake_Type, Role]) -&gt; bool:\n\"\"\"\n    Checks if the user has the given role(s).\n\n    Args:\n        *roles: The role(s) to check whether the user has it.\n\n    \"\"\"\n    return all(to_snowflake(role) in self._role_ids for role in roles)\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.timeout","title":"<code>timeout(communication_disabled_until, reason=MISSING)</code>  <code>async</code>","text":"<p>Disable a members communication for a given time.</p> <p>Parameters:</p> Name Type Description Default <code>communication_disabled_until</code> <code>Union[Timestamp, datetime, int, float, str, None]</code> <p>The time until the user can communicate again</p> required <code>reason</code> <code>Absent[str]</code> <p>The reason for this timeout</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>async def timeout(\n    self,\n    communication_disabled_until: Union[\"Timestamp\", datetime, int, float, str, None],\n    reason: Absent[str] = MISSING,\n) -&gt; dict:\n\"\"\"\n    Disable a members communication for a given time.\n\n    Args:\n        communication_disabled_until: The time until the user can communicate again\n        reason: The reason for this timeout\n\n    \"\"\"\n    if isinstance(communication_disabled_until, (datetime, int, float, str)):\n        communication_disabled_until = timestamp_converter(communication_disabled_until)\n\n    self.communication_disabled_until = communication_disabled_until\n\n    return await self._client.http.modify_guild_member(\n        self._guild_id,\n        self.id,\n        communication_disabled_until=communication_disabled_until,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.move","title":"<code>move(channel_id)</code>  <code>async</code>","text":"<p>Moves the member to a different voice channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Snowflake_Type</code> <p>The voice channel to move the member to</p> required Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>async def move(self, channel_id: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n    Moves the member to a different voice channel.\n\n    Args:\n        channel_id: The voice channel to move the member to\n\n    \"\"\"\n    await self._client.http.modify_guild_member(self._guild_id, self.id, channel_id=channel_id)\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.edit","title":"<code>edit(*, nickname=MISSING, roles=MISSING, mute=MISSING, deaf=MISSING, channel_id=MISSING, communication_disabled_until=MISSING, reason=MISSING)</code>  <code>async</code>","text":"<p>Modify attrbutes of this guild member.</p> <p>Parameters:</p> Name Type Description Default <code>nickname</code> <code>Absent[str]</code> <p>Value to set users nickname to</p> <code>MISSING</code> <code>roles</code> <code>Absent[Iterable[Snowflake_Type]]</code> <p>Array of role ids the member is assigned</p> <code>MISSING</code> <code>mute</code> <code>Absent[bool]</code> <p>Whether the user is muted in voice channels. Will throw a 400 if the user is not in a voice channel</p> <code>MISSING</code> <code>deaf</code> <code>Absent[bool]</code> <p>Whether the user is deafened in voice channels</p> <code>MISSING</code> <code>channel_id</code> <code>Absent[Snowflake_Type]</code> <p>id of channel to move user to (if they are connected to voice)</p> <code>MISSING</code> <code>communication_disabled_until</code> <code>Absent[Union[Timestamp, None]]</code> <p>when the user's timeout will expire and the user will be able to communicate in the guild again</p> <code>MISSING</code> <code>reason</code> <code>Absent[str]</code> <p>An optional reason for the audit log</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>async def edit(\n    self,\n    *,\n    nickname: Absent[str] = MISSING,\n    roles: Absent[Iterable[\"Snowflake_Type\"]] = MISSING,\n    mute: Absent[bool] = MISSING,\n    deaf: Absent[bool] = MISSING,\n    channel_id: Absent[\"Snowflake_Type\"] = MISSING,\n    communication_disabled_until: Absent[Union[\"Timestamp\", None]] = MISSING,\n    reason: Absent[str] = MISSING,\n) -&gt; None:\n\"\"\"\n    Modify attrbutes of this guild member.\n\n    Args:\n        nickname: Value to set users nickname to\n        roles: Array of role ids the member is assigned\n        mute: Whether the user is muted in voice channels. Will throw a 400 if the user is not in a voice channel\n        deaf: Whether the user is deafened in voice channels\n        channel_id: id of channel to move user to (if they are connected to voice)\n        communication_disabled_until: \twhen the user's timeout will expire and the user will be able to communicate in the guild again\n        reason: An optional reason for the audit log\n    \"\"\"\n    await self._client.http.modify_guild_member(\n        self._guild_id,\n        self.id,\n        nickname=nickname,\n        roles=roles,\n        mute=mute,\n        deaf=deaf,\n        channel_id=channel_id,\n        communication_disabled_until=communication_disabled_until,\n        reason=reason,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.kick","title":"<code>kick(reason=MISSING)</code>  <code>async</code>","text":"<p>Remove a member from the guild.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Absent[str]</code> <p>The reason for this removal</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>async def kick(self, reason: Absent[str] = MISSING) -&gt; None:\n\"\"\"\n    Remove a member from the guild.\n\n    Args:\n        reason: The reason for this removal\n\n    \"\"\"\n    await self._client.http.remove_guild_member(self._guild_id, self.id, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/user/#naff.models.discord.user.Member.ban","title":"<code>ban(delete_message_days=MISSING, delete_message_seconds=0, reason=MISSING)</code>  <code>async</code>","text":"<p>Ban a member from the guild.</p> <p>Parameters:</p> Name Type Description Default <code>delete_message_days</code> <code>int</code> <p>(deprecated) The number of days of messages to delete</p> <code>MISSING</code> <code>delete_message_seconds</code> <code>int</code> <p>The number of seconds of messages to delete</p> <code>0</code> <code>reason</code> <code>Absent[str]</code> <p>The reason for this ban</p> <code>MISSING</code> Source code in <code>naff\\models\\discord\\user.py</code> <pre><code>async def ban(\n    self, delete_message_days: Absent[int] = MISSING, delete_message_seconds: int = 0, reason: Absent[str] = MISSING\n) -&gt; None:\n\"\"\"\n    Ban a member from the guild.\n\n    Args:\n        delete_message_days: (deprecated) The number of days of messages to delete\n        delete_message_seconds: The number of seconds of messages to delete\n        reason: The reason for this ban\n\n    \"\"\"\n    if delete_message_days is not MISSING:\n        warn(\"delete_message_days  is deprecated and will be removed in a future update\", DeprecationWarning)\n        delete_message_seconds = delete_message_days * 3600\n    await self._client.http.create_guild_ban(self._guild_id, self.id, delete_message_seconds, reason=reason)\n</code></pre>"},{"location":"API%20Reference/models/Discord/voice_state/","title":"Voice state","text":""},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceState","title":"<code>VoiceState</code>","text":"<p>         Bases: <code>ClientObject</code></p> Source code in <code>naff\\models\\discord\\voice_state.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass VoiceState(ClientObject):\n    user_id: \"Snowflake_Type\" = attrs.field(repr=False, default=MISSING, converter=to_snowflake)\n\"\"\"the user id this voice state is for\"\"\"\n    session_id: str = attrs.field(repr=False, default=MISSING)\n\"\"\"the session id for this voice state\"\"\"\n    deaf: bool = attrs.field(repr=False, default=False)\n\"\"\"whether this user is deafened by the server\"\"\"\n    mute: bool = attrs.field(repr=False, default=False)\n\"\"\"whether this user is muted by the server\"\"\"\n    self_deaf: bool = attrs.field(repr=False, default=False)\n\"\"\"whether this user is locally deafened\"\"\"\n    self_mute: bool = attrs.field(repr=False, default=False)\n\"\"\"whether this user is locally muted\"\"\"\n    self_stream: Optional[bool] = attrs.field(repr=False, default=False)\n\"\"\"whether this user is streaming using \"Go Live\\\"\"\"\"\n    self_video: bool = attrs.field(repr=False, default=False)\n\"\"\"whether this user's camera is enabled\"\"\"\n    suppress: bool = attrs.field(repr=False, default=False)\n\"\"\"whether this user is muted by the current user\"\"\"\n    request_to_speak_timestamp: Optional[Timestamp] = attrs.field(\n        repr=False, default=None, converter=optional_c(timestamp_converter)\n    )\n\"\"\"the time at which the user requested to speak\"\"\"\n\n    # internal for props\n    _guild_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None, converter=to_snowflake)\n    _channel_id: \"Snowflake_Type\" = attrs.field(repr=False, converter=to_snowflake)\n    _member_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None, converter=to_snowflake)\n\n    @property\n    def guild(self) -&gt; \"Guild\":\n\"\"\"The guild this voice state is for.\"\"\"\n        return self._client.cache.get_guild(self._guild_id) if self._guild_id else None\n\n    @property\n    def channel(self) -&gt; \"TYPE_VOICE_CHANNEL\":\n\"\"\"The channel the user is connected to.\"\"\"\n        channel: \"TYPE_VOICE_CHANNEL\" = self._client.cache.get_channel(self._channel_id)\n\n        if channel:\n            # make sure the member is showing up as a part of the channel\n            # this is relevant for VoiceStateUpdate.before\n            # noinspection PyProtectedMember\n            if self._member_id not in channel._voice_member_ids:\n                # the list of voice members need to be deepcopied, otherwise the cached obj will be updated\n                # noinspection PyProtectedMember\n                voice_member_ids = copy.deepcopy(channel._voice_member_ids)\n\n                # create a copy of the obj\n                channel = copy.copy(channel)\n                channel._voice_member_ids = voice_member_ids\n\n                # add the member to that list\n                # noinspection PyProtectedMember\n                channel._voice_member_ids.append(self._member_id)\n\n        return channel\n\n    @property\n    def member(self) -&gt; \"Member\":\n\"\"\"The member this voice state is for.\"\"\"\n        return self._client.cache.get_member(self._guild_id, self._member_id) if self._guild_id else None\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        if member := data.pop(\"member\", None):\n            member = client.cache.place_member_data(data[\"guild_id\"], member)\n            data[\"member_id\"] = member.id\n        else:\n            data[\"member_id\"] = data[\"user_id\"]\n        return data\n</code></pre>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceState.user_id","title":"<code>user_id: Snowflake_Type = attrs.field(repr=False, default=MISSING, converter=to_snowflake)</code>  <code>class-attribute</code>","text":"<p>the user id this voice state is for</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceState.session_id","title":"<code>session_id: str = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>the session id for this voice state</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceState.deaf","title":"<code>deaf: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>whether this user is deafened by the server</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceState.mute","title":"<code>mute: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>whether this user is muted by the server</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceState.self_deaf","title":"<code>self_deaf: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>whether this user is locally deafened</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceState.self_mute","title":"<code>self_mute: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>whether this user is locally muted</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceState.self_stream","title":"<code>self_stream: Optional[bool] = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>whether this user is streaming using \"Go Live\"</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceState.self_video","title":"<code>self_video: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>whether this user's camera is enabled</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceState.suppress","title":"<code>suppress: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>whether this user is muted by the current user</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceState.request_to_speak_timestamp","title":"<code>request_to_speak_timestamp: Optional[Timestamp] = attrs.field(repr=False, default=None, converter=optional_c(timestamp_converter))</code>  <code>class-attribute</code>","text":"<p>the time at which the user requested to speak</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceState.guild","title":"<code>guild: Guild</code>  <code>property</code>","text":"<p>The guild this voice state is for.</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceState.channel","title":"<code>channel: TYPE_VOICE_CHANNEL</code>  <code>property</code>","text":"<p>The channel the user is connected to.</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceState.member","title":"<code>member: Member</code>  <code>property</code>","text":"<p>The member this voice state is for.</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceRegion","title":"<code>VoiceRegion</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> <p>A voice region.</p> Source code in <code>naff\\models\\discord\\voice_state.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass VoiceRegion(DictSerializationMixin):\n\"\"\"A voice region.\"\"\"\n\n    id: str = attrs.field(repr=True)\n\"\"\"unique ID for the region\"\"\"\n    name: str = attrs.field(repr=True)\n\"\"\"name of the region\"\"\"\n    vip: bool = attrs.field(default=False, repr=True)\n\"\"\"whether this is a VIP-only voice region\"\"\"\n    optimal: bool = attrs.field(repr=False, default=False)\n\"\"\"true for a single server that is closest to the current user's client\"\"\"\n    deprecated: bool = attrs.field(repr=False, default=False)\n\"\"\"whether this is a deprecated voice region (avoid switching to these)\"\"\"\n    custom: bool = attrs.field(repr=False, default=False)\n\"\"\"whether this is a custom voice region (used for events/etc)\"\"\"\n\n    def __str__(self) -&gt; str:\n        return self.name\n</code></pre>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceRegion.id","title":"<code>id: str = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>unique ID for the region</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceRegion.name","title":"<code>name: str = attrs.field(repr=True)</code>  <code>class-attribute</code>","text":"<p>name of the region</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceRegion.vip","title":"<code>vip: bool = attrs.field(default=False, repr=True)</code>  <code>class-attribute</code>","text":"<p>whether this is a VIP-only voice region</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceRegion.optimal","title":"<code>optimal: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>true for a single server that is closest to the current user's client</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceRegion.deprecated","title":"<code>deprecated: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>whether this is a deprecated voice region (avoid switching to these)</p>"},{"location":"API%20Reference/models/Discord/voice_state/#naff.models.discord.voice_state.VoiceRegion.custom","title":"<code>custom: bool = attrs.field(repr=False, default=False)</code>  <code>class-attribute</code>","text":"<p>whether this is a custom voice region (used for events/etc)</p>"},{"location":"API%20Reference/models/Discord/webhooks/","title":"Webhooks","text":""},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.WebhookTypes","title":"<code>WebhookTypes</code>","text":"<p>         Bases: <code>IntEnum</code></p> Source code in <code>naff\\models\\discord\\webhooks.py</code> <pre><code>class WebhookTypes(IntEnum):\n    INCOMING = 1\n\"\"\"Incoming Webhooks can post messages to channels with a generated token\"\"\"\n    CHANNEL_FOLLOWER = 2\n\"\"\"Channel Follower Webhooks are internal webhooks used with Channel Following to post new messages into channels\"\"\"\n    APPLICATION = 3\n\"\"\"Application webhooks are webhooks used with Interactions\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.WebhookTypes.INCOMING","title":"<code>INCOMING = 1</code>  <code>class-attribute</code>","text":"<p>Incoming Webhooks can post messages to channels with a generated token</p>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.WebhookTypes.CHANNEL_FOLLOWER","title":"<code>CHANNEL_FOLLOWER = 2</code>  <code>class-attribute</code>","text":"<p>Channel Follower Webhooks are internal webhooks used with Channel Following to post new messages into channels</p>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.WebhookTypes.APPLICATION","title":"<code>APPLICATION = 3</code>  <code>class-attribute</code>","text":"<p>Application webhooks are webhooks used with Interactions</p>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook","title":"<code>Webhook</code>","text":"<p>         Bases: <code>DiscordObject</code>, <code>SendMixin</code></p> Source code in <code>naff\\models\\discord\\webhooks.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass Webhook(DiscordObject, SendMixin):\n    type: WebhookTypes = attrs.field(\n        repr=False,\n    )\n\"\"\"The type of webhook\"\"\"\n\n    application_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None)\n\"\"\"the bot/OAuth2 application that created this webhook\"\"\"\n\n    guild_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None)\n\"\"\"the guild id this webhook is for, if any\"\"\"\n    channel_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None)\n\"\"\"the channel id this webhook is for, if any\"\"\"\n    user_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None)\n\"\"\"the user this webhook was created by\"\"\"\n\n    name: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"the default name of the webhook\"\"\"\n    avatar: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"the default user avatar hash of the webhook\"\"\"\n    token: str = attrs.field(repr=False, default=MISSING)\n\"\"\"the secure token of the webhook (returned for Incoming Webhooks)\"\"\"\n    url: Optional[str] = attrs.field(repr=False, default=None)\n\"\"\"the url used for executing the webhook (returned by the webhooks OAuth2 flow)\"\"\"\n\n    source_guild_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None)\n\"\"\"the guild of the channel that this webhook is following (returned for Channel Follower Webhooks)\"\"\"\n    source_channel_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None)\n\"\"\"the channel that this webhook is following (returned for Channel Follower Webhooks)\"\"\"\n\n    @classmethod\n    def from_url(cls, url: str, client: \"Client\") -&gt; \"Webhook\":\n\"\"\"\n        Webhook object from a URL.\n\n        Args:\n            client: The client to use to make the request.\n            url: Webhook URL\n\n        Returns:\n            A Webhook object.\n\n        \"\"\"\n        match = re.search(r\"discord(?:app)?\\.com/api/webhooks/(?P&lt;id&gt;[0-9]{17,})/(?P&lt;token&gt;[\\w\\-.]{60,68})\", url)\n        if match is None:\n            raise ValueError(\"Invalid webhook URL given.\")\n\n        data: Dict[str, Any] = match.groupdict()\n        data[\"type\"] = WebhookTypes.INCOMING\n        return cls.from_dict(data, client)\n\n    @classmethod\n    async def create(\n        cls,\n        client: \"Client\",\n        channel: Union[\"Snowflake_Type\", \"TYPE_MESSAGEABLE_CHANNEL\"],\n        name: str,\n        avatar: Absent[\"UPLOADABLE_TYPE\"] = MISSING,\n    ) -&gt; \"Webhook\":\n\"\"\"\n        Create a webhook.\n\n        Args:\n            client: The bot's client\n            channel: The channel to create the webhook in\n            name: The name of the webhook\n            avatar: An optional default avatar to use\n\n        Returns:\n            New webhook object\n\n        Raises:\n            ValueError: If you try to name the webhook \"Clyde\"\n\n        \"\"\"\n        if name.lower() == \"clyde\":\n            raise ValueError('Webhook names cannot be \"Clyde\"')\n\n        if not isinstance(channel, (str, int)):\n            channel = to_snowflake(channel)\n\n        if avatar:\n            avatar = to_image_data(avatar)\n\n        data = await client.http.create_webhook(channel, name, avatar)\n\n        new_cls = cls.from_dict(data, client)\n\n        return new_cls\n\n    @classmethod\n    def _process_dict(cls, data: Dict[str, Any], client: \"Client\") -&gt; Dict[str, Any]:\n        if data.get(\"user\"):\n            user = client.cache.place_user_data(data.pop(\"user\"))\n            data[\"user_id\"] = user.id\n        return data\n\n    async def edit(\n        self,\n        *,\n        name: Absent[str] = MISSING,\n        avatar: Absent[\"UPLOADABLE_TYPE\"] = MISSING,\n        channel_id: Absent[\"Snowflake_Type\"] = MISSING,\n    ) -&gt; None:\n\"\"\"\n        Edit this webhook.\n\n        Args:\n            name: The default name of the webhook.\n            avatar: The image for the default webhook avatar.\n            channel_id: The new channel id this webhook should be moved to.\n\n        Raises:\n            ValueError: If you try to name the webhook \"Clyde\"\n\n        \"\"\"\n        if name.lower() == \"clyde\":\n            raise ValueError('Webhook names cannot be \"Clyde\"')\n\n        data = await self._client.http.modify_webhook(\n            self.id, name, to_image_data(avatar), to_optional_snowflake(channel_id), self.token\n        )\n        self.update_from_dict(data)\n\n    async def delete(self) -&gt; None:\n\"\"\"Delete this webhook.\"\"\"\n        await self._client.http.delete_webhook(self.id, self.token)\n\n    async def send(\n        self,\n        content: Optional[str] = None,\n        *,\n        embed: Optional[Union[\"Embed\", dict]] = None,\n        embeds: Optional[Union[List[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n        components: Optional[\n            Union[List[List[Union[\"BaseComponent\", dict]]], List[Union[\"BaseComponent\", dict]], \"BaseComponent\", dict]\n        ] = None,\n        stickers: Optional[Union[List[Union[\"Sticker\", \"Snowflake_Type\"]], \"Sticker\", \"Snowflake_Type\"]] = None,\n        allowed_mentions: Optional[Union[\"AllowedMentions\", dict]] = None,\n        reply_to: Optional[Union[\"MessageReference\", \"Message\", dict, \"Snowflake_Type\"]] = None,\n        files: Optional[Union[\"UPLOADABLE_TYPE\", List[\"UPLOADABLE_TYPE\"]]] = None,\n        file: Optional[\"UPLOADABLE_TYPE\"] = None,\n        tts: bool = False,\n        suppress_embeds: bool = False,\n        flags: Optional[Union[int, \"MessageFlags\"]] = None,\n        username: str = None,\n        avatar_url: str = None,\n        wait: bool = False,\n        thread: \"Snowflake_Type\" = None,\n        **kwargs,\n    ) -&gt; Optional[\"Message\"]:\n\"\"\"\n        Send a message as this webhook.\n\n        Args:\n            content: Message text content.\n            embeds: Embedded rich content (up to 6000 characters).\n            embed: Embedded rich content (up to 6000 characters).\n            components: The components to include with the message.\n            stickers: IDs of up to 3 stickers in the server to send in the message.\n            allowed_mentions: Allowed mentions for the message.\n            reply_to: Message to reference, must be from the same channel.\n            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n            tts: Should this message use Text To Speech.\n            suppress_embeds: Should embeds be suppressed on this send\n            flags: Message flags to apply.\n            username: The username to use\n            avatar_url: The url of an image to use as the avatar\n            wait: Waits for confirmation of delivery. Set this to True if you intend to edit the message\n            thread: Send this webhook to a thread channel\n\n        Returns:\n            New message object that was sent if `wait` is set to True\n\n        \"\"\"\n        if not self.token:\n            raise ForeignWebhookException(\"You cannot send messages with a webhook without a token!\")\n\n        if not content and not (embeds or embed) and not (files or file) and not stickers:\n            raise EmptyMessageException(\"You cannot send a message without any content, embeds, files, or stickers\")\n\n        if suppress_embeds:\n            if isinstance(flags, int):\n                flags = MessageFlags(flags)\n            flags = flags | MessageFlags.SUPPRESS_EMBEDS\n\n        message_payload = process_message_payload(\n            content=content,\n            embeds=embeds or embed,\n            components=components,\n            stickers=stickers,\n            allowed_mentions=allowed_mentions,\n            reply_to=reply_to,\n            tts=tts,\n            flags=flags,\n            username=username,\n            avatar_url=avatar_url,\n            **kwargs,\n        )\n\n        message_data = await self._client.http.execute_webhook(\n            self.id, self.token, message_payload, wait, to_optional_snowflake(thread), files=files or file\n        )\n        if message_data:\n            return self._client.cache.place_message_data(message_data)\n\n    async def edit_message(\n        self,\n        message: Union[\"Message\", \"Snowflake_Type\"],\n        *,\n        content: Optional[str] = None,\n        embeds: Optional[Union[List[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n        components: Optional[\n            Union[List[List[Union[\"BaseComponent\", dict]]], List[Union[\"BaseComponent\", dict]], \"BaseComponent\", dict]\n        ] = None,\n        stickers: Optional[Union[List[Union[\"Sticker\", \"Snowflake_Type\"]], \"Sticker\", \"Snowflake_Type\"]] = None,\n        allowed_mentions: Optional[Union[\"AllowedMentions\", dict]] = None,\n        reply_to: Optional[Union[\"MessageReference\", \"Message\", dict, \"Snowflake_Type\"]] = None,\n        files: Optional[Union[\"UPLOADABLE_TYPE\", List[\"UPLOADABLE_TYPE\"]]] = None,\n        file: Optional[\"UPLOADABLE_TYPE\"] = None,\n        tts: bool = False,\n        flags: Optional[Union[int, \"MessageFlags\"]] = None,\n    ) -&gt; Optional[\"Message\"]:\n\"\"\"\n        Edit a message as this webhook.\n\n        Args:\n            message: Message to edit\n            content: Message text content.\n            embeds: Embedded rich content (up to 6000 characters).\n            components: The components to include with the message.\n            stickers: IDs of up to 3 stickers in the server to send in the message.\n            allowed_mentions: Allowed mentions for the message.\n            reply_to: Message to reference, must be from the same channel.\n            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n            tts: Should this message use Text To Speech.\n            flags: Message flags to apply.\n\n        Returns:\n            Updated message object that was sent if `wait` is set to True\n\n        \"\"\"\n        message_payload = process_message_payload(\n            content=content,\n            embeds=embeds,\n            components=components,\n            stickers=stickers,\n            allowed_mentions=allowed_mentions,\n            reply_to=reply_to,\n            tts=tts,\n            flags=flags,\n        )\n        msg_data = await self._client.http.edit_webhook_message(\n            self.id, self.token, to_snowflake(message), message_payload, files=files or file\n        )\n        if msg_data:\n            return self._client.cache.place_message_data(msg_data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.type","title":"<code>type: WebhookTypes = attrs.field(repr=False)</code>  <code>class-attribute</code>","text":"<p>The type of webhook</p>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.application_id","title":"<code>application_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>the bot/OAuth2 application that created this webhook</p>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.guild_id","title":"<code>guild_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>the guild id this webhook is for, if any</p>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.channel_id","title":"<code>channel_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>the channel id this webhook is for, if any</p>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.user_id","title":"<code>user_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>the user this webhook was created by</p>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.name","title":"<code>name: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>the default name of the webhook</p>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.avatar","title":"<code>avatar: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>the default user avatar hash of the webhook</p>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.token","title":"<code>token: str = attrs.field(repr=False, default=MISSING)</code>  <code>class-attribute</code>","text":"<p>the secure token of the webhook (returned for Incoming Webhooks)</p>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.url","title":"<code>url: Optional[str] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>the url used for executing the webhook (returned by the webhooks OAuth2 flow)</p>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.source_guild_id","title":"<code>source_guild_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>the guild of the channel that this webhook is following (returned for Channel Follower Webhooks)</p>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.source_channel_id","title":"<code>source_channel_id: Optional[Snowflake_Type] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>the channel that this webhook is following (returned for Channel Follower Webhooks)</p>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.from_url","title":"<code>from_url(url, client)</code>  <code>classmethod</code>","text":"<p>Webhook object from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The client to use to make the request.</p> required <code>url</code> <code>str</code> <p>Webhook URL</p> required <p>Returns:</p> Type Description <code>Webhook</code> <p>A Webhook object.</p> Source code in <code>naff\\models\\discord\\webhooks.py</code> <pre><code>@classmethod\ndef from_url(cls, url: str, client: \"Client\") -&gt; \"Webhook\":\n\"\"\"\n    Webhook object from a URL.\n\n    Args:\n        client: The client to use to make the request.\n        url: Webhook URL\n\n    Returns:\n        A Webhook object.\n\n    \"\"\"\n    match = re.search(r\"discord(?:app)?\\.com/api/webhooks/(?P&lt;id&gt;[0-9]{17,})/(?P&lt;token&gt;[\\w\\-.]{60,68})\", url)\n    if match is None:\n        raise ValueError(\"Invalid webhook URL given.\")\n\n    data: Dict[str, Any] = match.groupdict()\n    data[\"type\"] = WebhookTypes.INCOMING\n    return cls.from_dict(data, client)\n</code></pre>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.create","title":"<code>create(client, channel, name, avatar=MISSING)</code>  <code>classmethod</code> <code>async</code>","text":"<p>Create a webhook.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The bot's client</p> required <code>channel</code> <code>Union[Snowflake_Type, TYPE_MESSAGEABLE_CHANNEL]</code> <p>The channel to create the webhook in</p> required <code>name</code> <code>str</code> <p>The name of the webhook</p> required <code>avatar</code> <code>Absent[UPLOADABLE_TYPE]</code> <p>An optional default avatar to use</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Webhook</code> <p>New webhook object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If you try to name the webhook \"Clyde\"</p> Source code in <code>naff\\models\\discord\\webhooks.py</code> <pre><code>@classmethod\nasync def create(\n    cls,\n    client: \"Client\",\n    channel: Union[\"Snowflake_Type\", \"TYPE_MESSAGEABLE_CHANNEL\"],\n    name: str,\n    avatar: Absent[\"UPLOADABLE_TYPE\"] = MISSING,\n) -&gt; \"Webhook\":\n\"\"\"\n    Create a webhook.\n\n    Args:\n        client: The bot's client\n        channel: The channel to create the webhook in\n        name: The name of the webhook\n        avatar: An optional default avatar to use\n\n    Returns:\n        New webhook object\n\n    Raises:\n        ValueError: If you try to name the webhook \"Clyde\"\n\n    \"\"\"\n    if name.lower() == \"clyde\":\n        raise ValueError('Webhook names cannot be \"Clyde\"')\n\n    if not isinstance(channel, (str, int)):\n        channel = to_snowflake(channel)\n\n    if avatar:\n        avatar = to_image_data(avatar)\n\n    data = await client.http.create_webhook(channel, name, avatar)\n\n    new_cls = cls.from_dict(data, client)\n\n    return new_cls\n</code></pre>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.edit","title":"<code>edit(*, name=MISSING, avatar=MISSING, channel_id=MISSING)</code>  <code>async</code>","text":"<p>Edit this webhook.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Absent[str]</code> <p>The default name of the webhook.</p> <code>MISSING</code> <code>avatar</code> <code>Absent[UPLOADABLE_TYPE]</code> <p>The image for the default webhook avatar.</p> <code>MISSING</code> <code>channel_id</code> <code>Absent[Snowflake_Type]</code> <p>The new channel id this webhook should be moved to.</p> <code>MISSING</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If you try to name the webhook \"Clyde\"</p> Source code in <code>naff\\models\\discord\\webhooks.py</code> <pre><code>async def edit(\n    self,\n    *,\n    name: Absent[str] = MISSING,\n    avatar: Absent[\"UPLOADABLE_TYPE\"] = MISSING,\n    channel_id: Absent[\"Snowflake_Type\"] = MISSING,\n) -&gt; None:\n\"\"\"\n    Edit this webhook.\n\n    Args:\n        name: The default name of the webhook.\n        avatar: The image for the default webhook avatar.\n        channel_id: The new channel id this webhook should be moved to.\n\n    Raises:\n        ValueError: If you try to name the webhook \"Clyde\"\n\n    \"\"\"\n    if name.lower() == \"clyde\":\n        raise ValueError('Webhook names cannot be \"Clyde\"')\n\n    data = await self._client.http.modify_webhook(\n        self.id, name, to_image_data(avatar), to_optional_snowflake(channel_id), self.token\n    )\n    self.update_from_dict(data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.delete","title":"<code>delete()</code>  <code>async</code>","text":"<p>Delete this webhook.</p> Source code in <code>naff\\models\\discord\\webhooks.py</code> <pre><code>async def delete(self) -&gt; None:\n\"\"\"Delete this webhook.\"\"\"\n    await self._client.http.delete_webhook(self.id, self.token)\n</code></pre>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.send","title":"<code>send(content=None, *, embed=None, embeds=None, components=None, stickers=None, allowed_mentions=None, reply_to=None, files=None, file=None, tts=False, suppress_embeds=False, flags=None, username=None, avatar_url=None, wait=False, thread=None, **kwargs)</code>  <code>async</code>","text":"<p>Send a message as this webhook.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>Optional[str]</code> <p>Message text content.</p> <code>None</code> <code>embeds</code> <code>Optional[Union[List[Union[Embed, dict]], Union[Embed, dict]]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>embed</code> <code>Optional[Union[Embed, dict]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>components</code> <code>Optional[Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict]]</code> <p>The components to include with the message.</p> <code>None</code> <code>stickers</code> <code>Optional[Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type]]</code> <p>IDs of up to 3 stickers in the server to send in the message.</p> <code>None</code> <code>allowed_mentions</code> <code>Optional[Union[AllowedMentions, dict]]</code> <p>Allowed mentions for the message.</p> <code>None</code> <code>reply_to</code> <code>Optional[Union[MessageReference, Message, dict, Snowflake_Type]]</code> <p>Message to reference, must be from the same channel.</p> <code>None</code> <code>files</code> <code>Optional[Union[UPLOADABLE_TYPE, List[UPLOADABLE_TYPE]]]</code> <p>Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.</p> <code>None</code> <code>file</code> <code>Optional[UPLOADABLE_TYPE]</code> <p>Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.</p> <code>None</code> <code>tts</code> <code>bool</code> <p>Should this message use Text To Speech.</p> <code>False</code> <code>suppress_embeds</code> <code>bool</code> <p>Should embeds be suppressed on this send</p> <code>False</code> <code>flags</code> <code>Optional[Union[int, MessageFlags]]</code> <p>Message flags to apply.</p> <code>None</code> <code>username</code> <code>str</code> <p>The username to use</p> <code>None</code> <code>avatar_url</code> <code>str</code> <p>The url of an image to use as the avatar</p> <code>None</code> <code>wait</code> <code>bool</code> <p>Waits for confirmation of delivery. Set this to True if you intend to edit the message</p> <code>False</code> <code>thread</code> <code>Snowflake_Type</code> <p>Send this webhook to a thread channel</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Message]</code> <p>New message object that was sent if <code>wait</code> is set to True</p> Source code in <code>naff\\models\\discord\\webhooks.py</code> <pre><code>async def send(\n    self,\n    content: Optional[str] = None,\n    *,\n    embed: Optional[Union[\"Embed\", dict]] = None,\n    embeds: Optional[Union[List[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n    components: Optional[\n        Union[List[List[Union[\"BaseComponent\", dict]]], List[Union[\"BaseComponent\", dict]], \"BaseComponent\", dict]\n    ] = None,\n    stickers: Optional[Union[List[Union[\"Sticker\", \"Snowflake_Type\"]], \"Sticker\", \"Snowflake_Type\"]] = None,\n    allowed_mentions: Optional[Union[\"AllowedMentions\", dict]] = None,\n    reply_to: Optional[Union[\"MessageReference\", \"Message\", dict, \"Snowflake_Type\"]] = None,\n    files: Optional[Union[\"UPLOADABLE_TYPE\", List[\"UPLOADABLE_TYPE\"]]] = None,\n    file: Optional[\"UPLOADABLE_TYPE\"] = None,\n    tts: bool = False,\n    suppress_embeds: bool = False,\n    flags: Optional[Union[int, \"MessageFlags\"]] = None,\n    username: str = None,\n    avatar_url: str = None,\n    wait: bool = False,\n    thread: \"Snowflake_Type\" = None,\n    **kwargs,\n) -&gt; Optional[\"Message\"]:\n\"\"\"\n    Send a message as this webhook.\n\n    Args:\n        content: Message text content.\n        embeds: Embedded rich content (up to 6000 characters).\n        embed: Embedded rich content (up to 6000 characters).\n        components: The components to include with the message.\n        stickers: IDs of up to 3 stickers in the server to send in the message.\n        allowed_mentions: Allowed mentions for the message.\n        reply_to: Message to reference, must be from the same channel.\n        files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n        file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n        tts: Should this message use Text To Speech.\n        suppress_embeds: Should embeds be suppressed on this send\n        flags: Message flags to apply.\n        username: The username to use\n        avatar_url: The url of an image to use as the avatar\n        wait: Waits for confirmation of delivery. Set this to True if you intend to edit the message\n        thread: Send this webhook to a thread channel\n\n    Returns:\n        New message object that was sent if `wait` is set to True\n\n    \"\"\"\n    if not self.token:\n        raise ForeignWebhookException(\"You cannot send messages with a webhook without a token!\")\n\n    if not content and not (embeds or embed) and not (files or file) and not stickers:\n        raise EmptyMessageException(\"You cannot send a message without any content, embeds, files, or stickers\")\n\n    if suppress_embeds:\n        if isinstance(flags, int):\n            flags = MessageFlags(flags)\n        flags = flags | MessageFlags.SUPPRESS_EMBEDS\n\n    message_payload = process_message_payload(\n        content=content,\n        embeds=embeds or embed,\n        components=components,\n        stickers=stickers,\n        allowed_mentions=allowed_mentions,\n        reply_to=reply_to,\n        tts=tts,\n        flags=flags,\n        username=username,\n        avatar_url=avatar_url,\n        **kwargs,\n    )\n\n    message_data = await self._client.http.execute_webhook(\n        self.id, self.token, message_payload, wait, to_optional_snowflake(thread), files=files or file\n    )\n    if message_data:\n        return self._client.cache.place_message_data(message_data)\n</code></pre>"},{"location":"API%20Reference/models/Discord/webhooks/#naff.models.discord.webhooks.Webhook.edit_message","title":"<code>edit_message(message, *, content=None, embeds=None, components=None, stickers=None, allowed_mentions=None, reply_to=None, files=None, file=None, tts=False, flags=None)</code>  <code>async</code>","text":"<p>Edit a message as this webhook.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Union[Message, Snowflake_Type]</code> <p>Message to edit</p> required <code>content</code> <code>Optional[str]</code> <p>Message text content.</p> <code>None</code> <code>embeds</code> <code>Optional[Union[List[Union[Embed, dict]], Union[Embed, dict]]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>components</code> <code>Optional[Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict]]</code> <p>The components to include with the message.</p> <code>None</code> <code>stickers</code> <code>Optional[Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type]]</code> <p>IDs of up to 3 stickers in the server to send in the message.</p> <code>None</code> <code>allowed_mentions</code> <code>Optional[Union[AllowedMentions, dict]]</code> <p>Allowed mentions for the message.</p> <code>None</code> <code>reply_to</code> <code>Optional[Union[MessageReference, Message, dict, Snowflake_Type]]</code> <p>Message to reference, must be from the same channel.</p> <code>None</code> <code>files</code> <code>Optional[Union[UPLOADABLE_TYPE, List[UPLOADABLE_TYPE]]]</code> <p>Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.</p> <code>None</code> <code>file</code> <code>Optional[UPLOADABLE_TYPE]</code> <p>Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.</p> <code>None</code> <code>tts</code> <code>bool</code> <p>Should this message use Text To Speech.</p> <code>False</code> <code>flags</code> <code>Optional[Union[int, MessageFlags]]</code> <p>Message flags to apply.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Message]</code> <p>Updated message object that was sent if <code>wait</code> is set to True</p> Source code in <code>naff\\models\\discord\\webhooks.py</code> <pre><code>async def edit_message(\n    self,\n    message: Union[\"Message\", \"Snowflake_Type\"],\n    *,\n    content: Optional[str] = None,\n    embeds: Optional[Union[List[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n    components: Optional[\n        Union[List[List[Union[\"BaseComponent\", dict]]], List[Union[\"BaseComponent\", dict]], \"BaseComponent\", dict]\n    ] = None,\n    stickers: Optional[Union[List[Union[\"Sticker\", \"Snowflake_Type\"]], \"Sticker\", \"Snowflake_Type\"]] = None,\n    allowed_mentions: Optional[Union[\"AllowedMentions\", dict]] = None,\n    reply_to: Optional[Union[\"MessageReference\", \"Message\", dict, \"Snowflake_Type\"]] = None,\n    files: Optional[Union[\"UPLOADABLE_TYPE\", List[\"UPLOADABLE_TYPE\"]]] = None,\n    file: Optional[\"UPLOADABLE_TYPE\"] = None,\n    tts: bool = False,\n    flags: Optional[Union[int, \"MessageFlags\"]] = None,\n) -&gt; Optional[\"Message\"]:\n\"\"\"\n    Edit a message as this webhook.\n\n    Args:\n        message: Message to edit\n        content: Message text content.\n        embeds: Embedded rich content (up to 6000 characters).\n        components: The components to include with the message.\n        stickers: IDs of up to 3 stickers in the server to send in the message.\n        allowed_mentions: Allowed mentions for the message.\n        reply_to: Message to reference, must be from the same channel.\n        files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n        file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n        tts: Should this message use Text To Speech.\n        flags: Message flags to apply.\n\n    Returns:\n        Updated message object that was sent if `wait` is set to True\n\n    \"\"\"\n    message_payload = process_message_payload(\n        content=content,\n        embeds=embeds,\n        components=components,\n        stickers=stickers,\n        allowed_mentions=allowed_mentions,\n        reply_to=reply_to,\n        tts=tts,\n        flags=flags,\n    )\n    msg_data = await self._client.http.edit_webhook_message(\n        self.id, self.token, to_snowflake(message), message_payload, files=files or file\n    )\n    if msg_data:\n        return self._client.cache.place_message_data(msg_data)\n</code></pre>"},{"location":"API%20Reference/models/Misc/","title":"Misc Models Index","text":"<ul> <li>Iterator</li> </ul>"},{"location":"API%20Reference/models/Misc/iterator/","title":"Iterator","text":""},{"location":"API%20Reference/models/Misc/iterator/#naff.models.misc.iterator.AsyncIterator","title":"<code>AsyncIterator</code>","text":"<p>         Bases: <code>_AsyncIterator</code>, <code>ABC</code></p> Source code in <code>naff\\models\\misc\\iterator.py</code> <pre><code>class AsyncIterator(_AsyncIterator, ABC):\n    def __init__(self, limit: int = 50) -&gt; None:\n        self._queue: asyncio.Queue = asyncio.Queue()\n\"\"\"The queue of items in the iterator\"\"\"\n\n        self._limit: int = limit if limit else MISSING\n\"\"\"the limit of items to retrieve\"\"\"\n\n        self.last: Absent[Any] = MISSING\n\"\"\"The last item retrieved\"\"\"\n\n        self._retrieved_objects: List = []\n\"\"\"All items this iterator has retrieved\"\"\"\n\n    @property\n    def _continue(self) -&gt; bool:\n\"\"\"Whether iteration should continue. Returns False if the limit has been reached.\"\"\"\n        if not self._limit:\n            return True\n        return not len(self._retrieved_objects) &gt;= self._limit\n\n    @property\n    def get_limit(self) -&gt; int:\n\"\"\"Get how the maximum number of items that should be retrieved.\"\"\"\n        return min(self._limit - len(self._retrieved_objects), 100) if self._limit else 100\n\n    @property\n    def total_retrieved(self) -&gt; int:\n\"\"\"Get the total number of objects this iterator has retrieved.\"\"\"\n        return len(self._retrieved_objects)\n\n    async def add_object(self, obj) -&gt; None:\n\"\"\"Add an object to iterator's queue.\"\"\"\n        return await self._queue.put(obj)\n\n    @abstractmethod\n    async def fetch(self) -&gt; list:\n\"\"\"\n        Fetch additional objects.\n\n        Your implementation of this method *must* return a list of objects.\n        If no more objects are available, raise QueueEmpty\n\n        Returns:\n            List of objects\n\n        Raises:\n            QueueEmpty:  when no more objects are available.\n\n        \"\"\"\n        ...\n\n    async def _get_items(self) -&gt; None:\n        if self._continue:\n            data = await self.fetch()\n            [await self.add_object(obj) for obj in data]\n        else:\n            raise QueueEmpty\n\n    async def __anext__(self) -&gt; Any:\n        try:\n            if self._queue.empty():\n                await self._get_items()\n            self.last = self._queue.get_nowait()\n\n            # add the message to the already retrieved objects, so that the search function works when calling it multiple times\n            self._retrieved_objects.append(self.last)\n\n            return self.last\n        except QueueEmpty as e:\n            raise StopAsyncIteration from e\n\n    async def flatten(self) -&gt; List:\n\"\"\"Flatten this iterator into a list of objects.\"\"\"\n        return [elem async for elem in self]\n\n    async def search(self, target_id: \"snowflake.Snowflake_Type\") -&gt; bool:\n\"\"\"Search the iterator for an object with the given ID.\"\"\"\n        target_id = snowflake.to_snowflake(target_id)\n\n        if target_id in [o.id for o in self._retrieved_objects]:\n            return True\n\n        async for o in self:\n            if o.id == target_id:\n                return True\n        return False\n</code></pre>"},{"location":"API%20Reference/models/Misc/iterator/#naff.models.misc.iterator.AsyncIterator.last","title":"<code>last: Absent[Any] = MISSING</code>  <code>instance-attribute</code>","text":"<p>The last item retrieved</p>"},{"location":"API%20Reference/models/Misc/iterator/#naff.models.misc.iterator.AsyncIterator.get_limit","title":"<code>get_limit: int</code>  <code>property</code>","text":"<p>Get how the maximum number of items that should be retrieved.</p>"},{"location":"API%20Reference/models/Misc/iterator/#naff.models.misc.iterator.AsyncIterator.total_retrieved","title":"<code>total_retrieved: int</code>  <code>property</code>","text":"<p>Get the total number of objects this iterator has retrieved.</p>"},{"location":"API%20Reference/models/Misc/iterator/#naff.models.misc.iterator.AsyncIterator.add_object","title":"<code>add_object(obj)</code>  <code>async</code>","text":"<p>Add an object to iterator's queue.</p> Source code in <code>naff\\models\\misc\\iterator.py</code> <pre><code>async def add_object(self, obj) -&gt; None:\n\"\"\"Add an object to iterator's queue.\"\"\"\n    return await self._queue.put(obj)\n</code></pre>"},{"location":"API%20Reference/models/Misc/iterator/#naff.models.misc.iterator.AsyncIterator.fetch","title":"<code>fetch()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Fetch additional objects.</p> <p>Your implementation of this method must return a list of objects. If no more objects are available, raise QueueEmpty</p> <p>Returns:</p> Type Description <code>list</code> <p>List of objects</p> <p>Raises:</p> Type Description <code>QueueEmpty</code> <p>when no more objects are available.</p> Source code in <code>naff\\models\\misc\\iterator.py</code> <pre><code>@abstractmethod\nasync def fetch(self) -&gt; list:\n\"\"\"\n    Fetch additional objects.\n\n    Your implementation of this method *must* return a list of objects.\n    If no more objects are available, raise QueueEmpty\n\n    Returns:\n        List of objects\n\n    Raises:\n        QueueEmpty:  when no more objects are available.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API%20Reference/models/Misc/iterator/#naff.models.misc.iterator.AsyncIterator.flatten","title":"<code>flatten()</code>  <code>async</code>","text":"<p>Flatten this iterator into a list of objects.</p> Source code in <code>naff\\models\\misc\\iterator.py</code> <pre><code>async def flatten(self) -&gt; List:\n\"\"\"Flatten this iterator into a list of objects.\"\"\"\n    return [elem async for elem in self]\n</code></pre>"},{"location":"API%20Reference/models/Misc/iterator/#naff.models.misc.iterator.AsyncIterator.search","title":"<code>search(target_id)</code>  <code>async</code>","text":"<p>Search the iterator for an object with the given ID.</p> Source code in <code>naff\\models\\misc\\iterator.py</code> <pre><code>async def search(self, target_id: \"snowflake.Snowflake_Type\") -&gt; bool:\n\"\"\"Search the iterator for an object with the given ID.\"\"\"\n    target_id = snowflake.to_snowflake(target_id)\n\n    if target_id in [o.id for o in self._retrieved_objects]:\n        return True\n\n    async for o in self:\n        if o.id == target_id:\n            return True\n    return False\n</code></pre>"},{"location":"API%20Reference/models/Naff/","title":"NAFF Models Index","text":"<ul> <li>Active Voice State</li> <li>Application Commands</li> <li>Auto Defer</li> <li>Checks</li> <li>Commands</li> <li>Context</li> <li>Converters</li> <li>Cooldowns</li> <li>Extension</li> <li>Hybrid Commands</li> <li>Listeners</li> <li>Localisation</li> <li>Prefixed Commands</li> <li>Protocols</li> <li>Tasks</li> <li>Waits</li> </ul>"},{"location":"API%20Reference/models/Naff/active_voice_state/","title":"Active voice state","text":"Example Usage: <p><pre><code>from naff import slash_command, slash_option, OptionTypes, InteractionContext\nfrom naff.api.voice.audio import AudioVolume\n\n\n@slash_command(\"play\")\n@slash_option(\"song\", \"The song to play\", OptionTypes.STRING, required=True)\nasync def test_cmd(ctx: InteractionContext, song: str):\n    await ctx.defer()\n\n    if not ctx.voice_state:\n        await ctx.author.voice.channel.connect() # (1)!\n\n    await ctx.send(f\"Playing {song}\")\n    await ctx.voice_state.play(AudioVolume(song)) # (2)!\n</code></pre></p> <ol> <li>This connects the bot to the author's voice channel if we are not already connected</li> <li>Check out the Voice Support Guide for more info on audio playback</li> </ol>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState","title":"<code>ActiveVoiceState</code>","text":"<p>         Bases: <code>VoiceState</code></p> Source code in <code>naff\\models\\naff\\active_voice_state.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ActiveVoiceState(VoiceState):\n    ws: Optional[VoiceGateway] = attrs.field(repr=False, default=None)\n\"\"\"The websocket for this voice state\"\"\"\n    player: Optional[Player] = attrs.field(repr=False, default=None)\n\"\"\"The playback task that broadcasts audio data to discord\"\"\"\n    _volume: float = attrs.field(repr=False, default=0.5)\n\n    # standard voice states expect this data, this voice state lacks it initially; so we make them optional\n    user_id: \"Snowflake_Type\" = attrs.field(repr=False, default=MISSING, converter=optional(to_snowflake))\n    _guild_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))\n    _member_id: Optional[\"Snowflake_Type\"] = attrs.field(repr=False, default=None, converter=optional(to_snowflake))\n\n    def __attrs_post_init__(self) -&gt; None:\n        # jank line to handle the two inherently incompatible data structures\n        self._member_id = self.user_id = self._client.user.id\n\n    def __del__(self) -&gt; None:\n        if self.connected:\n            self.ws.close()\n        if self.player:\n            self.player.stop()\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;ActiveVoiceState: channel={self.channel} guild={self.guild} volume={self.volume} playing={self.playing} audio={self.current_audio}&gt;\"\n\n    @property\n    def current_audio(self) -&gt; Optional[\"BaseAudio\"]:\n\"\"\"The current audio being played\"\"\"\n        if self.player:\n            return self.player.current_audio\n\n    @property\n    def volume(self) -&gt; float:\n\"\"\"Get the volume of the player\"\"\"\n        return self._volume\n\n    @volume.setter\n    def volume(self, value) -&gt; None:\n\"\"\"Set the volume of the player\"\"\"\n        if value &lt; 0.0:\n            raise ValueError(\"Volume may not be negative.\")\n        self._volume = value\n        if self.player and hasattr(self.player.current_audio, \"volume\"):\n            self.player.current_audio.volume = value\n\n    @property\n    def paused(self) -&gt; bool:\n\"\"\"Is the player currently paused\"\"\"\n        if self.player:\n            return self.player.paused\n        return False\n\n    @property\n    def playing(self) -&gt; bool:\n\"\"\"Are we currently playing something?\"\"\"\n        # noinspection PyProtectedMember\n        if not self.player or not self.current_audio or self.player.stopped or not self.player._resume.is_set():\n            # if any of the above are truthy, we aren't playing\n            return False\n        return True\n\n    @property\n    def stopped(self) -&gt; bool:\n\"\"\"Is the player stopped?\"\"\"\n        if self.player:\n            return self.player.stopped\n        return True\n\n    @property\n    def connected(self) -&gt; bool:\n\"\"\"Is this voice state currently connected?\"\"\"\n        # noinspection PyProtectedMember\n        if self.ws is None:\n            return False\n        return self.ws._closed.is_set()\n\n    @property\n    def gateway(self) -&gt; \"GatewayClient\":\n        return self._client.get_guild_websocket(self._guild_id)\n\n    async def wait_for_stopped(self) -&gt; None:\n\"\"\"Wait for the player to stop playing.\"\"\"\n        if self.player:\n            # noinspection PyProtectedMember\n            await self.player._stopped.wait()\n\n    async def _ws_connect(self) -&gt; None:\n\"\"\"Runs the voice gateway connection\"\"\"\n        async with self.ws:\n            try:\n                await self.ws.run()\n            finally:\n                if self.playing:\n                    await self.stop()\n\n    async def ws_connect(self) -&gt; None:\n\"\"\"Connect to the voice gateway for this voice state\"\"\"\n        self.ws = VoiceGateway(self._client._connection_state, self._voice_state.data, self._voice_server.data)\n\n        asyncio.create_task(self._ws_connect())\n        await self.ws.wait_until_ready()\n\n    def _guild_predicate(self, event) -&gt; bool:\n        return int(event.data[\"guild_id\"]) == self._guild_id\n\n    async def connect(self, timeout: int = 5) -&gt; None:\n\"\"\"\n        Establish the voice connection.\n\n        Args:\n            timeout: How long to wait for state and server information from discord\n\n        Raises:\n            VoiceAlreadyConnected: if the voice state is already connected to the voice channel\n            VoiceConnectionTimeout: if the voice state fails to connect\n\n        \"\"\"\n        if self.connected:\n            raise VoiceAlreadyConnected\n        await self.gateway.voice_state_update(self._guild_id, self._channel_id, self.self_mute, self.self_deaf)\n\n        self.logger.debug(\"Waiting for voice connection data...\")\n\n        try:\n            self._voice_state, self._voice_server = await asyncio.gather(\n                self._client.wait_for(\"raw_voice_state_update\", self._guild_predicate, timeout=timeout),\n                self._client.wait_for(\"raw_voice_server_update\", self._guild_predicate, timeout=timeout),\n            )\n        except asyncio.TimeoutError:\n            raise VoiceConnectionTimeout from None\n\n        self.logger.debug(\"Attempting to initialise voice gateway...\")\n        await self.ws_connect()\n\n    async def disconnect(self) -&gt; None:\n\"\"\"Disconnect from the voice channel.\"\"\"\n        await self.gateway.voice_state_update(self._guild_id, None)\n\n    async def move(self, channel: \"Snowflake_Type\", timeout: int = 5) -&gt; None:\n\"\"\"\n        Move to another voice channel.\n\n        Args:\n            channel: The channel to move to\n            timeout: How long to wait for state and server information from discord\n\n        \"\"\"\n        target_channel = to_snowflake(channel)\n        if target_channel != self._channel_id:\n            already_paused = self.paused\n            if self.player:\n                self.player.pause()\n\n            self._channel_id = target_channel\n            await self.gateway.voice_state_update(self._guild_id, self._channel_id, self.self_mute, self.self_deaf)\n\n            self.logger.debug(\"Waiting for voice connection data...\")\n            try:\n                await self._client.wait_for(\"raw_voice_state_update\", self._guild_predicate, timeout=timeout)\n            except asyncio.TimeoutError:\n                await self._close_connection()\n                raise VoiceConnectionTimeout from None\n\n            if self.player and not already_paused:\n                self.player.resume()\n\n    async def stop(self) -&gt; None:\n\"\"\"Stop playback.\"\"\"\n        self.player.stop()\n        await self.player._stopped.wait()\n\n    def pause(self) -&gt; None:\n\"\"\"Pause playback\"\"\"\n        self.player.pause()\n\n    def resume(self) -&gt; None:\n\"\"\"Resume playback.\"\"\"\n        self.player.resume()\n\n    async def play(self, audio: \"BaseAudio\") -&gt; None:\n\"\"\"\n        Start playing an audio object.\n\n        Waits for the player to stop before returning.\n\n        Args:\n            audio: The audio object to play\n        \"\"\"\n        if self.player:\n            await self.stop()\n\n        with Player(audio, self, asyncio.get_running_loop()) as self.player:\n            self.player.play()\n            await self.wait_for_stopped()\n\n    def play_no_wait(self, audio: \"BaseAudio\") -&gt; None:\n\"\"\"\n        Start playing an audio object, but don't wait for playback to finish.\n\n        Args:\n            audio: The audio object to play\n        \"\"\"\n        asyncio.create_task(self.play(audio))\n\n    async def _voice_server_update(self, data) -&gt; None:\n\"\"\"\n        An internal receiver for voice server events.\n\n        Args:\n            data: voice server data\n        \"\"\"\n        self.ws.set_new_voice_server(data)\n\n    async def _voice_state_update(\n        self, before: Optional[VoiceState], after: Optional[VoiceState], data: Optional[VoiceStateData]\n    ) -&gt; None:\n\"\"\"\n        An internal receiver for voice server state events.\n\n        Args:\n            before: The previous voice state\n            after: The current voice state\n            data: Raw data from gateway\n        \"\"\"\n        if after is None:\n            # bot disconnected\n            self.logger.info(f\"Disconnecting from voice channel {self._channel_id}\")\n            await self._close_connection()\n            self._client.cache.delete_bot_voice_state(self._guild_id)\n            return\n\n        self.update_from_dict(data)\n\n    async def _close_connection(self) -&gt; None:\n\"\"\"Close the voice connection.\"\"\"\n        if self.playing:\n            await self.stop()\n        if self.connected:\n            self.ws.close()\n</code></pre>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.ws","title":"<code>ws: Optional[VoiceGateway] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The websocket for this voice state</p>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.player","title":"<code>player: Optional[Player] = attrs.field(repr=False, default=None)</code>  <code>class-attribute</code>","text":"<p>The playback task that broadcasts audio data to discord</p>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.current_audio","title":"<code>current_audio: Optional[BaseAudio]</code>  <code>property</code>","text":"<p>The current audio being played</p>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.volume","title":"<code>volume: float</code>  <code>property</code> <code>writable</code>","text":"<p>Get the volume of the player</p>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.paused","title":"<code>paused: bool</code>  <code>property</code>","text":"<p>Is the player currently paused</p>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.playing","title":"<code>playing: bool</code>  <code>property</code>","text":"<p>Are we currently playing something?</p>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.stopped","title":"<code>stopped: bool</code>  <code>property</code>","text":"<p>Is the player stopped?</p>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.connected","title":"<code>connected: bool</code>  <code>property</code>","text":"<p>Is this voice state currently connected?</p>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.wait_for_stopped","title":"<code>wait_for_stopped()</code>  <code>async</code>","text":"<p>Wait for the player to stop playing.</p> Source code in <code>naff\\models\\naff\\active_voice_state.py</code> <pre><code>async def wait_for_stopped(self) -&gt; None:\n\"\"\"Wait for the player to stop playing.\"\"\"\n    if self.player:\n        # noinspection PyProtectedMember\n        await self.player._stopped.wait()\n</code></pre>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.ws_connect","title":"<code>ws_connect()</code>  <code>async</code>","text":"<p>Connect to the voice gateway for this voice state</p> Source code in <code>naff\\models\\naff\\active_voice_state.py</code> <pre><code>async def ws_connect(self) -&gt; None:\n\"\"\"Connect to the voice gateway for this voice state\"\"\"\n    self.ws = VoiceGateway(self._client._connection_state, self._voice_state.data, self._voice_server.data)\n\n    asyncio.create_task(self._ws_connect())\n    await self.ws.wait_until_ready()\n</code></pre>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.connect","title":"<code>connect(timeout=5)</code>  <code>async</code>","text":"<p>Establish the voice connection.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>How long to wait for state and server information from discord</p> <code>5</code> <p>Raises:</p> Type Description <code>VoiceAlreadyConnected</code> <p>if the voice state is already connected to the voice channel</p> <code>VoiceConnectionTimeout</code> <p>if the voice state fails to connect</p> Source code in <code>naff\\models\\naff\\active_voice_state.py</code> <pre><code>async def connect(self, timeout: int = 5) -&gt; None:\n\"\"\"\n    Establish the voice connection.\n\n    Args:\n        timeout: How long to wait for state and server information from discord\n\n    Raises:\n        VoiceAlreadyConnected: if the voice state is already connected to the voice channel\n        VoiceConnectionTimeout: if the voice state fails to connect\n\n    \"\"\"\n    if self.connected:\n        raise VoiceAlreadyConnected\n    await self.gateway.voice_state_update(self._guild_id, self._channel_id, self.self_mute, self.self_deaf)\n\n    self.logger.debug(\"Waiting for voice connection data...\")\n\n    try:\n        self._voice_state, self._voice_server = await asyncio.gather(\n            self._client.wait_for(\"raw_voice_state_update\", self._guild_predicate, timeout=timeout),\n            self._client.wait_for(\"raw_voice_server_update\", self._guild_predicate, timeout=timeout),\n        )\n    except asyncio.TimeoutError:\n        raise VoiceConnectionTimeout from None\n\n    self.logger.debug(\"Attempting to initialise voice gateway...\")\n    await self.ws_connect()\n</code></pre>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.disconnect","title":"<code>disconnect()</code>  <code>async</code>","text":"<p>Disconnect from the voice channel.</p> Source code in <code>naff\\models\\naff\\active_voice_state.py</code> <pre><code>async def disconnect(self) -&gt; None:\n\"\"\"Disconnect from the voice channel.\"\"\"\n    await self.gateway.voice_state_update(self._guild_id, None)\n</code></pre>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.move","title":"<code>move(channel, timeout=5)</code>  <code>async</code>","text":"<p>Move to another voice channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Snowflake_Type</code> <p>The channel to move to</p> required <code>timeout</code> <code>int</code> <p>How long to wait for state and server information from discord</p> <code>5</code> Source code in <code>naff\\models\\naff\\active_voice_state.py</code> <pre><code>async def move(self, channel: \"Snowflake_Type\", timeout: int = 5) -&gt; None:\n\"\"\"\n    Move to another voice channel.\n\n    Args:\n        channel: The channel to move to\n        timeout: How long to wait for state and server information from discord\n\n    \"\"\"\n    target_channel = to_snowflake(channel)\n    if target_channel != self._channel_id:\n        already_paused = self.paused\n        if self.player:\n            self.player.pause()\n\n        self._channel_id = target_channel\n        await self.gateway.voice_state_update(self._guild_id, self._channel_id, self.self_mute, self.self_deaf)\n\n        self.logger.debug(\"Waiting for voice connection data...\")\n        try:\n            await self._client.wait_for(\"raw_voice_state_update\", self._guild_predicate, timeout=timeout)\n        except asyncio.TimeoutError:\n            await self._close_connection()\n            raise VoiceConnectionTimeout from None\n\n        if self.player and not already_paused:\n            self.player.resume()\n</code></pre>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop playback.</p> Source code in <code>naff\\models\\naff\\active_voice_state.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Stop playback.\"\"\"\n    self.player.stop()\n    await self.player._stopped.wait()\n</code></pre>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.pause","title":"<code>pause()</code>","text":"<p>Pause playback</p> Source code in <code>naff\\models\\naff\\active_voice_state.py</code> <pre><code>def pause(self) -&gt; None:\n\"\"\"Pause playback\"\"\"\n    self.player.pause()\n</code></pre>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.resume","title":"<code>resume()</code>","text":"<p>Resume playback.</p> Source code in <code>naff\\models\\naff\\active_voice_state.py</code> <pre><code>def resume(self) -&gt; None:\n\"\"\"Resume playback.\"\"\"\n    self.player.resume()\n</code></pre>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.play","title":"<code>play(audio)</code>  <code>async</code>","text":"<p>Start playing an audio object.</p> <p>Waits for the player to stop before returning.</p> <p>Parameters:</p> Name Type Description Default <code>audio</code> <code>BaseAudio</code> <p>The audio object to play</p> required Source code in <code>naff\\models\\naff\\active_voice_state.py</code> <pre><code>async def play(self, audio: \"BaseAudio\") -&gt; None:\n\"\"\"\n    Start playing an audio object.\n\n    Waits for the player to stop before returning.\n\n    Args:\n        audio: The audio object to play\n    \"\"\"\n    if self.player:\n        await self.stop()\n\n    with Player(audio, self, asyncio.get_running_loop()) as self.player:\n        self.player.play()\n        await self.wait_for_stopped()\n</code></pre>"},{"location":"API%20Reference/models/Naff/active_voice_state/#naff.models.naff.active_voice_state.ActiveVoiceState.play_no_wait","title":"<code>play_no_wait(audio)</code>","text":"<p>Start playing an audio object, but don't wait for playback to finish.</p> <p>Parameters:</p> Name Type Description Default <code>audio</code> <code>BaseAudio</code> <p>The audio object to play</p> required Source code in <code>naff\\models\\naff\\active_voice_state.py</code> <pre><code>def play_no_wait(self, audio: \"BaseAudio\") -&gt; None:\n\"\"\"\n    Start playing an audio object, but don't wait for playback to finish.\n\n    Args:\n        audio: The audio object to play\n    \"\"\"\n    asyncio.create_task(self.play(audio))\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/","title":"Annotations","text":""},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.CMD_BODY","title":"<code>CMD_BODY</code>","text":"<p>         Bases: <code>NoArgumentConverter[str]</code></p> <p>This argument is for the body of the message.</p> <p>IE:</p> <p>if <code>@bot hello how are you?</code> is sent this argument will be <code>hello how are you?</code></p> Source code in <code>naff\\models\\naff\\annotations\\argument.py</code> <pre><code>class CMD_BODY(NoArgumentConverter[str]):\n\"\"\"\n    This argument is for the body of the message.\n\n    IE:\n\n    if `@bot hello how are you?` is sent this argument will be `hello how are you?`\n    \"\"\"\n\n    async def convert(self, context: Context, _) -&gt; str:\n\"\"\"Returns the body of the message.\"\"\"\n        if not isinstance(context, PrefixedContext):\n            raise BadArgument(\"CMD_BODY can only be used with prefixed commands.\")\n        return context.content_parameters\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.argument.CMD_BODY.convert","title":"<code>convert(context, _)</code>  <code>async</code>","text":"<p>Returns the body of the message.</p> Source code in <code>naff\\models\\naff\\annotations\\argument.py</code> <pre><code>async def convert(self, context: Context, _) -&gt; str:\n\"\"\"Returns the body of the message.\"\"\"\n    if not isinstance(context, PrefixedContext):\n        raise BadArgument(\"CMD_BODY can only be used with prefixed commands.\")\n    return context.content_parameters\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.slash_str_option","title":"<code>slash_str_option(description, required=False, autocomplete=False, choices=None, min_length=None, max_length=None)</code>","text":"<p>Annotates an argument as a string type slash command option.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The description of your option</p> required <code>required</code> <code>bool</code> <p>Is this option required?</p> <code>False</code> <code>autocomplete</code> <code>bool</code> <p>Use autocomplete for this option</p> <code>False</code> <code>choices</code> <code>List[Union[SlashCommandChoice, dict]]</code> <p>The choices allowed by this command</p> <code>None</code> <code>min_length</code> <code>Optional[int]</code> <p>The minimum length of text a user can input.</p> <code>None</code> <code>max_length</code> <code>Optional[int]</code> <p>The maximum length of text a user can input.</p> <code>None</code> Source code in <code>naff\\models\\naff\\annotations\\slash.py</code> <pre><code>def slash_str_option(\n    description: str,\n    required: bool = False,\n    autocomplete: bool = False,\n    choices: List[Union[\"SlashCommandChoice\", dict]] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n) -&gt; Type[str]:\n\"\"\"\n    Annotates an argument as a string type slash command option.\n\n    Args:\n        description: The description of your option\n        required: Is this option required?\n        autocomplete: Use autocomplete for this option\n        choices: The choices allowed by this command\n        min_length: The minimum length of text a user can input.\n        max_length: The maximum length of text a user can input.\n\n    \"\"\"\n    option = SlashCommandOption(\n        name=\"placeholder\",\n        description=description,\n        required=required,\n        autocomplete=autocomplete,\n        choices=choices or [],\n        max_length=max_length,\n        min_length=min_length,\n        type=models.OptionTypes.STRING,\n    )\n    return option  # type: ignore\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.CMD_AUTHOR","title":"<code>CMD_AUTHOR</code>","text":"<p>         Bases: <code>NoArgumentConverter</code></p> <p>This argument is the author of the context.</p> Source code in <code>naff\\models\\naff\\annotations\\argument.py</code> <pre><code>class CMD_AUTHOR(NoArgumentConverter):\n\"\"\"This argument is the author of the context.\"\"\"\n\n    async def convert(self, context: Context, _) -&gt; \"Member | User\":\n\"\"\"Returns the author of the context.\"\"\"\n        return context.author\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.argument.CMD_AUTHOR.convert","title":"<code>convert(context, _)</code>  <code>async</code>","text":"<p>Returns the author of the context.</p> Source code in <code>naff\\models\\naff\\annotations\\argument.py</code> <pre><code>async def convert(self, context: Context, _) -&gt; \"Member | User\":\n\"\"\"Returns the author of the context.\"\"\"\n    return context.author\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.CMD_CHANNEL","title":"<code>CMD_CHANNEL</code>","text":"<p>         Bases: <code>NoArgumentConverter</code></p> <p>This argument is the channel the command was sent in.</p> Source code in <code>naff\\models\\naff\\annotations\\argument.py</code> <pre><code>class CMD_CHANNEL(NoArgumentConverter):\n\"\"\"This argument is the channel the command was sent in.\"\"\"\n\n    async def convert(self, context: Context, _) -&gt; \"TYPE_MESSAGEABLE_CHANNEL\":\n\"\"\"Returns the channel of the context.\"\"\"\n        return context.channel\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.argument.CMD_CHANNEL.convert","title":"<code>convert(context, _)</code>  <code>async</code>","text":"<p>Returns the channel of the context.</p> Source code in <code>naff\\models\\naff\\annotations\\argument.py</code> <pre><code>async def convert(self, context: Context, _) -&gt; \"TYPE_MESSAGEABLE_CHANNEL\":\n\"\"\"Returns the channel of the context.\"\"\"\n    return context.channel\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.CMD_ARGS","title":"<code>CMD_ARGS</code>","text":"<p>         Bases: <code>NoArgumentConverter[list[str]]</code></p> <p>This argument is all of the arguments sent with this context.</p> Source code in <code>naff\\models\\naff\\annotations\\argument.py</code> <pre><code>class CMD_ARGS(NoArgumentConverter[list[str]]):\n\"\"\"This argument is all of the arguments sent with this context.\"\"\"\n\n    @staticmethod\n    async def convert(context: Context, _) -&gt; list[str]:\n\"\"\"Returns the arguments for this context.\"\"\"\n        return context.args\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.argument.CMD_ARGS.convert","title":"<code>convert(context, _)</code>  <code>staticmethod</code> <code>async</code>","text":"<p>Returns the arguments for this context.</p> Source code in <code>naff\\models\\naff\\annotations\\argument.py</code> <pre><code>@staticmethod\nasync def convert(context: Context, _) -&gt; list[str]:\n\"\"\"Returns the arguments for this context.\"\"\"\n    return context.args\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.slash_float_option","title":"<code>slash_float_option(description, required=False, autocomplete=False, choices=None, min_value=None, max_value=None)</code>","text":"<p>Annotates an argument as a float type slash command option.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The description of your option</p> required <code>required</code> <code>bool</code> <p>Is this option required?</p> <code>False</code> <code>autocomplete</code> <code>bool</code> <p>Use autocomplete for this option</p> <code>False</code> <code>choices</code> <code>List[Union[SlashCommandChoice, dict]]</code> <p>The choices allowed by this command</p> <code>None</code> <code>min_value</code> <code>Optional[float]</code> <p>The minimum number allowed</p> <code>None</code> <code>max_value</code> <code>Optional[float]</code> <p>The maximum number allowed</p> <code>None</code> Source code in <code>naff\\models\\naff\\annotations\\slash.py</code> <pre><code>def slash_float_option(\n    description: str,\n    required: bool = False,\n    autocomplete: bool = False,\n    choices: List[Union[\"SlashCommandChoice\", dict]] = None,\n    min_value: Optional[float] = None,\n    max_value: Optional[float] = None,\n) -&gt; Type[float]:\n\"\"\"\n    Annotates an argument as a float type slash command option.\n\n    Args:\n        description: The description of your option\n        required: Is this option required?\n        autocomplete: Use autocomplete for this option\n        choices: The choices allowed by this command\n        min_value: The minimum number allowed\n        max_value: The maximum number allowed\n\n    \"\"\"\n    option = SlashCommandOption(\n        name=\"placeholder\",\n        description=description,\n        required=required,\n        autocomplete=autocomplete,\n        choices=choices or [],\n        max_value=max_value,\n        min_value=min_value,\n        type=models.OptionTypes.NUMBER,\n    )\n    return option  # type: ignore\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.slash_int_option","title":"<code>slash_int_option(description, required=False, autocomplete=False, choices=None, min_value=None, max_value=None)</code>","text":"<p>Annotates an argument as a integer type slash command option.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The description of your option</p> required <code>required</code> <code>bool</code> <p>Is this option required?</p> <code>False</code> <code>autocomplete</code> <code>bool</code> <p>Use autocomplete for this option</p> <code>False</code> <code>choices</code> <code>List[Union[SlashCommandChoice, dict]]</code> <p>The choices allowed by this command</p> <code>None</code> <code>min_value</code> <code>Optional[float]</code> <p>The minimum number allowed</p> <code>None</code> <code>max_value</code> <code>Optional[float]</code> <p>The maximum number allowed</p> <code>None</code> Source code in <code>naff\\models\\naff\\annotations\\slash.py</code> <pre><code>def slash_int_option(\n    description: str,\n    required: bool = False,\n    autocomplete: bool = False,\n    choices: List[Union[\"SlashCommandChoice\", dict]] = None,\n    min_value: Optional[float] = None,\n    max_value: Optional[float] = None,\n) -&gt; Type[int]:\n\"\"\"\n    Annotates an argument as a integer type slash command option.\n\n    Args:\n        description: The description of your option\n        required: Is this option required?\n        autocomplete: Use autocomplete for this option\n        choices: The choices allowed by this command\n        min_value: The minimum number allowed\n        max_value: The maximum number allowed\n\n    \"\"\"\n    option = SlashCommandOption(\n        name=\"placeholder\",\n        description=description,\n        required=required,\n        autocomplete=autocomplete,\n        choices=choices or [],\n        max_value=max_value,\n        min_value=min_value,\n        type=models.OptionTypes.INTEGER,\n    )\n    return option  # type: ignore\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.slash_bool_option","title":"<code>slash_bool_option(description, required=False)</code>","text":"<p>Annotates an argument as a boolean type slash command option.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The description of your option</p> required <code>required</code> <code>bool</code> <p>Is this option required?</p> <code>False</code> Source code in <code>naff\\models\\naff\\annotations\\slash.py</code> <pre><code>def slash_bool_option(\n    description: str,\n    required: bool = False,\n) -&gt; Type[bool]:\n\"\"\"\n    Annotates an argument as a boolean type slash command option.\n\n    Args:\n        description: The description of your option\n        required: Is this option required?\n\n    \"\"\"\n    option = SlashCommandOption(\n        name=\"placeholder\",\n        description=description,\n        required=required,\n        type=models.OptionTypes.BOOLEAN,\n    )\n    return option  # type: ignore\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.slash_user_option","title":"<code>slash_user_option(description, required=False, autocomplete=False)</code>","text":"<p>Annotates an argument as a user type slash command option.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The description of your option</p> required <code>required</code> <code>bool</code> <p>Is this option required?</p> <code>False</code> <code>autocomplete</code> <code>bool</code> <p>Use autocomplete for this option</p> <code>False</code> Source code in <code>naff\\models\\naff\\annotations\\slash.py</code> <pre><code>def slash_user_option(\n    description: str,\n    required: bool = False,\n    autocomplete: bool = False,\n) -&gt; Type[Union[\"User\", \"Member\"]]:\n\"\"\"\n    Annotates an argument as a user type slash command option.\n\n    Args:\n        description: The description of your option\n        required: Is this option required?\n        autocomplete: Use autocomplete for this option\n\n    \"\"\"\n    option = SlashCommandOption(\n        name=\"placeholder\",\n        description=description,\n        required=required,\n        autocomplete=autocomplete,\n        type=models.OptionTypes.USER,\n    )\n    return option  # type: ignore\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.slash_channel_option","title":"<code>slash_channel_option(description, required=False, autocomplete=False, choices=None, channel_types=None)</code>","text":"<p>Annotates an argument as a channel type slash command option.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The description of your option</p> required <code>required</code> <code>bool</code> <p>Is this option required?</p> <code>False</code> <code>autocomplete</code> <code>bool</code> <p>Use autocomplete for this option</p> <code>False</code> <code>choices</code> <code>List[Union[SlashCommandChoice, dict]]</code> <p>The choices allowed by this command</p> <code>None</code> <code>channel_types</code> <code>Optional[list[Union[ChannelTypes, int]]]</code> <p>The types of channel allowed by this option</p> <code>None</code> Source code in <code>naff\\models\\naff\\annotations\\slash.py</code> <pre><code>def slash_channel_option(\n    description: str,\n    required: bool = False,\n    autocomplete: bool = False,\n    choices: List[Union[\"SlashCommandChoice\", dict]] = None,\n    channel_types: Optional[list[Union[\"ChannelTypes\", int]]] = None,\n) -&gt; Type[\"BaseChannel\"]:\n\"\"\"\n    Annotates an argument as a channel type slash command option.\n\n    Args:\n        description: The description of your option\n        required: Is this option required?\n        autocomplete: Use autocomplete for this option\n        choices: The choices allowed by this command\n        channel_types: The types of channel allowed by this option\n\n    \"\"\"\n    option = SlashCommandOption(\n        name=\"placeholder\",\n        description=description,\n        required=required,\n        autocomplete=autocomplete,\n        choices=choices or [],\n        channel_types=channel_types,\n        type=models.OptionTypes.CHANNEL,\n    )\n    return option  # type: ignore\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.slash_role_option","title":"<code>slash_role_option(description, required=False, autocomplete=False, choices=None)</code>","text":"<p>Annotates an argument as a role type slash command option.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The description of your option</p> required <code>required</code> <code>bool</code> <p>Is this option required?</p> <code>False</code> <code>autocomplete</code> <code>bool</code> <p>Use autocomplete for this option</p> <code>False</code> <code>choices</code> <code>List[Union[SlashCommandChoice, dict]]</code> <p>The choices allowed by this command</p> <code>None</code> Source code in <code>naff\\models\\naff\\annotations\\slash.py</code> <pre><code>def slash_role_option(\n    description: str,\n    required: bool = False,\n    autocomplete: bool = False,\n    choices: List[Union[\"SlashCommandChoice\", dict]] = None,\n) -&gt; Type[\"Role\"]:\n\"\"\"\n    Annotates an argument as a role type slash command option.\n\n    Args:\n        description: The description of your option\n        required: Is this option required?\n        autocomplete: Use autocomplete for this option\n        choices: The choices allowed by this command\n\n    \"\"\"\n    option = SlashCommandOption(\n        name=\"placeholder\",\n        description=description,\n        required=required,\n        autocomplete=autocomplete,\n        choices=choices or [],\n        type=models.OptionTypes.ROLE,\n    )\n    return option  # type: ignore\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.slash_mentionable_option","title":"<code>slash_mentionable_option(description, required=False, autocomplete=False, choices=None)</code>","text":"<p>Annotates an argument as a mentionable type slash command option.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The description of your option</p> required <code>required</code> <code>bool</code> <p>Is this option required?</p> <code>False</code> <code>autocomplete</code> <code>bool</code> <p>Use autocomplete for this option</p> <code>False</code> <code>choices</code> <code>List[Union[SlashCommandChoice, dict]]</code> <p>The choices allowed by this command</p> <code>None</code> Source code in <code>naff\\models\\naff\\annotations\\slash.py</code> <pre><code>def slash_mentionable_option(\n    description: str,\n    required: bool = False,\n    autocomplete: bool = False,\n    choices: List[Union[\"SlashCommandChoice\", dict]] = None,\n) -&gt; Type[Union[\"Role\", \"BaseChannel\", \"User\", \"Member\"]]:\n\"\"\"\n    Annotates an argument as a mentionable type slash command option.\n\n    Args:\n        description: The description of your option\n        required: Is this option required?\n        autocomplete: Use autocomplete for this option\n        choices: The choices allowed by this command\n\n    \"\"\"\n    option = SlashCommandOption(\n        name=\"placeholder\",\n        description=description,\n        required=required,\n        autocomplete=autocomplete,\n        choices=choices or [],\n        type=models.OptionTypes.MENTIONABLE,\n    )\n    return option  # type: ignore\n</code></pre>"},{"location":"API%20Reference/models/Naff/annotations/#naff.models.naff.annotations.slash_attachment_option","title":"<code>slash_attachment_option(description, required=False)</code>","text":"<p>Annotates an argument as an attachment type slash command option.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The description of your option</p> required <code>required</code> <code>bool</code> <p>Is this option required?</p> <code>False</code> Source code in <code>naff\\models\\naff\\annotations\\slash.py</code> <pre><code>def slash_attachment_option(\n    description: str,\n    required: bool = False,\n) -&gt; Type[\"Attachment\"]:\n\"\"\"\n    Annotates an argument as an attachment type slash command option.\n\n    Args:\n        description: The description of your option\n        required: Is this option required?\n\n    \"\"\"\n    option = SlashCommandOption(\n        name=\"placeholder\", description=description, required=required, type=models.OptionTypes.ATTACHMENT\n    )\n\n    return option  # type: ignore\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/","title":"Application commands","text":""},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.LocalisedName","title":"<code>LocalisedName</code>","text":"<p>         Bases: <code>LocalisedField</code></p> <p>A localisation object for names.</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>@attrs.define(\n    eq=False, order=False, hash=False, field_transformer=attrs_validator(name_validator, skip_fields=[\"default_locale\"])\n)\nclass LocalisedName(LocalisedField):\n\"\"\"A localisation object for names.\"\"\"\n\n    def __repr__(self) -&gt; str:\n        return super().__repr__()\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.LocalisedDesc","title":"<code>LocalisedDesc</code>","text":"<p>         Bases: <code>LocalisedField</code></p> <p>A localisation object for descriptions.</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>@attrs.define(\n    eq=False, order=False, hash=False, field_transformer=attrs_validator(desc_validator, skip_fields=[\"default_locale\"])\n)\nclass LocalisedDesc(LocalisedField):\n\"\"\"A localisation object for descriptions.\"\"\"\n\n    def __repr__(self) -&gt; str:\n        return super().__repr__()\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.OptionTypes","title":"<code>OptionTypes</code>","text":"<p>         Bases: <code>IntEnum</code></p> <p>Option types supported by slash commands.</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>class OptionTypes(IntEnum):\n\"\"\"Option types supported by slash commands.\"\"\"\n\n    SUB_COMMAND = 1\n    SUB_COMMAND_GROUP = 2\n    STRING = 3\n    INTEGER = 4\n    BOOLEAN = 5\n    USER = 6\n    CHANNEL = 7\n    ROLE = 8\n    MENTIONABLE = 9\n    NUMBER = 10\n    ATTACHMENT = 11\n\n    @classmethod\n    def from_type(cls, t: type) -&gt; \"OptionTypes\":\n\"\"\"\n        Convert data types to their corresponding OptionType.\n\n        Args:\n            t: The datatype to convert\n\n        Returns:\n            OptionType or None\n\n        \"\"\"\n        if issubclass(t, str):\n            return cls.STRING\n        if issubclass(t, int):\n            return cls.INTEGER\n        if issubclass(t, bool):\n            return cls.BOOLEAN\n        if issubclass(t, BaseUser):\n            return cls.USER\n        if issubclass(t, channel.BaseChannel):\n            return cls.CHANNEL\n        if issubclass(t, Role):\n            return cls.ROLE\n        if issubclass(t, float):\n            return cls.NUMBER\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.OptionTypes.from_type","title":"<code>from_type(t)</code>  <code>classmethod</code>","text":"<p>Convert data types to their corresponding OptionType.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>type</code> <p>The datatype to convert</p> required <p>Returns:</p> Type Description <code>OptionTypes</code> <p>OptionType or None</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>@classmethod\ndef from_type(cls, t: type) -&gt; \"OptionTypes\":\n\"\"\"\n    Convert data types to their corresponding OptionType.\n\n    Args:\n        t: The datatype to convert\n\n    Returns:\n        OptionType or None\n\n    \"\"\"\n    if issubclass(t, str):\n        return cls.STRING\n    if issubclass(t, int):\n        return cls.INTEGER\n    if issubclass(t, bool):\n        return cls.BOOLEAN\n    if issubclass(t, BaseUser):\n        return cls.USER\n    if issubclass(t, channel.BaseChannel):\n        return cls.CHANNEL\n    if issubclass(t, Role):\n        return cls.ROLE\n    if issubclass(t, float):\n        return cls.NUMBER\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.CallbackTypes","title":"<code>CallbackTypes</code>","text":"<p>         Bases: <code>IntEnum</code></p> <p>Types of callback supported by interaction response.</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>class CallbackTypes(IntEnum):\n\"\"\"Types of callback supported by interaction response.\"\"\"\n\n    PONG = 1\n    CHANNEL_MESSAGE_WITH_SOURCE = 4\n    DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE = 5\n    DEFERRED_UPDATE_MESSAGE = 6\n    UPDATE_MESSAGE = 7\n    AUTOCOMPLETE_RESULT = 8\n    MODAL = 9\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.InteractionCommand","title":"<code>InteractionCommand</code>","text":"<p>         Bases: <code>BaseCommand</code></p> <p>Represents a discord abstract interaction command.</p> <p>Attributes:</p> Name Type Description <code>scope</code> <p>Denotes whether its global or for specific guild.</p> <code>default_member_permissions</code> <code>Optional[Permissions]</code> <p>What permissions members need to have by default to use this command.</p> <code>dm_permission</code> <code>bool</code> <p>Should this command be available in DMs.</p> <code>cmd_id</code> <code>Dict[str, Snowflake_Type]</code> <p>The id of this command given by discord.</p> <code>callback</code> <code>Callable[..., Coroutine]</code> <p>The coroutine to callback when this interaction is received.</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass InteractionCommand(BaseCommand):\n\"\"\"\n    Represents a discord abstract interaction command.\n\n    Attributes:\n        scope: Denotes whether its global or for specific guild.\n        default_member_permissions: What permissions members need to have by default to use this command.\n        dm_permission: Should this command be available in DMs.\n        cmd_id: The id of this command given by discord.\n        callback: The coroutine to callback when this interaction is received.\n\n    \"\"\"\n\n    name: LocalisedName | str = attrs.field(\n        repr=False, metadata=docs(\"1-32 character name\") | no_export_meta, converter=LocalisedName.converter\n    )\n    scopes: List[\"Snowflake_Type\"] = attrs.field(\n        default=[GLOBAL_SCOPE],\n        converter=to_snowflake_list,\n        metadata=docs(\"The scopes of this interaction. Global or guild ids\") | no_export_meta,\n    )\n    default_member_permissions: Optional[\"Permissions\"] = attrs.field(\n        repr=False, default=None, metadata=docs(\"What permissions members need to have by default to use this command\")\n    )\n    dm_permission: bool = attrs.field(repr=False, default=True, metadata=docs(\"Whether this command is enabled in DMs\"))\n    cmd_id: Dict[str, \"Snowflake_Type\"] = attrs.field(\n        repr=False, factory=dict, metadata=docs(\"The unique IDs of this commands\") | no_export_meta\n    )  # scope: cmd_id\n    callback: Callable[..., Coroutine] = attrs.field(\n        repr=False,\n        default=None,\n        metadata=docs(\"The coroutine to call when this interaction is received\") | no_export_meta,\n    )\n    auto_defer: \"AutoDefer\" = attrs.field(\n        default=MISSING,\n        metadata=docs(\"A system to automatically defer this command after a set duration\") | no_export_meta,\n    )\n    nsfw: bool = attrs.field(repr=False, default=False, metadata=docs(\"This command should only work in NSFW channels\"))\n    _application_id: \"Snowflake_Type\" = attrs.field(repr=False, default=None, converter=optional(to_snowflake))\n\n    def __attrs_post_init__(self) -&gt; None:\n        if self.callback is not None:\n            if hasattr(self.callback, \"auto_defer\"):\n                self.auto_defer = self.callback.auto_defer\n\n        super().__attrs_post_init__()\n\n    def to_dict(self) -&gt; dict:\n        data = super().to_dict()\n\n        if self.default_member_permissions is not None:\n            data[\"default_member_permissions\"] = str(int(self.default_member_permissions))\n        else:\n            data[\"default_member_permissions\"] = None\n\n        return data\n\n    def mention(self, scope: Optional[\"Snowflake_Type\"] = None) -&gt; str:\n\"\"\"\n        Returns a string that would mention the interaction.\n\n        Args:\n            scope: If the command is available in multiple scope, specify which scope to get the mention for. Defaults to the first available one if not specified.\n\n        Returns:\n            The markdown mention.\n        \"\"\"\n        if scope:\n            cmd_id = self.get_cmd_id(scope=scope)\n        else:\n            cmd_id = list(self.cmd_id.values())[0]\n\n        return f\"&lt;/{self.resolved_name}:{cmd_id}&gt;\"\n\n    @property\n    def resolved_name(self) -&gt; str:\n\"\"\"A representation of this interaction's name.\"\"\"\n        return str(self.name)\n\n    def get_localised_name(self, locale: str) -&gt; str:\n        return self.name.get_locale(locale)\n\n    def get_cmd_id(self, scope: \"Snowflake_Type\") -&gt; \"Snowflake_Type\":\n        return self.cmd_id.get(scope, self.cmd_id.get(GLOBAL_SCOPE, None))\n\n    @property\n    def is_subcommand(self) -&gt; bool:\n        return False\n\n    async def _permission_enforcer(self, ctx: \"Context\") -&gt; bool:\n\"\"\"A check that enforces Discord permissions.\"\"\"\n        # I wish this wasn't needed, but unfortunately Discord permissions cant be trusted to actually prevent usage\n        if self.dm_permission is False:\n            return ctx.guild is not None\n        return True\n\n    def is_enabled(self, ctx: \"Context\") -&gt; bool:\n\"\"\"\n        Check if this command is enabled in the given context.\n\n        Args:\n            ctx: The context to check.\n\n        Returns:\n            Whether this command is enabled in the given context.\n        \"\"\"\n        if not self.dm_permission and ctx.guild is None:\n            return False\n        elif self.dm_permission and ctx.guild is None:\n            # remaining checks are impossible if this is a DM and DMs are enabled\n            return True\n\n        if self.nsfw and not ctx.channel.is_nsfw():\n            return False\n        if cmd_perms := ctx.guild.command_permissions.get(self.get_cmd_id(ctx.guild.id)):\n            if not cmd_perms.is_enabled_in_context(ctx):\n                return False\n        if self.default_member_permissions is not None:\n            channel_perms = ctx.author.channel_permissions(ctx.channel)\n            if any(perm not in channel_perms for perm in self.default_member_permissions):\n                return False\n        return True\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.InteractionCommand.mention","title":"<code>mention(scope=None)</code>","text":"<p>Returns a string that would mention the interaction.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>Optional[Snowflake_Type]</code> <p>If the command is available in multiple scope, specify which scope to get the mention for. Defaults to the first available one if not specified.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The markdown mention.</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>def mention(self, scope: Optional[\"Snowflake_Type\"] = None) -&gt; str:\n\"\"\"\n    Returns a string that would mention the interaction.\n\n    Args:\n        scope: If the command is available in multiple scope, specify which scope to get the mention for. Defaults to the first available one if not specified.\n\n    Returns:\n        The markdown mention.\n    \"\"\"\n    if scope:\n        cmd_id = self.get_cmd_id(scope=scope)\n    else:\n        cmd_id = list(self.cmd_id.values())[0]\n\n    return f\"&lt;/{self.resolved_name}:{cmd_id}&gt;\"\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.InteractionCommand.resolved_name","title":"<code>resolved_name: str</code>  <code>property</code>","text":"<p>A representation of this interaction's name.</p>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.InteractionCommand.is_enabled","title":"<code>is_enabled(ctx)</code>","text":"<p>Check if this command is enabled in the given context.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether this command is enabled in the given context.</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>def is_enabled(self, ctx: \"Context\") -&gt; bool:\n\"\"\"\n    Check if this command is enabled in the given context.\n\n    Args:\n        ctx: The context to check.\n\n    Returns:\n        Whether this command is enabled in the given context.\n    \"\"\"\n    if not self.dm_permission and ctx.guild is None:\n        return False\n    elif self.dm_permission and ctx.guild is None:\n        # remaining checks are impossible if this is a DM and DMs are enabled\n        return True\n\n    if self.nsfw and not ctx.channel.is_nsfw():\n        return False\n    if cmd_perms := ctx.guild.command_permissions.get(self.get_cmd_id(ctx.guild.id)):\n        if not cmd_perms.is_enabled_in_context(ctx):\n            return False\n    if self.default_member_permissions is not None:\n        channel_perms = ctx.author.channel_permissions(ctx.channel)\n        if any(perm not in channel_perms for perm in self.default_member_permissions):\n            return False\n    return True\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.ContextMenu","title":"<code>ContextMenu</code>","text":"<p>         Bases: <code>InteractionCommand</code></p> <p>Represents a discord context menu.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>LocalisedField</code> <p>The name of this entry.</p> <code>type</code> <code>CommandTypes</code> <p>The type of entry (user or message).</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ContextMenu(InteractionCommand):\n\"\"\"\n    Represents a discord context menu.\n\n    Attributes:\n        name: The name of this entry.\n        type: The type of entry (user or message).\n\n    \"\"\"\n\n    name: LocalisedField = attrs.field(\n        repr=False, metadata=docs(\"1-32 character name\"), converter=LocalisedField.converter\n    )\n    type: CommandTypes = attrs.field(repr=False, metadata=docs(\"The type of command, defaults to 1 if not specified\"))\n\n    @type.validator\n    def _type_validator(self, attribute: str, value: int) -&gt; None:\n        if not isinstance(value, CommandTypes):\n            if value not in CommandTypes.__members__.values():\n                raise ValueError(\"Context Menu type not recognised, please consult the docs.\")\n        elif value == CommandTypes.CHAT_INPUT:\n            raise ValueError(\n                \"The CHAT_INPUT type is basically slash commands. Please use the @slash_command() \" \"decorator instead.\"\n            )\n\n    def to_dict(self) -&gt; dict:\n        data = super().to_dict()\n\n        data[\"name\"] = str(self.name)\n        return data\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.SlashCommandChoice","title":"<code>SlashCommandChoice</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> <p>Represents a discord slash command choice.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>LocalisedField | str</code> <p>The name the user will see</p> <code>value</code> <code>Union[str, int, float]</code> <p>The data sent to your code when this choice is used</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass SlashCommandChoice(DictSerializationMixin):\n\"\"\"\n    Represents a discord slash command choice.\n\n    Attributes:\n        name: The name the user will see\n        value: The data sent to your code when this choice is used\n\n    \"\"\"\n\n    name: LocalisedField | str = attrs.field(repr=False, converter=LocalisedField.converter)\n    value: Union[str, int, float] = attrs.field(\n        repr=False,\n    )\n\n    def as_dict(self) -&gt; dict:\n        return {\"name\": str(self.name), \"value\": self.value, \"name_localizations\": self.name.to_locale_dict()}\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.SlashCommandOption","title":"<code>SlashCommandOption</code>","text":"<p>         Bases: <code>DictSerializationMixin</code></p> <p>Represents a discord slash command option.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>LocalisedName | str</code> <p>The name of this option</p> <code>type</code> <code>Union[OptionTypes, int]</code> <p>The type of option</p> <code>description</code> <code>LocalisedDesc | str</code> <p>The description of this option</p> <code>required</code> <code>bool</code> <p>\"This option must be filled to use the command\"</p> <code>choices</code> <code>List[Union[SlashCommandChoice, Dict]]</code> <p>A list of choices the user has to pick between</p> <code>channel_types</code> <code>Optional[list[Union[ChannelTypes, int]]]</code> <p>The channel types permitted. The option needs to be a channel</p> <code>min_value</code> <code>Optional[float]</code> <p>The minimum value permitted. The option needs to be an integer or float</p> <code>max_value</code> <code>Optional[float]</code> <p>The maximum value permitted. The option needs to be an integer or float</p> <code>min_length</code> <code>Optional[int]</code> <p>The minimum length of text a user can input. The option needs to be a string</p> <code>max_length</code> <code>Optional[int]</code> <p>The maximum length of text a user can input. The option needs to be a string</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=False)\nclass SlashCommandOption(DictSerializationMixin):\n\"\"\"\n    Represents a discord slash command option.\n\n    Attributes:\n        name: The name of this option\n        type: The type of option\n        description: The description of this option\n        required: \"This option must be filled to use the command\"\n        choices: A list of choices the user has to pick between\n        channel_types: The channel types permitted. The option needs to be a channel\n        min_value: The minimum value permitted. The option needs to be an integer or float\n        max_value: The maximum value permitted. The option needs to be an integer or float\n        min_length: The minimum length of text a user can input. The option needs to be a string\n        max_length: The maximum length of text a user can input. The option needs to be a string\n\n    \"\"\"\n\n    name: LocalisedName | str = attrs.field(repr=False, converter=LocalisedName.converter)\n    type: Union[OptionTypes, int] = attrs.field(\n        repr=False,\n    )\n    description: LocalisedDesc | str = attrs.field(\n        repr=False, default=\"No Description Set\", converter=LocalisedDesc.converter\n    )\n    required: bool = attrs.field(repr=False, default=True)\n    autocomplete: bool = attrs.field(repr=False, default=False)\n    choices: List[Union[SlashCommandChoice, Dict]] = attrs.field(repr=False, factory=list)\n    channel_types: Optional[list[Union[ChannelTypes, int]]] = attrs.field(repr=False, default=None)\n    min_value: Optional[float] = attrs.field(repr=False, default=None)\n    max_value: Optional[float] = attrs.field(repr=False, default=None)\n    min_length: Optional[int] = attrs.field(repr=False, default=None)\n    max_length: Optional[int] = attrs.field(repr=False, default=None)\n\n    @type.validator\n    def _type_validator(self, attribute: str, value: int) -&gt; None:\n        if value == OptionTypes.SUB_COMMAND or value == OptionTypes.SUB_COMMAND_GROUP:\n            raise ValueError(\n                \"Options cannot be SUB_COMMAND or SUB_COMMAND_GROUP. If you want to use subcommands, \"\n                \"see the @sub_command() decorator.\"\n            )\n\n    @channel_types.validator\n    def _channel_types_validator(self, attribute: str, value: Optional[list[OptionTypes]]) -&gt; None:\n        if value is not None:\n            if self.type != OptionTypes.CHANNEL:\n                raise ValueError(\"The option needs to be CHANNEL to use this\")\n\n            allowed_int = [channel_type.value for channel_type in ChannelTypes]\n            for item in value:\n                if (item not in allowed_int) and (item not in ChannelTypes):\n                    raise ValueError(f\"{value} is not allowed here\")\n\n    @min_value.validator\n    def _min_value_validator(self, attribute: str, value: Optional[float]) -&gt; None:\n        if value is not None:\n            if self.type != OptionTypes.INTEGER and self.type != OptionTypes.NUMBER:\n                raise ValueError(\"`min_value` can only be supplied with int or float options\")\n\n            if self.type == OptionTypes.INTEGER:\n                if isinstance(value, float):\n                    raise ValueError(\"`min_value` needs to be an int in an int option\")\n\n            if self.max_value is not None and self.min_value is not None:\n                if self.max_value &lt; self.min_value:\n                    raise ValueError(\"`min_value` needs to be &lt;= than `max_value`\")\n\n    @max_value.validator\n    def _max_value_validator(self, attribute: str, value: Optional[float]) -&gt; None:\n        if value is not None:\n            if self.type != OptionTypes.INTEGER and self.type != OptionTypes.NUMBER:\n                raise ValueError(\"`max_value` can only be supplied with int or float options\")\n\n            if self.type == OptionTypes.INTEGER:\n                if isinstance(value, float):\n                    raise ValueError(\"`max_value` needs to be an int in an int option\")\n\n            if self.max_value and self.min_value:\n                if self.max_value &lt; self.min_value:\n                    raise ValueError(\"`min_value` needs to be &lt;= than `max_value`\")\n\n    @min_length.validator\n    def _min_length_validator(self, attribute: str, value: Optional[int]) -&gt; None:\n        if value is not None:\n            if self.type != OptionTypes.STRING:\n                raise ValueError(\"`min_length` can only be supplied with string options\")\n\n            if self.max_length is not None and self.min_length is not None:\n                if self.max_length &lt; self.min_length:\n                    raise ValueError(\"`min_length` needs to be &lt;= than `max_length`\")\n\n            if self.min_length &lt; 0:\n                raise ValueError(\"`min_length` needs to be &gt;= 0\")\n\n    @max_length.validator\n    def _max_length_validator(self, attribute: str, value: Optional[int]) -&gt; None:\n        if value is not None:\n            if self.type != OptionTypes.STRING:\n                raise ValueError(\"`max_length` can only be supplied with string options\")\n\n            if self.min_length is not None and self.max_length is not None:\n                if self.max_length &lt; self.min_length:\n                    raise ValueError(\"`min_length` needs to be &lt;= than `max_length`\")\n\n            if self.max_length &lt; 1:\n                raise ValueError(\"`max_length` needs to be &gt;= 1\")\n\n    def as_dict(self) -&gt; dict:\n        data = attrs.asdict(self)\n        data[\"name\"] = str(self.name)\n        data[\"description\"] = str(self.description)\n        data[\"choices\"] = [\n            choice.as_dict() if isinstance(choice, SlashCommandChoice) else choice for choice in self.choices\n        ]\n        data[\"name_localizations\"] = self.name.to_locale_dict()\n        data[\"description_localizations\"] = self.description.to_locale_dict()\n\n        return data\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.SlashCommand","title":"<code>SlashCommand</code>","text":"<p>         Bases: <code>InteractionCommand</code></p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass SlashCommand(InteractionCommand):\n    name: LocalisedName | str = attrs.field(repr=False, converter=LocalisedName.converter)\n    description: LocalisedDesc = attrs.field(\n        repr=False, default=\"No Description Set\", converter=LocalisedDesc.converter\n    )\n\n    group_name: LocalisedName | str = attrs.field(\n        repr=False, default=None, metadata=no_export_meta, converter=LocalisedName.converter\n    )\n    group_description: LocalisedDesc = attrs.field(\n        repr=False, default=\"No Description Set\", metadata=no_export_meta, converter=LocalisedDesc.converter\n    )\n\n    sub_cmd_name: LocalisedName | str = attrs.field(\n        repr=False, default=None, metadata=no_export_meta, converter=LocalisedName.converter\n    )\n    sub_cmd_description: LocalisedDesc = attrs.field(\n        repr=False, default=\"No Description Set\", metadata=no_export_meta, converter=LocalisedDesc.converter\n    )\n\n    options: List[Union[SlashCommandOption, Dict]] = attrs.field(repr=False, factory=list)\n    autocomplete_callbacks: dict = attrs.field(repr=False, factory=dict, metadata=no_export_meta)\n\n    @property\n    def resolved_name(self) -&gt; str:\n        return (\n            f\"{self.name}\"\n            f\"{f' {self.group_name}' if bool(self.group_name) else ''}\"\n            f\"{f' {self.sub_cmd_name}' if bool(self.sub_cmd_name) else ''}\"\n        )\n\n    def get_localised_name(self, locale: str) -&gt; str:\n        return (\n            f\"{self.name.get_locale(locale)}\"\n            f\"{f' {self.group_name.get_locale(locale)}' if bool(self.group_name) else ''}\"\n            f\"{f' {self.sub_cmd_name.get_locale(locale)}' if bool(self.sub_cmd_name) else ''}\"\n        )\n\n    @property\n    def is_subcommand(self) -&gt; bool:\n        return bool(self.sub_cmd_name)\n\n    def __attrs_post_init__(self) -&gt; None:\n        if self.callback is not None:\n            params = get_parameters(self.callback)\n            for name, val in params.items():\n                annotation = None\n                if val.annotation and isinstance(val.annotation, SlashCommandOption):\n                    annotation = val.annotation\n                elif typing.get_origin(val.annotation) is Annotated:\n                    for ann in typing.get_args(val.annotation):\n                        if isinstance(ann, SlashCommandOption):\n                            annotation = ann\n\n                if annotation:\n                    if not self.options:\n                        self.options = []\n                    annotation.name = name\n                    self.options.append(annotation)\n\n            if hasattr(self.callback, \"options\"):\n                if not self.options:\n                    self.options = []\n                self.options += self.callback.options\n\n        super().__attrs_post_init__()\n\n    def to_dict(self) -&gt; dict:\n        data = super().to_dict()\n\n        if self.is_subcommand:\n            data[\"name\"] = str(self.sub_cmd_name)\n            data[\"description\"] = str(self.sub_cmd_description)\n            data[\"name_localizations\"] = self.sub_cmd_name.to_locale_dict()\n            data[\"description_localizations\"] = self.sub_cmd_description.to_locale_dict()\n            data.pop(\"default_member_permissions\", None)\n            data.pop(\"dm_permission\", None)\n            data.pop(\"nsfw\", None)\n        else:\n            data[\"name_localizations\"] = self.name.to_locale_dict()\n            data[\"description_localizations\"] = self.description.to_locale_dict()\n        return data\n\n    @options.validator\n    def options_validator(self, attribute: str, value: List) -&gt; None:\n        if value:\n            if isinstance(value, list):\n                if len(value) &gt; SLASH_CMD_MAX_OPTIONS:\n                    raise ValueError(f\"Slash commands can only hold {SLASH_CMD_MAX_OPTIONS} options\")\n                if value != sorted(\n                    value,\n                    key=lambda x: x.required if isinstance(x, SlashCommandOption) else x[\"required\"],\n                    reverse=True,\n                ):\n                    raise ValueError(\"Required options must go before optional options\")\n\n            else:\n                raise TypeError(\"Options attribute must be either None or a list of options\")\n\n    def autocomplete(self, option_name: str) -&gt; Callable[..., Coroutine]:\n\"\"\"A decorator to declare a coroutine as an option autocomplete.\"\"\"\n\n        def wrapper(call: Callable[..., Coroutine]) -&gt; Callable[..., Coroutine]:\n            if not asyncio.iscoroutinefunction(call):\n                raise TypeError(\"autocomplete must be coroutine\")\n            self.autocomplete_callbacks[option_name] = call\n\n            # automatically set the option's autocomplete attribute to True\n            for opt in self.options:\n                if isinstance(opt, dict) and str(opt[\"name\"]) == option_name:\n                    opt[\"autocomplete\"] = True\n                elif isinstance(opt, SlashCommandOption) and str(opt.name) == option_name:\n                    opt.autocomplete = True\n\n            return call\n\n        option_name = option_name.lower()\n        return wrapper\n\n    def group(self, name: str = None, description: str = \"No Description Set\") -&gt; \"SlashCommand\":\n\n        return SlashCommand(\n            name=self.name,\n            description=self.description,\n            group_name=name,\n            group_description=description,\n            scopes=self.scopes,\n        )\n\n    def subcommand(\n        self,\n        sub_cmd_name: LocalisedName | str,\n        group_name: LocalisedName | str = None,\n        sub_cmd_description: Absent[LocalisedDesc | str] = MISSING,\n        group_description: Absent[LocalisedDesc | str] = MISSING,\n        options: List[Union[SlashCommandOption, Dict]] = None,\n        nsfw: bool = False,\n    ) -&gt; Callable[..., \"SlashCommand\"]:\n        def wrapper(call: Callable[..., Coroutine]) -&gt; \"SlashCommand\":\n            nonlocal sub_cmd_description\n\n            if not asyncio.iscoroutinefunction(call):\n                raise TypeError(\"Subcommand must be coroutine\")\n\n            if sub_cmd_description is MISSING:\n                sub_cmd_description = call.__doc__ or \"No Description Set\"\n\n            return SlashCommand(\n                name=self.name,\n                description=self.description,\n                group_name=group_name or self.group_name,\n                group_description=group_description or self.group_description,\n                sub_cmd_name=sub_cmd_name,\n                sub_cmd_description=sub_cmd_description,\n                default_member_permissions=self.default_member_permissions,\n                dm_permission=self.dm_permission,\n                options=options,\n                callback=call,\n                scopes=self.scopes,\n                nsfw=nsfw,\n            )\n\n        return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.SlashCommand.autocomplete","title":"<code>autocomplete(option_name)</code>","text":"<p>A decorator to declare a coroutine as an option autocomplete.</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>def autocomplete(self, option_name: str) -&gt; Callable[..., Coroutine]:\n\"\"\"A decorator to declare a coroutine as an option autocomplete.\"\"\"\n\n    def wrapper(call: Callable[..., Coroutine]) -&gt; Callable[..., Coroutine]:\n        if not asyncio.iscoroutinefunction(call):\n            raise TypeError(\"autocomplete must be coroutine\")\n        self.autocomplete_callbacks[option_name] = call\n\n        # automatically set the option's autocomplete attribute to True\n        for opt in self.options:\n            if isinstance(opt, dict) and str(opt[\"name\"]) == option_name:\n                opt[\"autocomplete\"] = True\n            elif isinstance(opt, SlashCommandOption) and str(opt.name) == option_name:\n                opt.autocomplete = True\n\n        return call\n\n    option_name = option_name.lower()\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.slash_command","title":"<code>slash_command(name, *, description=MISSING, scopes=MISSING, options=None, default_member_permissions=None, dm_permission=True, sub_cmd_name=None, group_name=None, sub_cmd_description='No Description Set', group_description='No Description Set', nsfw=False)</code>","text":"<p>A decorator to declare a coroutine as a slash command.</p> <p>Note</p> <p>While the base and group descriptions arent visible in the discord client, currently. We strongly advise defining them anyway, if you're using subcommands, as Discord has said they will be visible in one of the future ui updates.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | LocalisedName</code> <p>1-32 character name of the command</p> required <code>description</code> <code>Absent[str | LocalisedDesc]</code> <p>1-100 character description of the command</p> <code>MISSING</code> <code>scopes</code> <code>Absent[List[Snowflake_Type]]</code> <p>The scope this command exists within</p> <code>MISSING</code> <code>options</code> <code>Optional[List[Union[SlashCommandOption, Dict]]]</code> <p>The parameters for the command, max 25</p> <code>None</code> <code>default_member_permissions</code> <code>Optional[Permissions]</code> <p>What permissions members need to have by default to use this command.</p> <code>None</code> <code>dm_permission</code> <code>bool</code> <p>Should this command be available in DMs.</p> <code>True</code> <code>sub_cmd_name</code> <code>str | LocalisedName</code> <p>1-32 character name of the subcommand</p> <code>None</code> <code>sub_cmd_description</code> <code>str | LocalisedDesc</code> <p>1-100 character description of the subcommand</p> <code>'No Description Set'</code> <code>group_name</code> <code>str | LocalisedName</code> <p>1-32 character name of the group</p> <code>None</code> <code>group_description</code> <code>str | LocalisedDesc</code> <p>1-100 character description of the group</p> <code>'No Description Set'</code> <code>nsfw</code> <code>bool</code> <p>This command should only work in NSFW channels</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., Coroutine]], SlashCommand]</code> <p>SlashCommand Object</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>def slash_command(\n    name: str | LocalisedName,\n    *,\n    description: Absent[str | LocalisedDesc] = MISSING,\n    scopes: Absent[List[\"Snowflake_Type\"]] = MISSING,\n    options: Optional[List[Union[SlashCommandOption, Dict]]] = None,\n    default_member_permissions: Optional[\"Permissions\"] = None,\n    dm_permission: bool = True,\n    sub_cmd_name: str | LocalisedName = None,\n    group_name: str | LocalisedName = None,\n    sub_cmd_description: str | LocalisedDesc = \"No Description Set\",\n    group_description: str | LocalisedDesc = \"No Description Set\",\n    nsfw: bool = False,\n) -&gt; Callable[[Callable[..., Coroutine]], SlashCommand]:\n\"\"\"\n    A decorator to declare a coroutine as a slash command.\n\n    !!! note\n        While the base and group descriptions arent visible in the discord client, currently.\n        We strongly advise defining them anyway, if you're using subcommands, as Discord has said they will be visible in\n        one of the future ui updates.\n\n    Args:\n        name: 1-32 character name of the command\n        description: 1-100 character description of the command\n        scopes: The scope this command exists within\n        options: The parameters for the command, max 25\n        default_member_permissions: What permissions members need to have by default to use this command.\n        dm_permission: Should this command be available in DMs.\n        sub_cmd_name: 1-32 character name of the subcommand\n        sub_cmd_description: 1-100 character description of the subcommand\n        group_name: 1-32 character name of the group\n        group_description: 1-100 character description of the group\n        nsfw: This command should only work in NSFW channels\n\n    Returns:\n        SlashCommand Object\n\n    \"\"\"\n\n    def wrapper(func: Callable[..., Coroutine]) -&gt; SlashCommand:\n        if not asyncio.iscoroutinefunction(func):\n            raise ValueError(\"Commands must be coroutines\")\n\n        perm = default_member_permissions\n        if hasattr(func, \"default_member_permissions\"):\n            if perm:\n                perm = perm | func.default_member_permissions\n            else:\n                perm = func.default_member_permissions\n\n        _description = description\n        if _description is MISSING:\n            _description = func.__doc__ if func.__doc__ else \"No Description Set\"\n\n        cmd = SlashCommand(\n            name=name,\n            group_name=group_name,\n            group_description=group_description,\n            sub_cmd_name=sub_cmd_name,\n            sub_cmd_description=sub_cmd_description,\n            description=_description,\n            scopes=scopes if scopes else [GLOBAL_SCOPE],\n            default_member_permissions=perm,\n            dm_permission=dm_permission,\n            callback=func,\n            options=options,\n            nsfw=nsfw,\n        )\n\n        return cmd\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.subcommand","title":"<code>subcommand(base, *, subcommand_group=None, name=None, description=MISSING, base_description=None, base_desc=None, base_default_member_permissions=None, base_dm_permission=True, subcommand_group_description=None, sub_group_desc=None, scopes=None, options=None, nsfw=False)</code>","text":"<p>A decorator specifically tailored for creating subcommands.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>str | LocalisedName</code> <p>The name of the base command</p> required <code>subcommand_group</code> <code>Optional[str | LocalisedName]</code> <p>The name of the subcommand group, if any.</p> <code>None</code> <code>name</code> <code>Optional[str | LocalisedName]</code> <p>The name of the subcommand, defaults to the name of the coroutine.</p> <code>None</code> <code>description</code> <code>Absent[str | LocalisedDesc]</code> <p>The description of the subcommand</p> <code>MISSING</code> <code>base_description</code> <code>Optional[str | LocalisedDesc]</code> <p>The description of the base command</p> <code>None</code> <code>base_desc</code> <code>Optional[str | LocalisedDesc]</code> <p>An alias of <code>base_description</code></p> <code>None</code> <code>base_default_member_permissions</code> <code>Optional[Permissions]</code> <p>What permissions members need to have by default to use this command.</p> <code>None</code> <code>base_dm_permission</code> <code>bool</code> <p>Should this command be available in DMs.</p> <code>True</code> <code>subcommand_group_description</code> <code>Optional[str | LocalisedDesc]</code> <p>Description of the subcommand group</p> <code>None</code> <code>sub_group_desc</code> <code>Optional[str | LocalisedDesc]</code> <p>An alias for <code>subcommand_group_description</code></p> <code>None</code> <code>scopes</code> <code>List[Snowflake_Type]</code> <p>The scopes of which this command is available, defaults to GLOBAL_SCOPE</p> <code>None</code> <code>options</code> <code>List[dict]</code> <p>The options for this command</p> <code>None</code> <code>nsfw</code> <code>bool</code> <p>This command should only work in NSFW channels</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Coroutine], SlashCommand]</code> <p>A SlashCommand object</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>def subcommand(\n    base: str | LocalisedName,\n    *,\n    subcommand_group: Optional[str | LocalisedName] = None,\n    name: Optional[str | LocalisedName] = None,\n    description: Absent[str | LocalisedDesc] = MISSING,\n    base_description: Optional[str | LocalisedDesc] = None,\n    base_desc: Optional[str | LocalisedDesc] = None,\n    base_default_member_permissions: Optional[\"Permissions\"] = None,\n    base_dm_permission: bool = True,\n    subcommand_group_description: Optional[str | LocalisedDesc] = None,\n    sub_group_desc: Optional[str | LocalisedDesc] = None,\n    scopes: List[\"Snowflake_Type\"] = None,\n    options: List[dict] = None,\n    nsfw: bool = False,\n) -&gt; Callable[[Coroutine], SlashCommand]:\n\"\"\"\n    A decorator specifically tailored for creating subcommands.\n\n    Args:\n        base: The name of the base command\n        subcommand_group: The name of the subcommand group, if any.\n        name: The name of the subcommand, defaults to the name of the coroutine.\n        description: The description of the subcommand\n        base_description: The description of the base command\n        base_desc: An alias of `base_description`\n        base_default_member_permissions: What permissions members need to have by default to use this command.\n        base_dm_permission: Should this command be available in DMs.\n        subcommand_group_description: Description of the subcommand group\n        sub_group_desc: An alias for `subcommand_group_description`\n        scopes: The scopes of which this command is available, defaults to GLOBAL_SCOPE\n        options: The options for this command\n        nsfw: This command should only work in NSFW channels\n\n    Returns:\n        A SlashCommand object\n\n    \"\"\"\n\n    def wrapper(func) -&gt; SlashCommand:\n        if not asyncio.iscoroutinefunction(func):\n            raise ValueError(\"Commands must be coroutines\")\n\n        _description = description\n        if _description is MISSING:\n            _description = func.__doc__ if func.__doc__ else \"No Description Set\"\n\n        cmd = SlashCommand(\n            name=base,\n            description=(base_description or base_desc) or \"No Description Set\",\n            group_name=subcommand_group,\n            group_description=(subcommand_group_description or sub_group_desc) or \"No Description Set\",\n            sub_cmd_name=name,\n            sub_cmd_description=_description,\n            default_member_permissions=base_default_member_permissions,\n            dm_permission=base_dm_permission,\n            scopes=scopes if scopes else [GLOBAL_SCOPE],\n            callback=func,\n            options=options,\n            nsfw=nsfw,\n        )\n        return cmd\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.context_menu","title":"<code>context_menu(name, context_type, scopes=MISSING, default_member_permissions=None, dm_permission=True)</code>","text":"<p>A decorator to declare a coroutine as a Context Menu.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | LocalisedName</code> <p>1-32 character name of the context menu</p> required <code>context_type</code> <code>CommandTypes</code> <p>The type of context menu</p> required <code>scopes</code> <code>Absent[List[Snowflake_Type]]</code> <p>The scope this command exists within</p> <code>MISSING</code> <code>default_member_permissions</code> <code>Optional[Permissions]</code> <p>What permissions members need to have by default to use this command.</p> <code>None</code> <code>dm_permission</code> <code>bool</code> <p>Should this command be available in DMs.</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable[[Coroutine], ContextMenu]</code> <p>ContextMenu object</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>def context_menu(\n    name: str | LocalisedName,\n    context_type: \"CommandTypes\",\n    scopes: Absent[List[\"Snowflake_Type\"]] = MISSING,\n    default_member_permissions: Optional[\"Permissions\"] = None,\n    dm_permission: bool = True,\n) -&gt; Callable[[Coroutine], ContextMenu]:\n\"\"\"\n    A decorator to declare a coroutine as a Context Menu.\n\n    Args:\n        name: 1-32 character name of the context menu\n        context_type: The type of context menu\n        scopes: The scope this command exists within\n        default_member_permissions: What permissions members need to have by default to use this command.\n        dm_permission: Should this command be available in DMs.\n\n    Returns:\n        ContextMenu object\n\n    \"\"\"\n\n    def wrapper(func) -&gt; ContextMenu:\n        if not asyncio.iscoroutinefunction(func):\n            raise ValueError(\"Commands must be coroutines\")\n\n        perm = default_member_permissions\n        if hasattr(func, \"default_member_permissions\"):\n            if perm:\n                perm = perm | func.default_member_permissions\n            else:\n                perm = func.default_member_permissions\n\n        cmd = ContextMenu(\n            name=name,\n            type=context_type,\n            scopes=scopes if scopes else [GLOBAL_SCOPE],\n            default_member_permissions=perm,\n            dm_permission=dm_permission,\n            callback=func,\n        )\n        return cmd\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.component_callback","title":"<code>component_callback(*custom_id)</code>","text":"<p>Register a coroutine as a component callback.</p> <p>Component callbacks work the same way as commands, just using components as a way of invoking, instead of messages. Your callback will be given a single argument, <code>ComponentContext</code></p> <p>Parameters:</p> Name Type Description Default <code>*custom_id</code> <code>str</code> <p>The custom ID of the component to wait for</p> <code>()</code> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>def component_callback(*custom_id: str) -&gt; Callable[[Coroutine], ComponentCommand]:\n\"\"\"\n    Register a coroutine as a component callback.\n\n    Component callbacks work the same way as commands, just using components as a way of invoking, instead of messages.\n    Your callback will be given a single argument, `ComponentContext`\n\n    Args:\n        *custom_id: The custom ID of the component to wait for\n\n    \"\"\"\n\n    def wrapper(func) -&gt; ComponentCommand:\n        if not asyncio.iscoroutinefunction(func):\n            raise ValueError(\"Commands must be coroutines\")\n\n        return ComponentCommand(name=f\"ComponentCallback::{custom_id}\", callback=func, listeners=custom_id)\n\n    custom_id = _unpack_helper(custom_id)\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.modal_callback","title":"<code>modal_callback(*custom_id)</code>","text":"<p>Register a coroutine as a modal callback.</p> <p>Modal callbacks work the same way as commands, just using modals as a way of invoking, instead of messages. Your callback will be given a single argument, <code>ModalContext</code></p> <p>Parameters:</p> Name Type Description Default <code>*custom_id</code> <code>str</code> <p>The custom ID of the modal to wait for</p> <code>()</code> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>def modal_callback(*custom_id: str) -&gt; Callable[[Coroutine], ModalCommand]:\n\"\"\"\n    Register a coroutine as a modal callback.\n\n    Modal callbacks work the same way as commands, just using modals as a way of invoking, instead of messages.\n    Your callback will be given a single argument, `ModalContext`\n\n    Args:\n        *custom_id: The custom ID of the modal to wait for\n    \"\"\"\n\n    def wrapper(func) -&gt; ModalCommand:\n        if not asyncio.iscoroutinefunction(func):\n            raise ValueError(\"Commands must be coroutines\")\n\n        return ModalCommand(name=f\"ModalCallback::{custom_id}\", callback=func, listeners=custom_id)\n\n    custom_id = _unpack_helper(custom_id)\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.slash_option","title":"<code>slash_option(name, description, opt_type, required=False, autocomplete=False, choices=None, channel_types=None, min_value=None, max_value=None, min_length=None, max_length=None)</code>","text":"<p>A decorator to add an option to a slash command.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>1-32 lowercase character name matching ^[\\w-]{1,32}$</p> required <code>opt_type</code> <code>Union[OptionTypes, int]</code> <p>The type of option</p> required <code>description</code> <code>str</code> <p>1-100 character description of option</p> required <code>required</code> <code>bool</code> <p>If the parameter is required or optional--default false</p> <code>False</code> <code>choices</code> <code>List[Union[SlashCommandChoice, dict]]</code> <p>A list of choices the user has to pick between (max 25)</p> <code>None</code> <code>channel_types</code> <code>Optional[list[Union[ChannelTypes, int]]]</code> <p>The channel types permitted. The option needs to be a channel</p> <code>None</code> <code>min_value</code> <code>Optional[float]</code> <p>The minimum value permitted. The option needs to be an integer or float</p> <code>None</code> <code>max_value</code> <code>Optional[float]</code> <p>The maximum value permitted. The option needs to be an integer or float</p> <code>None</code> <code>min_length</code> <code>Optional[int]</code> <p>The minimum length of text a user can input. The option needs to be a string</p> <code>None</code> <code>max_length</code> <code>Optional[int]</code> <p>The maximum length of text a user can input. The option needs to be a string</p> <code>None</code> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>def slash_option(\n    name: str,\n    description: str,\n    opt_type: Union[OptionTypes, int],\n    required: bool = False,\n    autocomplete: bool = False,\n    choices: List[Union[SlashCommandChoice, dict]] = None,\n    channel_types: Optional[list[Union[ChannelTypes, int]]] = None,\n    min_value: Optional[float] = None,\n    max_value: Optional[float] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n) -&gt; Any:\nr\"\"\"\n    A decorator to add an option to a slash command.\n\n    Args:\n        name: 1-32 lowercase character name matching ^[\\w-]{1,32}$\n        opt_type: The type of option\n        description: 1-100 character description of option\n        required: If the parameter is required or optional--default false\n        choices: A list of choices the user has to pick between (max 25)\n        channel_types: The channel types permitted. The option needs to be a channel\n        min_value: The minimum value permitted. The option needs to be an integer or float\n        max_value: The maximum value permitted. The option needs to be an integer or float\n        min_length: The minimum length of text a user can input. The option needs to be a string\n        max_length: The maximum length of text a user can input. The option needs to be a string\n    \"\"\"\n\n    def wrapper(func: Coroutine) -&gt; Coroutine:\n        if hasattr(func, \"cmd_id\"):\n            raise Exception(\"slash_option decorators must be positioned under a slash_command decorator\")\n\n        option = SlashCommandOption(\n            name=name,\n            type=opt_type,\n            description=description,\n            required=required,\n            autocomplete=autocomplete,\n            choices=choices if choices else [],\n            channel_types=channel_types,\n            min_value=min_value,\n            max_value=max_value,\n            min_length=min_length,\n            max_length=max_length,\n        )\n        if not hasattr(func, \"options\"):\n            func.options = []\n        func.options.insert(0, option)\n        return func\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.slash_default_member_permission","title":"<code>slash_default_member_permission(permission)</code>","text":"<p>A decorator to permissions members need to have by default to use a command.</p> <p>Parameters:</p> Name Type Description Default <code>permission</code> <code>Permissions</code> <p>The permissions to require for to this command</p> required Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>def slash_default_member_permission(permission: \"Permissions\") -&gt; Any:\n\"\"\"\n    A decorator to permissions members need to have by default to use a command.\n\n    Args:\n        permission: The permissions to require for to this command\n\n    \"\"\"\n\n    def wrapper(func: Coroutine) -&gt; Coroutine:\n        if hasattr(func, \"cmd_id\"):\n            raise Exception(\n                \"slash_default_member_permission decorators must be positioned under a slash_command decorator\"\n            )\n\n        if not hasattr(func, \"default_member_permissions\") or func.default_member_permissions is None:\n            func.default_member_permissions = permission\n        else:\n            func.default_member_permissions = func.default_member_permissions | permission\n        return func\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.auto_defer","title":"<code>auto_defer(ephemeral=False, time_until_defer=0.0)</code>","text":"<p>A decorator to add an auto defer to a application command.</p> <p>Parameters:</p> Name Type Description Default <code>ephemeral</code> <code>bool</code> <p>Should the command be deferred as ephemeral</p> <code>False</code> <code>time_until_defer</code> <code>float</code> <p>How long to wait before deferring automatically</p> <code>0.0</code> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>def auto_defer(ephemeral: bool = False, time_until_defer: float = 0.0) -&gt; Callable[[Coroutine], Coroutine]:\n\"\"\"\n    A decorator to add an auto defer to a application command.\n\n    Args:\n        ephemeral: Should the command be deferred as ephemeral\n        time_until_defer: How long to wait before deferring automatically\n\n    \"\"\"\n\n    def wrapper(func: Coroutine) -&gt; Coroutine:\n        if hasattr(func, \"cmd_id\"):\n            raise Exception(\"auto_defer decorators must be positioned under a slash_command decorator\")\n        func.auto_defer = AutoDefer(enabled=True, ephemeral=ephemeral, time_until_defer=time_until_defer)\n        return func\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.application_commands_to_dict","title":"<code>application_commands_to_dict(commands, client)</code>","text":"<p>Convert the command list into a format that would be accepted by discord.</p> <p><code>Client.interactions</code> should be the variable passed to this</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>def application_commands_to_dict(\n    commands: Dict[\"Snowflake_Type\", Dict[str, InteractionCommand]], client: \"Client\"\n) -&gt; dict:\n\"\"\"\n    Convert the command list into a format that would be accepted by discord.\n\n    `Client.interactions` should be the variable passed to this\n\n    \"\"\"\n    cmd_bases = {}  # {cmd_base: [commands]}\n\"\"\"A store of commands organised by their base command\"\"\"\n    output = {}\n\"\"\"The output dictionary\"\"\"\n\n    def squash_subcommand(subcommands: List) -&gt; Dict:\n        output_data = {}\n        groups = {}\n        sub_cmds = []\n        for subcommand in subcommands:\n            if not output_data:\n                output_data = {\n                    \"name\": str(subcommand.name),\n                    \"description\": str(subcommand.description),\n                    \"options\": [],\n                    \"default_member_permissions\": str(int(subcommand.default_member_permissions))\n                    if subcommand.default_member_permissions\n                    else None,\n                    \"dm_permission\": subcommand.dm_permission,\n                    \"name_localizations\": subcommand.name.to_locale_dict(),\n                    \"description_localizations\": subcommand.description.to_locale_dict(),\n                    \"nsfw\": subcommand.nsfw,\n                }\n            if bool(subcommand.group_name):\n                if str(subcommand.group_name) not in groups:\n                    groups[str(subcommand.group_name)] = {\n                        \"name\": str(subcommand.group_name),\n                        \"description\": str(subcommand.group_description),\n                        \"type\": int(OptionTypes.SUB_COMMAND_GROUP),\n                        \"options\": [],\n                        \"name_localizations\": subcommand.group_name.to_locale_dict(),\n                        \"description_localizations\": subcommand.group_description.to_locale_dict(),\n                    }\n                groups[str(subcommand.group_name)][\"options\"].append(\n                    subcommand.to_dict() | {\"type\": int(OptionTypes.SUB_COMMAND)}\n                )\n            elif subcommand.is_subcommand:\n                sub_cmds.append(subcommand.to_dict() | {\"type\": int(OptionTypes.SUB_COMMAND)})\n        options = list(groups.values()) + sub_cmds\n        output_data[\"options\"] = options\n        return output_data\n\n    for _scope, cmds in commands.items():\n        for cmd in cmds.values():\n            cmd_name = str(cmd.name)\n            if cmd_name not in cmd_bases:\n                cmd_bases[cmd_name] = [cmd]\n                continue\n            if cmd not in cmd_bases[cmd_name]:\n                cmd_bases[cmd_name].append(cmd)\n\n    for cmd_list in cmd_bases.values():\n        if any(c.is_subcommand for c in cmd_list):\n            # validate all commands share required attributes\n            scopes: list[Snowflake_Type] = list({s for c in cmd_list for s in c.scopes})\n            base_description = next(\n                (\n                    c.description\n                    for c in cmd_list\n                    if str(c.description) is not None and str(c.description) != \"No Description Set\"\n                ),\n                \"No Description Set\",\n            )\n            nsfw = cmd_list[0].nsfw\n\n            if not all(str(c.description) in (str(base_description), \"No Description Set\") for c in cmd_list):\n                client.logger.warning(\n                    f\"Conflicting descriptions found in `{cmd_list[0].name}` subcommands; `{str(base_description)}` will be used\"\n                )\n            if not all(c.default_member_permissions == cmd_list[0].default_member_permissions for c in cmd_list):\n                raise ValueError(f\"Conflicting `default_member_permissions` values found in `{cmd_list[0].name}`\")\n            if not all(c.dm_permission == cmd_list[0].dm_permission for c in cmd_list):\n                raise ValueError(f\"Conflicting `dm_permission` values found in `{cmd_list[0].name}`\")\n            if not all(c.nsfw == nsfw for c in cmd_list):\n                client.logger.warning(f\"Conflicting `nsfw` values found in {cmd_list[0].name} - `True` will be used\")\n                nsfw = True\n\n            for cmd in cmd_list:\n                cmd.scopes = list(scopes)\n                cmd.description = base_description\n            # end validation of attributes\n            cmd_data = squash_subcommand(cmd_list)\n        else:\n            scopes = cmd_list[0].scopes\n            cmd_data = cmd_list[0].to_dict()\n        for s in scopes:\n            if s not in output:\n                output[s] = [cmd_data]\n                continue\n            output[s].append(cmd_data)\n    return output\n</code></pre>"},{"location":"API%20Reference/models/Naff/application_commands/#naff.models.naff.application_commands.sync_needed","title":"<code>sync_needed(local_cmd, remote_cmd=None)</code>","text":"<p>Compares a local application command to its remote counterpart to determine if a sync is required.</p> <p>Parameters:</p> Name Type Description Default <code>local_cmd</code> <code>dict</code> <p>The local json representation of the command</p> required <code>remote_cmd</code> <code>Optional[dict]</code> <p>The json representation of the command from Discord</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean indicating if a sync is needed</p> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>def sync_needed(local_cmd: dict, remote_cmd: Optional[dict] = None) -&gt; bool:\n\"\"\"\n    Compares a local application command to its remote counterpart to determine if a sync is required.\n\n    Args:\n        local_cmd: The local json representation of the command\n        remote_cmd: The json representation of the command from Discord\n\n    Returns:\n        Boolean indicating if a sync is needed\n    \"\"\"\n    if not remote_cmd:\n        # No remote version, command must be new\n        return True\n\n    if not _compare_commands(local_cmd, remote_cmd):\n        # basic comparison of attributes\n        return True\n\n    if remote_cmd[\"type\"] == CommandTypes.CHAT_INPUT:\n        try:\n            if not _compare_options(local_cmd[\"options\"], remote_cmd[\"options\"]):\n                # options are not the same, sync needed\n                return True\n        except KeyError:\n            if \"options\" in local_cmd or \"options\" in remote_cmd:\n                return True\n\n    return False\n</code></pre>"},{"location":"API%20Reference/models/Naff/auto_defer/","title":"Auto defer","text":"<p>A decorator to add an auto defer to a application command.</p> <p>Parameters:</p> Name Type Description Default <code>ephemeral</code> <code>bool</code> <p>Should the command be deferred as ephemeral</p> <code>False</code> <code>time_until_defer</code> <code>float</code> <p>How long to wait before deferring automatically</p> <code>0.0</code> Source code in <code>naff\\models\\naff\\application_commands.py</code> <pre><code>def auto_defer(ephemeral: bool = False, time_until_defer: float = 0.0) -&gt; Callable[[Coroutine], Coroutine]:\n\"\"\"\n    A decorator to add an auto defer to a application command.\n\n    Args:\n        ephemeral: Should the command be deferred as ephemeral\n        time_until_defer: How long to wait before deferring automatically\n\n    \"\"\"\n\n    def wrapper(func: Coroutine) -&gt; Coroutine:\n        if hasattr(func, \"cmd_id\"):\n            raise Exception(\"auto_defer decorators must be positioned under a slash_command decorator\")\n        func.auto_defer = AutoDefer(enabled=True, ephemeral=ephemeral, time_until_defer=time_until_defer)\n        return func\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/checks/","title":"Checks","text":"Example Usage: <pre><code>    from naff import check, has_any_role, slash_command\n\n    @slash_command(name='cmd')\n    @check(has_any_role(174918559539920897, 970018521511768094))\n    async def some_command(ctx):\n        ...\n</code></pre>"},{"location":"API%20Reference/models/Naff/checks/#naff.models.naff.checks.has_role","title":"<code>has_role(role)</code>","text":"<p>Check if the user has the given role.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>Snowflake_Type | Role</code> <p>The Role or role id to check for</p> required Source code in <code>naff\\models\\naff\\checks.py</code> <pre><code>def has_role(role: Snowflake_Type | Role) -&gt; TYPE_CHECK_FUNCTION:\n\"\"\"\n    Check if the user has the given role.\n\n    Args:\n        role: The Role or role id to check for\n\n    \"\"\"\n\n    async def check(ctx: Context) -&gt; bool:\n        if ctx.guild is None:\n            return False\n        author: Member = ctx.author  # pyright: ignore [reportGeneralTypeIssues]\n        return author.has_role(role)\n\n    return check\n</code></pre>"},{"location":"API%20Reference/models/Naff/checks/#naff.models.naff.checks.has_any_role","title":"<code>has_any_role(*roles)</code>","text":"<p>Checks if the user has any of the given roles.</p> <p>Parameters:</p> Name Type Description Default <code>*roles</code> <code>Snowflake_Type | Role</code> <p>The Role(s) or role id(s) to check for</p> <code>()</code> Source code in <code>naff\\models\\naff\\checks.py</code> <pre><code>def has_any_role(*roles: Snowflake_Type | Role) -&gt; TYPE_CHECK_FUNCTION:\n\"\"\"\n    Checks if the user has any of the given roles.\n\n    Args:\n        *roles: The Role(s) or role id(s) to check for\n    \"\"\"\n\n    async def check(ctx: Context) -&gt; bool:\n        if ctx.guild is None:\n            return False\n\n        author: Member = ctx.author  # pyright: ignore [reportGeneralTypeIssues]\n        if any(author.has_role(to_snowflake(r)) for r in roles):\n            return True\n        return False\n\n    return check\n</code></pre>"},{"location":"API%20Reference/models/Naff/checks/#naff.models.naff.checks.has_id","title":"<code>has_id(user_id)</code>","text":"<p>Checks if the author has the desired ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>id of the user to check for</p> required Source code in <code>naff\\models\\naff\\checks.py</code> <pre><code>def has_id(user_id: int) -&gt; TYPE_CHECK_FUNCTION:\n\"\"\"\n    Checks if the author has the desired ID.\n\n    Args:\n        user_id: id of the user to check for\n\n    \"\"\"\n\n    async def check(ctx: Context) -&gt; bool:\n        return ctx.author.id == user_id\n\n    return check\n</code></pre>"},{"location":"API%20Reference/models/Naff/checks/#naff.models.naff.checks.is_owner","title":"<code>is_owner()</code>","text":"<p>Checks if the author is the owner of the bot. This respects the <code>client.owner_ids</code> list.</p> Source code in <code>naff\\models\\naff\\checks.py</code> <pre><code>def is_owner() -&gt; TYPE_CHECK_FUNCTION:\n\"\"\"Checks if the author is the owner of the bot. This respects the `client.owner_ids` list.\"\"\"\n\n    async def check(ctx: Context) -&gt; bool:\n        _owner_ids: set = ctx.bot.owner_ids.copy()\n        if ctx.bot.app.team:\n            [_owner_ids.add(m.id) for m in ctx.bot.app.team.members]\n        return ctx.author.id in _owner_ids\n\n    return check\n</code></pre>"},{"location":"API%20Reference/models/Naff/checks/#naff.models.naff.checks.guild_only","title":"<code>guild_only()</code>","text":"<p>This command may only be ran in a guild.</p> Source code in <code>naff\\models\\naff\\checks.py</code> <pre><code>def guild_only() -&gt; TYPE_CHECK_FUNCTION:\n\"\"\"This command may only be ran in a guild.\"\"\"\n\n    async def check(ctx: Context) -&gt; bool:\n        return ctx.guild is not None\n\n    return check\n</code></pre>"},{"location":"API%20Reference/models/Naff/checks/#naff.models.naff.checks.dm_only","title":"<code>dm_only()</code>","text":"<p>This command may only be ran in a dm.</p> Source code in <code>naff\\models\\naff\\checks.py</code> <pre><code>def dm_only() -&gt; TYPE_CHECK_FUNCTION:\n\"\"\"This command may only be ran in a dm.\"\"\"\n\n    async def check(ctx: Context) -&gt; bool:\n        return ctx.guild is None\n\n    return check\n</code></pre>"},{"location":"API%20Reference/models/Naff/command/","title":"Command","text":""},{"location":"API%20Reference/models/Naff/command/#naff.models.naff.command.BaseCommand","title":"<code>BaseCommand</code>","text":"<p>         Bases: <code>DictSerializationMixin</code>, <code>CallbackObject</code></p> <p>An object all commands inherit from. Outlines the basic structure of a command, and handles checks.</p> <p>Attributes:</p> Name Type Description <code>extension</code> <code>Any</code> <p>The extension this command belongs to.</p> <code>enabled</code> <code>bool</code> <p>Whether this command is enabled</p> <code>checks</code> <code>list</code> <p>Any checks that must be run before this command can be run</p> <code>callback</code> <code>Callable[..., Coroutine]</code> <p>The coroutine to be called for this command</p> <code>error_callback</code> <code>Callable[..., Coroutine]</code> <p>The coroutine to be called when an error occurs</p> <code>pre_run_callback</code> <code>Callable[..., Coroutine]</code> <p>A coroutine to be called before this command is run but after the checks</p> <code>post_run_callback</code> <code>Callable[..., Coroutine]</code> <p>A coroutine to be called after this command has run</p> Source code in <code>naff\\models\\naff\\command.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass BaseCommand(DictSerializationMixin, CallbackObject):\n\"\"\"\n    An object all commands inherit from. Outlines the basic structure of a command, and handles checks.\n\n    Attributes:\n        extension: The extension this command belongs to.\n        enabled: Whether this command is enabled\n        checks: Any checks that must be run before this command can be run\n        callback: The coroutine to be called for this command\n        error_callback: The coroutine to be called when an error occurs\n        pre_run_callback: A coroutine to be called before this command is run **but** after the checks\n        post_run_callback: A coroutine to be called after this command has run\n\n    \"\"\"\n\n    extension: Any = attrs.field(\n        repr=False, default=None, metadata=docs(\"The extension this command belongs to\") | no_export_meta\n    )\n\n    enabled: bool = attrs.field(\n        repr=False, default=True, metadata=docs(\"Whether this can be run at all\") | no_export_meta\n    )\n    checks: list = attrs.field(\n        repr=False,\n        factory=list,\n        metadata=docs(\"Any checks that must be *checked* before the command can run\") | no_export_meta,\n    )\n    cooldown: Cooldown = attrs.field(\n        repr=False, default=MISSING, metadata=docs(\"An optional cooldown to apply to the command\") | no_export_meta\n    )\n    max_concurrency: MaxConcurrency = attrs.field(\n        default=MISSING,\n        metadata=docs(\"An optional maximum number of concurrent instances to apply to the command\") | no_export_meta,\n    )\n\n    callback: Callable[..., Coroutine] = attrs.field(\n        repr=False, default=None, metadata=docs(\"The coroutine to be called for this command\") | no_export_meta\n    )\n    error_callback: Callable[..., Coroutine] = attrs.field(\n        repr=False, default=None, metadata=no_export_meta | docs(\"The coroutine to be called when an error occurs\")\n    )\n    pre_run_callback: Callable[..., Coroutine] = attrs.field(\n        default=None,\n        metadata=no_export_meta\n        | docs(\"The coroutine to be called before the command is executed, **but** after the checks\"),\n    )\n    post_run_callback: Callable[..., Coroutine] = attrs.field(\n        repr=False,\n        default=None,\n        metadata=no_export_meta | docs(\"The coroutine to be called after the command has executed\"),\n    )\n\n    def __attrs_post_init__(self) -&gt; None:\n        if self.callback is not None:\n            if hasattr(self.callback, \"checks\"):\n                self.checks += self.callback.checks\n            if hasattr(self.callback, \"cooldown\"):\n                self.cooldown = self.callback.cooldown\n            if hasattr(self.callback, \"max_concurrency\"):\n                self.max_concurrency = self.callback.max_concurrency\n\n    def __hash__(self) -&gt; int:\n        return id(self)\n\n    async def __call__(self, context: \"Context\", *args, **kwargs) -&gt; None:\n\"\"\"\n        Calls this command.\n\n        Args:\n            context: The context of this command\n            args: Any\n            kwargs: Any\n\n        \"\"\"\n        # signals if a semaphore has been acquired, for exception handling\n        # if present assume one will be acquired\n        max_conc_acquired = self.max_concurrency is not MISSING\n\n        try:\n            if await self._can_run(context):\n                if self.pre_run_callback is not None:\n                    await self.call_with_binding(self.pre_run_callback, context, *args, **kwargs)\n\n                if self.extension is not None and self.extension.extension_prerun:\n                    for prerun in self.extension.extension_prerun:\n                        await prerun(context, *args, **kwargs)\n\n                await self.call_callback(self.callback, context)\n\n                if self.post_run_callback is not None:\n                    await self.call_with_binding(self.post_run_callback, context, *args, **kwargs)\n\n                if self.extension is not None and self.extension.extension_postrun:\n                    for postrun in self.extension.extension_postrun:\n                        await postrun(context, *args, **kwargs)\n\n        except Exception as e:\n            # if a MaxConcurrencyReached-exception is raised a connection was never acquired\n            max_conc_acquired = not isinstance(e, MaxConcurrencyReached)\n\n            if self.error_callback:\n                await self.error_callback(e, context, *args, **kwargs)\n            elif self.extension and self.extension.extension_error:\n                await self.extension.extension_error(e, context, *args, **kwargs)\n            else:\n                raise\n        finally:\n            if self.max_concurrency is not MISSING and max_conc_acquired:\n                await self.max_concurrency.release(context)\n\n    @staticmethod\n    def _get_converter_function(anno: type[Converter] | Converter, name: str) -&gt; Callable[[Context, str], Any]:\n        num_params = len(get_parameters(anno.convert))\n\n        # if we have three parameters for the function, it's likely it has a self parameter\n        # so we need to get rid of it by initing - typehinting hates this, btw!\n        # the below line will error out if we aren't supposed to init it, so that works out\n        try:\n            actual_anno: Converter = anno() if num_params == 3 else anno  # type: ignore\n        except TypeError:\n            raise ValueError(\n                f\"{get_object_name(anno)} for {name} is invalid: converters must have exactly 2 arguments.\"\n            ) from None\n\n        # we can only get to this point while having three params if we successfully inited\n        if num_params == 3:\n            num_params -= 1\n\n        if num_params != 2:\n            raise ValueError(\n                f\"{get_object_name(anno)} for {name} is invalid: converters must have exactly 2 arguments.\"\n            )\n\n        return actual_anno.convert\n\n    async def try_convert(self, converter: Optional[Callable], context: \"Context\", value: Any) -&gt; Any:\n        if converter is None:\n            return value\n        return await maybe_coroutine(converter, context, value)\n\n    def param_config(self, annotation: Any, name: str) -&gt; Tuple[Callable, Optional[dict]]:\n        # This thing is complicated. NAFF-annotations can either be annotated directly, or they can be annotated with Annotated[str, CMD_*]\n        # This helper function handles both cases, and returns a tuple of the converter and its config (if any)\n        if annotation is None:\n            return None\n        if typing.get_origin(annotation) is Annotated and (args := typing.get_args(annotation)):\n            for ann in args:\n                v = getattr(ann, name, None)\n                if v is not None:\n                    return (ann, v)\n        return (annotation, getattr(annotation, name, None))\n\n    async def call_callback(self, callback: Callable, context: \"Context\") -&gt; None:\n        _call = callback\n        if self.has_binding:\n            callback = functools.partial(callback, None, None)\n        else:\n            callback = functools.partial(callback, None)\n        parameters = get_parameters(callback)\n        args = []\n        kwargs = {}\n        if len(parameters) == 0:\n            # if no params, user only wants context\n            return await self.call_with_binding(_call, context)\n\n        c_args = copy.copy(context.args)\n        for param in parameters.values():\n            if isinstance(param.annotation, Converter):\n                # for any future dev looking at this:\n                # this checks if the class here has a convert function\n                # it does NOT check if the annotation is actually a subclass of Converter\n                # this is an intended behavior for Protocols with the runtime_checkable decorator\n                convert = functools.partial(\n                    self.try_convert, self._get_converter_function(param.annotation, param.name), context\n                )\n            else:\n                convert = functools.partial(self.try_convert, None, context)\n            func, config = self.param_config(param.annotation, \"_annotation_dat\")\n            if config:\n                # if user has used an naff-annotation, run the annotation, and pass the result to the user\n                local = {\"context\": context, \"extension\": self.extension, \"param\": param.name}\n                ano_args = [local[c] for c in config[\"args\"]]\n                if param.kind != param.POSITIONAL_ONLY:\n                    kwargs[param.name] = func(*ano_args)\n                else:\n                    args.append(func(*ano_args))\n                continue\n            elif param.name in context.kwargs:\n                # if parameter is in kwargs, user obviously wants it, pass it\n                if param.kind != param.POSITIONAL_ONLY:\n                    kwargs[param.name] = await convert(context.kwargs[param.name])\n                else:\n                    args.append(await convert(context.kwargs[param.name]))\n                if context.kwargs[param.name] in c_args:\n                    c_args.remove(context.kwargs[param.name])\n            elif param.default is not param.empty:\n                kwargs[param.name] = param.default\n            else:\n                if not str(param).startswith(\"*\"):\n                    if param.kind != param.KEYWORD_ONLY:\n                        try:\n                            args.append(await convert(c_args.pop(0)))\n                        except IndexError:\n                            raise ValueError(\n                                f\"{context.invoke_target} expects {len([p for p in parameters.values() if p.default is p.empty]) + len(callback.args)}\"\n                                f\" arguments but received {len(context.args)} instead\"\n                            ) from None\n                    else:\n                        raise ValueError(f\"Unable to resolve argument: {param.name}\")\n\n        if any(kwargs_reg.match(str(param)) for param in parameters.values()):\n            # if user has `**kwargs` pass all remaining kwargs\n            kwargs = kwargs | {k: v for k, v in context.kwargs.items() if k not in kwargs}\n        if any(args_reg.match(str(param)) for param in parameters.values()):\n            # user has `*args` pass all remaining args\n            args = args + [await convert(c) for c in c_args]\n        return await self.call_with_binding(_call, context, *args, **kwargs)\n\n    async def _can_run(self, context: Context) -&gt; bool:\n\"\"\"\n        Determines if this command can be run.\n\n        Args:\n            context: The context of the command\n\n        \"\"\"\n        max_conc_acquired = False  # signals if a semaphore has been acquired, for exception handling\n\n        try:\n            if not self.enabled:\n                return False\n\n            for _c in self.checks:\n                if not await _c(context):\n                    raise CommandCheckFailure(self, _c, context)\n\n            if self.extension and self.extension.extension_checks:\n                for _c in self.extension.extension_checks:\n                    if not await _c(context):\n                        raise CommandCheckFailure(self, _c, context)\n\n            if self.max_concurrency is not MISSING:\n                if not await self.max_concurrency.acquire(context):\n                    raise MaxConcurrencyReached(self, self.max_concurrency)\n\n            if self.cooldown is not MISSING:\n                if not await self.cooldown.acquire_token(context):\n                    raise CommandOnCooldown(self, await self.cooldown.get_cooldown(context))\n\n            return True\n\n        except Exception:\n            if max_conc_acquired:\n                await self.max_concurrency.release(context)\n            raise\n\n    def error(self, call: Callable[..., Coroutine]) -&gt; Callable[..., Coroutine]:\n\"\"\"A decorator to declare a coroutine as one that will be run upon an error.\"\"\"\n        if not asyncio.iscoroutinefunction(call):\n            raise TypeError(\"Error handler must be coroutine\")\n        self.error_callback = call\n        return call\n\n    def pre_run(self, call: Callable[..., Coroutine]) -&gt; Callable[..., Coroutine]:\n\"\"\"A decorator to declare a coroutine as one that will be run before the command.\"\"\"\n        if not asyncio.iscoroutinefunction(call):\n            raise TypeError(\"pre_run must be coroutine\")\n        self.pre_run_callback = call\n        return call\n\n    def post_run(self, call: Callable[..., Coroutine]) -&gt; Callable[..., Coroutine]:\n\"\"\"A decorator to declare a coroutine as one that will be run after the command has.\"\"\"\n        if not asyncio.iscoroutinefunction(call):\n            raise TypeError(\"post_run must be coroutine\")\n        self.post_run_callback = call\n        return call\n</code></pre>"},{"location":"API%20Reference/models/Naff/command/#naff.models.naff.command.BaseCommand.error","title":"<code>error(call)</code>","text":"<p>A decorator to declare a coroutine as one that will be run upon an error.</p> Source code in <code>naff\\models\\naff\\command.py</code> <pre><code>def error(self, call: Callable[..., Coroutine]) -&gt; Callable[..., Coroutine]:\n\"\"\"A decorator to declare a coroutine as one that will be run upon an error.\"\"\"\n    if not asyncio.iscoroutinefunction(call):\n        raise TypeError(\"Error handler must be coroutine\")\n    self.error_callback = call\n    return call\n</code></pre>"},{"location":"API%20Reference/models/Naff/command/#naff.models.naff.command.BaseCommand.pre_run","title":"<code>pre_run(call)</code>","text":"<p>A decorator to declare a coroutine as one that will be run before the command.</p> Source code in <code>naff\\models\\naff\\command.py</code> <pre><code>def pre_run(self, call: Callable[..., Coroutine]) -&gt; Callable[..., Coroutine]:\n\"\"\"A decorator to declare a coroutine as one that will be run before the command.\"\"\"\n    if not asyncio.iscoroutinefunction(call):\n        raise TypeError(\"pre_run must be coroutine\")\n    self.pre_run_callback = call\n    return call\n</code></pre>"},{"location":"API%20Reference/models/Naff/command/#naff.models.naff.command.BaseCommand.post_run","title":"<code>post_run(call)</code>","text":"<p>A decorator to declare a coroutine as one that will be run after the command has.</p> Source code in <code>naff\\models\\naff\\command.py</code> <pre><code>def post_run(self, call: Callable[..., Coroutine]) -&gt; Callable[..., Coroutine]:\n\"\"\"A decorator to declare a coroutine as one that will be run after the command has.\"\"\"\n    if not asyncio.iscoroutinefunction(call):\n        raise TypeError(\"post_run must be coroutine\")\n    self.post_run_callback = call\n    return call\n</code></pre>"},{"location":"API%20Reference/models/Naff/command/#naff.models.naff.command.check","title":"<code>check(check)</code>","text":"<p>Add a check to a command.</p> <p>Parameters:</p> Name Type Description Default <code>check</code> <code>Callable[[Context], Awaitable[bool]]</code> <p>A coroutine as a check for this command</p> required Source code in <code>naff\\models\\naff\\command.py</code> <pre><code>def check(check: Callable[[\"Context\"], Awaitable[bool]]) -&gt; Callable[[Coroutine], Coroutine]:\n\"\"\"\n    Add a check to a command.\n\n    Args:\n        check: A coroutine as a check for this command\n\n    \"\"\"\n\n    def wrapper(coro: Coroutine) -&gt; Coroutine:\n        if isinstance(coro, BaseCommand):\n            coro.checks.append(check)\n            return coro\n        if not hasattr(coro, \"checks\"):\n            coro.checks = []\n        coro.checks.append(check)\n        return coro\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/command/#naff.models.naff.command.cooldown","title":"<code>cooldown(bucket, rate, interval)</code>","text":"<p>Add a cooldown to a command.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>Buckets</code> <p>The bucket used to track cooldowns</p> required <code>rate</code> <code>int</code> <p>How many commands may be ran per interval</p> required <code>interval</code> <code>float</code> <p>How many seconds to wait for a cooldown</p> required Source code in <code>naff\\models\\naff\\command.py</code> <pre><code>def cooldown(bucket: Buckets, rate: int, interval: float) -&gt; Callable[[Coroutine], Coroutine]:\n\"\"\"\n    Add a cooldown to a command.\n\n    Args:\n        bucket: The bucket used to track cooldowns\n        rate: How many commands may be ran per interval\n        interval: How many seconds to wait for a cooldown\n\n    \"\"\"\n\n    def wrapper(coro: Coroutine) -&gt; Coroutine:\n        cooldown_obj = Cooldown(bucket, rate, interval)\n\n        coro.cooldown = cooldown_obj\n\n        return coro\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/command/#naff.models.naff.command.max_concurrency","title":"<code>max_concurrency(bucket, concurrent)</code>","text":"<p>Add a maximum number of concurrent instances to the command.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>Buckets</code> <p>The bucket to enforce the maximum within</p> required <code>concurrent</code> <code>int</code> <p>The maximum number of concurrent instances to allow</p> required Source code in <code>naff\\models\\naff\\command.py</code> <pre><code>def max_concurrency(bucket: Buckets, concurrent: int) -&gt; Callable[[Coroutine], Coroutine]:\n\"\"\"\n    Add a maximum number of concurrent instances to the command.\n\n    Args:\n        bucket: The bucket to enforce the maximum within\n        concurrent: The maximum number of concurrent instances to allow\n\n    \"\"\"\n\n    def wrapper(coro: Coroutine) -&gt; Coroutine:\n        max_conc = MaxConcurrency(concurrent, bucket)\n\n        coro.max_concurrency = max_conc\n\n        return coro\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/","title":"Context","text":""},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.Resolved","title":"<code>Resolved</code>","text":"<p>Represents resolved data in an interaction.</p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass Resolved:\n\"\"\"Represents resolved data in an interaction.\"\"\"\n\n    channels: Dict[\"Snowflake_Type\", \"TYPE_MESSAGEABLE_CHANNEL\"] = attrs.field(\n        repr=False, factory=dict, metadata=docs(\"A dictionary of channels mentioned in the interaction\")\n    )\n    members: Dict[\"Snowflake_Type\", \"Member\"] = attrs.field(\n        repr=False, factory=dict, metadata=docs(\"A dictionary of members mentioned in the interaction\")\n    )\n    users: Dict[\"Snowflake_Type\", \"User\"] = attrs.field(\n        repr=False, factory=dict, metadata=docs(\"A dictionary of users mentioned in the interaction\")\n    )\n    roles: Dict[\"Snowflake_Type\", \"Role\"] = attrs.field(\n        repr=False, factory=dict, metadata=docs(\"A dictionary of roles mentioned in the interaction\")\n    )\n    messages: Dict[\"Snowflake_Type\", \"Message\"] = attrs.field(\n        repr=False, factory=dict, metadata=docs(\"A dictionary of messages mentioned in the interaction\")\n    )\n    attachments: Dict[\"Snowflake_Type\", \"Attachment\"] = attrs.field(\n        repr=False, factory=dict, metadata=docs(\"A dictionary of attachments tied to the interaction\")\n    )\n\n    @classmethod\n    def from_dict(cls, client: \"Client\", data: dict, guild_id: Optional[\"Snowflake_Type\"] = None) -&gt; \"Resolved\":\n        new_cls = cls()\n\n        if channels := data.get(\"channels\"):\n            for key, _channel in channels.items():\n                new_cls.channels[key] = client.cache.place_channel_data(_channel)\n\n        if members := data.get(\"members\"):\n            for key, _member in members.items():\n                new_cls.members[key] = client.cache.place_member_data(\n                    guild_id, {**_member, \"user\": {**data[\"users\"][key]}}\n                )\n\n        if users := data.get(\"users\"):\n            for key, _user in users.items():\n                new_cls.users[key] = client.cache.place_user_data(_user)\n\n        if roles := data.get(\"roles\"):\n            for key, _role in roles.items():\n                new_cls.roles[key] = client.cache.get_role(to_snowflake(key))\n\n        if messages := data.get(\"messages\"):\n            for key, _msg in messages.items():\n                new_cls.messages[key] = client.cache.place_message_data(_msg)\n\n        if attachments := data.get(\"attachments\"):\n            for key, _attach in attachments.items():\n                new_cls.attachments[key] = Attachment.from_dict(_attach, client)\n\n        return new_cls\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.Context","title":"<code>Context</code>","text":"<p>Represents the context of a command.</p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass Context:\n\"\"\"Represents the context of a command.\"\"\"\n\n    _client: \"Client\" = attrs.field(repr=False, default=None)\n    invoke_target: str = attrs.field(repr=False, default=None, metadata=docs(\"The name of the command to be invoked\"))\n    command: Optional[\"BaseCommand\"] = attrs.field(repr=False, default=None, metadata=docs(\"The command to be invoked\"))\n\n    args: List = attrs.field(\n        repr=False, factory=list, metadata=docs(\"The list of arguments to be passed to the command\")\n    )\n    kwargs: Dict = attrs.field(repr=False, factory=dict, metadata=docs(\"The list of keyword arguments to be passed\"))\n\n    author: Union[\"Member\", \"User\"] = attrs.field(repr=False, default=None, metadata=docs(\"The author of the message\"))\n    channel: \"TYPE_MESSAGEABLE_CHANNEL\" = attrs.field(\n        repr=False, default=None, metadata=docs(\"The channel this was sent within\")\n    )\n    guild_id: \"Snowflake_Type\" = attrs.field(\n        repr=False,\n        default=None,\n        converter=to_optional_snowflake,\n        metadata=docs(\"The guild this was sent within, if not a DM\"),\n    )\n    message: \"Message\" = attrs.field(\n        repr=False, default=None, metadata=docs(\"The message associated with this context\")\n    )\n\n    logger: Logger = attrs.field(repr=False, init=False, factory=get_logger)\n\n    @property\n    def guild(self) -&gt; Optional[\"Guild\"]:\n        return self._client.cache.get_guild(self.guild_id)\n\n    @property\n    def bot(self) -&gt; \"Client\":\n\"\"\"A reference to the bot instance.\"\"\"\n        return self._client\n\n    @property\n    def voice_state(self) -&gt; Optional[\"ActiveVoiceState\"]:\n        return self._client.cache.get_bot_voice_state(self.guild_id)\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.Context.bot","title":"<code>bot: Client</code>  <code>property</code>","text":"<p>A reference to the bot instance.</p>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.InteractionContext","title":"<code>InteractionContext</code>","text":"<p>         Bases: <code>_BaseInteractionContext</code>, <code>SendMixin</code></p> <p>Represents the context of an interaction.</p> <p>Ephemeral messages:</p> <p>Ephemeral messages allow you to send messages that only the author of the interaction can see. They are best considered as <code>fire-and-forget</code>, in the sense that you cannot edit them once they have been sent.</p> <p>Should you attach a component (ie. button) to the ephemeral message, you will be able to edit it when responding to a button interaction.</p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass InteractionContext(_BaseInteractionContext, SendMixin):\n\"\"\"\n    Represents the context of an interaction.\n\n    !!! info \"Ephemeral messages:\"\n        Ephemeral messages allow you to send messages that only the author of the interaction can see.\n        They are best considered as `fire-and-forget`, in the sense that you cannot edit them once they have been sent.\n\n        Should you attach a component (ie. button) to the ephemeral message,\n        you will be able to edit it when responding to a button interaction.\n\n    \"\"\"\n\n    async def defer(self, ephemeral: bool = False) -&gt; None:\n\"\"\"\n        Defers the response, showing a loading state.\n\n        Args:\n            ephemeral: Should the response be ephemeral\n\n        \"\"\"\n        if self.deferred or self.responded:\n            raise AlreadyDeferred(\"You have already responded to this interaction!\")\n\n        payload = {\"type\": CallbackTypes.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE}\n        if ephemeral:\n            payload[\"data\"] = {\"flags\": MessageFlags.EPHEMERAL}\n\n        await self._client.http.post_initial_response(payload, self.interaction_id, self._token)\n        self.ephemeral = ephemeral\n        self.deferred = True\n\n    async def _send_http_request(\n        self, message_payload: Union[dict, \"FormData\"], files: Iterable[\"UPLOADABLE_TYPE\"] | None = None\n    ) -&gt; dict:\n        if self.responded:\n            message_data = await self._client.http.post_followup(\n                message_payload, self._client.app.id, self._token, files=files\n            )\n        else:\n            if isinstance(message_payload, FormData) and not self.deferred:\n                await self.defer(self.ephemeral)\n            if self.deferred:\n                message_data = await self._client.http.edit_interaction_message(\n                    message_payload, self._client.app.id, self._token, files=files\n                )\n                self.deferred = False\n            else:\n                payload = {\"type\": CallbackTypes.CHANNEL_MESSAGE_WITH_SOURCE, \"data\": message_payload}\n                await self._client.http.post_initial_response(payload, self.interaction_id, self._token, files=files)\n                message_data = await self._client.http.get_interaction_message(self._client.app.id, self._token)\n            self.responded = True\n\n        return message_data\n\n    async def send(\n        self,\n        content: Optional[str] = None,\n        *,\n        embeds: Optional[Union[Iterable[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n        embed: Optional[Union[\"Embed\", dict]] = None,\n        components: Optional[\n            Union[\n                Iterable[Iterable[Union[\"BaseComponent\", dict]]],\n                Iterable[Union[\"BaseComponent\", dict]],\n                \"BaseComponent\",\n                dict,\n            ]\n        ] = None,\n        stickers: Optional[Union[Iterable[Union[\"Sticker\", \"Snowflake_Type\"]], \"Sticker\", \"Snowflake_Type\"]] = None,\n        allowed_mentions: Optional[Union[\"AllowedMentions\", dict]] = None,\n        reply_to: Optional[Union[\"MessageReference\", \"Message\", dict, \"Snowflake_Type\"]] = None,\n        files: Optional[Union[UPLOADABLE_TYPE, Iterable[UPLOADABLE_TYPE]]] = None,\n        file: Optional[UPLOADABLE_TYPE] = None,\n        tts: bool = False,\n        suppress_embeds: bool = False,\n        flags: Optional[Union[int, \"MessageFlags\"]] = None,\n        ephemeral: bool = False,\n    ) -&gt; \"Message\":\n\"\"\"\n        Send a message.\n\n        Args:\n            content: Message text content.\n            embeds: Embedded rich content (up to 6000 characters).\n            embed: Embedded rich content (up to 6000 characters).\n            components: The components to include with the message.\n            stickers: IDs of up to 3 stickers in the server to send in the message.\n            allowed_mentions: Allowed mentions for the message.\n            reply_to: Message to reference, must be from the same channel.\n            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n            tts: Should this message use Text To Speech.\n            suppress_embeds: Should embeds be suppressed on this send\n            flags: Message flags to apply.\n            ephemeral bool: Should this message be sent as ephemeral (hidden)\n\n        Returns:\n            New message object that was sent.\n\n        \"\"\"\n        if ephemeral:\n            flags = MessageFlags.EPHEMERAL\n            self.ephemeral = True\n\n        if suppress_embeds:\n            if isinstance(flags, int):\n                flags = MessageFlags(flags)\n            flags = flags | MessageFlags.SUPPRESS_EMBEDS\n\n        return await super().send(\n            content,\n            embeds=embeds,\n            embed=embed,\n            components=components,\n            stickers=stickers,\n            allowed_mentions=allowed_mentions,\n            reply_to=reply_to,\n            files=files,\n            file=file,\n            tts=tts,\n            flags=flags,\n        )\n\n    async def delete(self, message: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n        Delete a message sent in response to this interaction.\n\n        Args:\n            message: The message to delete\n\n        \"\"\"\n        await self._client.http.delete_interaction_message(self._client.app.id, self._token, to_snowflake(message))\n\n    async def edit(\n        self,\n        message: \"Snowflake_Type\",\n        *,\n        content: Optional[str] = None,\n        embeds: Optional[Union[Sequence[Union[\"models.Embed\", dict]], Union[\"models.Embed\", dict]]] = None,\n        embed: Optional[Union[\"models.Embed\", dict]] = None,\n        components: Optional[\n            Union[\n                Sequence[Sequence[Union[\"models.BaseComponent\", dict]]],\n                Sequence[Union[\"models.BaseComponent\", dict]],\n                \"models.BaseComponent\",\n                dict,\n            ]\n        ] = None,\n        allowed_mentions: Optional[Union[\"models.AllowedMentions\", dict]] = None,\n        attachments: Optional[Optional[Sequence[Union[Attachment, dict]]]] = None,\n        files: Optional[Union[UPLOADABLE_TYPE, Sequence[UPLOADABLE_TYPE]]] = None,\n        file: Optional[UPLOADABLE_TYPE] = None,\n        tts: bool = False,\n    ) -&gt; \"models.Message\":\n        message_payload = models.process_message_payload(\n            content=content,\n            embeds=embeds or embed,\n            components=components,\n            allowed_mentions=allowed_mentions,\n            attachments=attachments,\n            tts=tts,\n        )\n\n        if file:\n            if files:\n                files = [file, *files]\n            else:\n                files = [file]\n\n        message_data = await self._client.http.edit_interaction_message(\n            payload=message_payload,\n            application_id=self._client.app.id,\n            token=self._token,\n            message_id=to_snowflake(message),\n            files=files,\n        )\n        if message_data:\n            return self._client.cache.place_message_data(message_data)\n\n    @property\n    def target(self) -&gt; \"Absent[Member | User | Message]\":\n\"\"\"For context menus, this will be the object of which was clicked on.\"\"\"\n        thing = MISSING\n\n        match self._context_type:\n            # Only searches caches based on what kind of context menu this is\n\n            case CommandTypes.USER:\n                # This can only be in the member or user cache\n                caches = (\n                    (self._client.cache.get_member, (self.guild_id, self.target_id)),\n                    (self._client.cache.get_user, (self.target_id,)),\n                )\n            case CommandTypes.MESSAGE:\n                # This can only be in the message cache\n                caches = ((self._client.cache.get_message, (self.channel.id, self.target_id)),)\n            case _:\n                # Most likely a new context type, check all rational caches for the target_id\n                self.logger.warning(f\"New Context Type Detected. Please Report: {self._context_type}\")\n                caches = (\n                    (self._client.cache.get_message, (self.channel.id, self.target_id)),\n                    (self._client.cache.get_member, (self.guild_id, self.target_id)),\n                    (self._client.cache.get_user, (self.target_id,)),\n                    (self._client.cache.get_channel, (self.target_id,)),\n                    (self._client.cache.get_role, (self.target_id,)),\n                    (self._client.cache.get_emoji, (self.target_id,)),  # unlikely, so check last\n                )\n\n        for cache, keys in caches:\n            thing = cache(*keys)\n            if thing is not None:\n                break\n        return thing\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.InteractionContext.defer","title":"<code>defer(ephemeral=False)</code>  <code>async</code>","text":"<p>Defers the response, showing a loading state.</p> <p>Parameters:</p> Name Type Description Default <code>ephemeral</code> <code>bool</code> <p>Should the response be ephemeral</p> <code>False</code> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>async def defer(self, ephemeral: bool = False) -&gt; None:\n\"\"\"\n    Defers the response, showing a loading state.\n\n    Args:\n        ephemeral: Should the response be ephemeral\n\n    \"\"\"\n    if self.deferred or self.responded:\n        raise AlreadyDeferred(\"You have already responded to this interaction!\")\n\n    payload = {\"type\": CallbackTypes.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE}\n    if ephemeral:\n        payload[\"data\"] = {\"flags\": MessageFlags.EPHEMERAL}\n\n    await self._client.http.post_initial_response(payload, self.interaction_id, self._token)\n    self.ephemeral = ephemeral\n    self.deferred = True\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.InteractionContext.send","title":"<code>send(content=None, *, embeds=None, embed=None, components=None, stickers=None, allowed_mentions=None, reply_to=None, files=None, file=None, tts=False, suppress_embeds=False, flags=None, ephemeral=False)</code>  <code>async</code>","text":"<p>Send a message.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>Optional[str]</code> <p>Message text content.</p> <code>None</code> <code>embeds</code> <code>Optional[Union[Iterable[Union[Embed, dict]], Union[Embed, dict]]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>embed</code> <code>Optional[Union[Embed, dict]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>components</code> <code>Optional[Union[Iterable[Iterable[Union[BaseComponent, dict]]], Iterable[Union[BaseComponent, dict]], BaseComponent, dict]]</code> <p>The components to include with the message.</p> <code>None</code> <code>stickers</code> <code>Optional[Union[Iterable[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type]]</code> <p>IDs of up to 3 stickers in the server to send in the message.</p> <code>None</code> <code>allowed_mentions</code> <code>Optional[Union[AllowedMentions, dict]]</code> <p>Allowed mentions for the message.</p> <code>None</code> <code>reply_to</code> <code>Optional[Union[MessageReference, Message, dict, Snowflake_Type]]</code> <p>Message to reference, must be from the same channel.</p> <code>None</code> <code>files</code> <code>Optional[Union[UPLOADABLE_TYPE, Iterable[UPLOADABLE_TYPE]]]</code> <p>Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.</p> <code>None</code> <code>file</code> <code>Optional[UPLOADABLE_TYPE]</code> <p>Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.</p> <code>None</code> <code>tts</code> <code>bool</code> <p>Should this message use Text To Speech.</p> <code>False</code> <code>suppress_embeds</code> <code>bool</code> <p>Should embeds be suppressed on this send</p> <code>False</code> <code>flags</code> <code>Optional[Union[int, MessageFlags]]</code> <p>Message flags to apply.</p> <code>None</code> <code>ephemeral</code> <code>bool</code> <p>Should this message be sent as ephemeral (hidden)</p> <code>False</code> <p>Returns:</p> Type Description <code>Message</code> <p>New message object that was sent.</p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>async def send(\n    self,\n    content: Optional[str] = None,\n    *,\n    embeds: Optional[Union[Iterable[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n    embed: Optional[Union[\"Embed\", dict]] = None,\n    components: Optional[\n        Union[\n            Iterable[Iterable[Union[\"BaseComponent\", dict]]],\n            Iterable[Union[\"BaseComponent\", dict]],\n            \"BaseComponent\",\n            dict,\n        ]\n    ] = None,\n    stickers: Optional[Union[Iterable[Union[\"Sticker\", \"Snowflake_Type\"]], \"Sticker\", \"Snowflake_Type\"]] = None,\n    allowed_mentions: Optional[Union[\"AllowedMentions\", dict]] = None,\n    reply_to: Optional[Union[\"MessageReference\", \"Message\", dict, \"Snowflake_Type\"]] = None,\n    files: Optional[Union[UPLOADABLE_TYPE, Iterable[UPLOADABLE_TYPE]]] = None,\n    file: Optional[UPLOADABLE_TYPE] = None,\n    tts: bool = False,\n    suppress_embeds: bool = False,\n    flags: Optional[Union[int, \"MessageFlags\"]] = None,\n    ephemeral: bool = False,\n) -&gt; \"Message\":\n\"\"\"\n    Send a message.\n\n    Args:\n        content: Message text content.\n        embeds: Embedded rich content (up to 6000 characters).\n        embed: Embedded rich content (up to 6000 characters).\n        components: The components to include with the message.\n        stickers: IDs of up to 3 stickers in the server to send in the message.\n        allowed_mentions: Allowed mentions for the message.\n        reply_to: Message to reference, must be from the same channel.\n        files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n        file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n        tts: Should this message use Text To Speech.\n        suppress_embeds: Should embeds be suppressed on this send\n        flags: Message flags to apply.\n        ephemeral bool: Should this message be sent as ephemeral (hidden)\n\n    Returns:\n        New message object that was sent.\n\n    \"\"\"\n    if ephemeral:\n        flags = MessageFlags.EPHEMERAL\n        self.ephemeral = True\n\n    if suppress_embeds:\n        if isinstance(flags, int):\n            flags = MessageFlags(flags)\n        flags = flags | MessageFlags.SUPPRESS_EMBEDS\n\n    return await super().send(\n        content,\n        embeds=embeds,\n        embed=embed,\n        components=components,\n        stickers=stickers,\n        allowed_mentions=allowed_mentions,\n        reply_to=reply_to,\n        files=files,\n        file=file,\n        tts=tts,\n        flags=flags,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.InteractionContext.delete","title":"<code>delete(message)</code>  <code>async</code>","text":"<p>Delete a message sent in response to this interaction.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Snowflake_Type</code> <p>The message to delete</p> required Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>async def delete(self, message: \"Snowflake_Type\") -&gt; None:\n\"\"\"\n    Delete a message sent in response to this interaction.\n\n    Args:\n        message: The message to delete\n\n    \"\"\"\n    await self._client.http.delete_interaction_message(self._client.app.id, self._token, to_snowflake(message))\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.InteractionContext.target","title":"<code>target: Absent[Member | User | Message]</code>  <code>property</code>","text":"<p>For context menus, this will be the object of which was clicked on.</p>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.ComponentContext","title":"<code>ComponentContext</code>","text":"<p>         Bases: <code>InteractionContext</code></p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ComponentContext(InteractionContext):\n    custom_id: str = attrs.field(\n        repr=False, default=\"\", metadata=docs(\"The ID given to the component that has been pressed\")\n    )\n    component_type: int = attrs.field(\n        repr=False, default=0, metadata=docs(\"The type of component that has been pressed\")\n    )\n\n    values: List = attrs.field(repr=False, factory=list, metadata=docs(\"The values set\"))\n\n    defer_edit_origin: bool = attrs.field(\n        repr=False, default=False, metadata=docs(\"Are we editing the message the component is on\")\n    )\n\n    @classmethod\n    def from_dict(cls, data: Dict, client: \"Client\") -&gt; \"ComponentContext\":\n\"\"\"Create a context object from a dictionary.\"\"\"\n        new_cls = super().from_dict(data, client)\n        new_cls.token = data[\"token\"]\n        new_cls.interaction_id = data[\"id\"]\n        new_cls.invoke_target = data[\"data\"][\"custom_id\"]\n        new_cls.custom_id = data[\"data\"][\"custom_id\"]\n        new_cls.component_type = data[\"data\"][\"component_type\"]\n        new_cls.message = client.cache.place_message_data(data[\"message\"])\n        new_cls.values = data[\"data\"].get(\"values\", [])\n\n        return new_cls\n\n    async def defer(self, ephemeral: bool = False, edit_origin: bool = False) -&gt; None:\n\"\"\"\n        Defers the response, showing a loading state.\n\n        Args:\n            ephemeral: Should the response be ephemeral\n            edit_origin: Whether we intend to edit the original message\n\n        \"\"\"\n        if self.deferred or self.responded:\n            raise AlreadyDeferred(\"You have already responded to this interaction!\")\n\n        payload = {\n            \"type\": CallbackTypes.DEFERRED_UPDATE_MESSAGE\n            if edit_origin\n            else CallbackTypes.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE\n        }\n\n        if ephemeral:\n            if edit_origin:\n                raise ValueError(\"`edit_origin` and `ephemeral` are mutually exclusive\")\n            payload[\"data\"] = {\"flags\": MessageFlags.EPHEMERAL}\n\n        await self._client.http.post_initial_response(payload, self.interaction_id, self._token)\n        self.deferred = True\n        self.ephemeral = ephemeral\n        self.defer_edit_origin = edit_origin\n\n    async def edit_origin(\n        self,\n        *,\n        content: str = None,\n        embeds: Optional[Union[Iterable[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n        embed: Optional[Union[\"Embed\", dict]] = None,\n        components: Optional[\n            Union[\n                Iterable[Iterable[Union[\"BaseComponent\", dict]]],\n                Iterable[Union[\"BaseComponent\", dict]],\n                \"BaseComponent\",\n                dict,\n            ]\n        ] = None,\n        allowed_mentions: Optional[Union[\"AllowedMentions\", dict]] = None,\n        files: Optional[Union[UPLOADABLE_TYPE, Iterable[UPLOADABLE_TYPE]]] = None,\n        file: Optional[UPLOADABLE_TYPE] = None,\n        tts: bool = False,\n    ) -&gt; \"Message\":\n\"\"\"\n        Edits the original message of the component.\n\n        Args:\n            content: Message text content.\n            embeds: Embedded rich content (up to 6000 characters).\n            embed: Embedded rich content (up to 6000 characters).\n            components: The components to include with the message.\n            allowed_mentions: Allowed mentions for the message.\n            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n            tts: Should this message use Text To Speech.\n\n        Returns:\n            The message after it was edited.\n\n        \"\"\"\n        if not self.responded and not self.deferred and (files or file):\n            # Discord doesn't allow files at initial response, so we defer then edit.\n            await self.defer(edit_origin=True)\n\n        message_payload = message.process_message_payload(\n            content=content,\n            embeds=embeds or embed,\n            components=components,\n            allowed_mentions=allowed_mentions,\n            tts=tts,\n        )\n\n        message_data = None\n        if self.deferred:\n            if not self.defer_edit_origin:\n                self.logger.warning(\n                    \"If you want to edit the original message, and need to defer, you must set the `edit_origin` kwarg to True!\"\n                )\n\n            message_data = await self._client.http.edit_interaction_message(\n                message_payload, self._client.app.id, self._token\n            )\n            self.deferred = False\n            self.defer_edit_origin = False\n        else:\n            payload = {\"type\": CallbackTypes.UPDATE_MESSAGE, \"data\": message_payload}\n            await self._client.http.post_initial_response(\n                payload, self.interaction_id, self._token, files=files or file\n            )\n            message_data = await self._client.http.get_interaction_message(self._client.app.id, self._token)\n\n        if message_data:\n            self.message = self._client.cache.place_message_data(message_data)\n            return self.message\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.ComponentContext.from_dict","title":"<code>from_dict(data, client)</code>  <code>classmethod</code>","text":"<p>Create a context object from a dictionary.</p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict, client: \"Client\") -&gt; \"ComponentContext\":\n\"\"\"Create a context object from a dictionary.\"\"\"\n    new_cls = super().from_dict(data, client)\n    new_cls.token = data[\"token\"]\n    new_cls.interaction_id = data[\"id\"]\n    new_cls.invoke_target = data[\"data\"][\"custom_id\"]\n    new_cls.custom_id = data[\"data\"][\"custom_id\"]\n    new_cls.component_type = data[\"data\"][\"component_type\"]\n    new_cls.message = client.cache.place_message_data(data[\"message\"])\n    new_cls.values = data[\"data\"].get(\"values\", [])\n\n    return new_cls\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.ComponentContext.defer","title":"<code>defer(ephemeral=False, edit_origin=False)</code>  <code>async</code>","text":"<p>Defers the response, showing a loading state.</p> <p>Parameters:</p> Name Type Description Default <code>ephemeral</code> <code>bool</code> <p>Should the response be ephemeral</p> <code>False</code> <code>edit_origin</code> <code>bool</code> <p>Whether we intend to edit the original message</p> <code>False</code> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>async def defer(self, ephemeral: bool = False, edit_origin: bool = False) -&gt; None:\n\"\"\"\n    Defers the response, showing a loading state.\n\n    Args:\n        ephemeral: Should the response be ephemeral\n        edit_origin: Whether we intend to edit the original message\n\n    \"\"\"\n    if self.deferred or self.responded:\n        raise AlreadyDeferred(\"You have already responded to this interaction!\")\n\n    payload = {\n        \"type\": CallbackTypes.DEFERRED_UPDATE_MESSAGE\n        if edit_origin\n        else CallbackTypes.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE\n    }\n\n    if ephemeral:\n        if edit_origin:\n            raise ValueError(\"`edit_origin` and `ephemeral` are mutually exclusive\")\n        payload[\"data\"] = {\"flags\": MessageFlags.EPHEMERAL}\n\n    await self._client.http.post_initial_response(payload, self.interaction_id, self._token)\n    self.deferred = True\n    self.ephemeral = ephemeral\n    self.defer_edit_origin = edit_origin\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.ComponentContext.edit_origin","title":"<code>edit_origin(*, content=None, embeds=None, embed=None, components=None, allowed_mentions=None, files=None, file=None, tts=False)</code>  <code>async</code>","text":"<p>Edits the original message of the component.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Message text content.</p> <code>None</code> <code>embeds</code> <code>Optional[Union[Iterable[Union[Embed, dict]], Union[Embed, dict]]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>embed</code> <code>Optional[Union[Embed, dict]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>components</code> <code>Optional[Union[Iterable[Iterable[Union[BaseComponent, dict]]], Iterable[Union[BaseComponent, dict]], BaseComponent, dict]]</code> <p>The components to include with the message.</p> <code>None</code> <code>allowed_mentions</code> <code>Optional[Union[AllowedMentions, dict]]</code> <p>Allowed mentions for the message.</p> <code>None</code> <code>files</code> <code>Optional[Union[UPLOADABLE_TYPE, Iterable[UPLOADABLE_TYPE]]]</code> <p>Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.</p> <code>None</code> <code>file</code> <code>Optional[UPLOADABLE_TYPE]</code> <p>Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.</p> <code>None</code> <code>tts</code> <code>bool</code> <p>Should this message use Text To Speech.</p> <code>False</code> <p>Returns:</p> Type Description <code>Message</code> <p>The message after it was edited.</p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>async def edit_origin(\n    self,\n    *,\n    content: str = None,\n    embeds: Optional[Union[Iterable[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n    embed: Optional[Union[\"Embed\", dict]] = None,\n    components: Optional[\n        Union[\n            Iterable[Iterable[Union[\"BaseComponent\", dict]]],\n            Iterable[Union[\"BaseComponent\", dict]],\n            \"BaseComponent\",\n            dict,\n        ]\n    ] = None,\n    allowed_mentions: Optional[Union[\"AllowedMentions\", dict]] = None,\n    files: Optional[Union[UPLOADABLE_TYPE, Iterable[UPLOADABLE_TYPE]]] = None,\n    file: Optional[UPLOADABLE_TYPE] = None,\n    tts: bool = False,\n) -&gt; \"Message\":\n\"\"\"\n    Edits the original message of the component.\n\n    Args:\n        content: Message text content.\n        embeds: Embedded rich content (up to 6000 characters).\n        embed: Embedded rich content (up to 6000 characters).\n        components: The components to include with the message.\n        allowed_mentions: Allowed mentions for the message.\n        files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n        file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n        tts: Should this message use Text To Speech.\n\n    Returns:\n        The message after it was edited.\n\n    \"\"\"\n    if not self.responded and not self.deferred and (files or file):\n        # Discord doesn't allow files at initial response, so we defer then edit.\n        await self.defer(edit_origin=True)\n\n    message_payload = message.process_message_payload(\n        content=content,\n        embeds=embeds or embed,\n        components=components,\n        allowed_mentions=allowed_mentions,\n        tts=tts,\n    )\n\n    message_data = None\n    if self.deferred:\n        if not self.defer_edit_origin:\n            self.logger.warning(\n                \"If you want to edit the original message, and need to defer, you must set the `edit_origin` kwarg to True!\"\n            )\n\n        message_data = await self._client.http.edit_interaction_message(\n            message_payload, self._client.app.id, self._token\n        )\n        self.deferred = False\n        self.defer_edit_origin = False\n    else:\n        payload = {\"type\": CallbackTypes.UPDATE_MESSAGE, \"data\": message_payload}\n        await self._client.http.post_initial_response(\n            payload, self.interaction_id, self._token, files=files or file\n        )\n        message_data = await self._client.http.get_interaction_message(self._client.app.id, self._token)\n\n    if message_data:\n        self.message = self._client.cache.place_message_data(message_data)\n        return self.message\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.AutocompleteContext","title":"<code>AutocompleteContext</code>","text":"<p>         Bases: <code>_BaseInteractionContext</code></p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass AutocompleteContext(_BaseInteractionContext):\n    focussed_option: str = attrs.field(\n        repr=False, default=MISSING, metadata=docs(\"The option the user is currently filling in\")\n    )\n\n    @classmethod\n    def from_dict(cls, data: Dict, client: \"Client\") -&gt; \"ComponentContext\":\n\"\"\"Create a context object from a dictionary.\"\"\"\n        new_cls = super().from_dict(data, client)\n\n        return new_cls\n\n    @property\n    def input_text(self) -&gt; str:\n\"\"\"The text the user has entered so far.\"\"\"\n        return self.kwargs.get(self.focussed_option, \"\")\n\n    async def send(self, choices: Iterable[Union[str, int, float, Dict[str, Union[str, int, float]]]]) -&gt; None:\n\"\"\"\n        Send your autocomplete choices to discord. Choices must be either a list of strings, or a dictionary following the following format:\n\n        ```json\n            {\n              \"name\": str,\n              \"value\": str\n            }\n        ```\n        Where name is the text visible in Discord, and value is the data sent back to your client when that choice is\n        chosen.\n\n        Args:\n            choices: 25 choices the user can pick\n\n        \"\"\"\n        processed_choices = []\n        for choice in choices:\n            if isinstance(choice, (int, float)):\n                processed_choices.append({\"name\": str(choice), \"value\": choice})\n            elif isinstance(choice, dict):\n                processed_choices.append(choice)\n            else:\n                choice = str(choice)\n                processed_choices.append({\"name\": choice, \"value\": choice.replace(\" \", \"_\")})\n\n        payload = {\"type\": CallbackTypes.AUTOCOMPLETE_RESULT, \"data\": {\"choices\": processed_choices}}\n        await self._client.http.post_initial_response(payload, self.interaction_id, self._token)\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.AutocompleteContext.from_dict","title":"<code>from_dict(data, client)</code>  <code>classmethod</code>","text":"<p>Create a context object from a dictionary.</p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict, client: \"Client\") -&gt; \"ComponentContext\":\n\"\"\"Create a context object from a dictionary.\"\"\"\n    new_cls = super().from_dict(data, client)\n\n    return new_cls\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.AutocompleteContext.input_text","title":"<code>input_text: str</code>  <code>property</code>","text":"<p>The text the user has entered so far.</p>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.AutocompleteContext.send","title":"<code>send(choices)</code>  <code>async</code>","text":"<p>Send your autocomplete choices to discord. Choices must be either a list of strings, or a dictionary following the following format:</p> <p><pre><code>    {\n\"name\": str,\n\"value\": str\n}\n</code></pre> Where name is the text visible in Discord, and value is the data sent back to your client when that choice is chosen.</p> <p>Parameters:</p> Name Type Description Default <code>choices</code> <code>Iterable[Union[str, int, float, Dict[str, Union[str, int, float]]]]</code> <p>25 choices the user can pick</p> required Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>async def send(self, choices: Iterable[Union[str, int, float, Dict[str, Union[str, int, float]]]]) -&gt; None:\n\"\"\"\n    Send your autocomplete choices to discord. Choices must be either a list of strings, or a dictionary following the following format:\n\n    ```json\n        {\n          \"name\": str,\n          \"value\": str\n        }\n    ```\n    Where name is the text visible in Discord, and value is the data sent back to your client when that choice is\n    chosen.\n\n    Args:\n        choices: 25 choices the user can pick\n\n    \"\"\"\n    processed_choices = []\n    for choice in choices:\n        if isinstance(choice, (int, float)):\n            processed_choices.append({\"name\": str(choice), \"value\": choice})\n        elif isinstance(choice, dict):\n            processed_choices.append(choice)\n        else:\n            choice = str(choice)\n            processed_choices.append({\"name\": choice, \"value\": choice.replace(\" \", \"_\")})\n\n    payload = {\"type\": CallbackTypes.AUTOCOMPLETE_RESULT, \"data\": {\"choices\": processed_choices}}\n    await self._client.http.post_initial_response(payload, self.interaction_id, self._token)\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.ModalContext","title":"<code>ModalContext</code>","text":"<p>         Bases: <code>InteractionContext</code></p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass ModalContext(InteractionContext):\n    custom_id: str = attrs.field(repr=False, default=\"\")\n\n    @classmethod\n    def from_dict(cls, data: Dict, client: \"Client\") -&gt; \"ModalContext\":\n        new_cls = super().from_dict(data, client)\n\n        new_cls.kwargs = {\n            comp[\"components\"][0][\"custom_id\"]: comp[\"components\"][0][\"value\"] for comp in data[\"data\"][\"components\"]\n        }\n        new_cls.custom_id = data[\"data\"][\"custom_id\"]\n        return new_cls\n\n    @property\n    def responses(self) -&gt; dict[str, str]:\n\"\"\"\n        Get the responses to this modal.\n\n        Returns:\n            A dictionary of responses. Keys are the custom_ids of your components.\n        \"\"\"\n        return self.kwargs\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.ModalContext.responses","title":"<code>responses: dict[str, str]</code>  <code>property</code>","text":"<p>Get the responses to this modal.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary of responses. Keys are the custom_ids of your components.</p>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.PrefixedContext","title":"<code>PrefixedContext</code>","text":"<p>         Bases: <code>Context</code>, <code>SendMixin</code></p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass PrefixedContext(Context, SendMixin):\n    prefix: str = attrs.field(repr=False, default=MISSING, metadata=docs(\"The prefix used to invoke this command\"))\n\n    @classmethod\n    def from_message(cls, client: \"Client\", message: \"Message\") -&gt; \"PrefixedContext\":\n        new_cls = cls(\n            client=client,\n            message=message,\n            author=message.author,\n            channel=message.channel,\n            guild_id=message._guild_id,\n        )\n        return new_cls\n\n    @property\n    def content_parameters(self) -&gt; str:\n        return self.message.content.removeprefix(f\"{self.prefix}{self.invoke_target}\").strip()\n\n    async def reply(\n        self,\n        content: Optional[str] = None,\n        embeds: Optional[Union[Iterable[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n        embed: Optional[Union[\"Embed\", dict]] = None,\n        **kwargs,\n    ) -&gt; \"Message\":\n\"\"\"Reply to this message, takes all the same attributes as `send`.\"\"\"\n        return await self.send(content=content, reply_to=self.message, embeds=embeds or embed, **kwargs)\n\n    async def _send_http_request(\n        self, message_payload: Union[dict, \"FormData\"], files: Iterable[\"UPLOADABLE_TYPE\"] | None = None\n    ) -&gt; dict:\n        return await self._client.http.create_message(message_payload, self.channel.id, files=files)\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.PrefixedContext.reply","title":"<code>reply(content=None, embeds=None, embed=None, **kwargs)</code>  <code>async</code>","text":"<p>Reply to this message, takes all the same attributes as <code>send</code>.</p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>async def reply(\n    self,\n    content: Optional[str] = None,\n    embeds: Optional[Union[Iterable[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n    embed: Optional[Union[\"Embed\", dict]] = None,\n    **kwargs,\n) -&gt; \"Message\":\n\"\"\"Reply to this message, takes all the same attributes as `send`.\"\"\"\n    return await self.send(content=content, reply_to=self.message, embeds=embeds or embed, **kwargs)\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.HybridContext","title":"<code>HybridContext</code>","text":"<p>         Bases: <code>Context</code></p> <p>Represents the context for hybrid commands, a slash command that can also be used as a prefixed command.</p> <p>This attempts to create a compatibility layer to allow contexts for an interaction or a message to be used seamlessly.</p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass HybridContext(Context):\n\"\"\"\n    Represents the context for hybrid commands, a slash command that can also be used as a prefixed command.\n\n    This attempts to create a compatibility layer to allow contexts for an interaction or a message to be used seamlessly.\n    \"\"\"\n\n    deferred: bool = attrs.field(repr=False, default=False, metadata=docs(\"Is this context deferred?\"))\n    responded: bool = attrs.field(repr=False, default=False, metadata=docs(\"Have we responded to this?\"))\n    app_permissions: Permissions = attrs.field(\n        repr=False, default=0, converter=Permissions, metadata=docs(\"The permissions this context has\")\n    )\n\n    _interaction_context: Optional[InteractionContext] = attrs.field(repr=False, default=None)\n    _prefixed_context: Optional[PrefixedContext] = attrs.field(repr=False, default=None)\n\n    @classmethod\n    def from_interaction_context(cls, context: InteractionContext) -&gt; \"HybridContext\":\n        return cls(\n            client=context._client,  # type: ignore\n            interaction_context=context,  # type: ignore\n            invoke_target=context.invoke_target,\n            command=context.command,\n            args=context.args,\n            kwargs=context.kwargs,\n            author=context.author,\n            channel=context.channel,\n            guild_id=context.guild_id,\n            deferred=context.deferred,\n            responded=context.responded,\n            app_permissions=context.app_permissions,\n        )\n\n    @classmethod\n    def from_prefixed_context(cls, context: PrefixedContext) -&gt; \"HybridContext\":\n        # this is a \"best guess\" on what the permissions are\n        # this may or may not be totally accurate\n        if hasattr(context.channel, \"permissions_for\"):\n            app_permissions = context.channel.permissions_for(context.guild.me)  # type: ignore\n        elif context.channel.type in {10, 11, 12}:  # it's a thread\n            app_permissions = context.channel.parent_channel.permissions_for(context.guild.me)  # type: ignore\n        else:\n            # this is what happens with interaction contexts in dms\n            app_permissions = 0\n\n        return cls(\n            client=context._client,  # type: ignore\n            prefixed_context=context,  # type: ignore\n            invoke_target=context.invoke_target,\n            command=context.command,\n            args=context.args,\n            kwargs=context.kwargs,  # this is usually empty\n            author=context.author,\n            channel=context.channel,\n            guild_id=context.guild_id,\n            message=context.message,\n            app_permissions=app_permissions,\n        )\n\n    @property\n    def inner_context(self) -&gt; InteractionContext | PrefixedContext:\n\"\"\"\n        Returns the context powering the current hybrid context.\n\n        This can be used for scope-specific actions, like sending modals in an interaction.\n        \"\"\"\n        return self._interaction_context or self._prefixed_context  # type: ignore\n\n    @property\n    def ephemeral(self) -&gt; bool:\n\"\"\"Returns if responses to this interaction are ephemeral, if this is an interaction. Otherwise, returns False.\"\"\"\n        return self._interaction_context.ephemeral if self._interaction_context else False\n\n    @property\n    def expires_at(self) -&gt; Optional[Timestamp]:\n\"\"\"The timestamp the context is expected to expire at, or None if the context never expires.\"\"\"\n        if not self._interaction_context:\n            return None\n\n        if self.responded:\n            return Timestamp.from_snowflake(self._interaction_context.interaction_id) + datetime.timedelta(minutes=15)\n        return Timestamp.from_snowflake(self._interaction_context.interaction_id) + datetime.timedelta(seconds=3)\n\n    @property\n    def expired(self) -&gt; bool:\n\"\"\"Has the context expired yet?\"\"\"\n        return Timestamp.utcnow() &gt;= self.expires_at if self.expires_at else False\n\n    @property\n    def invoked_name(self) -&gt; str:\n        return (\n            self.command.get_localised_name(self._interaction_context.locale)\n            if self._interaction_context\n            else self.invoke_target\n        )\n\n    async def defer(self, ephemeral: bool = False) -&gt; None:\n\"\"\"\n        Either defers the response (if used in an interaction) or triggers a typing indicator for 10 seconds (if used for messages).\n\n        Args:\n            ephemeral: Should the response be ephemeral? Only applies to responses for interactions.\n\n        \"\"\"\n        if self._interaction_context:\n            await self._interaction_context.defer(ephemeral=ephemeral)\n        else:\n            await self.channel.trigger_typing()\n\n        self.deferred = True\n\n    async def reply(\n        self,\n        content: Optional[str] = None,\n        embeds: Optional[Union[Iterable[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n        embed: Optional[Union[\"Embed\", dict]] = None,\n        **kwargs,\n    ) -&gt; \"Message\":\n\"\"\"\n        Reply to this message, takes all the same attributes as `send`.\n\n        For interactions, this functions the same as `send`.\n        \"\"\"\n        kwargs = locals()\n        kwargs.pop(\"self\")\n        extra_kwargs = kwargs.pop(\"kwargs\")\n        kwargs |= extra_kwargs\n\n        if self._interaction_context:\n            result = await self._interaction_context.send(**kwargs)\n        else:\n            kwargs.pop(\"ephemeral\", None)\n            result = await self._prefixed_context.reply(**kwargs)  # type: ignore\n\n        self.responded = True\n        return result\n\n    async def send(\n        self,\n        content: Optional[str] = None,\n        *,\n        embeds: Optional[Union[Iterable[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n        embed: Optional[Union[\"Embed\", dict]] = None,\n        components: Optional[\n            Union[\n                Iterable[Iterable[Union[\"BaseComponent\", dict]]],\n                Iterable[Union[\"BaseComponent\", dict]],\n                \"BaseComponent\",\n                dict,\n            ]\n        ] = None,\n        stickers: Optional[Union[Iterable[Union[\"Sticker\", \"Snowflake_Type\"]], \"Sticker\", \"Snowflake_Type\"]] = None,\n        allowed_mentions: Optional[Union[\"AllowedMentions\", dict]] = None,\n        reply_to: Optional[Union[\"MessageReference\", \"Message\", dict, \"Snowflake_Type\"]] = None,\n        file: Optional[Union[\"File\", \"IOBase\", \"Path\", str]] = None,\n        tts: bool = False,\n        flags: Optional[Union[int, \"MessageFlags\"]] = None,\n        ephemeral: bool = False,\n        **kwargs,\n    ) -&gt; \"Message\":\n\"\"\"\n        Send a message.\n\n        Args:\n            content: Message text content.\n            embeds: Embedded rich content (up to 6000 characters).\n            embed: Embedded rich content (up to 6000 characters).\n            components: The components to include with the message.\n            stickers: IDs of up to 3 stickers in the server to send in the message.\n            allowed_mentions: Allowed mentions for the message.\n            reply_to: Message to reference, must be from the same channel.\n            files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n            file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n            tts: Should this message use Text To Speech.\n            suppress_embeds: Should embeds be suppressed on this send\n            flags: Message flags to apply.\n            ephemeral: Should this message be sent as ephemeral (hidden) - only works with interactions.\n\n        Returns:\n            New message object that was sent.\n\n        \"\"\"\n        kwargs = locals()\n        kwargs.pop(\"self\")\n        extra_kwargs = kwargs.pop(\"kwargs\")\n        kwargs |= extra_kwargs\n\n        if self._interaction_context:\n            result = await self._interaction_context.send(**kwargs)\n        else:\n            kwargs.pop(\"ephemeral\", None)\n            result = await self._prefixed_context.send(**kwargs)  # type: ignore\n\n        self.responded = True\n        return result\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.HybridContext.inner_context","title":"<code>inner_context: InteractionContext | PrefixedContext</code>  <code>property</code>","text":"<p>Returns the context powering the current hybrid context.</p> <p>This can be used for scope-specific actions, like sending modals in an interaction.</p>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.HybridContext.ephemeral","title":"<code>ephemeral: bool</code>  <code>property</code>","text":"<p>Returns if responses to this interaction are ephemeral, if this is an interaction. Otherwise, returns False.</p>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.HybridContext.expires_at","title":"<code>expires_at: Optional[Timestamp]</code>  <code>property</code>","text":"<p>The timestamp the context is expected to expire at, or None if the context never expires.</p>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.HybridContext.expired","title":"<code>expired: bool</code>  <code>property</code>","text":"<p>Has the context expired yet?</p>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.HybridContext.defer","title":"<code>defer(ephemeral=False)</code>  <code>async</code>","text":"<p>Either defers the response (if used in an interaction) or triggers a typing indicator for 10 seconds (if used for messages).</p> <p>Parameters:</p> Name Type Description Default <code>ephemeral</code> <code>bool</code> <p>Should the response be ephemeral? Only applies to responses for interactions.</p> <code>False</code> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>async def defer(self, ephemeral: bool = False) -&gt; None:\n\"\"\"\n    Either defers the response (if used in an interaction) or triggers a typing indicator for 10 seconds (if used for messages).\n\n    Args:\n        ephemeral: Should the response be ephemeral? Only applies to responses for interactions.\n\n    \"\"\"\n    if self._interaction_context:\n        await self._interaction_context.defer(ephemeral=ephemeral)\n    else:\n        await self.channel.trigger_typing()\n\n    self.deferred = True\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.HybridContext.reply","title":"<code>reply(content=None, embeds=None, embed=None, **kwargs)</code>  <code>async</code>","text":"<p>Reply to this message, takes all the same attributes as <code>send</code>.</p> <p>For interactions, this functions the same as <code>send</code>.</p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>async def reply(\n    self,\n    content: Optional[str] = None,\n    embeds: Optional[Union[Iterable[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n    embed: Optional[Union[\"Embed\", dict]] = None,\n    **kwargs,\n) -&gt; \"Message\":\n\"\"\"\n    Reply to this message, takes all the same attributes as `send`.\n\n    For interactions, this functions the same as `send`.\n    \"\"\"\n    kwargs = locals()\n    kwargs.pop(\"self\")\n    extra_kwargs = kwargs.pop(\"kwargs\")\n    kwargs |= extra_kwargs\n\n    if self._interaction_context:\n        result = await self._interaction_context.send(**kwargs)\n    else:\n        kwargs.pop(\"ephemeral\", None)\n        result = await self._prefixed_context.reply(**kwargs)  # type: ignore\n\n    self.responded = True\n    return result\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.HybridContext.send","title":"<code>send(content=None, *, embeds=None, embed=None, components=None, stickers=None, allowed_mentions=None, reply_to=None, file=None, tts=False, flags=None, ephemeral=False, **kwargs)</code>  <code>async</code>","text":"<p>Send a message.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>Optional[str]</code> <p>Message text content.</p> <code>None</code> <code>embeds</code> <code>Optional[Union[Iterable[Union[Embed, dict]], Union[Embed, dict]]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>embed</code> <code>Optional[Union[Embed, dict]]</code> <p>Embedded rich content (up to 6000 characters).</p> <code>None</code> <code>components</code> <code>Optional[Union[Iterable[Iterable[Union[BaseComponent, dict]]], Iterable[Union[BaseComponent, dict]], BaseComponent, dict]]</code> <p>The components to include with the message.</p> <code>None</code> <code>stickers</code> <code>Optional[Union[Iterable[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type]]</code> <p>IDs of up to 3 stickers in the server to send in the message.</p> <code>None</code> <code>allowed_mentions</code> <code>Optional[Union[AllowedMentions, dict]]</code> <p>Allowed mentions for the message.</p> <code>None</code> <code>reply_to</code> <code>Optional[Union[MessageReference, Message, dict, Snowflake_Type]]</code> <p>Message to reference, must be from the same channel.</p> <code>None</code> <code>files</code> <p>Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.</p> required <code>file</code> <code>Optional[Union[File, IOBase, Path, str]]</code> <p>Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.</p> <code>None</code> <code>tts</code> <code>bool</code> <p>Should this message use Text To Speech.</p> <code>False</code> <code>suppress_embeds</code> <p>Should embeds be suppressed on this send</p> required <code>flags</code> <code>Optional[Union[int, MessageFlags]]</code> <p>Message flags to apply.</p> <code>None</code> <code>ephemeral</code> <code>bool</code> <p>Should this message be sent as ephemeral (hidden) - only works with interactions.</p> <code>False</code> <p>Returns:</p> Type Description <code>Message</code> <p>New message object that was sent.</p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>async def send(\n    self,\n    content: Optional[str] = None,\n    *,\n    embeds: Optional[Union[Iterable[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n    embed: Optional[Union[\"Embed\", dict]] = None,\n    components: Optional[\n        Union[\n            Iterable[Iterable[Union[\"BaseComponent\", dict]]],\n            Iterable[Union[\"BaseComponent\", dict]],\n            \"BaseComponent\",\n            dict,\n        ]\n    ] = None,\n    stickers: Optional[Union[Iterable[Union[\"Sticker\", \"Snowflake_Type\"]], \"Sticker\", \"Snowflake_Type\"]] = None,\n    allowed_mentions: Optional[Union[\"AllowedMentions\", dict]] = None,\n    reply_to: Optional[Union[\"MessageReference\", \"Message\", dict, \"Snowflake_Type\"]] = None,\n    file: Optional[Union[\"File\", \"IOBase\", \"Path\", str]] = None,\n    tts: bool = False,\n    flags: Optional[Union[int, \"MessageFlags\"]] = None,\n    ephemeral: bool = False,\n    **kwargs,\n) -&gt; \"Message\":\n\"\"\"\n    Send a message.\n\n    Args:\n        content: Message text content.\n        embeds: Embedded rich content (up to 6000 characters).\n        embed: Embedded rich content (up to 6000 characters).\n        components: The components to include with the message.\n        stickers: IDs of up to 3 stickers in the server to send in the message.\n        allowed_mentions: Allowed mentions for the message.\n        reply_to: Message to reference, must be from the same channel.\n        files: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n        file: Files to send, the path, bytes or File() instance, defaults to None. You may have up to 10 files.\n        tts: Should this message use Text To Speech.\n        suppress_embeds: Should embeds be suppressed on this send\n        flags: Message flags to apply.\n        ephemeral: Should this message be sent as ephemeral (hidden) - only works with interactions.\n\n    Returns:\n        New message object that was sent.\n\n    \"\"\"\n    kwargs = locals()\n    kwargs.pop(\"self\")\n    extra_kwargs = kwargs.pop(\"kwargs\")\n    kwargs |= extra_kwargs\n\n    if self._interaction_context:\n        result = await self._interaction_context.send(**kwargs)\n    else:\n        kwargs.pop(\"ephemeral\", None)\n        result = await self._prefixed_context.send(**kwargs)  # type: ignore\n\n    self.responded = True\n    return result\n</code></pre>"},{"location":"API%20Reference/models/Naff/context/#naff.models.naff.context.SendableContext","title":"<code>SendableContext</code>","text":"<p>         Bases: <code>Protocol</code></p> <p>A protocol that supports any context that can send messages.</p> <p>Use it to type hint something that accepts both PrefixedContext and InteractionContext.</p> Source code in <code>naff\\models\\naff\\context.py</code> <pre><code>@runtime_checkable\nclass SendableContext(Protocol):\n\"\"\"\n    A protocol that supports any context that can send messages.\n\n    Use it to type hint something that accepts both PrefixedContext and InteractionContext.\n    \"\"\"\n\n    channel: \"TYPE_MESSAGEABLE_CHANNEL\"\n    invoke_target: str\n\n    author: Union[\"Member\", \"User\"]\n    guild_id: \"Snowflake_Type\"\n    message: \"Message\"\n\n    @property\n    def bot(self) -&gt; \"Client\":\n        ...\n\n    @property\n    def guild(self) -&gt; Optional[\"Guild\"]:\n        ...\n\n    async def send(\n        self,\n        content: Optional[str] = None,\n        *,\n        embeds: Optional[Union[Iterable[Union[\"Embed\", dict]], Union[\"Embed\", dict]]] = None,\n        embed: Optional[Union[\"Embed\", dict]] = None,\n        components: Optional[\n            Union[\n                Iterable[Iterable[Union[\"BaseComponent\", dict]]],\n                Iterable[Union[\"BaseComponent\", dict]],\n                \"BaseComponent\",\n                dict,\n            ]\n        ] = None,\n        stickers: Optional[Union[Iterable[Union[\"Sticker\", \"Snowflake_Type\"]], \"Sticker\", \"Snowflake_Type\"]] = None,\n        allowed_mentions: Optional[Union[\"AllowedMentions\", dict]] = None,\n        reply_to: Optional[Union[\"MessageReference\", \"Message\", dict, \"Snowflake_Type\"]] = None,\n        files: Optional[Union[\"UPLOADABLE_TYPE\", Iterable[\"UPLOADABLE_TYPE\"]]] = None,\n        file: Optional[\"UPLOADABLE_TYPE\"] = None,\n        tts: bool = False,\n        suppress_embeds: bool = False,\n        flags: Optional[Union[int, \"MessageFlags\"]] = None,\n        delete_after: Optional[float] = None,\n        **kwargs: Any,\n    ) -&gt; \"Message\":\n        ...\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/","title":"Converters","text":""},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.NoArgumentConverter","title":"<code>NoArgumentConverter</code>","text":"<p>         Bases: <code>Converter[T_co]</code></p> <p>An indicator class for special type of converters that only uses the Context.</p> <p>This is mainly needed for prefixed commands, as arguments will be \"eaten up\" by converters otherwise.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>class NoArgumentConverter(Converter[T_co]):\n\"\"\"\n    An indicator class for special type of converters that only uses the Context.\n\n    This is mainly needed for prefixed commands, as arguments will be \"eaten up\" by converters otherwise.\n    \"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.IDConverter","title":"<code>IDConverter</code>","text":"<p>         Bases: <code>Converter[T_co]</code></p> <p>The base converter for objects that have snowflake IDs.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>class IDConverter(Converter[T_co]):\n\"\"\"The base converter for objects that have snowflake IDs.\"\"\"\n\n    @staticmethod\n    def _get_id_match(argument: str) -&gt; Optional[re.Match[str]]:\n        return _ID_REGEX.match(argument)\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.SnowflakeConverter","title":"<code>SnowflakeConverter</code>","text":"<p>         Bases: <code>IDConverter[SnowflakeObject]</code></p> <p>Converts a string argument to a SnowflakeObject.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>class SnowflakeConverter(IDConverter[SnowflakeObject]):\n\"\"\"Converts a string argument to a SnowflakeObject.\"\"\"\n\n    async def convert(self, ctx: Context, argument: str) -&gt; SnowflakeObject:\n\"\"\"\n        Converts a given string to a SnowflakeObject.\n\n        The lookup strategy is as follows:\n\n        1. By raw snowflake ID.\n\n        2. By role or channel mention.\n\n        Args:\n            ctx: The context to use for the conversion.\n            argument: The argument to be converted.\n\n        Returns:\n            SnowflakeObject: The converted object.\n        \"\"\"\n        match = self._get_id_match(argument) or re.match(r\"&lt;(?:@(?:!|&amp;)?|#)([0-9]{15,})&gt;$\", argument)\n\n        if match is None:\n            raise BadArgument(argument)\n\n        return SnowflakeObject(int(match.group(1)))  # type: ignore\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.SnowflakeConverter.convert","title":"<code>convert(ctx, argument)</code>  <code>async</code>","text":"<p>Converts a given string to a SnowflakeObject.</p> <p>The lookup strategy is as follows:</p> <ol> <li> <p>By raw snowflake ID.</p> </li> <li> <p>By role or channel mention.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context to use for the conversion.</p> required <code>argument</code> <code>str</code> <p>The argument to be converted.</p> required <p>Returns:</p> Name Type Description <code>SnowflakeObject</code> <code>SnowflakeObject</code> <p>The converted object.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>async def convert(self, ctx: Context, argument: str) -&gt; SnowflakeObject:\n\"\"\"\n    Converts a given string to a SnowflakeObject.\n\n    The lookup strategy is as follows:\n\n    1. By raw snowflake ID.\n\n    2. By role or channel mention.\n\n    Args:\n        ctx: The context to use for the conversion.\n        argument: The argument to be converted.\n\n    Returns:\n        SnowflakeObject: The converted object.\n    \"\"\"\n    match = self._get_id_match(argument) or re.match(r\"&lt;(?:@(?:!|&amp;)?|#)([0-9]{15,})&gt;$\", argument)\n\n    if match is None:\n        raise BadArgument(argument)\n\n    return SnowflakeObject(int(match.group(1)))  # type: ignore\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.ChannelConverter","title":"<code>ChannelConverter</code>","text":"<p>         Bases: <code>IDConverter[T_co]</code></p> <p>The base converter for channel objects.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>class ChannelConverter(IDConverter[T_co]):\n\"\"\"The base converter for channel objects.\"\"\"\n\n    def _check(self, result: BaseChannel) -&gt; bool:\n        return True\n\n    async def convert(self, ctx: Context, argument: str) -&gt; T_co:\n\"\"\"\n        Converts a given string to a Channel object.\n\n        The lookup strategy is as follows:\n\n        1. By raw snowflake ID.\n\n        2. By channel mention.\n\n        3. By name - the bot will search in a guild if the context has it, otherwise it will search globally.\n\n        Args:\n            ctx: The context to use for the conversion.\n            argument: The argument to be converted.\n\n        Returns:\n            BaseChannel: The converted object.\n            The channel type will be of the type the converter represents.\n        \"\"\"\n        match = self._get_id_match(argument) or re.match(r\"&lt;#([0-9]{15,})&gt;$\", argument)\n        result = None\n\n        if match:\n            result = await ctx.bot.fetch_channel(int(match.group(1)))\n        elif ctx.guild:\n            result = next((c for c in ctx.guild.channels if c.name == argument), None)\n        else:\n            result = next((c for c in ctx.bot.cache.channel_cache.values() if c.name == argument), None)\n\n        if not result:\n            raise BadArgument(f'Channel \"{argument}\" not found.')\n\n        if self._check(result):\n            return result  # type: ignore\n\n        raise BadArgument(f'Channel \"{argument}\" not found.')\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.ChannelConverter.convert","title":"<code>convert(ctx, argument)</code>  <code>async</code>","text":"<p>Converts a given string to a Channel object.</p> <p>The lookup strategy is as follows:</p> <ol> <li> <p>By raw snowflake ID.</p> </li> <li> <p>By channel mention.</p> </li> <li> <p>By name - the bot will search in a guild if the context has it, otherwise it will search globally.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context to use for the conversion.</p> required <code>argument</code> <code>str</code> <p>The argument to be converted.</p> required <p>Returns:</p> Name Type Description <code>BaseChannel</code> <code>T_co</code> <p>The converted object.</p> <code>T_co</code> <p>The channel type will be of the type the converter represents.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>async def convert(self, ctx: Context, argument: str) -&gt; T_co:\n\"\"\"\n    Converts a given string to a Channel object.\n\n    The lookup strategy is as follows:\n\n    1. By raw snowflake ID.\n\n    2. By channel mention.\n\n    3. By name - the bot will search in a guild if the context has it, otherwise it will search globally.\n\n    Args:\n        ctx: The context to use for the conversion.\n        argument: The argument to be converted.\n\n    Returns:\n        BaseChannel: The converted object.\n        The channel type will be of the type the converter represents.\n    \"\"\"\n    match = self._get_id_match(argument) or re.match(r\"&lt;#([0-9]{15,})&gt;$\", argument)\n    result = None\n\n    if match:\n        result = await ctx.bot.fetch_channel(int(match.group(1)))\n    elif ctx.guild:\n        result = next((c for c in ctx.guild.channels if c.name == argument), None)\n    else:\n        result = next((c for c in ctx.bot.cache.channel_cache.values() if c.name == argument), None)\n\n    if not result:\n        raise BadArgument(f'Channel \"{argument}\" not found.')\n\n    if self._check(result):\n        return result  # type: ignore\n\n    raise BadArgument(f'Channel \"{argument}\" not found.')\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.UserConverter","title":"<code>UserConverter</code>","text":"<p>         Bases: <code>IDConverter[User]</code></p> <p>Converts a string argument to a User object.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>class UserConverter(IDConverter[User]):\n\"\"\"Converts a string argument to a User object.\"\"\"\n\n    async def convert(self, ctx: Context, argument: str) -&gt; User:\n\"\"\"\n        Converts a given string to a User object.\n\n        The lookup strategy is as follows:\n\n        1. By raw snowflake ID.\n\n        2. By mention.\n\n        3. By username + tag (ex User#1234).\n\n        4. By username.\n\n        Args:\n            ctx: The context to use for the conversion.\n            argument: The argument to be converted.\n\n        Returns:\n            User: The converted object.\n        \"\"\"\n        match = self._get_id_match(argument) or re.match(r\"&lt;@!?([0-9]{15,})&gt;$\", argument)\n        result = None\n\n        if match:\n            result = await ctx.bot.fetch_user(int(match.group(1)))\n        else:\n            if len(argument) &gt; 5 and argument[-5] == \"#\":\n                result = next((u for u in ctx.bot.cache.user_cache.values() if u.tag == argument), None)\n\n            if not result:\n                result = next((u for u in ctx.bot.cache.user_cache.values() if u.username == argument), None)\n\n        if not result:\n            raise BadArgument(f'User \"{argument}\" not found.')\n\n        return result\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.UserConverter.convert","title":"<code>convert(ctx, argument)</code>  <code>async</code>","text":"<p>Converts a given string to a User object.</p> <p>The lookup strategy is as follows:</p> <ol> <li> <p>By raw snowflake ID.</p> </li> <li> <p>By mention.</p> </li> <li> <p>By username + tag (ex User#1234).</p> </li> <li> <p>By username.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context to use for the conversion.</p> required <code>argument</code> <code>str</code> <p>The argument to be converted.</p> required <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>The converted object.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>async def convert(self, ctx: Context, argument: str) -&gt; User:\n\"\"\"\n    Converts a given string to a User object.\n\n    The lookup strategy is as follows:\n\n    1. By raw snowflake ID.\n\n    2. By mention.\n\n    3. By username + tag (ex User#1234).\n\n    4. By username.\n\n    Args:\n        ctx: The context to use for the conversion.\n        argument: The argument to be converted.\n\n    Returns:\n        User: The converted object.\n    \"\"\"\n    match = self._get_id_match(argument) or re.match(r\"&lt;@!?([0-9]{15,})&gt;$\", argument)\n    result = None\n\n    if match:\n        result = await ctx.bot.fetch_user(int(match.group(1)))\n    else:\n        if len(argument) &gt; 5 and argument[-5] == \"#\":\n            result = next((u for u in ctx.bot.cache.user_cache.values() if u.tag == argument), None)\n\n        if not result:\n            result = next((u for u in ctx.bot.cache.user_cache.values() if u.username == argument), None)\n\n    if not result:\n        raise BadArgument(f'User \"{argument}\" not found.')\n\n    return result\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.MemberConverter","title":"<code>MemberConverter</code>","text":"<p>         Bases: <code>IDConverter[Member]</code></p> <p>Converts a string argument to a Member object.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>class MemberConverter(IDConverter[Member]):\n\"\"\"Converts a string argument to a Member object.\"\"\"\n\n    def _get_member_from_list(self, members: list[Member], argument: str) -&gt; Optional[Member]:\n        # sourcery skip: assign-if-exp\n        result = None\n        if len(argument) &gt; 5 and argument[-5] == \"#\":\n            result = next((m for m in members if m.user.tag == argument), None)\n\n        if not result:\n            result = next((m for m in members if m.display_name == argument or m.user.username == argument), None)\n\n        return result\n\n    async def convert(self, ctx: Context, argument: str) -&gt; Member:\n\"\"\"\n        Converts a given string to a Member object. This will only work in guilds.\n\n        The lookup strategy is as follows:\n\n        1. By raw snowflake ID.\n\n        2. By mention.\n\n        3. By username + tag (ex User#1234).\n\n        4. By nickname.\n\n        5. By username.\n\n        Args:\n            ctx: The context to use for the conversion.\n            argument: The argument to be converted.\n\n        Returns:\n            Member: The converted object.\n        \"\"\"\n        if not ctx.guild:\n            raise BadArgument(\"This command cannot be used in private messages.\")\n\n        match = self._get_id_match(argument) or re.match(r\"&lt;@!?([0-9]{15,})&gt;$\", argument)\n        result = None\n\n        if match:\n            result = await ctx.guild.fetch_member(int(match.group(1)))\n        elif ctx.guild.chunked:\n            result = self._get_member_from_list(ctx.guild.members, argument)\n        else:\n            query = argument\n            if len(argument) &gt; 5 and argument[-5] == \"#\":\n                query, _, _ = argument.rpartition(\"#\")\n\n            members = await ctx.guild.search_members(query, limit=100)\n            result = self._get_member_from_list(members, argument)\n\n        if not result:\n            raise BadArgument(f'Member \"{argument}\" not found.')\n\n        return result\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.MemberConverter.convert","title":"<code>convert(ctx, argument)</code>  <code>async</code>","text":"<p>Converts a given string to a Member object. This will only work in guilds.</p> <p>The lookup strategy is as follows:</p> <ol> <li> <p>By raw snowflake ID.</p> </li> <li> <p>By mention.</p> </li> <li> <p>By username + tag (ex User#1234).</p> </li> <li> <p>By nickname.</p> </li> <li> <p>By username.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context to use for the conversion.</p> required <code>argument</code> <code>str</code> <p>The argument to be converted.</p> required <p>Returns:</p> Name Type Description <code>Member</code> <code>Member</code> <p>The converted object.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>async def convert(self, ctx: Context, argument: str) -&gt; Member:\n\"\"\"\n    Converts a given string to a Member object. This will only work in guilds.\n\n    The lookup strategy is as follows:\n\n    1. By raw snowflake ID.\n\n    2. By mention.\n\n    3. By username + tag (ex User#1234).\n\n    4. By nickname.\n\n    5. By username.\n\n    Args:\n        ctx: The context to use for the conversion.\n        argument: The argument to be converted.\n\n    Returns:\n        Member: The converted object.\n    \"\"\"\n    if not ctx.guild:\n        raise BadArgument(\"This command cannot be used in private messages.\")\n\n    match = self._get_id_match(argument) or re.match(r\"&lt;@!?([0-9]{15,})&gt;$\", argument)\n    result = None\n\n    if match:\n        result = await ctx.guild.fetch_member(int(match.group(1)))\n    elif ctx.guild.chunked:\n        result = self._get_member_from_list(ctx.guild.members, argument)\n    else:\n        query = argument\n        if len(argument) &gt; 5 and argument[-5] == \"#\":\n            query, _, _ = argument.rpartition(\"#\")\n\n        members = await ctx.guild.search_members(query, limit=100)\n        result = self._get_member_from_list(members, argument)\n\n    if not result:\n        raise BadArgument(f'Member \"{argument}\" not found.')\n\n    return result\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.MessageConverter","title":"<code>MessageConverter</code>","text":"<p>         Bases: <code>Converter[Message]</code></p> <p>Converts a string argument to a Message object.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>class MessageConverter(Converter[Message]):\n\"\"\"Converts a string argument to a Message object.\"\"\"\n\n    # either just the id or &lt;chan_id&gt;-&lt;mes_id&gt;, a format you can get by shift clicking \"copy id\"\n    _ID_REGEX = re.compile(r\"(?:(?P&lt;channel_id&gt;[0-9]{15,})-)?(?P&lt;message_id&gt;[0-9]{15,})\")\n    # of course, having a way to get it from a link is nice\n    _MESSAGE_LINK_REGEX = re.compile(\n        r\"https?://[\\S]*?discord(?:app)?\\.com/channels/(?P&lt;guild_id&gt;[0-9]{15,}|@me)/(?P&lt;channel_id&gt;[0-9]{15,})/(?P&lt;message_id&gt;[0-9]{15,})\\/?$\"\n    )\n\n    async def convert(self, ctx: Context, argument: str) -&gt; Message:\n\"\"\"\n        Converts a given string to a Message object.\n\n        The lookup strategy is as follows:\n\n        1. By raw snowflake ID. The message must be in the same channel as the context.\n\n        2. By message + channel ID in the format of \"{Channel ID}-{Message ID}\". This can be obtained by shift clicking \"Copy ID\" when Developer Mode is enabled.\n\n        3. By message link.\n\n        Args:\n            ctx: The context to use for the conversion.\n            argument: The argument to be converted.\n\n        Returns:\n            Message: The converted object.\n        \"\"\"\n        match = self._ID_REGEX.match(argument) or self._MESSAGE_LINK_REGEX.match(argument)\n        if not match:\n            raise BadArgument(f'Message \"{argument}\" not found.')\n\n        data = match.groupdict()\n\n        message_id = data[\"message_id\"]\n        channel_id = int(data[\"channel_id\"]) if data.get(\"channel_id\") else ctx.channel.id\n\n        # this guild checking is technically unnecessary, but we do it just in case\n        # it means a user cant just provide an invalid guild id and still get a message\n        guild_id = data[\"guild_id\"] if data.get(\"guild_id\") else ctx.guild_id\n        guild_id = int(guild_id) if guild_id != \"@me\" else None\n\n        try:\n            # this takes less possible requests than getting the guild and/or channel\n            mes = await ctx.bot.cache.fetch_message(channel_id, message_id)\n            if mes._guild_id != guild_id:\n                raise BadArgument(f'Message \"{argument}\" not found.')\n            return mes\n        except Forbidden as e:\n            raise BadArgument(f\"Cannot read messages for &lt;#{channel_id}&gt;.\") from e\n        except HTTPException as e:\n            raise BadArgument(f'Message \"{argument}\" not found.') from e\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.MessageConverter.convert","title":"<code>convert(ctx, argument)</code>  <code>async</code>","text":"<p>Converts a given string to a Message object.</p> <p>The lookup strategy is as follows:</p> <ol> <li> <p>By raw snowflake ID. The message must be in the same channel as the context.</p> </li> <li> <p>By message + channel ID in the format of \"{Channel ID}-{Message ID}\". This can be obtained by shift clicking \"Copy ID\" when Developer Mode is enabled.</p> </li> <li> <p>By message link.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context to use for the conversion.</p> required <code>argument</code> <code>str</code> <p>The argument to be converted.</p> required <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The converted object.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>async def convert(self, ctx: Context, argument: str) -&gt; Message:\n\"\"\"\n    Converts a given string to a Message object.\n\n    The lookup strategy is as follows:\n\n    1. By raw snowflake ID. The message must be in the same channel as the context.\n\n    2. By message + channel ID in the format of \"{Channel ID}-{Message ID}\". This can be obtained by shift clicking \"Copy ID\" when Developer Mode is enabled.\n\n    3. By message link.\n\n    Args:\n        ctx: The context to use for the conversion.\n        argument: The argument to be converted.\n\n    Returns:\n        Message: The converted object.\n    \"\"\"\n    match = self._ID_REGEX.match(argument) or self._MESSAGE_LINK_REGEX.match(argument)\n    if not match:\n        raise BadArgument(f'Message \"{argument}\" not found.')\n\n    data = match.groupdict()\n\n    message_id = data[\"message_id\"]\n    channel_id = int(data[\"channel_id\"]) if data.get(\"channel_id\") else ctx.channel.id\n\n    # this guild checking is technically unnecessary, but we do it just in case\n    # it means a user cant just provide an invalid guild id and still get a message\n    guild_id = data[\"guild_id\"] if data.get(\"guild_id\") else ctx.guild_id\n    guild_id = int(guild_id) if guild_id != \"@me\" else None\n\n    try:\n        # this takes less possible requests than getting the guild and/or channel\n        mes = await ctx.bot.cache.fetch_message(channel_id, message_id)\n        if mes._guild_id != guild_id:\n            raise BadArgument(f'Message \"{argument}\" not found.')\n        return mes\n    except Forbidden as e:\n        raise BadArgument(f\"Cannot read messages for &lt;#{channel_id}&gt;.\") from e\n    except HTTPException as e:\n        raise BadArgument(f'Message \"{argument}\" not found.') from e\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.GuildConverter","title":"<code>GuildConverter</code>","text":"<p>         Bases: <code>IDConverter[Guild]</code></p> <p>Converts a string argument to a Guild object.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>class GuildConverter(IDConverter[Guild]):\n\"\"\"Converts a string argument to a Guild object.\"\"\"\n\n    async def convert(self, ctx: Context, argument: str) -&gt; Guild:\n\"\"\"\n        Converts a given string to a Guild object.\n\n        The lookup strategy is as follows:\n\n        1. By raw snowflake ID.\n\n        2. By name.\n\n        Args:\n            ctx: The context to use for the conversion.\n            argument: The argument to be converted.\n\n        Returns:\n            Guild: The converted object.\n        \"\"\"\n        match = self._get_id_match(argument)\n        result = None\n\n        if match:\n            result = await ctx.bot.fetch_guild(int(match.group(1)))\n        else:\n            result = next((g for g in ctx.bot.guilds if g.name == argument), None)\n\n        if not result:\n            raise BadArgument(f'Guild \"{argument}\" not found.')\n\n        return result\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.GuildConverter.convert","title":"<code>convert(ctx, argument)</code>  <code>async</code>","text":"<p>Converts a given string to a Guild object.</p> <p>The lookup strategy is as follows:</p> <ol> <li> <p>By raw snowflake ID.</p> </li> <li> <p>By name.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context to use for the conversion.</p> required <code>argument</code> <code>str</code> <p>The argument to be converted.</p> required <p>Returns:</p> Name Type Description <code>Guild</code> <code>Guild</code> <p>The converted object.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>async def convert(self, ctx: Context, argument: str) -&gt; Guild:\n\"\"\"\n    Converts a given string to a Guild object.\n\n    The lookup strategy is as follows:\n\n    1. By raw snowflake ID.\n\n    2. By name.\n\n    Args:\n        ctx: The context to use for the conversion.\n        argument: The argument to be converted.\n\n    Returns:\n        Guild: The converted object.\n    \"\"\"\n    match = self._get_id_match(argument)\n    result = None\n\n    if match:\n        result = await ctx.bot.fetch_guild(int(match.group(1)))\n    else:\n        result = next((g for g in ctx.bot.guilds if g.name == argument), None)\n\n    if not result:\n        raise BadArgument(f'Guild \"{argument}\" not found.')\n\n    return result\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.RoleConverter","title":"<code>RoleConverter</code>","text":"<p>         Bases: <code>IDConverter[Role]</code></p> <p>Converts a string argument to a Role object.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>class RoleConverter(IDConverter[Role]):\n\"\"\"Converts a string argument to a Role object.\"\"\"\n\n    async def convert(self, ctx: Context, argument: str) -&gt; Role:\n\"\"\"\n        Converts a given string to a Role object.\n\n        The lookup strategy is as follows:\n\n        1. By raw snowflake ID.\n\n        2. By mention.\n\n        3. By name.\n\n        Args:\n            ctx: The context to use for the conversion.\n            argument: The argument to be converted.\n\n        Returns:\n            Role: The converted object.\n        \"\"\"\n        if not ctx.guild:\n            raise BadArgument(\"This command cannot be used in private messages.\")\n\n        match = self._get_id_match(argument) or re.match(r\"&lt;@&amp;([0-9]{15,})&gt;$\", argument)\n        result = None\n\n        if match:\n            result = await ctx.guild.fetch_role(int(match.group(1)))\n        else:\n            result = next((r for r in ctx.guild.roles if r.name == argument), None)\n\n        if not result:\n            raise BadArgument(f'Role \"{argument}\" not found.')\n\n        return result\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.RoleConverter.convert","title":"<code>convert(ctx, argument)</code>  <code>async</code>","text":"<p>Converts a given string to a Role object.</p> <p>The lookup strategy is as follows:</p> <ol> <li> <p>By raw snowflake ID.</p> </li> <li> <p>By mention.</p> </li> <li> <p>By name.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context to use for the conversion.</p> required <code>argument</code> <code>str</code> <p>The argument to be converted.</p> required <p>Returns:</p> Name Type Description <code>Role</code> <code>Role</code> <p>The converted object.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>async def convert(self, ctx: Context, argument: str) -&gt; Role:\n\"\"\"\n    Converts a given string to a Role object.\n\n    The lookup strategy is as follows:\n\n    1. By raw snowflake ID.\n\n    2. By mention.\n\n    3. By name.\n\n    Args:\n        ctx: The context to use for the conversion.\n        argument: The argument to be converted.\n\n    Returns:\n        Role: The converted object.\n    \"\"\"\n    if not ctx.guild:\n        raise BadArgument(\"This command cannot be used in private messages.\")\n\n    match = self._get_id_match(argument) or re.match(r\"&lt;@&amp;([0-9]{15,})&gt;$\", argument)\n    result = None\n\n    if match:\n        result = await ctx.guild.fetch_role(int(match.group(1)))\n    else:\n        result = next((r for r in ctx.guild.roles if r.name == argument), None)\n\n    if not result:\n        raise BadArgument(f'Role \"{argument}\" not found.')\n\n    return result\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.PartialEmojiConverter","title":"<code>PartialEmojiConverter</code>","text":"<p>         Bases: <code>IDConverter[PartialEmoji]</code></p> <p>Converts a string argument to a PartialEmoji object.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>class PartialEmojiConverter(IDConverter[PartialEmoji]):\n\"\"\"Converts a string argument to a PartialEmoji object.\"\"\"\n\n    async def convert(self, ctx: Context, argument: str) -&gt; PartialEmoji:\n\"\"\"\n        Converts a given string to a PartialEmoji object.\n\n        This converter only accepts emoji strings.\n\n        Args:\n            ctx: The context to use for the conversion.\n            argument: The argument to be converted.\n\n        Returns:\n            PartialEmoji: The converted object.\n        \"\"\"\n        if match := re.match(r\"&lt;a?:[a-zA-Z0-9\\_]{1,32}:([0-9]{15,})&gt;$\", argument):\n            emoji_animated = bool(match.group(1))\n            emoji_name = match.group(2)\n            emoji_id = int(match.group(3))\n\n            return PartialEmoji(id=emoji_id, name=emoji_name, animated=emoji_animated)  # type: ignore\n\n        raise BadArgument(f'Couldn\\'t convert \"{argument}\" to {PartialEmoji.__name__}.')\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.PartialEmojiConverter.convert","title":"<code>convert(ctx, argument)</code>  <code>async</code>","text":"<p>Converts a given string to a PartialEmoji object.</p> <p>This converter only accepts emoji strings.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context to use for the conversion.</p> required <code>argument</code> <code>str</code> <p>The argument to be converted.</p> required <p>Returns:</p> Name Type Description <code>PartialEmoji</code> <code>PartialEmoji</code> <p>The converted object.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>async def convert(self, ctx: Context, argument: str) -&gt; PartialEmoji:\n\"\"\"\n    Converts a given string to a PartialEmoji object.\n\n    This converter only accepts emoji strings.\n\n    Args:\n        ctx: The context to use for the conversion.\n        argument: The argument to be converted.\n\n    Returns:\n        PartialEmoji: The converted object.\n    \"\"\"\n    if match := re.match(r\"&lt;a?:[a-zA-Z0-9\\_]{1,32}:([0-9]{15,})&gt;$\", argument):\n        emoji_animated = bool(match.group(1))\n        emoji_name = match.group(2)\n        emoji_id = int(match.group(3))\n\n        return PartialEmoji(id=emoji_id, name=emoji_name, animated=emoji_animated)  # type: ignore\n\n    raise BadArgument(f'Couldn\\'t convert \"{argument}\" to {PartialEmoji.__name__}.')\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.CustomEmojiConverter","title":"<code>CustomEmojiConverter</code>","text":"<p>         Bases: <code>IDConverter[CustomEmoji]</code></p> <p>Converts a string argument to a CustomEmoji object.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>class CustomEmojiConverter(IDConverter[CustomEmoji]):\n\"\"\"Converts a string argument to a CustomEmoji object.\"\"\"\n\n    async def convert(self, ctx: Context, argument: str) -&gt; CustomEmoji:\n\"\"\"\n        Converts a given string to a CustomEmoji object.\n\n        The lookup strategy is as follows:\n\n        1. By raw snowflake ID.\n\n        2. By the emoji string format.\n\n        3. By name.\n\n        Args:\n            ctx: The context to use for the conversion.\n            argument: The argument to be converted.\n\n        Returns:\n            CustomEmoji: The converted object.\n        \"\"\"\n        if not ctx.guild:\n            raise BadArgument(\"This command cannot be used in private messages.\")\n\n        match = self._get_id_match(argument) or re.match(r\"&lt;a?:[a-zA-Z0-9\\_]{1,32}:([0-9]{15,})&gt;$\", argument)\n        result = None\n\n        if match:\n            result = await ctx.guild.fetch_custom_emoji(int(match.group(1)))\n        else:\n            if ctx.bot.cache.enable_emoji_cache:\n                emojis = ctx.bot.cache.emoji_cache.values()  # type: ignore\n                result = next((e for e in emojis if e.name == argument))\n\n            if not result:\n                emojis = await ctx.guild.fetch_all_custom_emojis()\n                result = next((e for e in emojis if e.name == argument))\n\n        if not result:\n            raise BadArgument(f'Emoji \"{argument}\" not found.')\n\n        return result\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.CustomEmojiConverter.convert","title":"<code>convert(ctx, argument)</code>  <code>async</code>","text":"<p>Converts a given string to a CustomEmoji object.</p> <p>The lookup strategy is as follows:</p> <ol> <li> <p>By raw snowflake ID.</p> </li> <li> <p>By the emoji string format.</p> </li> <li> <p>By name.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context to use for the conversion.</p> required <code>argument</code> <code>str</code> <p>The argument to be converted.</p> required <p>Returns:</p> Name Type Description <code>CustomEmoji</code> <code>CustomEmoji</code> <p>The converted object.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>async def convert(self, ctx: Context, argument: str) -&gt; CustomEmoji:\n\"\"\"\n    Converts a given string to a CustomEmoji object.\n\n    The lookup strategy is as follows:\n\n    1. By raw snowflake ID.\n\n    2. By the emoji string format.\n\n    3. By name.\n\n    Args:\n        ctx: The context to use for the conversion.\n        argument: The argument to be converted.\n\n    Returns:\n        CustomEmoji: The converted object.\n    \"\"\"\n    if not ctx.guild:\n        raise BadArgument(\"This command cannot be used in private messages.\")\n\n    match = self._get_id_match(argument) or re.match(r\"&lt;a?:[a-zA-Z0-9\\_]{1,32}:([0-9]{15,})&gt;$\", argument)\n    result = None\n\n    if match:\n        result = await ctx.guild.fetch_custom_emoji(int(match.group(1)))\n    else:\n        if ctx.bot.cache.enable_emoji_cache:\n            emojis = ctx.bot.cache.emoji_cache.values()  # type: ignore\n            result = next((e for e in emojis if e.name == argument))\n\n        if not result:\n            emojis = await ctx.guild.fetch_all_custom_emojis()\n            result = next((e for e in emojis if e.name == argument))\n\n    if not result:\n        raise BadArgument(f'Emoji \"{argument}\" not found.')\n\n    return result\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.Greedy","title":"<code>Greedy</code>","text":"<p>         Bases: <code>List[T]</code></p> <p>A special marker class to mark an argument in a prefixed command to repeatedly convert until it fails to convert an argument.</p> Source code in <code>naff\\models\\naff\\converters.py</code> <pre><code>class Greedy(List[T]):\n\"\"\"A special marker class to mark an argument in a prefixed command to repeatedly convert until it fails to convert an argument.\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Naff/converters/#naff.models.naff.converters.NAFF_MODEL_TO_CONVERTER","title":"<code>NAFF_MODEL_TO_CONVERTER: dict[type, type[Converter]] = {SnowflakeObject: SnowflakeConverter, BaseChannel: BaseChannelConverter, DMChannel: DMChannelConverter, DM: DMConverter, DMGroup: DMGroupConverter, GuildChannel: GuildChannelConverter, GuildNews: GuildNewsConverter, GuildCategory: GuildCategoryConverter, GuildText: GuildTextConverter, ThreadChannel: ThreadChannelConverter, GuildNewsThread: GuildNewsThreadConverter, GuildPublicThread: GuildPublicThreadConverter, GuildPrivateThread: GuildPrivateThreadConverter, VoiceChannel: VoiceChannelConverter, GuildVoice: GuildVoiceConverter, GuildStageVoice: GuildStageVoiceConverter, TYPE_ALL_CHANNEL: BaseChannelConverter, TYPE_DM_CHANNEL: DMChannelConverter, TYPE_GUILD_CHANNEL: GuildChannelConverter, TYPE_THREAD_CHANNEL: ThreadChannelConverter, TYPE_VOICE_CHANNEL: VoiceChannelConverter, TYPE_MESSAGEABLE_CHANNEL: MessageableChannelConverter, User: UserConverter, Member: MemberConverter, Message: MessageConverter, Guild: GuildConverter, Role: RoleConverter, PartialEmoji: PartialEmojiConverter, CustomEmoji: CustomEmojiConverter}</code>  <code>module-attribute</code>","text":"<p>A dictionary mapping of naff objects to their corresponding converters.</p>"},{"location":"API%20Reference/models/Naff/cooldowns/","title":"Cooldowns","text":"Example Usage: <p><pre><code>from naff import slash_command, cooldown, Buckets\n\n@slash_command(name='cmd')\n@cooldown(Buckets.user, 1, 10) # (1)!\nasync def some_command(ctx):\n    ...\n</code></pre></p> <ol> <li>This will create a cooldown for each user; allowing them to use the command once every 10 seconds</li> </ol>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.Buckets","title":"<code>Buckets</code>","text":"<p>         Bases: <code>IntEnum</code></p> <p>Outlines the cooldown buckets that may be used. Should a bucket for guilds exist, and the command is invoked in a DM, a sane default will be used.</p> Note <p>To add your own, override this</p> Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>class Buckets(IntEnum):\n\"\"\"\n    Outlines the cooldown buckets that may be used. Should a bucket for guilds exist, and the command is invoked in a DM, a sane default will be used.\n\n    ??? note\n         To add your own, override this\n\n    \"\"\"\n\n    DEFAULT = 0\n\"\"\"Default is the same as user\"\"\"\n    USER = 1\n\"\"\"Per user cooldowns\"\"\"\n    GUILD = 2\n\"\"\"Per guild cooldowns\"\"\"\n    CHANNEL = 3\n\"\"\"Per channel cooldowns\"\"\"\n    MEMBER = 4\n\"\"\"Per guild member cooldowns\"\"\"\n    CATEGORY = 5\n\"\"\"Per category cooldowns\"\"\"\n    ROLE = 6\n\"\"\"Per role cooldowns\"\"\"\n\n    async def get_key(self, context: \"Context\") -&gt; Any:\n        if self is Buckets.USER:\n            return context.author.id\n        elif self is Buckets.GUILD:\n            return context.guild_id if context.guild else context.author.id\n        elif self is Buckets.CHANNEL:\n            return context.channel.id\n        elif self is Buckets.MEMBER:\n            return (context.guild_id, context.author.id) if context.guild else context.author.id\n        elif self is Buckets.CATEGORY:\n            return await context.channel.parent_id if context.channel.parent else context.channel.id\n        elif self is Buckets.ROLE:\n            return context.channel.id if not context.guild else context.author.top_role.id\n        else:\n            return context.author.id\n\n    def __call__(self, context: \"Context\") -&gt; Any:\n        return self.get_key(context)\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.Buckets.DEFAULT","title":"<code>DEFAULT = 0</code>  <code>class-attribute</code>","text":"<p>Default is the same as user</p>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.Buckets.USER","title":"<code>USER = 1</code>  <code>class-attribute</code>","text":"<p>Per user cooldowns</p>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.Buckets.GUILD","title":"<code>GUILD = 2</code>  <code>class-attribute</code>","text":"<p>Per guild cooldowns</p>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.Buckets.CHANNEL","title":"<code>CHANNEL = 3</code>  <code>class-attribute</code>","text":"<p>Per channel cooldowns</p>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.Buckets.MEMBER","title":"<code>MEMBER = 4</code>  <code>class-attribute</code>","text":"<p>Per guild member cooldowns</p>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.Buckets.CATEGORY","title":"<code>CATEGORY = 5</code>  <code>class-attribute</code>","text":"<p>Per category cooldowns</p>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.Buckets.ROLE","title":"<code>ROLE = 6</code>  <code>class-attribute</code>","text":"<p>Per role cooldowns</p>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.Cooldown","title":"<code>Cooldown</code>","text":"<p>Manages cooldowns and their respective buckets for a command.</p> Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>class Cooldown:\n\"\"\"Manages cooldowns and their respective buckets for a command.\"\"\"\n\n    __slots__ = \"bucket\", \"cooldown_repositories\", \"rate\", \"interval\"\n\n    def __init__(self, cooldown_bucket: Buckets, rate: int, interval: float) -&gt; None:\n        self.bucket: Buckets = cooldown_bucket\n        self.cooldown_repositories = {}\n        self.rate: int = rate\n        self.interval: float = interval\n\n    async def get_cooldown(self, context: \"Context\") -&gt; \"CooldownSystem\":\n        key = await self.bucket(context)\n\n        if key not in self.cooldown_repositories:\n            cooldown = CooldownSystem(self.rate, self.interval)\n            self.cooldown_repositories[key] = cooldown\n            return cooldown\n        return self.cooldown_repositories.get(await self.bucket(context))\n\n    async def acquire_token(self, context: \"Context\") -&gt; bool:\n\"\"\"\n        Attempt to acquire a token for a command to run. Uses the context of the command to use the correct CooldownSystem.\n\n        Args:\n            context: The context of the command\n\n        Returns:\n            True if a token was acquired, False if not\n\n        \"\"\"\n        cooldown = await self.get_cooldown(context)\n\n        return cooldown.acquire_token()\n\n    async def get_cooldown_time(self, context: \"Context\") -&gt; float:\n\"\"\"\n        Get the remaining cooldown time.\n\n        Args:\n            context: The context of the command\n\n        Returns:\n            remaining cooldown time, will return 0 if the cooldown has not been reached\n\n        \"\"\"\n        cooldown = await self.get_cooldown(context)\n        return cooldown.get_cooldown_time()\n\n    async def on_cooldown(self, context: \"Context\") -&gt; bool:\n\"\"\"\n        Returns the cooldown state of the command.\n\n        Args:\n            context: The context of the command\n\n        Returns:\n            boolean state if the command is on cooldown or not\n\n        \"\"\"\n        cooldown = await self.get_cooldown(context)\n        return cooldown.on_cooldown()\n\n    async def reset_all(self) -&gt; None:\n\"\"\"\n        Resets this cooldown system to its initial state.\n\n        !!! warning     To be clear, this will reset **all** cooldowns\n        for this command to their initial states\n\n        \"\"\"\n        # this doesnt need to be async, but for consistency, it is\n        self.cooldown_repositories = {}\n\n    async def reset(self, context: \"Context\") -&gt; None:\n\"\"\"\n        Resets the cooldown for the bucket of which invoked this command.\n\n        Args:\n            context: The context of the command\n\n        \"\"\"\n        cooldown = await self.get_cooldown(context)\n        cooldown.reset()\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.Cooldown.acquire_token","title":"<code>acquire_token(context)</code>  <code>async</code>","text":"<p>Attempt to acquire a token for a command to run. Uses the context of the command to use the correct CooldownSystem.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>The context of the command</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a token was acquired, False if not</p> Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>async def acquire_token(self, context: \"Context\") -&gt; bool:\n\"\"\"\n    Attempt to acquire a token for a command to run. Uses the context of the command to use the correct CooldownSystem.\n\n    Args:\n        context: The context of the command\n\n    Returns:\n        True if a token was acquired, False if not\n\n    \"\"\"\n    cooldown = await self.get_cooldown(context)\n\n    return cooldown.acquire_token()\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.Cooldown.get_cooldown_time","title":"<code>get_cooldown_time(context)</code>  <code>async</code>","text":"<p>Get the remaining cooldown time.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>The context of the command</p> required <p>Returns:</p> Type Description <code>float</code> <p>remaining cooldown time, will return 0 if the cooldown has not been reached</p> Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>async def get_cooldown_time(self, context: \"Context\") -&gt; float:\n\"\"\"\n    Get the remaining cooldown time.\n\n    Args:\n        context: The context of the command\n\n    Returns:\n        remaining cooldown time, will return 0 if the cooldown has not been reached\n\n    \"\"\"\n    cooldown = await self.get_cooldown(context)\n    return cooldown.get_cooldown_time()\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.Cooldown.on_cooldown","title":"<code>on_cooldown(context)</code>  <code>async</code>","text":"<p>Returns the cooldown state of the command.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>The context of the command</p> required <p>Returns:</p> Type Description <code>bool</code> <p>boolean state if the command is on cooldown or not</p> Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>async def on_cooldown(self, context: \"Context\") -&gt; bool:\n\"\"\"\n    Returns the cooldown state of the command.\n\n    Args:\n        context: The context of the command\n\n    Returns:\n        boolean state if the command is on cooldown or not\n\n    \"\"\"\n    cooldown = await self.get_cooldown(context)\n    return cooldown.on_cooldown()\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.Cooldown.reset_all","title":"<code>reset_all()</code>  <code>async</code>","text":"<p>Resets this cooldown system to its initial state.</p> <p>!!! warning     To be clear, this will reset all cooldowns for this command to their initial states</p> Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>async def reset_all(self) -&gt; None:\n\"\"\"\n    Resets this cooldown system to its initial state.\n\n    !!! warning     To be clear, this will reset **all** cooldowns\n    for this command to their initial states\n\n    \"\"\"\n    # this doesnt need to be async, but for consistency, it is\n    self.cooldown_repositories = {}\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.Cooldown.reset","title":"<code>reset(context)</code>  <code>async</code>","text":"<p>Resets the cooldown for the bucket of which invoked this command.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>The context of the command</p> required Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>async def reset(self, context: \"Context\") -&gt; None:\n\"\"\"\n    Resets the cooldown for the bucket of which invoked this command.\n\n    Args:\n        context: The context of the command\n\n    \"\"\"\n    cooldown = await self.get_cooldown(context)\n    cooldown.reset()\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.CooldownSystem","title":"<code>CooldownSystem</code>","text":"<p>Represents a cooldown system for commands.</p> <p>Attributes:</p> Name Type Description <code>rate</code> <code>int</code> <p>How many commands may be ran per interval</p> <code>interval</code> <code>float</code> <p>How many seconds to wait for a cooldown</p> <code>opened</code> <code>float</code> <p>When this cooldown session began</p> Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>class CooldownSystem:\n\"\"\"\n    Represents a cooldown system for commands.\n\n    Attributes:\n        rate: How many commands may be ran per interval\n        interval: How many seconds to wait for a cooldown\n        opened: When this cooldown session began\n\n    \"\"\"\n\n    __slots__ = \"rate\", \"interval\", \"opened\", \"_tokens\"\n\n    def __init__(self, rate: int, interval: float) -&gt; None:\n        self.rate: int = rate\n        self.interval: float = interval\n        self.opened: float = 0.0\n\n        self._tokens: int = self.rate\n\n        # sanity checks\n        if self.rate == 0:\n            raise ValueError(\"Cooldown rate must be greater than 0\")\n        if self.interval == 0:\n            raise ValueError(\"Cooldown interval must be greater than 0\")\n\n    def reset(self) -&gt; None:\n\"\"\"Resets the tokens for this cooldown.\"\"\"\n        self._tokens = self.rate\n        self.opened = 0.0\n\n    def on_cooldown(self) -&gt; bool:\n\"\"\"\n        Returns the cooldown state of the command.\n\n        Returns:\n            boolean state if the command is on cooldown or not\n        \"\"\"\n        self.determine_cooldown()\n\n        if self._tokens == 0:\n            return True\n        return False\n\n    def acquire_token(self) -&gt; bool:\n\"\"\"\n        Attempt to acquire a token for a command to run.\n\n        Returns:\n            True if a token was acquired, False if not\n\n        \"\"\"\n        self.determine_cooldown()\n\n        if self._tokens == 0:\n            return False\n        if self._tokens == self.rate:\n            self.opened = time.time()\n        self._tokens -= 1\n\n        return True\n\n    def get_cooldown_time(self) -&gt; float:\n\"\"\"\n        Returns how long until the cooldown will reset.\n\n        Returns:\n            remaining cooldown time, will return 0 if the cooldown has not been reached\n\n        \"\"\"\n        self.determine_cooldown()\n        if self._tokens != 0:\n            return 0\n        return self.interval - (time.time() - self.opened)\n\n    def determine_cooldown(self) -&gt; None:\n\"\"\"Determines the state of the cooldown system.\"\"\"\n        c_time = time.time()\n\n        if c_time &gt; self.opened + self.interval:\n            # cooldown has expired, reset the cooldown\n            self.reset()\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.CooldownSystem.reset","title":"<code>reset()</code>","text":"<p>Resets the tokens for this cooldown.</p> Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>def reset(self) -&gt; None:\n\"\"\"Resets the tokens for this cooldown.\"\"\"\n    self._tokens = self.rate\n    self.opened = 0.0\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.CooldownSystem.on_cooldown","title":"<code>on_cooldown()</code>","text":"<p>Returns the cooldown state of the command.</p> <p>Returns:</p> Type Description <code>bool</code> <p>boolean state if the command is on cooldown or not</p> Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>def on_cooldown(self) -&gt; bool:\n\"\"\"\n    Returns the cooldown state of the command.\n\n    Returns:\n        boolean state if the command is on cooldown or not\n    \"\"\"\n    self.determine_cooldown()\n\n    if self._tokens == 0:\n        return True\n    return False\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.CooldownSystem.acquire_token","title":"<code>acquire_token()</code>","text":"<p>Attempt to acquire a token for a command to run.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if a token was acquired, False if not</p> Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>def acquire_token(self) -&gt; bool:\n\"\"\"\n    Attempt to acquire a token for a command to run.\n\n    Returns:\n        True if a token was acquired, False if not\n\n    \"\"\"\n    self.determine_cooldown()\n\n    if self._tokens == 0:\n        return False\n    if self._tokens == self.rate:\n        self.opened = time.time()\n    self._tokens -= 1\n\n    return True\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.CooldownSystem.get_cooldown_time","title":"<code>get_cooldown_time()</code>","text":"<p>Returns how long until the cooldown will reset.</p> <p>Returns:</p> Type Description <code>float</code> <p>remaining cooldown time, will return 0 if the cooldown has not been reached</p> Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>def get_cooldown_time(self) -&gt; float:\n\"\"\"\n    Returns how long until the cooldown will reset.\n\n    Returns:\n        remaining cooldown time, will return 0 if the cooldown has not been reached\n\n    \"\"\"\n    self.determine_cooldown()\n    if self._tokens != 0:\n        return 0\n    return self.interval - (time.time() - self.opened)\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.CooldownSystem.determine_cooldown","title":"<code>determine_cooldown()</code>","text":"<p>Determines the state of the cooldown system.</p> Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>def determine_cooldown(self) -&gt; None:\n\"\"\"Determines the state of the cooldown system.\"\"\"\n    c_time = time.time()\n\n    if c_time &gt; self.opened + self.interval:\n        # cooldown has expired, reset the cooldown\n        self.reset()\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.MaxConcurrency","title":"<code>MaxConcurrency</code>","text":"<p>Limits how many instances of a command may be running concurrently.</p> <p>Attributes:</p> Name Type Description <code>bucket</code> <code>Buckets</code> <p>The bucket this concurrency applies to</p> <code>concurrent</code> <code>int</code> <p>The maximum number of concurrent instances permitted to</p> <code>wait</code> <code>bool</code> <p>Should we wait until a instance is available</p> Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>class MaxConcurrency:\n\"\"\"\n    Limits how many instances of a command may be running concurrently.\n\n    Attributes:\n        bucket Buckets: The bucket this concurrency applies to\n        concurrent int: The maximum number of concurrent instances permitted to\n        wait bool: Should we wait until a instance is available\n\n    \"\"\"\n\n    def __init__(self, concurrent: int, concurrency_bucket: Buckets, wait: bool = False) -&gt; None:\n        self.bucket: Buckets = concurrency_bucket\n        self.concurrency_repository: Dict = {}\n        self.concurrent: int = concurrent\n        self.wait = wait\n\n    async def get_semaphore(self, context: \"Context\") -&gt; asyncio.Semaphore:\n\"\"\"\n        Get the semaphore associated with the given context.\n\n        Args:\n            context: The commands context\n\n        Returns:\n            A semaphore object\n        \"\"\"\n        key = await self.bucket(context)\n\n        if key not in self.concurrency_repository:\n            semaphore = asyncio.Semaphore(self.concurrent)\n            self.concurrency_repository[key] = semaphore\n            return semaphore\n        return self.concurrency_repository.get(key)\n\n    async def acquire(self, context: \"Context\") -&gt; bool:\n\"\"\"\n        Acquire an instance of the semaphore.\n\n        Args:\n            context:The context of the command\n        Returns:\n            If the semaphore was successfully acquired\n\n        \"\"\"\n        semaphore = await self.get_semaphore(context)\n\n        if not self.wait and semaphore.locked():\n            return False\n        acquired = await semaphore.acquire()\n        return acquired\n\n    async def release(self, context: \"Context\") -&gt; None:\n\"\"\"\n        Release the semaphore.\n\n        Args:\n            context: The context of the command\n\n        \"\"\"\n        semaphore = await self.get_semaphore(context)\n\n        semaphore.release()\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.MaxConcurrency.get_semaphore","title":"<code>get_semaphore(context)</code>  <code>async</code>","text":"<p>Get the semaphore associated with the given context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>The commands context</p> required <p>Returns:</p> Type Description <code>asyncio.Semaphore</code> <p>A semaphore object</p> Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>async def get_semaphore(self, context: \"Context\") -&gt; asyncio.Semaphore:\n\"\"\"\n    Get the semaphore associated with the given context.\n\n    Args:\n        context: The commands context\n\n    Returns:\n        A semaphore object\n    \"\"\"\n    key = await self.bucket(context)\n\n    if key not in self.concurrency_repository:\n        semaphore = asyncio.Semaphore(self.concurrent)\n        self.concurrency_repository[key] = semaphore\n        return semaphore\n    return self.concurrency_repository.get(key)\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.MaxConcurrency.acquire","title":"<code>acquire(context)</code>  <code>async</code>","text":"<p>Acquire an instance of the semaphore.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>The context of the command</p> required <p>Returns:</p> Type Description <code>bool</code> <p>If the semaphore was successfully acquired</p> Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>async def acquire(self, context: \"Context\") -&gt; bool:\n\"\"\"\n    Acquire an instance of the semaphore.\n\n    Args:\n        context:The context of the command\n    Returns:\n        If the semaphore was successfully acquired\n\n    \"\"\"\n    semaphore = await self.get_semaphore(context)\n\n    if not self.wait and semaphore.locked():\n        return False\n    acquired = await semaphore.acquire()\n    return acquired\n</code></pre>"},{"location":"API%20Reference/models/Naff/cooldowns/#naff.models.naff.cooldowns.MaxConcurrency.release","title":"<code>release(context)</code>  <code>async</code>","text":"<p>Release the semaphore.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>The context of the command</p> required Source code in <code>naff\\models\\naff\\cooldowns.py</code> <pre><code>async def release(self, context: \"Context\") -&gt; None:\n\"\"\"\n    Release the semaphore.\n\n    Args:\n        context: The context of the command\n\n    \"\"\"\n    semaphore = await self.get_semaphore(context)\n\n    semaphore.release()\n</code></pre>"},{"location":"API%20Reference/models/Naff/extension/","title":"Extension","text":""},{"location":"API%20Reference/models/Naff/extension/#naff.models.naff.extension.Extension","title":"<code>Extension</code>","text":"<p>A class that allows you to separate your commands and listeners into separate files. Skins require an entrypoint in the same file called <code>setup</code>, this function allows client to load the Extension.</p> Example Usage: <pre><code>class ExampleExt(Extension):\n    def __init__(self, bot):\n        print(\"Extension Created\")\n\n    @prefixed_command()\n    async def some_command(self, context):\n        await ctx.send(f\"I was sent from a extension called {self.name}\")\n</code></pre> <p>Attributes:</p> Name Type Description <code>bot</code> <code>Client</code> <p>A reference to the client</p> <code>name</code> <code>str</code> <p>The name of this Extension (<code>read-only</code>)</p> <code>description</code> <code>str</code> <p>A description of this Extension</p> <code>extension_checks</code> <code>str</code> <p>A list of checks to be ran on any command in this extension</p> <code>extension_prerun</code> <code>List</code> <p>A list of coroutines to be run before any command in this extension</p> <code>extension_postrun</code> <code>List</code> <p>A list of coroutines to be run after any command in this extension</p> <code>interaction_tree</code> <code>Dict</code> <p>A dictionary of registered application commands in a tree</p> Source code in <code>naff\\models\\naff\\extension.py</code> <pre><code>class Extension:\n\"\"\"\n    A class that allows you to separate your commands and listeners into separate files. Skins require an entrypoint in the same file called `setup`, this function allows client to load the Extension.\n\n    ??? Hint \"Example Usage:\"\n        ```python\n        class ExampleExt(Extension):\n            def __init__(self, bot):\n                print(\"Extension Created\")\n\n            @prefixed_command()\n            async def some_command(self, context):\n                await ctx.send(f\"I was sent from a extension called {self.name}\")\n        ```\n\n    Attributes:\n        bot Client: A reference to the client\n        name str: The name of this Extension (`read-only`)\n        description str: A description of this Extension\n        extension_checks str: A list of checks to be ran on any command in this extension\n        extension_prerun List: A list of coroutines to be run before any command in this extension\n        extension_postrun List: A list of coroutines to be run after any command in this extension\n        interaction_tree Dict: A dictionary of registered application commands in a tree\n\n    \"\"\"\n\n    bot: \"Client\"\n    name: str\n    extension_name: str\n    description: str\n    extension_checks: List\n    extension_prerun: List\n    extension_postrun: List\n    extension_error: Optional[Callable[..., Coroutine]]\n    interaction_tree: Dict[\"Snowflake_Type\", Dict[str, \"InteractionCommand\" | Dict[str, \"InteractionCommand\"]]]\n    _commands: List\n    _listeners: List\n    auto_defer: \"AutoDefer\"\n\n    def __new__(cls, bot: \"Client\", *args, **kwargs) -&gt; \"Extension\":\n        new_cls = super().__new__(cls)\n        new_cls.bot = bot\n        new_cls.name = cls.__name__\n        new_cls.extension_checks = []\n        new_cls.extension_prerun = []\n        new_cls.extension_postrun = []\n        new_cls.extension_error = None\n        new_cls.interaction_tree = {}\n        new_cls.auto_defer = MISSING\n\n        new_cls.description = kwargs.get(\"Description\", None)\n        if not new_cls.description:\n            new_cls.description = inspect.cleandoc(cls.__doc__) if cls.__doc__ else None\n\n        # load commands from class\n        new_cls._commands = []\n        new_cls._listeners = []\n\n        for _name, val in inspect.getmembers(\n            new_cls, predicate=lambda x: isinstance(x, (naff.BaseCommand, naff.Listener, Task))\n        ):\n            if isinstance(val, naff.BaseCommand):\n                val.extension = new_cls\n                val = wrap_partial(val, new_cls)\n\n                if not isinstance(val, naff.PrefixedCommand) or not val.is_subcommand:\n                    # we do not want to add prefixed subcommands\n                    new_cls._commands.append(val)\n\n                    if isinstance(val, naff.ModalCommand):\n                        bot.add_modal_callback(val)\n                    elif isinstance(val, naff.ComponentCommand):\n                        bot.add_component_callback(val)\n                    elif isinstance(val, naff.HybridCommand):\n                        bot.add_hybrid_command(val)\n                    elif isinstance(val, naff.InteractionCommand):\n                        if not bot.add_interaction(val):\n                            continue\n                        base, group, sub, *_ = val.resolved_name.split(\" \") + [None, None]\n                        for scope in val.scopes:\n                            if scope not in new_cls.interaction_tree:\n                                new_cls.interaction_tree[scope] = {}\n                            if group is None or isinstance(val, ContextMenu):\n                                new_cls.interaction_tree[scope][val.resolved_name] = val\n                            elif group is not None:\n                                if not (current := new_cls.interaction_tree[scope].get(base)) or isinstance(\n                                    current, naff.InteractionCommand\n                                ):\n                                    new_cls.interaction_tree[scope][base] = {}\n                                if sub is None:\n                                    new_cls.interaction_tree[scope][base][group] = val\n                                else:\n                                    if not (current := new_cls.interaction_tree[scope][base].get(group)) or isinstance(\n                                        current, naff.InteractionCommand\n                                    ):\n                                        new_cls.interaction_tree[scope][base][group] = {}\n                                    new_cls.interaction_tree[scope][base][group][sub] = val\n                    else:\n                        bot.add_prefixed_command(val)\n\n            elif isinstance(val, naff.Listener):\n                val = val.copy_with_binding(new_cls)\n                bot.add_listener(val)\n                new_cls.listeners.append(val)\n            elif isinstance(val, Task):\n                wrap_partial(val, new_cls)\n\n        bot.logger.debug(\n            f\"{len(new_cls._commands)} commands and {len(new_cls.listeners)} listeners\"\n            f\" have been loaded from `{new_cls.name}`\"\n        )\n\n        new_cls.extension_name = inspect.getmodule(new_cls).__name__\n        new_cls.bot.ext[new_cls.name] = new_cls\n\n        if hasattr(new_cls, \"async_start\"):\n            if inspect.iscoroutinefunction(new_cls.async_start):\n                bot.async_startup_tasks.append(new_cls.async_start())\n            else:\n                raise TypeError(\"async_start is a reserved method and must be a coroutine\")\n\n        return new_cls\n\n    @property\n    def __name__(self) -&gt; str:\n        return self.name\n\n    @property\n    def commands(self) -&gt; List[\"BaseCommand\"]:\n\"\"\"Get the commands from this Extension.\"\"\"\n        return self._commands\n\n    @property\n    def listeners(self) -&gt; List[\"Listener\"]:\n\"\"\"Get the listeners from this Extension.\"\"\"\n        return self._listeners\n\n    def drop(self) -&gt; None:\n\"\"\"Called when this Extension is being removed.\"\"\"\n        for func in self._commands:\n            if isinstance(func, naff.ModalCommand):\n                for listener in func.listeners:\n                    # noinspection PyProtectedMember\n                    self.bot._modal_callbacks.pop(listener)\n            elif isinstance(func, naff.ComponentCommand):\n                for listener in func.listeners:\n                    # noinspection PyProtectedMember\n                    self.bot._component_callbacks.pop(listener)\n            elif isinstance(func, naff.InteractionCommand):\n                for scope in func.scopes:\n                    if self.bot.interactions.get(scope):\n                        self.bot.interactions[scope].pop(func.resolved_name, [])\n\n                if isinstance(func, naff.HybridCommand):\n                    # here's where things get complicated - we need to unload the prefixed command\n                    # by necessity, there's a lot of logic here to determine what needs to be unloaded\n                    if not func.callback:  # not like it was added\n                        return\n\n                    if func.is_subcommand:\n                        prefixed_base = self.bot.prefixed_commands.get(str(func.name))\n                        _base_cmd = prefixed_base\n                        if not prefixed_base:\n                            # if something weird happened here, here's a safeguard\n                            continue\n\n                        if func.group_name:\n                            prefixed_base = prefixed_base.subcommands.get(str(func.group_name))\n                            if not prefixed_base:\n                                continue\n\n                        prefixed_base.remove_command(str(func.sub_cmd_name))\n\n                        if not prefixed_base.subcommands:\n                            # the base cmd is now empty, delete it\n                            if func.group_name:\n                                _base_cmd.remove_command(str(func.group_name))  # type: ignore\n\n                                # and now the base command is empty\n                                if not _base_cmd.subcommands:  # type: ignore\n                                    # in case you're curious, i did try to put the below behavior\n                                    # in a function here, but then it turns out a weird python\n                                    # bug can happen if i did that\n                                    if cmd := self.bot.prefixed_commands.pop(str(func.name), None):\n                                        for alias in cmd.aliases:\n                                            self.bot.prefixed_commands.pop(alias, None)\n\n                            elif cmd := self.bot.prefixed_commands.pop(str(func.name), None):\n                                for alias in cmd.aliases:\n                                    self.bot.prefixed_commands.pop(alias, None)\n\n                    elif cmd := self.bot.prefixed_commands.pop(str(func.name), None):\n                        for alias in cmd.aliases:\n                            self.bot.prefixed_commands.pop(alias, None)\n\n            elif isinstance(func, naff.PrefixedCommand):\n                if not func.is_subcommand:\n                    self.bot.prefixed_commands.pop(func.name, None)\n                    for alias in func.aliases:\n                        self.bot.prefixed_commands.pop(alias, None)\n        for func in self.listeners:\n            self.bot.listeners[func.event].remove(func)\n\n        self.bot.ext.pop(self.name, None)\n        self.bot.logger.debug(f\"{self.name} has been drop\")\n\n    def add_ext_auto_defer(self, ephemeral: bool = False, time_until_defer: float = 0.0) -&gt; None:\n\"\"\"\n        Add a auto defer for all commands in this extension.\n\n        Args:\n            ephemeral: Should the command be deferred as ephemeral\n            time_until_defer: How long to wait before deferring automatically\n\n        \"\"\"\n        self.auto_defer = naff.AutoDefer(enabled=True, ephemeral=ephemeral, time_until_defer=time_until_defer)\n\n    def add_ext_check(self, coroutine: Callable[[\"Context\"], Awaitable[bool]]) -&gt; None:\n\"\"\"\n        Add a coroutine as a check for all commands in this extension to run. This coroutine must take **only** the parameter `context`.\n\n        ??? Hint \"Example Usage:\"\n            ```python\n            def __init__(self, bot):\n                self.add_ext_check(self.example)\n\n            @staticmethod\n            async def example(context: Context):\n                if context.author.id == 123456789:\n                    return True\n                return False\n            ```\n        Args:\n            coroutine: The coroutine to use as a check\n\n        \"\"\"\n        if not asyncio.iscoroutinefunction(coroutine):\n            raise TypeError(\"Check must be a coroutine\")\n\n        if not self.extension_checks:\n            self.extension_checks = []\n\n        self.extension_checks.append(coroutine)\n\n    def add_extension_prerun(self, coroutine: Callable[..., Coroutine]) -&gt; None:\n\"\"\"\n        Add a coroutine to be run **before** all commands in this Extension.\n\n        !!! note\n            Pre-runs will **only** be run if the commands checks pass\n\n        ??? Hint \"Example Usage:\"\n            ```python\n            def __init__(self, bot):\n                self.add_extension_prerun(self.example)\n\n            async def example(self, context: Context):\n                await ctx.send(\"I ran first\")\n            ```\n\n        Args:\n            coroutine: The coroutine to run\n\n        \"\"\"\n        if not asyncio.iscoroutinefunction(coroutine):\n            raise TypeError(\"Callback must be a coroutine\")\n\n        if not self.extension_prerun:\n            self.extension_prerun = []\n        self.extension_prerun.append(coroutine)\n\n    def add_extension_postrun(self, coroutine: Callable[..., Coroutine]) -&gt; None:\n\"\"\"\n        Add a coroutine to be run **after** all commands in this Extension.\n\n        ??? Hint \"Example Usage:\"\n            ```python\n            def __init__(self, bot):\n                self.add_extension_postrun(self.example)\n\n            async def example(self, context: Context):\n                await ctx.send(\"I ran first\")\n            ```\n\n        Args:\n            coroutine: The coroutine to run\n\n        \"\"\"\n        if not asyncio.iscoroutinefunction(coroutine):\n            raise TypeError(\"Callback must be a coroutine\")\n\n        if not self.extension_postrun:\n            self.extension_postrun = []\n        self.extension_postrun.append(coroutine)\n\n    def set_extension_error(self, coroutine: Callable[..., Coroutine]) -&gt; None:\n\"\"\"\n        Add a coroutine to handle any exceptions raised in this extension.\n\n        ??? Hint \"Example Usage:\"\n            ```python\n            def __init__(self, bot):\n                self.set_extension_error(self.example)\n\n        Args:\n            coroutine: The coroutine to run\n\n        \"\"\"\n        if not asyncio.iscoroutinefunction(coroutine):\n            raise TypeError(\"Callback must be a coroutine\")\n\n        if self.extension_error:\n            self.bot.logger.warning(\"Extension error callback has been overridden!\")\n        self.extension_error = coroutine\n</code></pre>"},{"location":"API%20Reference/models/Naff/extension/#naff.models.naff.extension.Extension.commands","title":"<code>commands: List[BaseCommand]</code>  <code>property</code>","text":"<p>Get the commands from this Extension.</p>"},{"location":"API%20Reference/models/Naff/extension/#naff.models.naff.extension.Extension.listeners","title":"<code>listeners: List[Listener]</code>  <code>property</code>","text":"<p>Get the listeners from this Extension.</p>"},{"location":"API%20Reference/models/Naff/extension/#naff.models.naff.extension.Extension.drop","title":"<code>drop()</code>","text":"<p>Called when this Extension is being removed.</p> Source code in <code>naff\\models\\naff\\extension.py</code> <pre><code>def drop(self) -&gt; None:\n\"\"\"Called when this Extension is being removed.\"\"\"\n    for func in self._commands:\n        if isinstance(func, naff.ModalCommand):\n            for listener in func.listeners:\n                # noinspection PyProtectedMember\n                self.bot._modal_callbacks.pop(listener)\n        elif isinstance(func, naff.ComponentCommand):\n            for listener in func.listeners:\n                # noinspection PyProtectedMember\n                self.bot._component_callbacks.pop(listener)\n        elif isinstance(func, naff.InteractionCommand):\n            for scope in func.scopes:\n                if self.bot.interactions.get(scope):\n                    self.bot.interactions[scope].pop(func.resolved_name, [])\n\n            if isinstance(func, naff.HybridCommand):\n                # here's where things get complicated - we need to unload the prefixed command\n                # by necessity, there's a lot of logic here to determine what needs to be unloaded\n                if not func.callback:  # not like it was added\n                    return\n\n                if func.is_subcommand:\n                    prefixed_base = self.bot.prefixed_commands.get(str(func.name))\n                    _base_cmd = prefixed_base\n                    if not prefixed_base:\n                        # if something weird happened here, here's a safeguard\n                        continue\n\n                    if func.group_name:\n                        prefixed_base = prefixed_base.subcommands.get(str(func.group_name))\n                        if not prefixed_base:\n                            continue\n\n                    prefixed_base.remove_command(str(func.sub_cmd_name))\n\n                    if not prefixed_base.subcommands:\n                        # the base cmd is now empty, delete it\n                        if func.group_name:\n                            _base_cmd.remove_command(str(func.group_name))  # type: ignore\n\n                            # and now the base command is empty\n                            if not _base_cmd.subcommands:  # type: ignore\n                                # in case you're curious, i did try to put the below behavior\n                                # in a function here, but then it turns out a weird python\n                                # bug can happen if i did that\n                                if cmd := self.bot.prefixed_commands.pop(str(func.name), None):\n                                    for alias in cmd.aliases:\n                                        self.bot.prefixed_commands.pop(alias, None)\n\n                        elif cmd := self.bot.prefixed_commands.pop(str(func.name), None):\n                            for alias in cmd.aliases:\n                                self.bot.prefixed_commands.pop(alias, None)\n\n                elif cmd := self.bot.prefixed_commands.pop(str(func.name), None):\n                    for alias in cmd.aliases:\n                        self.bot.prefixed_commands.pop(alias, None)\n\n        elif isinstance(func, naff.PrefixedCommand):\n            if not func.is_subcommand:\n                self.bot.prefixed_commands.pop(func.name, None)\n                for alias in func.aliases:\n                    self.bot.prefixed_commands.pop(alias, None)\n    for func in self.listeners:\n        self.bot.listeners[func.event].remove(func)\n\n    self.bot.ext.pop(self.name, None)\n    self.bot.logger.debug(f\"{self.name} has been drop\")\n</code></pre>"},{"location":"API%20Reference/models/Naff/extension/#naff.models.naff.extension.Extension.add_ext_auto_defer","title":"<code>add_ext_auto_defer(ephemeral=False, time_until_defer=0.0)</code>","text":"<p>Add a auto defer for all commands in this extension.</p> <p>Parameters:</p> Name Type Description Default <code>ephemeral</code> <code>bool</code> <p>Should the command be deferred as ephemeral</p> <code>False</code> <code>time_until_defer</code> <code>float</code> <p>How long to wait before deferring automatically</p> <code>0.0</code> Source code in <code>naff\\models\\naff\\extension.py</code> <pre><code>def add_ext_auto_defer(self, ephemeral: bool = False, time_until_defer: float = 0.0) -&gt; None:\n\"\"\"\n    Add a auto defer for all commands in this extension.\n\n    Args:\n        ephemeral: Should the command be deferred as ephemeral\n        time_until_defer: How long to wait before deferring automatically\n\n    \"\"\"\n    self.auto_defer = naff.AutoDefer(enabled=True, ephemeral=ephemeral, time_until_defer=time_until_defer)\n</code></pre>"},{"location":"API%20Reference/models/Naff/extension/#naff.models.naff.extension.Extension.add_ext_check","title":"<code>add_ext_check(coroutine)</code>","text":"<p>Add a coroutine as a check for all commands in this extension to run. This coroutine must take only the parameter <code>context</code>.</p> Example Usage: <pre><code>def __init__(self, bot):\n    self.add_ext_check(self.example)\n\n@staticmethod\nasync def example(context: Context):\n    if context.author.id == 123456789:\n        return True\n    return False\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>coroutine</code> <code>Callable[[Context], Awaitable[bool]]</code> <p>The coroutine to use as a check</p> required Source code in <code>naff\\models\\naff\\extension.py</code> <pre><code>def add_ext_check(self, coroutine: Callable[[\"Context\"], Awaitable[bool]]) -&gt; None:\n\"\"\"\n    Add a coroutine as a check for all commands in this extension to run. This coroutine must take **only** the parameter `context`.\n\n    ??? Hint \"Example Usage:\"\n        ```python\n        def __init__(self, bot):\n            self.add_ext_check(self.example)\n\n        @staticmethod\n        async def example(context: Context):\n            if context.author.id == 123456789:\n                return True\n            return False\n        ```\n    Args:\n        coroutine: The coroutine to use as a check\n\n    \"\"\"\n    if not asyncio.iscoroutinefunction(coroutine):\n        raise TypeError(\"Check must be a coroutine\")\n\n    if not self.extension_checks:\n        self.extension_checks = []\n\n    self.extension_checks.append(coroutine)\n</code></pre>"},{"location":"API%20Reference/models/Naff/extension/#naff.models.naff.extension.Extension.add_extension_prerun","title":"<code>add_extension_prerun(coroutine)</code>","text":"<p>Add a coroutine to be run before all commands in this Extension.</p> <p>Note</p> <p>Pre-runs will only be run if the commands checks pass</p> Example Usage: <pre><code>def __init__(self, bot):\n    self.add_extension_prerun(self.example)\n\nasync def example(self, context: Context):\n    await ctx.send(\"I ran first\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>coroutine</code> <code>Callable[..., Coroutine]</code> <p>The coroutine to run</p> required Source code in <code>naff\\models\\naff\\extension.py</code> <pre><code>def add_extension_prerun(self, coroutine: Callable[..., Coroutine]) -&gt; None:\n\"\"\"\n    Add a coroutine to be run **before** all commands in this Extension.\n\n    !!! note\n        Pre-runs will **only** be run if the commands checks pass\n\n    ??? Hint \"Example Usage:\"\n        ```python\n        def __init__(self, bot):\n            self.add_extension_prerun(self.example)\n\n        async def example(self, context: Context):\n            await ctx.send(\"I ran first\")\n        ```\n\n    Args:\n        coroutine: The coroutine to run\n\n    \"\"\"\n    if not asyncio.iscoroutinefunction(coroutine):\n        raise TypeError(\"Callback must be a coroutine\")\n\n    if not self.extension_prerun:\n        self.extension_prerun = []\n    self.extension_prerun.append(coroutine)\n</code></pre>"},{"location":"API%20Reference/models/Naff/extension/#naff.models.naff.extension.Extension.add_extension_postrun","title":"<code>add_extension_postrun(coroutine)</code>","text":"<p>Add a coroutine to be run after all commands in this Extension.</p> Example Usage: <pre><code>def __init__(self, bot):\n    self.add_extension_postrun(self.example)\n\nasync def example(self, context: Context):\n    await ctx.send(\"I ran first\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>coroutine</code> <code>Callable[..., Coroutine]</code> <p>The coroutine to run</p> required Source code in <code>naff\\models\\naff\\extension.py</code> <pre><code>def add_extension_postrun(self, coroutine: Callable[..., Coroutine]) -&gt; None:\n\"\"\"\n    Add a coroutine to be run **after** all commands in this Extension.\n\n    ??? Hint \"Example Usage:\"\n        ```python\n        def __init__(self, bot):\n            self.add_extension_postrun(self.example)\n\n        async def example(self, context: Context):\n            await ctx.send(\"I ran first\")\n        ```\n\n    Args:\n        coroutine: The coroutine to run\n\n    \"\"\"\n    if not asyncio.iscoroutinefunction(coroutine):\n        raise TypeError(\"Callback must be a coroutine\")\n\n    if not self.extension_postrun:\n        self.extension_postrun = []\n    self.extension_postrun.append(coroutine)\n</code></pre>"},{"location":"API%20Reference/models/Naff/extension/#naff.models.naff.extension.Extension.set_extension_error","title":"<code>set_extension_error(coroutine)</code>","text":"<p>Add a coroutine to handle any exceptions raised in this extension.</p> Example Usage: <p>```python def init(self, bot):     self.set_extension_error(self.example)</p> <p>Args:     coroutine: The coroutine to run</p> Source code in <code>naff\\models\\naff\\extension.py</code> <pre><code>def set_extension_error(self, coroutine: Callable[..., Coroutine]) -&gt; None:\n\"\"\"\n    Add a coroutine to handle any exceptions raised in this extension.\n\n    ??? Hint \"Example Usage:\"\n        ```python\n        def __init__(self, bot):\n            self.set_extension_error(self.example)\n\n    Args:\n        coroutine: The coroutine to run\n\n    \"\"\"\n    if not asyncio.iscoroutinefunction(coroutine):\n        raise TypeError(\"Callback must be a coroutine\")\n\n    if self.extension_error:\n        self.bot.logger.warning(\"Extension error callback has been overridden!\")\n    self.extension_error = coroutine\n</code></pre>"},{"location":"API%20Reference/models/Naff/hybrid_commands/","title":"Hybrid commands","text":""},{"location":"API%20Reference/models/Naff/hybrid_commands/#naff.models.naff.hybrid_commands.HybridCommand","title":"<code>HybridCommand</code>","text":"<p>         Bases: <code>SlashCommand</code></p> <p>A subclass of SlashCommand that handles the logic for hybrid commands.</p> Source code in <code>naff\\models\\naff\\hybrid_commands.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass HybridCommand(SlashCommand):\n\"\"\"A subclass of SlashCommand that handles the logic for hybrid commands.\"\"\"\n\n    async def __call__(self, context: InteractionContext, *args, **kwargs) -&gt; None:\n        new_ctx = context.bot.hybrid_context.from_interaction_context(context)\n        return await super().__call__(new_ctx, *args, **kwargs)\n\n    def group(self, name: str = None, description: str = \"No Description Set\") -&gt; \"HybridCommand\":\n        return HybridCommand(\n            name=self.name,\n            description=self.description,\n            group_name=name,\n            group_description=description,\n            scopes=self.scopes,\n        )\n\n    def subcommand(\n        self,\n        sub_cmd_name: LocalisedName | str,\n        group_name: LocalisedName | str = None,\n        sub_cmd_description: Absent[LocalisedDesc | str] = MISSING,\n        group_description: Absent[LocalisedDesc | str] = MISSING,\n        options: list[SlashCommandOption | dict] = None,\n        nsfw: bool = False,\n    ) -&gt; Callable[..., \"HybridCommand\"]:\n        def wrapper(call: Callable[..., Coroutine]) -&gt; \"HybridCommand\":\n            nonlocal sub_cmd_description\n\n            if not asyncio.iscoroutinefunction(call):\n                raise TypeError(\"Subcommand must be coroutine\")\n\n            if sub_cmd_description is MISSING:\n                sub_cmd_description = call.__doc__ or \"No Description Set\"\n\n            return HybridCommand(\n                name=self.name,\n                description=self.description,\n                group_name=group_name or self.group_name,\n                group_description=group_description or self.group_description,\n                sub_cmd_name=sub_cmd_name,\n                sub_cmd_description=sub_cmd_description,\n                default_member_permissions=self.default_member_permissions,\n                dm_permission=self.dm_permission,\n                options=options,\n                callback=call,\n                scopes=self.scopes,\n                nsfw=nsfw,\n            )\n\n        return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/hybrid_commands/#naff.models.naff.hybrid_commands.hybrid_command","title":"<code>hybrid_command(name, *, description=MISSING, scopes=MISSING, options=None, default_member_permissions=None, dm_permission=True, sub_cmd_name=None, group_name=None, sub_cmd_description='No Description Set', group_description='No Description Set', nsfw=False)</code>","text":"<p>A decorator to declare a coroutine as a hybrid command.</p> <p>Hybrid commands are a slash command that can also function as a prefixed command. These use a HybridContext instead of an InteractionContext, but otherwise are mostly identical to normal slash commands.</p> <p>Note that hybrid commands do not support autocompletes. They also only partially support attachments, allowing one attachment option for a command.</p> note <p>While the base and group descriptions aren't visible in the discord client, currently. We strongly advise defining them anyway, if you're using subcommands, as Discord has said they will be visible in one of the future ui updates. They are also visible as the description for their prefixed command counterparts.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | LocalisedName</code> <p>1-32 character name of the command</p> required <code>description</code> <code>Absent[str | LocalisedDesc]</code> <p>1-100 character description of the command</p> <code>MISSING</code> <code>scopes</code> <code>Absent[list[Snowflake_Type]]</code> <p>The scope this command exists within</p> <code>MISSING</code> <code>options</code> <code>Optional[list[SlashCommandOption | dict]]</code> <p>The parameters for the command, max 25</p> <code>None</code> <code>default_member_permissions</code> <code>Optional[Permissions]</code> <p>What permissions members need to have by default to use this command.</p> <code>None</code> <code>dm_permission</code> <code>bool</code> <p>Should this command be available in DMs.</p> <code>True</code> <code>sub_cmd_name</code> <code>str | LocalisedName</code> <p>1-32 character name of the subcommand</p> <code>None</code> <code>sub_cmd_description</code> <code>str | LocalisedDesc</code> <p>1-100 character description of the subcommand</p> <code>'No Description Set'</code> <code>group_name</code> <code>str | LocalisedName</code> <p>1-32 character name of the group</p> <code>None</code> <code>group_description</code> <code>str | LocalisedDesc</code> <p>1-100 character description of the group</p> <code>'No Description Set'</code> <code>nsfw</code> <code>bool</code> <p>This command should only work in NSFW channels</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., Coroutine]], HybridCommand]</code> <p>HybridCommand Object</p> Source code in <code>naff\\models\\naff\\hybrid_commands.py</code> <pre><code>def hybrid_command(\n    name: str | LocalisedName,\n    *,\n    description: Absent[str | LocalisedDesc] = MISSING,\n    scopes: Absent[list[\"Snowflake_Type\"]] = MISSING,\n    options: Optional[list[SlashCommandOption | dict]] = None,\n    default_member_permissions: Optional[\"Permissions\"] = None,\n    dm_permission: bool = True,\n    sub_cmd_name: str | LocalisedName = None,\n    group_name: str | LocalisedName = None,\n    sub_cmd_description: str | LocalisedDesc = \"No Description Set\",\n    group_description: str | LocalisedDesc = \"No Description Set\",\n    nsfw: bool = False,\n) -&gt; Callable[[Callable[..., Coroutine]], HybridCommand]:\n\"\"\"\n    A decorator to declare a coroutine as a hybrid command.\n\n    Hybrid commands are a slash command that can also function as a prefixed command.\n    These use a HybridContext instead of an InteractionContext, but otherwise are mostly identical to normal slash commands.\n\n    Note that hybrid commands do not support autocompletes.\n    They also only partially support attachments, allowing one attachment option for a command.\n\n    note:\n        While the base and group descriptions aren't visible in the discord client, currently.\n        We strongly advise defining them anyway, if you're using subcommands, as Discord has said they will be visible in\n        one of the future ui updates.\n        They are also visible as the description for their prefixed command counterparts.\n\n    Args:\n        name: 1-32 character name of the command\n        description: 1-100 character description of the command\n        scopes: The scope this command exists within\n        options: The parameters for the command, max 25\n        default_member_permissions: What permissions members need to have by default to use this command.\n        dm_permission: Should this command be available in DMs.\n        sub_cmd_name: 1-32 character name of the subcommand\n        sub_cmd_description: 1-100 character description of the subcommand\n        group_name: 1-32 character name of the group\n        group_description: 1-100 character description of the group\n        nsfw: This command should only work in NSFW channels\n\n    Returns:\n        HybridCommand Object\n\n    \"\"\"\n\n    def wrapper(func: Callable[..., Coroutine]) -&gt; HybridCommand:\n        if not asyncio.iscoroutinefunction(func):\n            raise ValueError(\"Commands must be coroutines\")\n\n        perm = default_member_permissions\n        if hasattr(func, \"default_member_permissions\"):\n            if perm:\n                perm = perm | func.default_member_permissions\n            else:\n                perm = func.default_member_permissions\n\n        _description = description\n        if _description is MISSING:\n            _description = func.__doc__ or \"No Description Set\"\n\n        return HybridCommand(\n            name=name,\n            group_name=group_name,\n            group_description=group_description,\n            sub_cmd_name=sub_cmd_name,\n            sub_cmd_description=sub_cmd_description,\n            description=_description,\n            scopes=scopes or [GLOBAL_SCOPE],\n            default_member_permissions=perm,\n            dm_permission=dm_permission,\n            callback=func,\n            options=options,\n            nsfw=nsfw,\n        )\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/hybrid_commands/#naff.models.naff.hybrid_commands.hybrid_subcommand","title":"<code>hybrid_subcommand(base, *, subcommand_group=None, name=None, description=MISSING, base_description=None, base_desc=None, base_default_member_permissions=None, base_dm_permission=True, subcommand_group_description=None, sub_group_desc=None, scopes=None, options=None, nsfw=False)</code>","text":"<p>A decorator specifically tailored for creating hybrid subcommands.</p> <p>See the hybrid_command decorator for more information.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>str | LocalisedName</code> <p>The name of the base command</p> required <code>subcommand_group</code> <code>Optional[str | LocalisedName]</code> <p>The name of the subcommand group, if any.</p> <code>None</code> <code>name</code> <code>Optional[str | LocalisedName]</code> <p>The name of the subcommand, defaults to the name of the coroutine.</p> <code>None</code> <code>description</code> <code>Absent[str | LocalisedDesc]</code> <p>The description of the subcommand</p> <code>MISSING</code> <code>base_description</code> <code>Optional[str | LocalisedDesc]</code> <p>The description of the base command</p> <code>None</code> <code>base_desc</code> <code>Optional[str | LocalisedDesc]</code> <p>An alias of <code>base_description</code></p> <code>None</code> <code>base_default_member_permissions</code> <code>Optional[Permissions]</code> <p>What permissions members need to have by default to use this command.</p> <code>None</code> <code>base_dm_permission</code> <code>bool</code> <p>Should this command be available in DMs.</p> <code>True</code> <code>subcommand_group_description</code> <code>Optional[str | LocalisedDesc]</code> <p>Description of the subcommand group</p> <code>None</code> <code>sub_group_desc</code> <code>Optional[str | LocalisedDesc]</code> <p>An alias for <code>subcommand_group_description</code></p> <code>None</code> <code>scopes</code> <code>list[Snowflake_Type]</code> <p>The scopes of which this command is available, defaults to GLOBAL_SCOPE</p> <code>None</code> <code>options</code> <code>list[dict]</code> <p>The options for this command</p> <code>None</code> <code>nsfw</code> <code>bool</code> <p>This command should only work in NSFW channels</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Coroutine], HybridCommand]</code> <p>A HybridCommand object</p> Source code in <code>naff\\models\\naff\\hybrid_commands.py</code> <pre><code>def hybrid_subcommand(\n    base: str | LocalisedName,\n    *,\n    subcommand_group: Optional[str | LocalisedName] = None,\n    name: Optional[str | LocalisedName] = None,\n    description: Absent[str | LocalisedDesc] = MISSING,\n    base_description: Optional[str | LocalisedDesc] = None,\n    base_desc: Optional[str | LocalisedDesc] = None,\n    base_default_member_permissions: Optional[\"Permissions\"] = None,\n    base_dm_permission: bool = True,\n    subcommand_group_description: Optional[str | LocalisedDesc] = None,\n    sub_group_desc: Optional[str | LocalisedDesc] = None,\n    scopes: list[\"Snowflake_Type\"] = None,\n    options: list[dict] = None,\n    nsfw: bool = False,\n) -&gt; Callable[[Coroutine], HybridCommand]:\n\"\"\"\n    A decorator specifically tailored for creating hybrid subcommands.\n\n    See the hybrid_command decorator for more information.\n\n    Args:\n        base: The name of the base command\n        subcommand_group: The name of the subcommand group, if any.\n        name: The name of the subcommand, defaults to the name of the coroutine.\n        description: The description of the subcommand\n        base_description: The description of the base command\n        base_desc: An alias of `base_description`\n        base_default_member_permissions: What permissions members need to have by default to use this command.\n        base_dm_permission: Should this command be available in DMs.\n        subcommand_group_description: Description of the subcommand group\n        sub_group_desc: An alias for `subcommand_group_description`\n        scopes: The scopes of which this command is available, defaults to GLOBAL_SCOPE\n        options: The options for this command\n        nsfw: This command should only work in NSFW channels\n\n    Returns:\n        A HybridCommand object\n\n    \"\"\"\n\n    def wrapper(func) -&gt; HybridCommand:\n        if not asyncio.iscoroutinefunction(func):\n            raise ValueError(\"Commands must be coroutines\")\n\n        _description = description\n        if _description is MISSING:\n            _description = func.__doc__ or \"No Description Set\"\n\n        return HybridCommand(\n            name=base,\n            description=(base_description or base_desc) or \"No Description Set\",\n            group_name=subcommand_group,\n            group_description=(subcommand_group_description or sub_group_desc) or \"No Description Set\",\n            sub_cmd_name=name,\n            sub_cmd_description=_description,\n            default_member_permissions=base_default_member_permissions,\n            dm_permission=base_dm_permission,\n            scopes=scopes or [GLOBAL_SCOPE],\n            callback=func,\n            options=options,\n            nsfw=nsfw,\n        )\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/listener/","title":"Listener","text":""},{"location":"API%20Reference/models/Naff/listener/#naff.models.naff.listener.Listener","title":"<code>Listener</code>","text":"<p>         Bases: <code>CallbackObject</code></p> Source code in <code>naff\\models\\naff\\listener.py</code> <pre><code>class Listener(CallbackObject):\n\n    event: str\n\"\"\"Name of the event to listen to.\"\"\"\n    callback: Coroutine\n\"\"\"Coroutine to call when the event is triggered.\"\"\"\n    is_default_listener: bool\n\"\"\"Whether this listener is provided automatically by the library, and might be unwanted by users.\"\"\"\n    disable_default_listeners: bool\n\"\"\"Whether this listener supersedes default listeners.  If true, any default listeners will be unregistered.\"\"\"\n    delay_until_ready: bool\n\"\"\"whether to delay the event until the client is ready\"\"\"\n\n    def __init__(\n        self,\n        func: Callable[..., Coroutine],\n        event: str,\n        *,\n        delay_until_ready: bool = False,\n        is_default_listener: bool = False,\n        disable_default_listeners: bool = False,\n    ) -&gt; None:\n        super().__init__()\n\n        if is_default_listener:\n            disable_default_listeners = False\n\n        self.event = event\n        self.callback = func\n        self.delay_until_ready = delay_until_ready\n        self.is_default_listener = is_default_listener\n        self.disable_default_listeners = disable_default_listeners\n\n    @classmethod\n    def create(\n        cls,\n        event_name: Absent[str | BaseEvent] = MISSING,\n        *,\n        delay_until_ready: bool = False,\n        is_default_listener: bool = False,\n        disable_default_listeners: bool = False,\n    ) -&gt; Callable[[Coroutine], \"Listener\"]:\n\"\"\"\n        Decorator for creating an event listener.\n\n        Args:\n            event_name: The name of the event to listen to. If left blank, event name will be inferred from the function name or parameter.\n            delay_until_ready: Whether to delay the listener until the client is ready.\n            is_default_listener: Whether this listener is provided automatically by the library, and might be unwanted by users.\n            disable_default_listeners: Whether this listener supersedes default listeners.  If true, any default listeners will be unregistered.\n\n\n        Returns:\n            A listener object.\n\n        \"\"\"\n\n        def wrapper(coro: Coroutine) -&gt; \"Listener\":\n            if not asyncio.iscoroutinefunction(coro):\n                raise TypeError(\"Listener must be a coroutine\")\n\n            name = event_name\n\n            if name is MISSING:\n                for typehint in coro.__annotations__.values():\n                    if (\n                        inspect.isclass(typehint)\n                        and issubclass(typehint, BaseEvent)\n                        and typehint.__name__ != \"RawGatewayEvent\"\n                    ):\n                        name = typehint.__name__\n                        break\n\n                if not name:\n                    name = coro.__name__\n\n            return cls(\n                coro,\n                get_event_name(name),\n                delay_until_ready=delay_until_ready,\n                is_default_listener=is_default_listener,\n                disable_default_listeners=disable_default_listeners,\n            )\n\n        return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/listener/#naff.models.naff.listener.Listener.create","title":"<code>create(event_name=MISSING, *, delay_until_ready=False, is_default_listener=False, disable_default_listeners=False)</code>  <code>classmethod</code>","text":"<p>Decorator for creating an event listener.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>Absent[str | BaseEvent]</code> <p>The name of the event to listen to. If left blank, event name will be inferred from the function name or parameter.</p> <code>MISSING</code> <code>delay_until_ready</code> <code>bool</code> <p>Whether to delay the listener until the client is ready.</p> <code>False</code> <code>is_default_listener</code> <code>bool</code> <p>Whether this listener is provided automatically by the library, and might be unwanted by users.</p> <code>False</code> <code>disable_default_listeners</code> <code>bool</code> <p>Whether this listener supersedes default listeners.  If true, any default listeners will be unregistered.</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Coroutine], Listener]</code> <p>A listener object.</p> Source code in <code>naff\\models\\naff\\listener.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    event_name: Absent[str | BaseEvent] = MISSING,\n    *,\n    delay_until_ready: bool = False,\n    is_default_listener: bool = False,\n    disable_default_listeners: bool = False,\n) -&gt; Callable[[Coroutine], \"Listener\"]:\n\"\"\"\n    Decorator for creating an event listener.\n\n    Args:\n        event_name: The name of the event to listen to. If left blank, event name will be inferred from the function name or parameter.\n        delay_until_ready: Whether to delay the listener until the client is ready.\n        is_default_listener: Whether this listener is provided automatically by the library, and might be unwanted by users.\n        disable_default_listeners: Whether this listener supersedes default listeners.  If true, any default listeners will be unregistered.\n\n\n    Returns:\n        A listener object.\n\n    \"\"\"\n\n    def wrapper(coro: Coroutine) -&gt; \"Listener\":\n        if not asyncio.iscoroutinefunction(coro):\n            raise TypeError(\"Listener must be a coroutine\")\n\n        name = event_name\n\n        if name is MISSING:\n            for typehint in coro.__annotations__.values():\n                if (\n                    inspect.isclass(typehint)\n                    and issubclass(typehint, BaseEvent)\n                    and typehint.__name__ != \"RawGatewayEvent\"\n                ):\n                    name = typehint.__name__\n                    break\n\n            if not name:\n                name = coro.__name__\n\n        return cls(\n            coro,\n            get_event_name(name),\n            delay_until_ready=delay_until_ready,\n            is_default_listener=is_default_listener,\n            disable_default_listeners=disable_default_listeners,\n        )\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/listener/#naff.models.naff.listener.listen","title":"<code>listen(event_name=MISSING, *, delay_until_ready=False, is_default_listener=False, disable_default_listeners=False)</code>","text":"<p>Decorator to make a function an event listener.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>Absent[str | BaseEvent]</code> <p>The name of the event to listen to. If left blank, event name will be inferred from the function name or parameter.</p> <code>MISSING</code> <code>delay_until_ready</code> <code>bool</code> <p>Whether to delay the listener until the client is ready.</p> <code>False</code> <code>is_default_listener</code> <code>bool</code> <p>Whether this listener is provided automatically by the library, and might be unwanted by users.</p> <code>False</code> <code>disable_default_listeners</code> <code>bool</code> <p>Whether this listener supersedes default listeners.  If true, any default listeners will be unregistered.</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., Coroutine]], Listener]</code> <p>A listener object.</p> Source code in <code>naff\\models\\naff\\listener.py</code> <pre><code>def listen(\n    event_name: Absent[str | BaseEvent] = MISSING,\n    *,\n    delay_until_ready: bool = False,\n    is_default_listener: bool = False,\n    disable_default_listeners: bool = False,\n) -&gt; Callable[[Callable[..., Coroutine]], Listener]:\n\"\"\"\n    Decorator to make a function an event listener.\n\n    Args:\n        event_name: The name of the event to listen to. If left blank, event name will be inferred from the function name or parameter.\n        delay_until_ready: Whether to delay the listener until the client is ready.\n        is_default_listener: Whether this listener is provided automatically by the library, and might be unwanted by users.\n        disable_default_listeners: Whether this listener supersedes default listeners.  If true, any default listeners will be unregistered.\n\n\n    Returns:\n        A listener object.\n\n    \"\"\"\n    return Listener.create(\n        event_name,\n        delay_until_ready=delay_until_ready,\n        is_default_listener=is_default_listener,\n        disable_default_listeners=disable_default_listeners,\n    )\n</code></pre>"},{"location":"API%20Reference/models/Naff/localisation/","title":"Localisation","text":""},{"location":"API%20Reference/models/Naff/localisation/#naff.models.naff.localisation.LocalisedField","title":"<code>LocalisedField</code>","text":"<p>An object that enables support for localising fields.</p> <p>Supported locales: https://discord.com/developers/docs/reference#locales</p> Source code in <code>naff\\models\\naff\\localisation.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, slots=False)\nclass LocalisedField:\n\"\"\"\n    An object that enables support for localising fields.\n\n    Supported locales: https://discord.com/developers/docs/reference#locales\n    \"\"\"\n\n    default_locale: str = attrs.field(repr=False, default=const.default_locale)\n\n    bulgarian: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"bg\"})\n    chinese_china: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"zh-CN\"})\n    chinese_taiwan: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"zh-TW\"})\n    croatian: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"hr\"})\n    czech: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"cs\"})\n    danish: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"da\"})\n    dutch: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"nl\"})\n    english_uk: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"en-GB\"})\n    english_us: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"en-US\"})\n    finnish: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"fi\"})\n    french: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"fr\"})\n    german: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"de\"})\n    greek: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"el\"})\n    hindi: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"hi\"})\n    hungarian: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"hu\"})\n    italian: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"it\"})\n    japanese: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"ja\"})\n    korean: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"ko\"})\n    lithuanian: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"lt\"})\n    norwegian: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"no\"})\n    polish: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"pl\"})\n    portuguese_brazilian: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"pt-BR\"})\n    romanian_romania: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"ro\"})\n    russian: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"ru\"})\n    spanish: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"es-ES\"})\n    swedish: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"sv-SE\"})\n    thai: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"th\"})\n    turkish: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"tr\"})\n    ukrainian: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"uk\"})\n    vietnamese: str | None = attrs.field(repr=False, default=None, metadata={\"locale-code\": \"vi\"})\n\n    def __str__(self) -&gt; str:\n        return str(self.default)\n\n    def __bool__(self) -&gt; bool:\n        return self.default is not None\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}: default_locale={self.default_locale}, value='{self}'&gt;\"\n\n    @cached_property\n    def _code_mapping(self) -&gt; dict:\n\"\"\"Generates a lookup table for this object on demand to allow for value retrieval with locale codes\"\"\"\n        data = {}\n        for attr in self.__attrs_attrs__:\n            if attr.name != self.default_locale:\n                if code := attr.metadata.get(\"locale-code\"):\n                    data[code] = attr.name\n        return data\n\n    @property\n    def default(self) -&gt; str:\n\"\"\"The default value based on the CONST default_locale\"\"\"\n        return getattr(self, self.default_locale)\n\n    def get_locale(self, locale: str) -&gt; str:\n\"\"\"\n        Get the value for the specified locale. Supports locale-codes and locale names.\n\n        Args:\n            locale: The locale to fetch\n\n        Returns:\n            The localised string, or the default value\n        \"\"\"\n        if val := getattr(self, locale, None):\n            # Attempt to retrieve an attribute with the specified locale\n            return val\n        if attr := self._code_mapping.get(locale):\n            # assume the locale is a code, and attempt to find an attribute with that code\n            if val := getattr(self, attr, None):\n                # if the value isn't None, return\n                return val\n\n        # no value was found, return default\n        return self.default\n\n    @classmethod\n    def converter(cls, value: str | None) -&gt; \"LocalisedField\":\n        if isinstance(value, LocalisedField):\n            return value\n        obj = cls()\n        if value:\n            obj.__setattr__(obj.default_locale, str(value))\n\n        return obj\n\n    @default_locale.validator\n    def _default_locale_validator(self, _, value: str) -&gt; None:\n        try:\n            getattr(self, value)\n        except AttributeError:\n            raise ValueError(f\"`{value}` is not a supported default localisation\") from None\n\n    def as_dict(self) -&gt; str:\n        return str(self)\n\n    def to_locale_dict(self) -&gt; dict:\n        data = {}\n        for attr in self.__attrs_attrs__:\n            if attr.name != self.default_locale:\n                if \"locale-code\" in attr.metadata:\n                    if val := getattr(self, attr.name):\n                        data[attr.metadata[\"locale-code\"]] = val\n\n        if not data:\n            data = None  # handle discord being stupid\n        return data\n</code></pre>"},{"location":"API%20Reference/models/Naff/localisation/#naff.models.naff.localisation.LocalisedField.default","title":"<code>default: str</code>  <code>property</code>","text":"<p>The default value based on the CONST default_locale</p>"},{"location":"API%20Reference/models/Naff/localisation/#naff.models.naff.localisation.LocalisedField.get_locale","title":"<code>get_locale(locale)</code>","text":"<p>Get the value for the specified locale. Supports locale-codes and locale names.</p> <p>Parameters:</p> Name Type Description Default <code>locale</code> <code>str</code> <p>The locale to fetch</p> required <p>Returns:</p> Type Description <code>str</code> <p>The localised string, or the default value</p> Source code in <code>naff\\models\\naff\\localisation.py</code> <pre><code>def get_locale(self, locale: str) -&gt; str:\n\"\"\"\n    Get the value for the specified locale. Supports locale-codes and locale names.\n\n    Args:\n        locale: The locale to fetch\n\n    Returns:\n        The localised string, or the default value\n    \"\"\"\n    if val := getattr(self, locale, None):\n        # Attempt to retrieve an attribute with the specified locale\n        return val\n    if attr := self._code_mapping.get(locale):\n        # assume the locale is a code, and attempt to find an attribute with that code\n        if val := getattr(self, attr, None):\n            # if the value isn't None, return\n            return val\n\n    # no value was found, return default\n    return self.default\n</code></pre>"},{"location":"API%20Reference/models/Naff/prefixed_commands/","title":"Prefixed commands","text":""},{"location":"API%20Reference/models/Naff/prefixed_commands/#naff.models.naff.prefixed_commands.PrefixedCommandParameter","title":"<code>PrefixedCommandParameter</code>","text":"<p>An object representing parameters in a prefixed command.</p> <p>This class should not be instantiated directly.</p> Source code in <code>naff\\models\\naff\\prefixed_commands.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, slots=True)\nclass PrefixedCommandParameter:\n\"\"\"\n    An object representing parameters in a prefixed command.\n\n    This class should not be instantiated directly.\n    \"\"\"\n\n    name: str = attrs.field(default=None, metadata=docs(\"The name of the parameter.\"))\n    default: Optional[Any] = attrs.field(default=None, metadata=docs(\"The default value of the parameter.\"))\n    type: Type = attrs.field(\n        default=None, metadata=docs(\"The type of the parameter.\")\n    )  # yes i can use type here, mkdocs doesnt like that\n    kind: inspect._ParameterKind = attrs.field(default=inspect.Parameter.POSITIONAL_OR_KEYWORD)\n\"\"\"The kind of parameter this is as related to the function.\"\"\"\n    converters: list[Callable[[\"PrefixedContext\", str], Any]] = attrs.field(\n        factory=list, metadata=docs(\"A list of the converter functions for the parameter that convert to its type.\")\n    )\n    greedy: bool = attrs.field(default=False, metadata=docs(\"Is the parameter greedy?\"))\n    union: bool = attrs.field(default=False, metadata=docs(\"Is the parameter a union?\"))\n    variable: bool = attrs.field(default=False, metadata=docs(\"Was the parameter marked as a variable argument?\"))\n    consume_rest: bool = attrs.field(\n        default=False, metadata=docs(\"Was the parameter marked to consume the rest of the input?\")\n    )\n    no_argument: bool = attrs.field(\n        default=False, metadata=docs(\"Does this parameter have a converter that subclasses `NoArgumentConverter`?\")\n    )\n\n    @property\n    def optional(self) -&gt; bool:\n\"\"\"Is this parameter optional?\"\"\"\n        return self.default != MISSING\n</code></pre>"},{"location":"API%20Reference/models/Naff/prefixed_commands/#naff.models.naff.prefixed_commands.PrefixedCommandParameter.kind","title":"<code>kind: inspect._ParameterKind = attrs.field(default=inspect.Parameter.POSITIONAL_OR_KEYWORD)</code>  <code>class-attribute</code>","text":"<p>The kind of parameter this is as related to the function.</p>"},{"location":"API%20Reference/models/Naff/prefixed_commands/#naff.models.naff.prefixed_commands.PrefixedCommandParameter.optional","title":"<code>optional: bool</code>  <code>property</code>","text":"<p>Is this parameter optional?</p>"},{"location":"API%20Reference/models/Naff/prefixed_commands/#naff.models.naff.prefixed_commands.PrefixedCommand","title":"<code>PrefixedCommand</code>","text":"<p>         Bases: <code>BaseCommand</code></p> Source code in <code>naff\\models\\naff\\prefixed_commands.py</code> <pre><code>@attrs.define(eq=False, order=False, hash=False, kw_only=True)\nclass PrefixedCommand(BaseCommand):\n    name: str = attrs.field(repr=False, metadata=docs(\"The name of the command.\"))\n    parameters: list[PrefixedCommandParameter] = attrs.field(\n        repr=False, metadata=docs(\"The parameters of the command.\"), factory=list\n    )\n    aliases: list[str] = attrs.field(\n        metadata=docs(\"The list of aliases the command can be invoked under.\"),\n        factory=list,\n    )\n    hidden: bool = attrs.field(\n        metadata=docs(\"If `True`, help commands should not show this in the help output (unless toggled to do so).\"),\n        default=False,\n    )\n    ignore_extra: bool = attrs.field(\n        metadata=docs(\n            \"If `True`, ignores extraneous strings passed to a command if all its requirements are met (e.g. ?foo a b c\"\n            \" when only expecting a and b). Otherwise, an error is raised. Defaults to True.\"\n        ),\n        default=True,\n    )\n    hierarchical_checking: bool = attrs.field(\n        metadata=docs(\n            \"If `True` and if the base of a subcommand, every subcommand underneath it will run this command's checks\"\n            \" and cooldowns before its own. Otherwise, only the subcommand's checks are checked.\"\n        ),\n        default=True,\n    )\n    help: Optional[str] = attrs.field(repr=False, metadata=docs(\"The long help text for the command.\"), default=None)\n    brief: Optional[str] = attrs.field(repr=False, metadata=docs(\"The short help text for the command.\"), default=None)\n    parent: Optional[\"PrefixedCommand\"] = attrs.field(\n        repr=False, metadata=docs(\"The parent command, if applicable.\"), default=None\n    )\n    subcommands: dict[str, \"PrefixedCommand\"] = attrs.field(\n        repr=False, metadata=docs(\"A dict of all subcommands for the command.\"), factory=dict\n    )\n    _usage: Optional[str] = attrs.field(repr=False, default=None)\n    _inspect_signature: Optional[inspect.Signature] = attrs.field(repr=False, default=None)\n\n    def __attrs_post_init__(self) -&gt; None:\n        super().__attrs_post_init__()  # we want checks to work\n\n        # we have to do this afterwards as these rely on the callback\n        # and its own value, which is impossible to get with attrs\n        # methods, i think\n\n        if self.help:\n            self.help = inspect.cleandoc(self.help)\n        else:\n            self.help = inspect.getdoc(self.callback)\n            if isinstance(self.help, bytes):\n                self.help = self.help.decode(\"utf-8\")\n\n        if self.brief is None:\n            self.brief = self.help.splitlines()[0] if self.help is not None else None\n\n    @property\n    def usage(self) -&gt; str:\n\"\"\"\n        A string displaying how the command can be used.\n\n        If no string is set, it will default to the command's signature.\n        Useful for help commands.\n        \"\"\"\n        return self._usage or self.signature\n\n    @usage.setter\n    def usage(self, usage: str) -&gt; None:\n        self._usage = usage\n\n    @property\n    def qualified_name(self) -&gt; str:\n\"\"\"Returns the full qualified name of this command.\"\"\"\n        name_deq = deque()\n        command = self\n\n        while command.parent is not None:\n            name_deq.appendleft(command.name)\n            command = command.parent\n\n        name_deq.appendleft(command.name)\n        return \" \".join(name_deq)\n\n    @property\n    def all_subcommands(self) -&gt; frozenset[\"PrefixedCommand\"]:\n\"\"\"Returns all unique subcommands underneath this command.\"\"\"\n        return frozenset(self.subcommands.values())\n\n    @property\n    def signature(self) -&gt; str:\n\"\"\"Returns a POSIX-like signature useful for help command output.\"\"\"\n        if not self.parameters:\n            return \"\"\n\n        results = []\n\n        for param in self.parameters:\n            anno = param.type\n            name = param.name\n\n            if typing.get_origin(anno) == Annotated:\n                anno = typing.get_args(anno)[1]\n\n            if not param.greedy and param.union:\n                union_args = typing.get_args(anno)\n                if len(union_args) == 2 and param.optional:\n                    anno = union_args[0]\n\n            if typing.get_origin(anno) is Literal:\n                # it's better to list the values it can be than display the variable name itself\n                name = \"|\".join(f'\"{v}\"' if isinstance(v, str) else str(v) for v in typing.get_args(anno))\n\n            # we need to do a lot of manipulations with the signature\n            # string, so using a deque as a string builder makes sense for performance\n            result_builder: deque[str] = deque()\n\n            if param.optional and param.default is not None:\n                # it would be weird making it look like name=None\n                result_builder.append(f\"{name}={param.default}\")\n            else:\n                result_builder.append(name)\n\n            if param.variable:\n                # this is inside the brackets\n                result_builder.append(\"...\")\n\n            # surround the result with brackets\n            if param.optional:\n                result_builder.appendleft(\"[\")\n                result_builder.append(\"]\")\n            else:\n                result_builder.appendleft(\"&lt;\")\n                result_builder.append(\"&gt;\")\n\n            if param.greedy:\n                # this is outside the brackets, making it differentiable from\n                # a variable argument\n                result_builder.append(\"...\")\n\n            results.append(\"\".join(result_builder))\n\n        return \" \".join(results)\n\n    @property\n    def is_subcommand(self) -&gt; bool:\n\"\"\"Return whether this command is a subcommand or not.\"\"\"\n        return bool(self.parent)\n\n    def _parse_parameters(self) -&gt; None:\n\"\"\"\n        Parses the parameters that this command has into a form naff can use.\n\n        This is purposely separated like this to allow \"lazy parsing\" - parsing\n        as the command is added to a bot rather than being parsed immediately.\n        This allows variables like \"self\" to be filtered out, and is useful for\n        potential future additions.\n        \"\"\"\n        # clear out old parameters just in case\n        self.parameters = []\n\n        if not self._inspect_signature:\n            # we don't care about the ctx or self variables\n            if self.has_binding:\n                callback = functools.partial(self.callback, None, None)\n            else:\n                callback = functools.partial(self.callback, None)\n\n            self._inspect_signature = inspect.signature(callback)\n\n        params = self._inspect_signature.parameters\n\n        # this is used by keyword-only and variable args to make sure there isn't more than one of either\n        # mind you, we also don't want one keyword-only and one variable arg either\n        finished_params = False\n\n        for name, param in params.items():\n            if finished_params:\n                raise ValueError(\"Cannot have multiple keyword-only or variable arguments.\")\n\n            cmd_param = PrefixedCommandParameter()\n            cmd_param.name = name\n            cmd_param.kind = param.kind\n            cmd_param.default = param.default if param.default is not param.empty else MISSING\n\n            cmd_param.type = anno = param.annotation\n\n            if typing.get_origin(anno) == Greedy:\n                anno, default = _greedy_parse(anno, param)\n\n                if default is not param.empty:\n                    cmd_param.default = default\n                cmd_param.greedy = True\n\n            if typing.get_origin(anno) in {Union, UnionType}:\n                cmd_param.union = True\n                for arg in typing.get_args(anno):\n                    if _check_for_no_arg(anno):\n                        cmd_param.no_argument = True\n\n                    if arg != NoneType:\n                        converter = _get_converter(arg, name)\n                        cmd_param.converters.append(converter)\n                    elif not cmd_param.optional:  # d.py-like behavior\n                        cmd_param.default = None\n            else:\n                if _check_for_no_arg(anno):\n                    cmd_param.no_argument = True\n\n                converter = _get_converter(anno, name)\n                cmd_param.converters.append(converter)\n\n            match param.kind:\n                case param.KEYWORD_ONLY:\n                    if cmd_param.greedy:\n                        raise ValueError(\"Keyword-only arguments cannot be Greedy.\")\n\n                    cmd_param.consume_rest = True\n                    finished_params = True\n                case param.VAR_POSITIONAL:\n                    if cmd_param.optional:\n                        # there's a lot of parser ambiguities here, so i'd rather not\n                        raise ValueError(\"Variable arguments cannot have default values or be Optional.\")\n                    if cmd_param.greedy:\n                        raise ValueError(\"Variable arguments cannot be Greedy.\")\n\n                    cmd_param.variable = True\n                    finished_params = True\n\n            self.parameters.append(cmd_param)\n\n        # we need to deal with subcommands too\n        for command in self.all_subcommands:\n            command._parse_parameters()\n\n    def add_command(self, cmd: \"PrefixedCommand\") -&gt; None:\n\"\"\"\n        Adds a command as a subcommand to this command.\n\n        Args:\n            cmd: The command to add\n        \"\"\"\n        cmd.parent = self  # just so we know this is a subcommand\n\n        if self.subcommands.get(cmd.name):\n            raise ValueError(\n                f\"Duplicate command! Multiple commands share the name/alias: {self.qualified_name} {cmd.name}.\"\n            )\n        self.subcommands[cmd.name] = cmd\n\n        for alias in cmd.aliases:\n            if self.subcommands.get(alias):\n                raise ValueError(\n                    f\"Duplicate command! Multiple commands share the name/alias: {self.qualified_name} {cmd.name}.\"\n                )\n            self.subcommands[alias] = cmd\n\n    def remove_command(self, name: str) -&gt; None:\n\"\"\"\n        Removes a command as a subcommand from this command.\n\n        If an alias is specified, only the alias will be removed.\n\n        Args:\n            name: The command to remove.\n        \"\"\"\n        command = self.subcommands.pop(name, None)\n\n        if command is None:\n            return\n\n        if name in command.aliases:\n            command.aliases.remove(name)\n            return\n\n        for alias in command.aliases:\n            self.subcommands.pop(alias, None)\n\n    def get_command(self, name: str) -&gt; Optional[\"PrefixedCommand\"]:\n\"\"\"\n        Gets a subcommand from this command. Can get subcommands of subcommands if needed.\n\n        Args:\n            name: The command to search for.\n\n        Returns:\n            PrefixedCommand: The command object, if found.\n        \"\"\"\n        if \" \" not in name:\n            return self.subcommands.get(name)\n\n        names = name.split()\n        if not names:\n            return None\n\n        cmd = self.subcommands.get(names[0])\n        if not cmd or not cmd.subcommands:\n            return cmd\n\n        for name in names[1:]:\n            try:\n                cmd = cmd.subcommands[name]\n            except (AttributeError, KeyError):\n                return None\n\n        return cmd\n\n    def subcommand(\n        self,\n        name: Optional[str] = None,\n        *,\n        aliases: Optional[list[str]] = None,\n        help: Optional[str] = None,\n        brief: Optional[str] = None,\n        usage: Optional[str] = None,\n        enabled: bool = True,\n        hidden: bool = False,\n        ignore_extra: bool = True,\n        hierarchical_checking: bool = True,\n    ) -&gt; (Callable[..., \"PrefixedCommand\"]):\n\"\"\"\n        A decorator to declare a subcommand for a prefixed command.\n\n        Args:\n            name: The name of the command. Defaults to the name of the coroutine.\n            aliases: The list of aliases the command can be invoked under.\n            help: The long help text for the command. Defaults to the docstring of the coroutine, if there is one.\n            brief: The short help text for the command. Defaults to the first line of the help text, if there is one.\n            usage: A string displaying how the command can be used. If no string is set, it will default to the command's signature. Useful for help commands.\n            enabled: Whether this command can be run at all.\n            hidden: If `True`, the default help command (when it is added) does not show this in the help output.\n            ignore_extra: If `True`, ignores extraneous strings passed to a command if all its requirements are met (e.g. ?foo a b c when only expecting a and b). Otherwise, an error is raised.\n            hierarchical_checking: If `True` and if the base of a subcommand, every subcommand underneath it will run this command's checks before its own. Otherwise, only the subcommand's checks are checked.\n        \"\"\"\n\n        def wrapper(func: Callable) -&gt; \"PrefixedCommand\":\n            cmd = PrefixedCommand(  # type: ignore\n                callback=func,\n                name=name or func.__name__,\n                aliases=aliases or [],\n                help=help,\n                brief=brief,\n                usage=usage,  # type: ignore\n                enabled=enabled,\n                hidden=hidden,\n                ignore_extra=ignore_extra,\n                hierarchical_checking=hierarchical_checking,\n            )\n            self.add_command(cmd)\n            return cmd\n\n        return wrapper\n\n    async def call_callback(self, callback: Callable, ctx: \"PrefixedContext\") -&gt; None:\n\"\"\"\n        Runs the callback of this command.\n\n        Args:\n            callback (Callable: The callback to run. This is provided for compatibility with naff.\n            ctx (naff.MessageContext): The context to use for this command.\n        \"\"\"\n        # sourcery skip: remove-empty-nested-block, remove-redundant-if, remove-unnecessary-else\n        if len(self.parameters) == 0:\n            if ctx.args and not self.ignore_extra:\n                raise BadArgument(f\"Too many arguments passed to {self.name}.\")\n            return await self.call_with_binding(callback, ctx)\n        else:\n            # this is slightly costly, but probably worth it\n            new_args: list[Any] = []\n            kwargs: dict[str, Any] = {}\n            args = _PrefixedArgsIterator(tuple(ctx.args))\n            param_index = 0\n\n            for arg in args:\n                while param_index &lt; len(self.parameters):\n                    param = self.parameters[param_index]\n\n                    if param.consume_rest:\n                        arg = args.consume_rest()\n\n                    if param.variable:\n                        args_to_convert = args.get_rest_of_args()\n                        new_arg = [await _convert(param, ctx, arg) for arg in args_to_convert]\n                        new_arg = tuple(arg[0] for arg in new_arg)\n                        new_args.extend(new_arg)\n                        param_index += 1\n                        break\n\n                    if param.greedy:\n                        greedy_args, broke_off = await _greedy_convert(param, ctx, args)\n\n                        new_args.append(greedy_args)\n                        param_index += 1\n                        if broke_off:\n                            args.back()\n\n                        if param.default:\n                            continue\n                        else:\n                            break\n\n                    converted, used_default = await _convert(param, ctx, arg)\n                    if param.kind in {\n                        inspect.Parameter.POSITIONAL_ONLY,\n                        inspect.Parameter.VAR_POSITIONAL,\n                    }:\n                        new_args.append(converted)\n                    else:\n                        kwargs[param.name] = converted\n                    param_index += 1\n\n                    if not used_default:\n                        break\n\n            if param_index &lt; len(self.parameters):\n                for param in self.parameters[param_index:]:\n                    if param.no_argument:\n                        converted, _ = await _convert(param, ctx, None)  # type: ignore\n                        if not param.consume_rest:\n                            new_args.append(converted)\n                        else:\n                            kwargs[param.name] = converted\n                            break\n                        continue\n\n                    if not param.optional:\n                        raise BadArgument(f\"{param.name} is a required argument that is missing.\")\n                    else:\n                        if param.kind in {\n                            inspect.Parameter.POSITIONAL_ONLY,\n                            inspect.Parameter.VAR_POSITIONAL,\n                        }:\n                            new_args.append(param.default)\n                        else:\n                            kwargs[param.name] = param.default\n                            break\n            elif not self.ignore_extra and not args.finished:\n                raise BadArgument(f\"Too many arguments passed to {self.name}.\")\n\n            return await self.call_with_binding(callback, ctx, *new_args, **kwargs)\n</code></pre>"},{"location":"API%20Reference/models/Naff/prefixed_commands/#naff.models.naff.prefixed_commands.PrefixedCommand.usage","title":"<code>usage: str</code>  <code>property</code> <code>writable</code>","text":"<p>A string displaying how the command can be used.</p> <p>If no string is set, it will default to the command's signature. Useful for help commands.</p>"},{"location":"API%20Reference/models/Naff/prefixed_commands/#naff.models.naff.prefixed_commands.PrefixedCommand.qualified_name","title":"<code>qualified_name: str</code>  <code>property</code>","text":"<p>Returns the full qualified name of this command.</p>"},{"location":"API%20Reference/models/Naff/prefixed_commands/#naff.models.naff.prefixed_commands.PrefixedCommand.all_subcommands","title":"<code>all_subcommands: frozenset[PrefixedCommand]</code>  <code>property</code>","text":"<p>Returns all unique subcommands underneath this command.</p>"},{"location":"API%20Reference/models/Naff/prefixed_commands/#naff.models.naff.prefixed_commands.PrefixedCommand.signature","title":"<code>signature: str</code>  <code>property</code>","text":"<p>Returns a POSIX-like signature useful for help command output.</p>"},{"location":"API%20Reference/models/Naff/prefixed_commands/#naff.models.naff.prefixed_commands.PrefixedCommand.is_subcommand","title":"<code>is_subcommand: bool</code>  <code>property</code>","text":"<p>Return whether this command is a subcommand or not.</p>"},{"location":"API%20Reference/models/Naff/prefixed_commands/#naff.models.naff.prefixed_commands.PrefixedCommand.add_command","title":"<code>add_command(cmd)</code>","text":"<p>Adds a command as a subcommand to this command.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>PrefixedCommand</code> <p>The command to add</p> required Source code in <code>naff\\models\\naff\\prefixed_commands.py</code> <pre><code>def add_command(self, cmd: \"PrefixedCommand\") -&gt; None:\n\"\"\"\n    Adds a command as a subcommand to this command.\n\n    Args:\n        cmd: The command to add\n    \"\"\"\n    cmd.parent = self  # just so we know this is a subcommand\n\n    if self.subcommands.get(cmd.name):\n        raise ValueError(\n            f\"Duplicate command! Multiple commands share the name/alias: {self.qualified_name} {cmd.name}.\"\n        )\n    self.subcommands[cmd.name] = cmd\n\n    for alias in cmd.aliases:\n        if self.subcommands.get(alias):\n            raise ValueError(\n                f\"Duplicate command! Multiple commands share the name/alias: {self.qualified_name} {cmd.name}.\"\n            )\n        self.subcommands[alias] = cmd\n</code></pre>"},{"location":"API%20Reference/models/Naff/prefixed_commands/#naff.models.naff.prefixed_commands.PrefixedCommand.remove_command","title":"<code>remove_command(name)</code>","text":"<p>Removes a command as a subcommand from this command.</p> <p>If an alias is specified, only the alias will be removed.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The command to remove.</p> required Source code in <code>naff\\models\\naff\\prefixed_commands.py</code> <pre><code>def remove_command(self, name: str) -&gt; None:\n\"\"\"\n    Removes a command as a subcommand from this command.\n\n    If an alias is specified, only the alias will be removed.\n\n    Args:\n        name: The command to remove.\n    \"\"\"\n    command = self.subcommands.pop(name, None)\n\n    if command is None:\n        return\n\n    if name in command.aliases:\n        command.aliases.remove(name)\n        return\n\n    for alias in command.aliases:\n        self.subcommands.pop(alias, None)\n</code></pre>"},{"location":"API%20Reference/models/Naff/prefixed_commands/#naff.models.naff.prefixed_commands.PrefixedCommand.get_command","title":"<code>get_command(name)</code>","text":"<p>Gets a subcommand from this command. Can get subcommands of subcommands if needed.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The command to search for.</p> required <p>Returns:</p> Name Type Description <code>PrefixedCommand</code> <code>Optional[PrefixedCommand]</code> <p>The command object, if found.</p> Source code in <code>naff\\models\\naff\\prefixed_commands.py</code> <pre><code>def get_command(self, name: str) -&gt; Optional[\"PrefixedCommand\"]:\n\"\"\"\n    Gets a subcommand from this command. Can get subcommands of subcommands if needed.\n\n    Args:\n        name: The command to search for.\n\n    Returns:\n        PrefixedCommand: The command object, if found.\n    \"\"\"\n    if \" \" not in name:\n        return self.subcommands.get(name)\n\n    names = name.split()\n    if not names:\n        return None\n\n    cmd = self.subcommands.get(names[0])\n    if not cmd or not cmd.subcommands:\n        return cmd\n\n    for name in names[1:]:\n        try:\n            cmd = cmd.subcommands[name]\n        except (AttributeError, KeyError):\n            return None\n\n    return cmd\n</code></pre>"},{"location":"API%20Reference/models/Naff/prefixed_commands/#naff.models.naff.prefixed_commands.PrefixedCommand.subcommand","title":"<code>subcommand(name=None, *, aliases=None, help=None, brief=None, usage=None, enabled=True, hidden=False, ignore_extra=True, hierarchical_checking=True)</code>","text":"<p>A decorator to declare a subcommand for a prefixed command.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the command. Defaults to the name of the coroutine.</p> <code>None</code> <code>aliases</code> <code>Optional[list[str]]</code> <p>The list of aliases the command can be invoked under.</p> <code>None</code> <code>help</code> <code>Optional[str]</code> <p>The long help text for the command. Defaults to the docstring of the coroutine, if there is one.</p> <code>None</code> <code>brief</code> <code>Optional[str]</code> <p>The short help text for the command. Defaults to the first line of the help text, if there is one.</p> <code>None</code> <code>usage</code> <code>Optional[str]</code> <p>A string displaying how the command can be used. If no string is set, it will default to the command's signature. Useful for help commands.</p> <code>None</code> <code>enabled</code> <code>bool</code> <p>Whether this command can be run at all.</p> <code>True</code> <code>hidden</code> <code>bool</code> <p>If <code>True</code>, the default help command (when it is added) does not show this in the help output.</p> <code>False</code> <code>ignore_extra</code> <code>bool</code> <p>If <code>True</code>, ignores extraneous strings passed to a command if all its requirements are met (e.g. ?foo a b c when only expecting a and b). Otherwise, an error is raised.</p> <code>True</code> <code>hierarchical_checking</code> <code>bool</code> <p>If <code>True</code> and if the base of a subcommand, every subcommand underneath it will run this command's checks before its own. Otherwise, only the subcommand's checks are checked.</p> <code>True</code> Source code in <code>naff\\models\\naff\\prefixed_commands.py</code> <pre><code>def subcommand(\n    self,\n    name: Optional[str] = None,\n    *,\n    aliases: Optional[list[str]] = None,\n    help: Optional[str] = None,\n    brief: Optional[str] = None,\n    usage: Optional[str] = None,\n    enabled: bool = True,\n    hidden: bool = False,\n    ignore_extra: bool = True,\n    hierarchical_checking: bool = True,\n) -&gt; (Callable[..., \"PrefixedCommand\"]):\n\"\"\"\n    A decorator to declare a subcommand for a prefixed command.\n\n    Args:\n        name: The name of the command. Defaults to the name of the coroutine.\n        aliases: The list of aliases the command can be invoked under.\n        help: The long help text for the command. Defaults to the docstring of the coroutine, if there is one.\n        brief: The short help text for the command. Defaults to the first line of the help text, if there is one.\n        usage: A string displaying how the command can be used. If no string is set, it will default to the command's signature. Useful for help commands.\n        enabled: Whether this command can be run at all.\n        hidden: If `True`, the default help command (when it is added) does not show this in the help output.\n        ignore_extra: If `True`, ignores extraneous strings passed to a command if all its requirements are met (e.g. ?foo a b c when only expecting a and b). Otherwise, an error is raised.\n        hierarchical_checking: If `True` and if the base of a subcommand, every subcommand underneath it will run this command's checks before its own. Otherwise, only the subcommand's checks are checked.\n    \"\"\"\n\n    def wrapper(func: Callable) -&gt; \"PrefixedCommand\":\n        cmd = PrefixedCommand(  # type: ignore\n            callback=func,\n            name=name or func.__name__,\n            aliases=aliases or [],\n            help=help,\n            brief=brief,\n            usage=usage,  # type: ignore\n            enabled=enabled,\n            hidden=hidden,\n            ignore_extra=ignore_extra,\n            hierarchical_checking=hierarchical_checking,\n        )\n        self.add_command(cmd)\n        return cmd\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/prefixed_commands/#naff.models.naff.prefixed_commands.PrefixedCommand.call_callback","title":"<code>call_callback(callback, ctx)</code>  <code>async</code>","text":"<p>Runs the callback of this command.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable</code> <p>The callback to run. This is provided for compatibility with naff.</p> required <code>ctx</code> <code>naff.MessageContext</code> <p>The context to use for this command.</p> required Source code in <code>naff\\models\\naff\\prefixed_commands.py</code> <pre><code>async def call_callback(self, callback: Callable, ctx: \"PrefixedContext\") -&gt; None:\n\"\"\"\n    Runs the callback of this command.\n\n    Args:\n        callback (Callable: The callback to run. This is provided for compatibility with naff.\n        ctx (naff.MessageContext): The context to use for this command.\n    \"\"\"\n    # sourcery skip: remove-empty-nested-block, remove-redundant-if, remove-unnecessary-else\n    if len(self.parameters) == 0:\n        if ctx.args and not self.ignore_extra:\n            raise BadArgument(f\"Too many arguments passed to {self.name}.\")\n        return await self.call_with_binding(callback, ctx)\n    else:\n        # this is slightly costly, but probably worth it\n        new_args: list[Any] = []\n        kwargs: dict[str, Any] = {}\n        args = _PrefixedArgsIterator(tuple(ctx.args))\n        param_index = 0\n\n        for arg in args:\n            while param_index &lt; len(self.parameters):\n                param = self.parameters[param_index]\n\n                if param.consume_rest:\n                    arg = args.consume_rest()\n\n                if param.variable:\n                    args_to_convert = args.get_rest_of_args()\n                    new_arg = [await _convert(param, ctx, arg) for arg in args_to_convert]\n                    new_arg = tuple(arg[0] for arg in new_arg)\n                    new_args.extend(new_arg)\n                    param_index += 1\n                    break\n\n                if param.greedy:\n                    greedy_args, broke_off = await _greedy_convert(param, ctx, args)\n\n                    new_args.append(greedy_args)\n                    param_index += 1\n                    if broke_off:\n                        args.back()\n\n                    if param.default:\n                        continue\n                    else:\n                        break\n\n                converted, used_default = await _convert(param, ctx, arg)\n                if param.kind in {\n                    inspect.Parameter.POSITIONAL_ONLY,\n                    inspect.Parameter.VAR_POSITIONAL,\n                }:\n                    new_args.append(converted)\n                else:\n                    kwargs[param.name] = converted\n                param_index += 1\n\n                if not used_default:\n                    break\n\n        if param_index &lt; len(self.parameters):\n            for param in self.parameters[param_index:]:\n                if param.no_argument:\n                    converted, _ = await _convert(param, ctx, None)  # type: ignore\n                    if not param.consume_rest:\n                        new_args.append(converted)\n                    else:\n                        kwargs[param.name] = converted\n                        break\n                    continue\n\n                if not param.optional:\n                    raise BadArgument(f\"{param.name} is a required argument that is missing.\")\n                else:\n                    if param.kind in {\n                        inspect.Parameter.POSITIONAL_ONLY,\n                        inspect.Parameter.VAR_POSITIONAL,\n                    }:\n                        new_args.append(param.default)\n                    else:\n                        kwargs[param.name] = param.default\n                        break\n        elif not self.ignore_extra and not args.finished:\n            raise BadArgument(f\"Too many arguments passed to {self.name}.\")\n\n        return await self.call_with_binding(callback, ctx, *new_args, **kwargs)\n</code></pre>"},{"location":"API%20Reference/models/Naff/prefixed_commands/#naff.models.naff.prefixed_commands.prefixed_command","title":"<code>prefixed_command(name=None, *, aliases=None, help=None, brief=None, usage=None, enabled=True, hidden=False, ignore_extra=True, hierarchical_checking=True)</code>","text":"<p>A decorator to declare a coroutine as a prefixed command.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the command. Defaults to the name of the coroutine.</p> <code>None</code> <code>aliases</code> <code>Optional[list[str]]</code> <p>The list of aliases the command can be invoked under.</p> <code>None</code> <code>help</code> <code>Optional[str]</code> <p>The long help text for the command. Defaults to the docstring of the coroutine, if there is one.</p> <code>None</code> <code>brief</code> <code>Optional[str]</code> <p>The short help text for the command. Defaults to the first line of the help text, if there is one.</p> <code>None</code> <code>usage</code> <code>Optional[str]</code> <p>A string displaying how the command can be used. If no string is set, it will default to the command's signature. Useful for help commands.</p> <code>None</code> <code>enabled</code> <code>bool</code> <p>Whether this command can be run at all.</p> <code>True</code> <code>hidden</code> <code>bool</code> <p>If <code>True</code>, the default help command (when it is added) does not show this in the help output.</p> <code>False</code> <code>ignore_extra</code> <code>bool</code> <p>If <code>True</code>, ignores extraneous strings passed to a command if all its requirements are met (e.g. ?foo a b c when only expecting a and b). Otherwise, an error is raised.</p> <code>True</code> <code>hierarchical_checking</code> <code>bool</code> <p>If <code>True</code> and if the base of a subcommand, every subcommand underneath it will run this command's checks before its own. Otherwise, only the subcommand's checks are checked.</p> <code>True</code> Source code in <code>naff\\models\\naff\\prefixed_commands.py</code> <pre><code>def prefixed_command(\n    name: Optional[str] = None,\n    *,\n    aliases: Optional[list[str]] = None,\n    help: Optional[str] = None,\n    brief: Optional[str] = None,\n    usage: Optional[str] = None,\n    enabled: bool = True,\n    hidden: bool = False,\n    ignore_extra: bool = True,\n    hierarchical_checking: bool = True,\n) -&gt; Callable[..., PrefixedCommand]:\n\"\"\"\n    A decorator to declare a coroutine as a prefixed command.\n\n    Args:\n        name: The name of the command. Defaults to the name of the coroutine.\n        aliases: The list of aliases the command can be invoked under.\n        help: The long help text for the command. Defaults to the docstring of the coroutine, if there is one.\n        brief: The short help text for the command. Defaults to the first line of the help text, if there is one.\n        usage: A string displaying how the command can be used. If no string is set, it will default to the command's signature. Useful for help commands.\n        enabled: Whether this command can be run at all.\n        hidden: If `True`, the default help command (when it is added) does not show this in the help output.\n        ignore_extra: If `True`, ignores extraneous strings passed to a command if all its requirements are met (e.g. ?foo a b c when only expecting a and b). Otherwise, an error is raised.\n        hierarchical_checking: If `True` and if the base of a subcommand, every subcommand underneath it will run this command's checks before its own. Otherwise, only the subcommand's checks are checked.\n    \"\"\"\n\n    def wrapper(func: Callable) -&gt; PrefixedCommand:\n        return PrefixedCommand(  # type: ignore\n            callback=func,\n            name=name or func.__name__,\n            aliases=aliases or [],\n            help=help,\n            brief=brief,\n            usage=usage,  # type: ignore\n            enabled=enabled,\n            hidden=hidden,\n            ignore_extra=ignore_extra,\n            hierarchical_checking=hierarchical_checking,\n        )\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/protocols/","title":"Protocols","text":""},{"location":"API%20Reference/models/Naff/protocols/#naff.models.naff.protocols.Converter","title":"<code>Converter</code>","text":"<p>         Bases: <code>Protocol[T_co]</code></p> <p>A protocol representing a class used to convert an argument.</p> Source code in <code>naff\\models\\naff\\protocols.py</code> <pre><code>@typing.runtime_checkable\nclass Converter(Protocol[T_co]):\n\"\"\"A protocol representing a class used to convert an argument.\"\"\"\n\n    async def convert(self, ctx: \"Context\", argument: Any) -&gt; T_co:\n\"\"\"\n        The function that converts an argument to the appropriate type.\n\n        This should be overridden by subclasses for their conversion logic.\n\n        Args:\n            ctx: The context to use for the conversion.\n            argument: The argument to be converted.\n\n        Returns:\n            Any: The converted argument.\n        \"\"\"\n        raise NotImplementedError(\"Derived classes need to implement this.\")\n</code></pre>"},{"location":"API%20Reference/models/Naff/protocols/#naff.models.naff.protocols.Converter.convert","title":"<code>convert(ctx, argument)</code>  <code>async</code>","text":"<p>The function that converts an argument to the appropriate type.</p> <p>This should be overridden by subclasses for their conversion logic.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context to use for the conversion.</p> required <code>argument</code> <code>Any</code> <p>The argument to be converted.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>T_co</code> <p>The converted argument.</p> Source code in <code>naff\\models\\naff\\protocols.py</code> <pre><code>async def convert(self, ctx: \"Context\", argument: Any) -&gt; T_co:\n\"\"\"\n    The function that converts an argument to the appropriate type.\n\n    This should be overridden by subclasses for their conversion logic.\n\n    Args:\n        ctx: The context to use for the conversion.\n        argument: The argument to be converted.\n\n    Returns:\n        Any: The converted argument.\n    \"\"\"\n    raise NotImplementedError(\"Derived classes need to implement this.\")\n</code></pre>"},{"location":"API%20Reference/models/Naff/tasks/","title":"Tasks","text":""},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.BaseTrigger","title":"<code>BaseTrigger</code>","text":"<p>         Bases: <code>ABC</code></p> Source code in <code>naff\\models\\naff\\tasks\\triggers.py</code> <pre><code>class BaseTrigger(ABC):\n    last_call_time: datetime\n\n    def __new__(cls, *args, **kwargs) -&gt; \"BaseTrigger\":\n        new_cls = super().__new__(cls)\n        new_cls.last_call_time = datetime.now()\n        return new_cls\n\n    def __or__(self, other: \"BaseTrigger\") -&gt; \"OrTrigger\":\n        return OrTrigger(self, other)\n\n    @abstractmethod\n    def next_fire(self) -&gt; datetime | None:\n\"\"\"\n        Return the next datetime to fire on.\n\n        Returns:\n            Datetime if one can be determined. If no datetime can be determined, return None\n\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.triggers.BaseTrigger.next_fire","title":"<code>next_fire()</code>  <code>abstractmethod</code>","text":"<p>Return the next datetime to fire on.</p> <p>Returns:</p> Type Description <code>datetime | None</code> <p>Datetime if one can be determined. If no datetime can be determined, return None</p> Source code in <code>naff\\models\\naff\\tasks\\triggers.py</code> <pre><code>@abstractmethod\ndef next_fire(self) -&gt; datetime | None:\n\"\"\"\n    Return the next datetime to fire on.\n\n    Returns:\n        Datetime if one can be determined. If no datetime can be determined, return None\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.Task","title":"<code>Task</code>","text":"<p>Create an asynchronous background tasks. Tasks allow you to run code according to a trigger object.</p> <p>A task's trigger must inherit from <code>BaseTrigger</code>.</p> <p>Attributes:</p> Name Type Description <code>callback</code> <code>Callable</code> <p>The function to be called when the trigger is triggered.</p> <code>trigger</code> <code>BaseTrigger</code> <p>The trigger object that determines when the task should run.</p> <code>task</code> <code>Optional[_Task]</code> <p>The task object that is running the trigger loop.</p> <code>iteration</code> <code>int</code> <p>The number of times the task has run.</p> Source code in <code>naff\\models\\naff\\tasks\\task.py</code> <pre><code>class Task:\n\"\"\"\n    Create an asynchronous background tasks. Tasks allow you to run code according to a trigger object.\n\n    A task's trigger must inherit from `BaseTrigger`.\n\n    Attributes:\n        callback (Callable): The function to be called when the trigger is triggered.\n        trigger (BaseTrigger): The trigger object that determines when the task should run.\n        task (Optional[_Task]): The task object that is running the trigger loop.\n        iteration (int): The number of times the task has run.\n\n    \"\"\"\n\n    callback: Callable\n    trigger: BaseTrigger\n    task: _Task | None\n    _stop: asyncio.Event\n    iteration: int\n\n    def __init__(self, callback: Callable, trigger: BaseTrigger) -&gt; None:\n        self.callback = callback\n        self.trigger = trigger\n        self._stop = asyncio.Event()\n        self.task = None\n        self.iteration = 0\n\n    @property\n    def started(self) -&gt; bool:\n\"\"\"Whether the task is started\"\"\"\n        return self.task is not None\n\n    @property\n    def running(self) -&gt; bool:\n\"\"\"Whether the task is running\"\"\"\n        return self.task is not None and not self.task.done()\n\n    @property\n    def done(self) -&gt; bool:\n\"\"\"Whether the task is done/finished\"\"\"\n        return self.task is not None and self.task.done()\n\n    @property\n    def next_run(self) -&gt; datetime | None:\n\"\"\"Get the next datetime this task will run.\"\"\"\n        if not self.running:\n            return None\n\n        return self.trigger.next_fire()\n\n    @property\n    def delta_until_run(self) -&gt; timedelta | None:\n\"\"\"Get the time until the next run of this task.\"\"\"\n        if not self.running:\n            return None\n\n        next_run = self.next_run\n        return next_run - datetime.now() if next_run is not None else None\n\n    def on_error_sentry_hook(self, error: Exception) -&gt; None:\n\"\"\"A dummy method for naff.ext.sentry to hook\"\"\"\n\n    def on_error(self, error: Exception) -&gt; None:\n\"\"\"Error handler for this task. Called when an exception is raised during execution of the task.\"\"\"\n        self.on_error_sentry_hook(error)\n        naff.Client.default_error_handler(\"Task\", error)\n\n    async def __call__(self) -&gt; None:\n        try:\n            if inspect.iscoroutinefunction(self.callback):\n                val = await self.callback()\n            else:\n                val = self.callback()\n\n            if isinstance(val, BaseTrigger):\n                self.reschedule(val)\n        except Exception as e:\n            self.on_error(e)\n\n    def _fire(self, fire_time: datetime) -&gt; None:\n\"\"\"Called when the task is being fired.\"\"\"\n        self.trigger.last_call_time = fire_time\n        asyncio.create_task(self())\n        self.iteration += 1\n\n    async def _task_loop(self) -&gt; None:\n\"\"\"The main task loop to fire the task at the specified time based on triggers configured.\"\"\"\n        while not self._stop.is_set():\n            fire_time = self.trigger.next_fire()\n            if fire_time is None:\n                return self.stop()\n\n            try:\n                await asyncio.wait_for(self._stop.wait(), max(0.0, (fire_time - datetime.now()).total_seconds()))\n            except asyncio.TimeoutError:\n                pass\n            else:\n                return None\n\n            self._fire(fire_time)\n\n    def start(self) -&gt; None:\n\"\"\"Start this task.\"\"\"\n        try:\n            self._stop.clear()\n            self.task = asyncio.create_task(self._task_loop())\n        except RuntimeError:\n            get_logger().error(\n                \"Unable to start task without a running event loop! We recommend starting tasks within an `on_startup` event.\"\n            )\n\n    def stop(self) -&gt; None:\n\"\"\"End this task.\"\"\"\n        self._stop.set()\n        if self.task:\n            self.task.cancel()\n\n    def restart(self) -&gt; None:\n\"\"\"Restart this task.\"\"\"\n        self.stop()\n        self.start()\n\n    def reschedule(self, trigger: BaseTrigger) -&gt; None:\n\"\"\"\n        Change the trigger being used by this task.\n\n        Args:\n            trigger: The new Trigger to use\n\n        \"\"\"\n        self.trigger = trigger\n        self.restart()\n\n    @classmethod\n    def create(cls, trigger: BaseTrigger) -&gt; Callable[[Callable], \"Task\"]:\n\"\"\"\n        A decorator to create a task.\n\n        Example:\n            ```python\n            @Task.create(IntervalTrigger(minutes=5))\n            async def my_task():\n                print(\"It's been 5 minutes!\")\n\n            @listen()\n            async def on_startup():\n                my_task.start()\n            ```\n\n        Args:\n            trigger: The trigger to use for this task\n\n        \"\"\"\n\n        def wrapper(func: Callable) -&gt; \"Task\":\n            return cls(func, trigger)\n\n        return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.task.Task.started","title":"<code>started: bool</code>  <code>property</code>","text":"<p>Whether the task is started</p>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.task.Task.running","title":"<code>running: bool</code>  <code>property</code>","text":"<p>Whether the task is running</p>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.task.Task.done","title":"<code>done: bool</code>  <code>property</code>","text":"<p>Whether the task is done/finished</p>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.task.Task.next_run","title":"<code>next_run: datetime | None</code>  <code>property</code>","text":"<p>Get the next datetime this task will run.</p>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.task.Task.delta_until_run","title":"<code>delta_until_run: timedelta | None</code>  <code>property</code>","text":"<p>Get the time until the next run of this task.</p>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.task.Task.on_error_sentry_hook","title":"<code>on_error_sentry_hook(error)</code>","text":"<p>A dummy method for naff.ext.sentry to hook</p> Source code in <code>naff\\models\\naff\\tasks\\task.py</code> <pre><code>def on_error_sentry_hook(self, error: Exception) -&gt; None:\n\"\"\"A dummy method for naff.ext.sentry to hook\"\"\"\n</code></pre>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.task.Task.on_error","title":"<code>on_error(error)</code>","text":"<p>Error handler for this task. Called when an exception is raised during execution of the task.</p> Source code in <code>naff\\models\\naff\\tasks\\task.py</code> <pre><code>def on_error(self, error: Exception) -&gt; None:\n\"\"\"Error handler for this task. Called when an exception is raised during execution of the task.\"\"\"\n    self.on_error_sentry_hook(error)\n    naff.Client.default_error_handler(\"Task\", error)\n</code></pre>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.task.Task.start","title":"<code>start()</code>","text":"<p>Start this task.</p> Source code in <code>naff\\models\\naff\\tasks\\task.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start this task.\"\"\"\n    try:\n        self._stop.clear()\n        self.task = asyncio.create_task(self._task_loop())\n    except RuntimeError:\n        get_logger().error(\n            \"Unable to start task without a running event loop! We recommend starting tasks within an `on_startup` event.\"\n        )\n</code></pre>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.task.Task.stop","title":"<code>stop()</code>","text":"<p>End this task.</p> Source code in <code>naff\\models\\naff\\tasks\\task.py</code> <pre><code>def stop(self) -&gt; None:\n\"\"\"End this task.\"\"\"\n    self._stop.set()\n    if self.task:\n        self.task.cancel()\n</code></pre>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.task.Task.restart","title":"<code>restart()</code>","text":"<p>Restart this task.</p> Source code in <code>naff\\models\\naff\\tasks\\task.py</code> <pre><code>def restart(self) -&gt; None:\n\"\"\"Restart this task.\"\"\"\n    self.stop()\n    self.start()\n</code></pre>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.task.Task.reschedule","title":"<code>reschedule(trigger)</code>","text":"<p>Change the trigger being used by this task.</p> <p>Parameters:</p> Name Type Description Default <code>trigger</code> <code>BaseTrigger</code> <p>The new Trigger to use</p> required Source code in <code>naff\\models\\naff\\tasks\\task.py</code> <pre><code>def reschedule(self, trigger: BaseTrigger) -&gt; None:\n\"\"\"\n    Change the trigger being used by this task.\n\n    Args:\n        trigger: The new Trigger to use\n\n    \"\"\"\n    self.trigger = trigger\n    self.restart()\n</code></pre>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.task.Task.create","title":"<code>create(trigger)</code>  <code>classmethod</code>","text":"<p>A decorator to create a task.</p> Example <pre><code>@Task.create(IntervalTrigger(minutes=5))\nasync def my_task():\n    print(\"It's been 5 minutes!\")\n\n@listen()\nasync def on_startup():\n    my_task.start()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>trigger</code> <code>BaseTrigger</code> <p>The trigger to use for this task</p> required Source code in <code>naff\\models\\naff\\tasks\\task.py</code> <pre><code>@classmethod\ndef create(cls, trigger: BaseTrigger) -&gt; Callable[[Callable], \"Task\"]:\n\"\"\"\n    A decorator to create a task.\n\n    Example:\n        ```python\n        @Task.create(IntervalTrigger(minutes=5))\n        async def my_task():\n            print(\"It's been 5 minutes!\")\n\n        @listen()\n        async def on_startup():\n            my_task.start()\n        ```\n\n    Args:\n        trigger: The trigger to use for this task\n\n    \"\"\"\n\n    def wrapper(func: Callable) -&gt; \"Task\":\n        return cls(func, trigger)\n\n    return wrapper\n</code></pre>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.IntervalTrigger","title":"<code>IntervalTrigger</code>","text":"<p>         Bases: <code>BaseTrigger</code></p> <p>Trigger the task every set interval.</p> <p>Attributes:</p> Name Type Description <code>seconds</code> <code>Union[int, float]</code> <p>How many seconds between intervals</p> <code>minutes</code> <code>Union[int, float]</code> <p>How many minutes between intervals</p> <code>hours</code> <code>Union[int, float]</code> <p>How many hours between intervals</p> <code>days</code> <code>Union[int, float]</code> <p>How many days between intervals</p> <code>weeks</code> <code>Union[int, float]</code> <p>How many weeks between intervals</p> Source code in <code>naff\\models\\naff\\tasks\\triggers.py</code> <pre><code>class IntervalTrigger(BaseTrigger):\n\"\"\"\n    Trigger the task every set interval.\n\n    Attributes:\n        seconds Union[int, float]: How many seconds between intervals\n        minutes Union[int, float]: How many minutes between intervals\n        hours Union[int, float]: How many hours between intervals\n        days Union[int, float]: How many days between intervals\n        weeks Union[int, float]: How many weeks between intervals\n\n    \"\"\"\n\n    _t = int | float\n\n    def __init__(self, seconds: _t = 0, minutes: _t = 0, hours: _t = 0, days: _t = 0, weeks: _t = 0) -&gt; None:\n        self.delta = timedelta(days=days, seconds=seconds, minutes=minutes, hours=hours, weeks=weeks)\n\n        # lazy check for negatives\n        if (datetime.now() + self.delta) &lt; datetime.now():\n            raise ValueError(\"Interval values must result in a time in the future!\")\n\n    def next_fire(self) -&gt; datetime | None:\n        return self.last_call_time + self.delta\n</code></pre>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.DateTrigger","title":"<code>DateTrigger</code>","text":"<p>         Bases: <code>BaseTrigger</code></p> <p>Trigger the task once, when the specified datetime is reached.</p> <p>Attributes:</p> Name Type Description <code>target_datetime</code> <code>datetime</code> <p>A datetime representing the date/time to run this task</p> Source code in <code>naff\\models\\naff\\tasks\\triggers.py</code> <pre><code>class DateTrigger(BaseTrigger):\n\"\"\"\n    Trigger the task once, when the specified datetime is reached.\n\n    Attributes:\n        target_datetime datetime: A datetime representing the date/time to run this task\n\n    \"\"\"\n\n    def __init__(self, target_datetime: datetime) -&gt; None:\n        self.target = target_datetime\n\n    def next_fire(self) -&gt; datetime | None:\n        if datetime.now() &lt; self.target:\n            return self.target\n        return None\n</code></pre>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.TimeTrigger","title":"<code>TimeTrigger</code>","text":"<p>         Bases: <code>BaseTrigger</code></p> <p>Trigger the task every day, at a specified (24 hour clock) time.</p> <p>Attributes:</p> Name Type Description <code>hour</code> <code>int</code> <p>The hour of the day (24 hour clock)</p> <code>minute</code> <code>int</code> <p>The minute of the hour</p> <code>seconds</code> <code>int</code> <p>The seconds of the minute</p> <code>utc</code> <code>bool</code> <p>If this time is in UTC</p> Source code in <code>naff\\models\\naff\\tasks\\triggers.py</code> <pre><code>class TimeTrigger(BaseTrigger):\n\"\"\"\n    Trigger the task every day, at a specified (24 hour clock) time.\n\n    Attributes:\n        hour int: The hour of the day (24 hour clock)\n        minute int: The minute of the hour\n        seconds int: The seconds of the minute\n        utc bool: If this time is in UTC\n\n    \"\"\"\n\n    def __init__(self, hour: int = 0, minute: int = 0, seconds: int = 0, utc: bool = True) -&gt; None:\n        self.target_time = (hour, minute, seconds)\n        self.tz = timezone.utc if utc else None\n\n    def next_fire(self) -&gt; datetime | None:\n        now = datetime.now()\n        target = datetime(\n            now.year, now.month, now.day, self.target_time[0], self.target_time[1], self.target_time[2], tzinfo=self.tz\n        )\n        if target.tzinfo == timezone.utc:\n            target = target.astimezone(now.tzinfo)\n            target = target.replace(tzinfo=None)\n\n        if target &lt;= self.last_call_time:\n            target += timedelta(days=1)\n        return target\n</code></pre>"},{"location":"API%20Reference/models/Naff/tasks/#naff.models.naff.tasks.OrTrigger","title":"<code>OrTrigger</code>","text":"<p>         Bases: <code>BaseTrigger</code></p> <p>Trigger a task when any sub-trigger is fulfilled.</p> Source code in <code>naff\\models\\naff\\tasks\\triggers.py</code> <pre><code>class OrTrigger(BaseTrigger):\n\"\"\"Trigger a task when any sub-trigger is fulfilled.\"\"\"\n\n    def __init__(self, *trigger: BaseTrigger) -&gt; None:\n        self.triggers: list[BaseTrigger] = list(trigger)\n\n    def _get_delta(self, d: BaseTrigger) -&gt; timedelta:\n        next_fire = d.next_fire()\n        if not next_fire:\n            return timedelta.max\n        return abs(next_fire - self.last_call_time)\n\n    def __or__(self, other: \"BaseTrigger\") -&gt; \"OrTrigger\":\n        self.triggers.append(other)\n        return self\n\n    def next_fire(self) -&gt; datetime | None:\n        if len(self.triggers) == 1:\n            return self.triggers[0].next_fire()\n        trigger = min(self.triggers, key=self._get_delta)\n        return trigger.next_fire()\n</code></pre>"},{"location":"API%20Reference/models/Naff/wait/","title":"Wait","text":""},{"location":"API%20Reference/models/Naff/wait/#naff.models.naff.wait.Wait","title":"<code>Wait</code>","text":"<p>Class for waiting for a future event to happen. Internally used by wait_for.</p> Source code in <code>naff\\models\\naff\\wait.py</code> <pre><code>class Wait:\n\"\"\"Class for waiting for a future event to happen. Internally used by wait_for.\"\"\"\n\n    def __init__(self, event: str, checks: Optional[Callable[..., bool]], future: Future) -&gt; None:\n        self.event = event\n        self.checks = checks\n        self.future = future\n\n    def __call__(self, *args, **kwargs) -&gt; bool:\n        if self.future.cancelled():\n            return True\n\n        if self.checks:\n            try:\n                check_result = self.checks(*args, **kwargs)\n            except Exception as exc:\n                self.future.set_exception(exc)\n                return True\n        else:\n            check_result = True\n\n        if check_result:\n            self.future.set_result(*args, **kwargs)\n            return True\n\n        return False\n</code></pre>"},{"location":"Guides/","title":"Index","text":"<p>Let's be honest; reading API documentation is a bit of a pain. These guides are meant to help you get started with the library and offer a point of reference.</p> <ul> <li> <p> Getting Started</p> <p>So you want to make a bot starting from naffing. This guide aims to get you started as fast as possible.</p> </li> <li> <p> Creating Your Bot</p> <p>How to make a bot on the Discord Developer Dashboard.</p> </li> <li> <p> Slash Commands</p> <p>So you want to make a slash command (or interaction, as they are officially called), but don't know how to get started? Then this is the right place for you.</p> </li> <li> <p> Context Menus</p> <p>Interact with users in a more natural way. Just use the second button on your mouse.</p> </li> <li> <p> Components</p> <p>While interactions are cool and all, they are still missing a vital component. Introducing components, aka Buttons, Selects, soon Text Input Fields</p> </li> <li> <p> Modals</p> <p>As everyone knows from surfing the web, popups are really great. Everyone loves them and they make for a great UX. Luckily for you, you have the option to regale your users love for them by using modals.</p> </li> <li> <p> Prefixed Commands</p> <p>Going old-school with prefixed-commands? No problem. Let's get your message commands up and running.</p> </li> <li> <p> Converters</p> <p>If your bot is complex enough, you might find yourself wanting to use custom models in your commands. Converters are classes that allow you to do just that.</p> </li> <li> <p> Events</p> <p>HEY! LISTEN! If you want to know more about events, you can check out this guide.</p> </li> <li> <p> Extensions</p> <p>Damn, your code is getting pretty messy now, huh? Wouldn't it be nice if you could organise your commands and listeners into separate files?</p> </li> <li> <p> Advanced Extensions</p> <p>You have learned how to create interactions and how to keep your code clean with extensions. This guide show you how to elevate your extensions to the next level.</p> </li> <li> <p> Voice Support</p> <p>So you want to start playing some \ud83c\udfb5tunes\ud83c\udfb6 in voice channels? Well let's get that going for you.</p> </li> <li> <p> Localisation</p> <p>So your bot has grown, and now you need to localize localise your bot. Well thank god we support localisation then, huh?</p> </li> <li> <p> Pagination</p> <p>We've all hit that point where Discord won't let you send enough characters, at that point you can either flood the channel with multiple messages, or you can start paginating your messages.</p> </li> <li> <p> Tasks</p> <p>Tasks are background processes that can be used to asynchronously run code with a specified trigger.</p> </li> <li> <p> Sharding</p> <p>Oh damn, your bot is getting pretty big, huh? Well I guess its time we discuss sharding.</p> </li> <li> <p> Migration from discord.py</p> <p>Whats different between NAFF and discord.py?</p> </li> <li> <p> 2.x Migration Guide</p> <p>How do I migrate from 1.x to 2.x?</p> </li> </ul>"},{"location":"Guides/01%20Getting%20Started/","title":"Introduction","text":"<p>Hi! So you want to make a bot starting from naffing. This guide aims to get you started as fast as possible, for more advanced use-cases check out the other guides.</p>"},{"location":"Guides/01%20Getting%20Started/#requirements","title":"Requirements","text":"<ul> <li> Python 3.10 or greater</li> <li> Know how to use <code>pip</code></li> <li> A bot account</li> <li> An aversion to puns</li> </ul>"},{"location":"Guides/01%20Getting%20Started/#installation-methods","title":"Installation Methods","text":"<p>There are two different ways to install this library and create your bot.</p> Using a TemplateManual Installation <p>We created a cookiecutter template which you can use to set up your own bot faster. With the template, your code will already have a well-defined structure which will make development easier for you.</p> <p>We recommend newer devs to make use of this template.</p> <p>Congratulations! You now have a basic understanding of this library. If you have any questions check out our other guides, or join the Discord Server</p> <p>For more examples, check out the examples page</p>"},{"location":"Guides/01%20Getting%20Started/#template-feature","title":"Template Feature","text":"<ul> <li>Basic, ready to go bot</li> <li>Implementation of best practises</li> <li>NAFF, and general extensibility</li> <li>Example command, context menu, component, and event</li> <li>Logging to both console and file</li> <li>Pip and poetry config</li> <li>Pre-commit config</li> <li>Dockerfile and pre-made docker-compose</li> </ul>"},{"location":"Guides/01%20Getting%20Started/#template-installation","title":"Template Installation","text":"<ol> <li>Install cookiecutter - <code>pip install cookiecutter</code></li> <li>Set up the template - <code>cookiecutter https://github.com/Discord-Snake-Pit/Bot-Template</code></li> </ol> <p>And that's it!</p> <p>More information can be found here.</p>"},{"location":"Guides/01%20Getting%20Started/#virtual-environments","title":"Virtual-Environments","text":"<p>We strongly recommend that you make use of Virtual Environments when working on any project. This means that each project will have its own libraries of any version and does not affect anything else on your system. Don't worry, this isn't setting up a full-fledged virtual machine, just small python environment.</p>  Linux Windows <pre><code>cd \"[your bots directory]\"\npython3 -m venv venv\nsource venv/bin/activate\n</code></pre> <pre><code>cd \"[your bots directory]\"\npy -3 -m venv venv\nvenv/Scripts/activate\n</code></pre> <p>It's that simple, now you're using a virtual environment. If you want to leave the environment just type <code>deactivate</code>. If you want to learn more about the virtual environments, check out this page</p>"},{"location":"Guides/01%20Getting%20Started/#pip-install","title":"Pip install","text":"<p>Now let's get the library installed.</p>  Linux Windows <pre><code>python3 -m pip install naff --upgrade\n</code></pre> <pre><code>py -3 -m pip install naff --upgrade\n</code></pre>"},{"location":"Guides/01%20Getting%20Started/#basic-bot","title":"Basic bot","text":"<p>Now let's get a basic bot going, for your code, you'll want something like this:</p> <pre><code>from naff import Client, Intents, listen\n\nbot = Client(intents=Intents.DEFAULT)\n# intents are what events we want to receive from discord, `DEFAULT` is usually fine\n\n@listen()  # this decorator tells snek that it needs to listen for the corresponding event, and run this coroutine\nasync def on_ready():\n    # This event is called when the bot is ready to respond to commands\n    print(\"Ready\")\n    print(f\"This bot is owned by {bot.owner}\")\n\n\n@listen()\nasync def on_message_create(event):\n    # This event is called when a message is sent in a channel the bot can see\n    print(f\"message received: {event.message.content}\")\n\n\nbot.start(\"Put your token here\")\n</code></pre>"},{"location":"Guides/02%20Creating%20Your%20Bot/","title":"Creating Your Bot","text":"<p>To make a bot on Discord, you must first create an application on Discord. Thankfully, Discord has made this process very simple:</p> <ol> <li> <p>Login to the Discord website</p> </li> <li> <p>Navigate to the Developer Application page</p> </li> <li> <p>Press <code>New Application</code> </p> </li> <li> <p>Give your application a name, and press <code>Create</code> </p> Note <p>Don't worry if there isn't a <code>team</code> option, this only appears if you have a developer team. If you have a team and want to assign your bot to it, use this.</p> </li> <li> <p>In the <code>Bot</code> tab, press <code>Add bot</code> </p> </li> <li> <p>You now have a bot! You're going to want to press <code>Reset Token</code> to get your bot's token, so you can start coding     </p> Note <p>You may (or may not) be asked to enter your password or 2FA authentication code to confirm this action.</p> <p>Warning: Do not share your token!</p> <p>Think of this token as your bots username and password in one. You should never share this with someone else. If someone has your token, they can do absolutely anything with your bot, from banning every member in every server to leaving every server your bot is in.</p> <p>If you think you have leaked your token, press <code>Reset Token</code> on the same page you copy your token on, this will revoke your token (logging out all exisitng sessions), and generate a new token for you.</p> <p>Github will automatically revoke your token if you accidentally commit it, but don't rely on this as a crutch, keep your token safe.</p> </li> </ol>"},{"location":"Guides/02%20Creating%20Your%20Bot/#inviting-your-bot","title":"Inviting your bot!","text":"<p>So you've created a bot, but it's not in a server yet. Lets fix that.</p> <ol> <li> <p>On the Developer Application page from above, select your bot</p> </li> <li> <p>Navigate to the <code>OAuth2</code> tab</p> </li> <li> <p>Scroll down to the <code>URL Generator</code>. This is where we're going to create our invite link     </p> </li> <li> <p>Select the <code>bot</code> option, and if you want to use application commands, select <code>applications.commands</code> as well</p> </li> <li> <p>If your bot needs any special permissions, select those below     </p> </li> <li> <p>Now you have an invite link! Simply use this to invite your bot.</p> <p>Note</p> <p>You need <code>manage server</code> permissions to add a bot to a server</p> </li> </ol>"},{"location":"Guides/03%20Creating%20Commands/","title":"Creating Slash Commands","text":"<p>So you want to make a slash command (or interaction, as they are officially called), but don't know how to get started? Then this is the right place for you.</p>"},{"location":"Guides/03%20Creating%20Commands/#your-first-command","title":"Your First Command","text":"<p>To create an interaction, simply define an asynchronous function and use the <code>@slash_command()</code> decorator above it.</p> <p>Interactions need to be responded to within 3 seconds. To do this, use <code>await ctx.send()</code>. If your code needs more time, don't worry. You can use <code>await ctx.defer()</code> to increase the time until you need to respond to the command to 15 minutes. <pre><code>@slash_command(name=\"my_command\", description=\"My first command :)\")\nasync def my_command_function(ctx: InteractionContext):\n    await ctx.send(\"Hello World\")\n\n@slash_command(name=\"my_long_command\", description=\"My second command :)\")\nasync def my_long_command_function(ctx: InteractionContext):\n    # need to defer it, otherwise, it fails\n    await ctx.defer()\n\n    # do stuff for a bit\n    await asyncio.sleep(600)\n\n    await ctx.send(\"Hello World\")\n</code></pre>     ??? note         Command names must be lowercase and can only contain <code>-</code> and <code>_</code> as special symbols and must not contain spaces.</p> <p>When testing, it is recommended to use non-global commands, as they sync instantly. For that, you can either define <code>scopes</code> in every command or set <code>debug_scope</code> in the bot instantiation which sets the scope automatically for all commands.</p> <p>You can define non-global commands by passing a list of guild ids to <code>scopes</code> in the interaction creation. <pre><code>@slash_command(name=\"my_command\", description=\"My first command :)\", scopes=[870046872864165888])\nasync def my_command_function(ctx: InteractionContext):\n    await ctx.send(\"Hello World\")\n</code></pre></p> <p>For more information, please visit the API reference here.</p>"},{"location":"Guides/03%20Creating%20Commands/#subcommands","title":"Subcommands","text":"<p>If you have multiple commands that fit under the same category, subcommands are perfect for you.</p> <p>Let's define a basic subcommand: <pre><code>@slash_command(\n    name=\"base\",\n    description=\"My command base\",\n    group_name=\"group\",\n    group_description=\"My command group\",\n    sub_cmd_name=\"command\",\n    sub_cmd_description=\"My command\",\n)\nasync def my_command_function(ctx: InteractionContext):\n    await ctx.send(\"Hello World\")\n</code></pre></p> <p>This will show up in discord as <code>/base group command</code>. There are two ways to add additional subcommands:</p>  Decorator Repeat Definition <pre><code>@my_command_function.subcommand(sub_cmd_name=\"second_command\", sub_cmd_description=\"My second command\")\nasync def my_second_command_function(ctx: InteractionContext):\n    await ctx.send(\"Hello World\")\n</code></pre> <pre><code>@slash_command(\n    name=\"base\",\n    description=\"My command base\",\n    group_name=\"group\",\n    group_description=\"My command group\",\n    sub_cmd_name=\"second_command\",\n    sub_cmd_description=\"My second command\",\n)\nasync def my_second_command_function(ctx: InteractionContext):\n    await ctx.send(\"Hello World\")\n</code></pre> <p>Note: This is particularly useful if you want to split subcommands into different files.</p>"},{"location":"Guides/03%20Creating%20Commands/#but-i-need-more-options","title":"But I Need More Options","text":"<p>Interactions can also have options. There are a bunch of different types of options:</p> Option Type Return Type Description <code>OptionTypes.STRING</code> <code>str</code> Limit the input to a string. <code>OptionTypes.INTEGER</code> <code>int</code> Limit the input to a integer. <code>OptionTypes.NUMBER</code> <code>float</code> Limit the input to a float. <code>OptionTypes.BOOLEAN</code> <code>bool</code> Let the user choose either <code>True</code> or <code>False</code>. <code>OptionTypes.USER</code> <code>Member</code> in guilds, else <code>User</code> Let the user choose a discord user from an automatically-generated list of options. <code>OptionTypes.CHANNEL</code> <code>GuildChannel</code> in guilds, else <code>DMChannel</code> Let the user choose a discord channel from an automatically-generated list of options. <code>OptionTypes.ROLE</code> <code>Role</code> Let the user choose a discord role from an automatically-generated list of options. <code>OptionTypes.MENTIONABLE</code> <code>DiscordObject</code> Let the user chose any discord mentionable from an automatically generated list of options. <code>OptionTypes.ATTACHMENT</code> <code>Attachment</code> Let the user upload an attachment. <p>Now that you know all the options you have for options, you can opt into adding options to your interaction.</p> <p>You do that by using the <code>@slash_option()</code> decorator and passing the option name as a function parameter: <pre><code>@slash_command(name=\"my_command\", ...)\n@slash_option(\n    name=\"integer_option\",\n    description=\"Integer Option\",\n    required=True,\n    opt_type=OptionTypes.INTEGER\n)\nasync def my_command_function(ctx: InteractionContext, integer_option: int):\n    await ctx.send(f\"You input {integer_option}\")\n</code></pre></p> <p>Options can either be required or not. If an option is not required, make sure to set a default value for them.</p> <p>Always make sure to define all required options first, this is a Discord requirement! <pre><code>@slash_command(name=\"my_command\", ...)\n@slash_option(\n    name=\"integer_option\",\n    description=\"Integer Option\",\n    required=False,\n    opt_type=OptionTypes.INTEGER\n)\nasync def my_command_function(ctx: InteractionContext, integer_option: int = 5):\n    await ctx.send(f\"You input {integer_option}\")\n</code></pre></p> <p>For more information, please visit the API reference here.</p>"},{"location":"Guides/03%20Creating%20Commands/#restricting-options","title":"Restricting Options","text":"<p>If you are using an <code>OptionTypes.CHANNEL</code> option, you can restrict the channel a user can choose by setting <code>channel_types</code>: <pre><code>@slash_command(name=\"my_command\", ...)\n@slash_option(\n    name=\"channel_option\",\n    description=\"Channel Option\",\n    required=True,\n    opt_type=OptionTypes.CHANNEL,\n    channel_types=[ChannelTypes.GUILD_TEXT]\n)\nasync def my_command_function(ctx: InteractionContext, channel_option: GUILD_TEXT):\n    await channel_option.send(\"This is a text channel in a guild\")\n\n    await ctx.send(\"...\")\n</code></pre></p> <p>You can also set an upper and lower limit for both <code>OptionTypes.INTEGER</code> and <code>OptionTypes.NUMBER</code> by setting <code>min_value</code> and <code>max_value</code>: <pre><code>@slash_command(name=\"my_command\", ...)\n@slash_option(\n    name=\"integer_option\",\n    description=\"Integer Option\",\n    required=True,\n    opt_type=OptionTypes.INTEGER,\n    min_value=10,\n    max_value=15\n)\nasync def my_command_function(ctx: InteractionContext, integer_option: int):\n    await ctx.send(f\"You input {integer_option} which is always between 10 and 15\")\n</code></pre></p> <p>The same can be done with the length of an option when using <code>OptionTypes.STRING</code> by setting <code>min_length</code> and <code>max_length</code>: <pre><code>@slash_command(name=\"my_command\", ...)\n@slash_option(\n    name=\"string_option\",\n    description=\"String Option\",\n    required=True,\n    opt_type=OptionTypes.STRING,\n    min_length=5,\n    max_length=10\n)\nasync def my_command_function(ctx: InteractionContext, string_option: str):\n    await ctx.send(f\"You input `{string_option}` which is between 5 and 10 characters long\")\n</code></pre></p> <p>Option Names</p> <p>Be aware that the option <code>name</code> and the function parameter need to be the same (In this example both are <code>integer_option</code>).</p>"},{"location":"Guides/03%20Creating%20Commands/#but-i-want-a-choice","title":"But I Want A Choice","text":"<p>If your users are dumb constantly misspell specific strings, it might be wise to set up choices. With choices, the user can no longer freely input whatever they want, instead, they must choose from a curated list.</p> <p>To create a choice, simply fill <code>choices</code> in <code>@slash_option()</code>. An option can have up to 25 choices: <pre><code>@slash_command(name=\"my_command\", ...)\n@slash_option(\n    name=\"integer_option\",\n    description=\"Integer Option\",\n    required=True,\n    opt_type=OptionTypes.INTEGER,\n    choices=[\n        SlashCommandChoice(name=\"One\", value=1),\n        SlashCommandChoice(name=\"Two\", value=2)\n    ]\n)\nasync def my_command_function(ctx: InteractionContext, integer_option: int):\n    await ctx.send(f\"You input {integer_option} which is either 1 or 2\")\n</code></pre></p> <p>For more information, please visit the API reference here.</p>"},{"location":"Guides/03%20Creating%20Commands/#i-need-more-than-25-choices","title":"I Need More Than 25 Choices","text":"<p>Looks like you want autocomplete options. These dynamically show users choices based on their input. The downside is that you need to supply the choices on request, making this a bit more tricky to set up.</p> <p>To use autocomplete options, set <code>autocomplete=True</code> in <code>@slash_option()</code>: <pre><code>@slash_command(name=\"my_command\", ...)\n@slash_option(\n    name=\"string_option\",\n    description=\"String Option\",\n    required=True,\n    opt_type=OptionTypes.STRING,\n    autocomplete=True\n)\nasync def my_command_function(ctx: InteractionContext, string_option: str):\n    await ctx.send(f\"You input {string_option}\")\n</code></pre></p> <p>Then you need to register the autocomplete callback, aka the function Discord calls when users fill in the option.</p> <p>In there, you have three seconds to return whatever choices you want to the user. In this example we will simply return their input with \"a\", \"b\" or \"c\" appended: <pre><code>@my_command.autocomplete(\"string_option\")\nasync def autocomplete(self, ctx: AutocompleteContext, string_option: str):\n    # make sure this is done within three seconds\n    await ctx.send(\n        choices=[\n            {\n                \"name\": f\"{string_option}a\",\n                \"value\": f\"{string_option}a\",\n            },\n            {\n                \"name\": f\"{string_option}b\",\n                \"value\": f\"{string_option}b\",\n            },\n            {\n                \"name\": f\"{string_option}c\",\n                \"value\": f\"{string_option}c\",\n            },\n        ]\n    )\n</code></pre></p>"},{"location":"Guides/03%20Creating%20Commands/#but-i-dont-like-decorators","title":"But I Don't Like Decorators","text":"<p>You are in luck. There are currently four different ways to create interactions, one does not need any decorators at all.</p>  Multiple Decorators Single Decorator Function Annotations Manual Registration <pre><code>@slash_command(name=\"my_command\", description=\"My first command :)\")\n@slash_option(\n    name=\"integer_option\",\n    description=\"Integer Option\",\n    required=True,\n    opt_type=OptionTypes.INTEGER\n)\nasync def my_command_function(ctx: InteractionContext, integer_option: int):\n    await ctx.send(f\"You input {integer_option}\")\n</code></pre> <pre><code>@slash_command(\n    name=\"my_command\",\n    description=\"My first command :)\",\n    options=[\n        SlashCommandOption(\n            name=\"integer_option\",\n            description=\"Integer Option\",\n            required=True,\n            opt_type=OptionTypes.INTEGER\n        )\n    ]\n)\nasync def my_command_function(ctx: InteractionContext, integer_option: int):\n    await ctx.send(f\"You input {integer_option}\")\n</code></pre> <pre><code>@slash_command(name=\"my_command\", description=\"My first command :)\")\nasync def my_command_function(ctx: InteractionContext, integer_option: slash_int_option(\"Integer Option\")):\n    await ctx.send(f\"You input {integer_option}\")\n</code></pre> <pre><code>async def my_command_function(ctx: InteractionContext, integer_option: int):\n    await ctx.send(f\"You input {integer_option}\")\n\nbot.add_interaction(\n    command=SlashCommand(\n        name=\"my_command\",\n        description=\"My first command :)\",\n        options=[\n            SlashCommandOption(\n                name=\"integer_option\",\n                description=\"Integer Option\",\n                required=True,\n                opt_type=OptionTypes.INTEGER\n            )\n        ]\n    )\n)\n</code></pre>"},{"location":"Guides/03%20Creating%20Commands/#i-dont-want-my-friends-using-my-commands","title":"I Don't Want My Friends Using My Commands","text":"<p>How rude.</p> <p>Anyway, this is somewhat possible with command permissions. While you cannot explicitly block / allow certain roles / members / channels to use your commands on the bot side, you can define default permissions which members need to have to use the command.</p> <p>However, these default permissions can be overwritten by server admins, so this system is not safe for stuff like owner only eval commands. This system is designed to limit access to admin commands after a bot is added to a server, before admins have a chance to customise the permissions they want.</p> <p>If you do not want admins to be able to overwrite your permissions, or the permissions are not flexible enough for you, you should use checks.</p> <p>In this example, we will limit access to the command to members with the <code>MANAGE_EVENTS</code> and <code>MANAGE_THREADS</code> permissions. There are two ways to define permissions.</p>  Decorators Function Definition <pre><code>@slash_command(name=\"my_command\")\n@slash_default_member_permission(Permissions.MANAGE_EVENTS)\n@slash_default_member_permission(Permissions.MANAGE_THREADS)\nasync def my_command_function(ctx: InteractionContext):\n    ...\n</code></pre> <pre><code>@slash_command(\n    name=\"my_command\",\n    default_member_permissions=Permissions.MANAGE_EVENTS | Permissions.MANAGE_THREADS,\n)\nasync def my_command_function(ctx: InteractionContext):\n    ...\n</code></pre> <p>Multiple permissions are defined with the bitwise OR operator <code>|</code>.</p>"},{"location":"Guides/03%20Creating%20Commands/#blocking-commands-in-dms","title":"Blocking Commands in DMs","text":"<p>You can also block commands in DMs. To do that, just set <code>dm_permission</code> to false.</p> <pre><code>@slash_command(\n    name=\"my_guild_only_command\",\n    dm_permission=False,\n)\nasync def my_command_function(ctx: InteractionContext):\n    ...\n</code></pre>"},{"location":"Guides/03%20Creating%20Commands/#context-menus","title":"Context Menus","text":"<p>Both default permissions and DM blocking can be used the same way for context menus, since they are normal slash commands under the hood.</p>"},{"location":"Guides/03%20Creating%20Commands/#check-this-out","title":"Check This Out","text":"<p>Checks allow you to define who can use your commands however you want.</p> <p>There are a few pre-made checks for you to use, and you can simply create your own custom checks.</p> Build-In CheckCustom CheckReusing Checks <p>Check that the author is the owner of the bot:  </p> <pre><code>@is_owner()\n@slash_command(name=\"my_command\")\nasync def my_command_function(ctx: InteractionContext):\n    ...\n</code></pre> <p>Check that the author's name starts with <code>a</code>:  </p> <pre><code>async def my_check(ctx: Context):\n    return ctx.author.name.startswith(\"a\")\n\n@check(check=my_check)\n@slash_command(name=\"my_command\")\nasync def my_command_function(ctx: InteractionContext):\n    ...\n</code></pre> <p>You can reuse checks in extensions by adding them to the extension check list</p> <pre><code>class MyExtension(Extension):\n    def __init__(self, bot) -&gt; None:\n        super().__init__(bot)\n        self.add_ext_check(is_owner())\n\n@slash_command(name=\"my_command\")\nasync def my_command_function(ctx: InteractionContext):\n    ...\n\n@slash_command(name=\"my_command2\")\nasync def my_command_function2(ctx: InteractionContext):\n    ...\n\ndef setup(bot) -&gt; None:\n    MyExtension(bot)\n</code></pre> <p>The check will be checked for every command in the extension.</p>"},{"location":"Guides/03%20Creating%20Commands/#i-dont-want-to-define-the-same-option-every-time","title":"I Don't Want To Define The Same Option Every Time","text":"<p>If you are like me, you find yourself reusing options in different commands and having to redefine them every time which is both annoying and bad programming.</p> <p>Luckily, you can simply make your own decorators that themselves call <code>@slash_option()</code>: <pre><code>def my_own_int_option():\n\"\"\"Call with `@my_own_int_option()`\"\"\"\n\n    def wrapper(func):\n        return slash_option(\n            name=\"integer_option\",\n            description=\"Integer Option\",\n            opt_type=OptionTypes.INTEGER,\n            required=True\n        )(func)\n\n    return wrapper\n\n\n@slash_command(name=\"my_command\", ...)\n@my_own_int_option()\nasync def my_command_function(ctx: InteractionContext, integer_option: int):\n    await ctx.send(f\"You input {integer_option}\")\n</code></pre></p> <p>The same principle can be used to reuse autocomplete options.</p>"},{"location":"Guides/03%20Creating%20Commands/#simplified-error-handling","title":"Simplified Error Handling","text":"<p>If you want error handling for all commands, you can override <code>Client</code> and define your own. Any error from interactions will trigger <code>on_command_error</code>. That includes context menus.</p> <p>In this example, we are logging the error and responding to the interaction if not done so yet: <pre><code>class CustomClient(Client):\n    async def on_command_error(self, ctx: InteractionContext, error: Exception):\n        logger.error(error)\n        if not ctx.responded:\n            await ctx.send(\"Something went wrong.\")\n\nclient = CustomErrorClient(...)\n</code></pre></p> <p>There also is <code>on_command</code> which you can overwrite too. That fires on every interactions usage.</p>"},{"location":"Guides/03%20Creating%20Commands/#i-need-a-custom-parameter-type","title":"I Need A Custom Parameter Type","text":"<p>If your bot is complex enough, you might find yourself wanting to use custom models in your commands.</p> <p>To do this, you'll want to use a string option, and define a converter. Information on how to use converters can be found on the converter page.</p>"},{"location":"Guides/03%20Creating%20Commands/#i-want-to-make-a-prefixed-command-too","title":"I Want To Make A Prefixed Command Too","text":"<p>You're in luck! You can use a hybrid command, which is a slash command that also gets converted to an equivalent prefixed command under the hood.</p> <p>To use it, simply replace <code>@slash_command</code> with <code>@hybrid_command</code>, and <code>InteractionContext</code> with <code>HybridContext</code>, like so:</p> <pre><code>@hybrid_command(name=\"my_command\", description=\"My hybrid command!\")\nasync def my_command_function(ctx: HybridContext):\n    await ctx.send(\"Hello World\")\n</code></pre> <p>Suggesting you are using the default mention settings for your bot, you should be able to run this command by <code>@BotPing my_command</code>.</p> <p>As you can see, the only difference between hybrid commands and slash commands, from a developer perspective, is that they use <code>HybridContext</code>, which attempts to seamlessly allow using the same context for slash and prefixed commands. You can always get the underlying context via <code>inner_context</code>, though.</p> <p>There are only two limitations with them: they only support one attachment option, and they do not support autocomplete.</p>"},{"location":"Guides/04%20Context%20Menus/","title":"Creating Context Menus","text":"<p>Context menus are interactions under the hood. Defining them is very similar. Context menus work off <code>ctx.target</code> which contains the object the user interacted with.</p> <p>You can also define <code>scopes</code> and <code>permissions</code> for them, just like with interactions.</p> <p>For more information, please visit the API reference here.</p>"},{"location":"Guides/04%20Context%20Menus/#message-context-menus","title":"Message Context Menus","text":"<p>These open up if you right-click a message and choose <code>Apps</code>.</p> <p>This example repeats the selected the message:</p> <pre><code>@context_menu(name=\"repeat\", context_type=CommandTypes.MESSAGE)\nasync def repeat(ctx: InteractionContext):\n    message: Message = ctx.target\n    await ctx.send(message.content)\n</code></pre>"},{"location":"Guides/04%20Context%20Menus/#user-context-menus","title":"User Context Menus","text":"<p>These open up if you right-click a user and choose <code>Apps</code>.</p> <p>This example pings the user:</p> <p><pre><code>@context_menu(name=\"ping\", context_type=CommandTypes.USER)\nasync def ping(ctx: InteractionContext):\n    member: Member = ctx.target\n    await ctx.send(member.mention)\n</code></pre>     ??? note         Command names must be lowercase and can only contain <code>-</code> and <code>_</code> as special symbols and must not contain spaces.</p>"},{"location":"Guides/05%20Components/","title":"Components","text":"<p>While interactions are cool and all, they are still missing a vital component. Introducing components, aka Buttons, Selects, soon Text Input Fields. Components can be added to any message by passing them to <code>components</code> in any <code>.send()</code> method.</p> <p>They are organised in a 5x5 grid, so you either have to manage the layout yourself, use <code>spread_to_rows()</code> where we organise them for you, or have a single component.</p> <p>If you want to define the layout yourself, you have to put them in an <code>ActionRow()</code>. The <code>components</code> parameter need a list of up to five <code>ActionRow()</code>.</p> <code>ActionRow()</code> <code>spread_to_rows()</code> With only one component <pre><code>components: list[ActionRow] = [\n    ActionRow(\n        Button(\n            style=ButtonStyles.GREEN,\n            label=\"Click Me\",\n        ),\n        Button(\n            style=ButtonStyles.GREEN,\n            label=\"Click Me Too\",\n        )\n    )\n]\n\nawait channel.send(\"Look, Buttons!\", components=components)\n</code></pre> <pre><code>components: list[ActionRow] = spread_to_rows(\n    Button(\n        style=ButtonStyles.GREEN,\n        label=\"Click Me\",\n    ),\n    Button(\n        style=ButtonStyles.GREEN,\n        label=\"Click Me Too\",\n    )\n)\n\nawait channel.send(\"Look, Buttons!\", components=components)\n</code></pre> <p>If you only have one component, you do not need to worry about the layout at all and can simply pass it. We will put it in an <code>ActionRow</code> behind the scenes.</p> <pre><code>components = Button(\n    style=ButtonStyles.GREEN,\n    label=\"Click Me\",\n)\n\nawait channel.send(\"Look, Buttons!\", components=components)\n</code></pre> <p>For simplicity's sake, example three will be used for all examples going forward.</p> <p>If you want to delete components, you need to pass <code>components=[]</code> to <code>.edit()</code>.</p>"},{"location":"Guides/05%20Components/#you-have-to-button-up","title":"You Have To Button Up","text":"<p>Buttons are, you guessed right, buttons. Users can click them, and they can be disabled if you wish. That's all really.</p> <pre><code>components = Button(\n    style=ButtonStyles.GREEN,\n    label=\"Click Me\",\n    disabled=False,\n)\n\nawait channel.send(\"Look a Button!\", components=components)\n</code></pre> <p>For more information, please visit the API reference here.</p>"},{"location":"Guides/05%20Components/#i-need-more-style","title":"I Need More Style","text":"<p>You are in luck, there are a bunch of colours you can choose from.     </p> <p>The colours correspond to the styles found in <code>ButtonStyles</code>. Click here for more information.</p> <p>If you use <code>ButtonStyles.URL</code>, you can pass an url to the button with <code>url</code>. Users who click the button will get redirected to your url. <pre><code>components = Button(\n    style=ButtonStyles.URL,\n    label=\"Click Me\",\n    url=\"https://github.com/Discord-Snake-Pit/NAFF\",\n)\n\nawait channel.send(\"Look a Button!\", components=components)\n</code></pre></p> <p><code>ButtonStyles.URL</code> does not receive events, or work with callbacks.</p>"},{"location":"Guides/05%20Components/#select-your-favorite","title":"Select Your Favorite","text":"<p>Sometimes there might be more than a handful options which users need to decide between. That's when a <code>Select</code> should probably be used.</p> <p>Selects are very similar to Buttons. The main difference is that you get a list of options to choose from.</p> <p>If you want to use string options, then you use <code>StringSelect</code>. Simply pass a list of strings to <code>options</code> and you are good to go. You can also explicitly pass <code>SelectOptions</code> to control the value attribute.</p> <p>You can also define how many options users can choose by setting <code>min_values</code> and <code>max_values</code>.</p> <p><pre><code>from naff import StringSelectMenu, SelectOption\n\ncomponents = StringSelectMenu(\n    options=[\n        \"Pizza\", \"Pasta\", \"Burger\", \"Salad\"\n    ],\n    placeholder=\"What is your favourite food?\",\n    min_values=1,\n    max_values=1,\n)\n\nawait channel.send(\"Look a Select!\", components=components)\n</code></pre>     ??? note         You can only have upto 25 options in a Select</p> <p>Alternatively, you can use <code>RoleSelectMenu</code>, <code>UserSelectMenu</code> and <code>ChannelSelectMenu</code> to select roles, users and channels respectively. These select menus are very similar to <code>StringSelectMenu</code>, but they don't allow you to pass a list of options; it's all done behind the scenes.</p> <p>```python</p> <p>For more information, please visit the API reference here.</p>"},{"location":"Guides/05%20Components/#responding","title":"Responding","text":"<p>Okay now you can make components, but how do you interact with users? There are three ways to respond to components.</p> <p>If you add your component to a temporary message asking for additional user input, just should probably use <code>bot.wait_for_component()</code>. These have the downside that, for example, they won't work anymore after restarting your bot.</p> <p>Otherwise, you are looking for a persistent callback. For that, you want to define <code>custom_id</code> in your component creation.</p> <p>When responding to a component you need to satisfy discord either by responding to the context with <code>ctx.send()</code> or by editing the component with <code>ctx.edit_origin()</code>. You get access to the context with <code>component.context</code>.</p> <code>bot.wait_for_component()</code> Persistent Callback Option 1 Persistent Callback Option 2 Persistent Callback Option 3 <p>As with discord.py, this supports checks and timeouts.</p> <p>In this example, we are checking that the username starts with \"a\" and clicks the button within 30 seconds. If it times out, we're just gonna disable it ```python components = Button(     custom_id=\"my_button_id\",     style=ButtonStyles.GREEN,     label=\"Click Me\", )</p> <p>message = await channel.send(\"Look a Button!\", components=components)</p> <p>You can listen to the <code>on_component()</code> event and then handle your callback. This works even after restarts!</p> <p>```python async def my_command(...):     components = Button(         custom_id=\"my_button_id\",         style=ButtonStyles.GREEN,         label=\"Click Me\",     )</p> <pre><code>await channel.send(\"Look a Button!\", components=components)\n</code></pre> <p>@listen() async def on_component(event: Component):     ctx = event.context</p> <pre><code>match ctx.custom_id:\n    case \"my_button_id\":\n        await ctx.send(\"You clicked it!\")\n</code></pre> <p>```</p> <p>If you have a lot of components, putting everything in the <code>on_component()</code> event can get messy really quick.</p> <p>Similarly to Option 1, you can define <code>@component_callback</code> listeners. This works after restarts too.</p> <p>You have to pass your <code>custom_id</code> to <code>@component_callback(custom_id)</code> for the library to be able to register the callback function to the wanted component.</p> <p>```python async def my_command(...):     components = Button(         custom_id=\"my_button_id\",         style=ButtonStyles.GREEN,         label=\"Click Me\",     )</p> <pre><code>await channel.send(\"Look a Button!\", components=components)\n</code></pre> <p>Personally, I put my callbacks into different files, which is why I use this method, because the usage of different files can make using decorators challenging.</p> <p>For this example to work, the function name needs to be the same as the <code>custom_id</code> of the component.</p> <p>```python async def my_command(...):     components = Button(         custom_id=\"my_button_id\",         style=ButtonStyles.GREEN,         label=\"Click Me\",     )</p> <pre><code>await channel.send(\"Look a Button!\", components=components)\n</code></pre>"},{"location":"Guides/05%20Components/#define-the-check","title":"define the check","text":"<p>def check(component: Button) -&gt; bool:     return component.context.author.startswith(\"a\")</p> <p>try:     # you need to pass the component you want to listen for here     # you can also pass an ActionRow, or a list of ActionRows. Then a press on any component in there will be listened for     used_component = await bot.wait_for_component(components=components, check=check, timeout=30)</p> <p>except TimeoutError:     print(\"Timed Out!\")</p> <pre><code>components[0].components[0].disabled = True\nawait message.edit(components=components)\n</code></pre> <p>else:     await used_component.context.send(\"Your name starts with 'a'\") ```</p> <p>You can also use this to check for a normal message instead of a component interaction.</p> <p>For more information, please visit the API reference here.</p>"},{"location":"Guides/05%20Components/#you-need-to-pass-your-custom_id-to-this-decorator","title":"you need to pass your custom_id to this decorator","text":"<p>@component_callback(\"my_button_id\") async def my_callback(ctx: ComponentContext):     await ctx.send(\"You clicked it!\") ```</p>"},{"location":"Guides/05%20Components/#my-callbacks-go-in-here-or-i-subclass-this-if-i-want-to-split-it-up","title":"my callbacks go in here or I subclass this if I want to split it up","text":"<p>class MyComponentCallbacks:     @staticmethod     async def my_button_id(ctx: ComponentContext):         await ctx.send(\"You clicked it!\")</p>"},{"location":"Guides/05%20Components/#magically-register-all-functions-from-the-class","title":"magically register all functions from the class","text":"<p>for custom_id in [k for k in MyComponentCallbacks.dict if not k.startswith(\"__\")]:     bot.add_component_callback(         ComponentCommand(             name=f\"ComponentCallback::{custom_id}\",             callback=getattr(ComponentCallbacks, custom_id),             listeners=[custom_id],         )     ) ```</p>"},{"location":"Guides/06%20Modals/","title":"Modals","text":"<p>As everyone knows from surfing the web, popups are really great. Everyone loves them and they make for a great UX. Luckily for you, you have the option to regale your users love for them by using modals.</p> <p>Modals are made of modular (hah) components, similar to <code>ActionRow</code> from the last Chapter. Importantly, both modals themselves and modal components also have a <code>custom_id</code> which you can supply. If you want to do anything with the data the users input, it is highly recommended that you set a <code>custom_id</code> for your components.</p> <p>You cannot not use the same components you can use in <code>ActionRow</code> for modals.</p>"},{"location":"Guides/06%20Modals/#making-modular-modals","title":"Making Modular Modals","text":"<p>Modals are one of the ways you can respond to interactions. They are intended for when you need to query a lot of information from a user.</p> <p>Modals are valid responses to Slash Commands and Components. You cannot respond to a modal with a modal. Use <code>ctx.send_modal()</code> to send a modal.</p> <pre><code>@slash_command(name=\"my_modal_command\", description=\"Playing with Modals\")\nasync def my_command_function(ctx: InteractionContext):\n    my_modal = Modal(\n        title=\"My Modal\",\n        components=[\n            ShortText(label=\"Short Input Text\", custom_id=\"short_text\"),\n            ParagraphText(label=\"Long Input Text\", custom_id=\"long_text\"),\n        ],\n    )\n    await ctx.send_modal(modal=my_modal)\n    ...\n</code></pre> <p>This example leads to the following modal:     </p>"},{"location":"Guides/06%20Modals/#reading-responses","title":"Reading Responses","text":"<p>Okay now the users can input and submit information, but we cannot view their response yet. To wait for a user to fill out a modal and then get the data, use <code>bot.wait_for_modal(my_modal)</code>.</p> <p>As with <code>bot.wait_for_component()</code>, <code>bot.wait_for_modal()</code> supports timeouts. Checks are not supported, since modals are not persistent like Components, and only visible to the Interaction invoker.</p> <pre><code>...\nmodal_ctx: ModalContext = await ctx.bot.wait_for_modal(my_modal)\nawait modal_ctx.send(f\"\"\"You input {modal_ctx.responses[\"short_text\"]} and {modal_ctx.responses[\"long_text\"]}\"\"\")\n</code></pre> <p><code>bot.wait_for_modal()</code> returns <code>ModalContext</code> which, to nobodies surprise, you need to respond to as well. Respond to it by utilising <code>modal_ctx.send()</code>, as you are probably already used to.</p> <p>To get the data the user input, you can use <code>modal_ctx.responses</code>. This returns a dictionary with the <code>custom_id</code> you set for your components as keys, and the users inputs as values. As previously mentioned, you really want to set your own <code>custom_id</code> otherwise you will have problems figuring out which input belongs to which component.  </p>"},{"location":"Guides/06%20Modals/#customising-components","title":"Customising Components","text":"<p>Modal components are customisable in their appearance. You can set a placeholder, pre-fill them, restrict what users can input, or make them optional.</p> <pre><code>@slash_command(name=\"my_modal_command\", description=\"Playing with Modals\")\nasync def my_command_function(ctx: InteractionContext):\n        my_modal = Modal(\n        title=\"My Modal\",\n        components=[\n            ShortText(\n                label=\"Short Input Text\",\n                custom_id=\"short_text\",\n                value=\"Pre-filled text\",\n                min_length=10,\n            ),\n            ShortText(\n                label=\"Short Input Text\",\n                custom_id=\"optional_short_text\",\n                required=False,\n                placeholder=\"Please be concise\",\n                max_length=10,\n            ),\n        ],\n    )\n    await ctx.send_modal(modal=my_modal)\n    ...\n</code></pre> <p>This example leads to the following modal:     </p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/","title":"Creating Prefixed Commands","text":"<p>Prefixed commands, called by Discord as \"text commands\" and sometimes called \"message commands\" (not to be confused with Context Menu Message Commands), are commands that are triggered when a user sends a normal message with a designated \"prefix\" in front of them.</p> Naming <p>While Discord themselves has used \"text commands\" to refer to these, we disagree with this naming. We think it is confusing, especially when referring to how Discord refers to slash commands (chat input commands). Thus, this library will use \"prefixed commands\", both in code and for its documentation.</p> <p>While slash commands have been released, and is typically the way you should be making commands these days, there are many cases where the \"legacy\" commands may want to be kept due to various reasons, like wanting to use types not well-supported by Discord or to allow for greater flexibility for permission handling.</p> <p>Whatever the reason is, <code>NAFF</code> has an extensive yet familiar prefixed command architecture ready to be used.</p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#your-first-prefixed-command","title":"Your First Prefixed Command","text":"<p>To create a prefixed command, simply define an asynchronous function and use the <code>@prefixed_command()</code> decorator above it.</p> <pre><code>@prefixed_command(name=\"my_command\")\nasync def my_command_function(ctx: PrefixedContext):\n    await ctx.reply(\"Hello world!\")\n</code></pre> Command Name <p>If <code>name</code> is not specified, <code>NAFF</code> will automatically use the function's name as the command's name.</p> <p>If the bot's prefix was set to <code>!</code>, then a user could invoke it like so:</p> <p></p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#subcommands","title":"Subcommands","text":"<p>Subcommands are rather simple, too:</p> <pre><code>@prefixed_command()\nasync def base_command(ctx: PrefixedContext):\n    await ctx.reply(\"This is the base command.\")\n\n@base_command.subcommand()\nasync def subcommand(ctx: PrefixedContext):\n    await ctx.reply(\"This is a subcommand.\")\n</code></pre> <p>A user can use them like so:</p> <p></p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#parameters","title":"Parameters","text":"<p>Often, when using prefixed commands, you typically want to parse what the user says into separated parameters/arguments. This can be done easily in this library using a Python-esque syntax.</p> <p>For example, to make a command that takes in one argument, we can do: <pre><code>@prefixed_command()\nasync def test(ctx: PrefixedContext, arg):\n    await ctx.reply(arg)\n</code></pre></p> <p>When a user uses the command, all they simply need to do is pass a word after the command:</p> <p></p> <p>If the user wishes to use multiple words in an argument like this, they can wrap it in quotes like so:</p> <p></p> <p>Forgetting Quotes</p> <p>If a user forgets or simply does not wrap multiple words in an argument in quotes, the library will only use the first word for the argument and ignore the rest.</p> <p></p> <p>You can add as many parameters as you want to a command: <pre><code>@prefixed_command()\nasync def test(ctx: PrefixedContext, arg1, arg2):\n    await ctx.reply(f\"Arguments: {arg1}, {arg2}.\")\n</code></pre></p> <p></p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#variable-and-keyword-only-arguments","title":"Variable and Keyword-Only Arguments","text":"<p>There may be times where you wish for an argument to be able to have multiple words without wrapping them in quotes. There are two ways of approaching this.</p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#variable","title":"Variable","text":"<p>If you wish to get a list (or more specifically, a tuple) of words for one argument, or simply want an undetermined amount of arguments for a command, then you should use a variable argument: <pre><code>@prefixed_command()\nasync def test(ctx: PrefixedContext, *args):\n    await ctx.reply(f\"{len(args)} arguments: {', '.join(args)}\")\n</code></pre></p> <p>The result looks something like this:</p> <p></p> <p>Notice how the quoted words are still parsed as one argument in the tuple.</p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#keyword-only","title":"Keyword-Only","text":"<p>If you simply wish to take in the rest of the user's input as an argument, you can use a keyword-only argument, like so: <pre><code>@prefixed_command()\nasync def test(ctx: PrefixedContext, *, arg):\n    await ctx.reply(arg)\n</code></pre></p> <p>The result looks like this:</p> <p></p> Quotes <p>If a user passes quotes into a keyword-only argument, then the resulting argument will have said quotes.</p> <p></p> <p>Parser ambiguities</p> <p>Due to parser ambiguities, you can only have either a single variable or keyword-only/consume rest argument.</p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#typehinting-and-converters","title":"Typehinting and Converters","text":""},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#basic-types","title":"Basic Types","text":"<p>Parameters, by default, are assumed to be strings, since <code>Message.content</code>, the content used for prefixed commands, is one. However, there are many times where you want to have a parameter be a more specific type, like an integer or boolean.</p> <p><code>NAFF</code> provides an easy syntax to do so:</p> <pre><code>@prefixed_command()\nasync def test(ctx: PrefixedContext, an_int: int, a_float: float):\n    await ctx.reply(str(an_int + a_float))\n</code></pre> <p></p> <p>Words/arguments will automatically be converted to the specified type. If <code>NAFF</code> is unable to convert it (a user could easily pass a letter into <code>an_int</code>), then it will raise a <code>BadArgument</code> error, which can be handled by an error handler. Error handling is handled similarly to how it is handled with slash commands.</p> <p>You can even pass in a function for parameters:</p> <pre><code>def to_upper(arg: str):\n    return arg.upper()\n\n@prefixed_command()\nasync def test(ctx: PrefixedContext, uppered: to_upper):\n    await ctx.reply(uppered)\n</code></pre> <p></p> Functions <p>If functions are used as arguments, they can either have one parameter (which is the passed argument as a string) or two parameters (which are the context and the argument). They can also be asynchronous or synchronous. Also, your typechecker will likely complain about this. You can ignore it for <code>NAFF</code>.</p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#booleans","title":"Booleans","text":"<p>Booleans, unlike other basic types, are handled somewhat differently, as using the default <code>bool</code> converter would make any non-empty argument <code>True</code>. It is instead evaluated as so:</p> <pre><code>if lowered in {\"yes\", \"y\", \"true\", \"t\", \"1\", \"enable\", \"on\"}:\n    return True\nelif lowered in {\"no\", \"n\", \"false\", \"f\", \"0\", \"disable\", \"off\"}:\n    return False\n</code></pre>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#converters","title":"Converters","text":"<p>Converters work much in the same way as they do for other commands; see the guide for converters for reference.</p> <p>There are a few specific converters that only work with prefixed commands due to their nature, however.</p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#discord-converters","title":"Discord Converters","text":"<p>Prefixed commands can be typehinted with some Discord models, like so:</p> <pre><code>@prefixed_command()\nasync def poke(ctx: PrefixedContext, target: Member):\n    await ctx.reply(f\"{target.mention}, you got poked by {ctx.author.mention}!\")\n</code></pre> <p>The argument here will automatically be converted into a <code>Member</code> object:</p> <p></p> <p>A table of supported objects and their converters can be found here. You may use the Discord model itself in your command for prefixed commands, just like the above, and their respective converter will be used under the hood.</p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#typingunion","title":"<code>typing.Union</code>","text":"<p><code>typing.Union</code> allows for a parameter/argument to be of multiple types instead of one. <code>NAFF</code> will attempt to convert a given argument into each type specified (starting from the first one), going down the \"list\" until a valid match is found.</p> <p>For example, the below will try to convert an argument to a <code>GuildText</code> first, then a <code>User</code> if it cannot do so.</p> <pre><code>@prefixed_command()\nasync def union(ctx: PrefixedContext, param: Union[GuildText, User]):\n    await ctx.reply(str(param))\n</code></pre> <p></p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#typingoptional","title":"<code>typing.Optional</code>","text":"<p>Usually, <code>Optional[OBJECT]</code> is an alias for <code>Union[OBJECT, None]</code> - it indicates the parameter can be passed <code>None</code> or an instance of the object itself. It means something slightly different here, however.</p> <p>If a parameter is marked as <code>Optional</code>, then the command handler will try converting it to the type inside of it, defaulting to either <code>None</code> or a default value, if found. A similar behavior is done is the value has a default value, regardless of if it is marked with <code>Optional</code> or not.</p> <p>For example, you could use the following code:</p> <pre><code>@prefixed_command()\nasync def ban(ctx: PrefixedContext, member: Member, delete_message_days: Optional[int] = 0, *, reason: str):\n    await member.ban(delete_message_days=delete_message_days, reason=reason)\n    await ctx.reply(f\"Banned {member.mention} for {reason}. Deleted {delete_message_days} days of their messages.\")\n</code></pre> <p>And if a user omits the <code>delete_message_days</code> parameter, it would act as so:</p> <p></p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#typingliteral","title":"<code>typing.Literal</code>","text":"<p><code>typing.Literal</code> specifies that a parameter must be one of the values in the list. <code>NAFF</code> also forces that here (though this only works with values of basic types, like <code>str</code> or <code>int</code>):</p> <pre><code>@prefixed_command()\nasync def one_or_two(ctx: PrefixedContext, num: Literal[1, 2]):\n    await ctx.reply(str(num))\n</code></pre> <p></p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#typingannotated","title":"<code>typing.Annotated</code>","text":"<p>Using <code>typing.Annotated</code> can allow you to have more proper typehints when using converters:</p> <pre><code>class JudgementConverter(Converter):\n    async def convert(self, ctx: PrefixedContext, argument: str):\n        return f\"{ctx.author.mention} is {argument}.\"\n\n@prefixed_command()\nasync def judgement(ctx: PrefixedContext, judgment: Annotated[str, JudgementConverter]):\n    await ctx.reply(judgment)\n</code></pre> <p><code>NAFF</code> will use the second parameter in <code>Annotated</code> as the actual converter.</p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#greedy","title":"<code>Greedy</code>","text":"<p>The <code>Greedy</code> class, included in this library, specifies <code>NAFF</code> to keep converting as many arguments as it can until it fails to do so. For example:</p> <pre><code>@prefixed_command()\nasync def slap(ctx: PrefixedContext, members: Greedy[Member]):\n    slapped = \", \".join(x.display_name for x in members)\n    await ctx.reply(f\"{slapped} just got slapped!\")\n</code></pre> <p></p> <p>Greedy Warnings</p> <p><code>Greedy</code> does not default to being optional. You must specify that it is by giving it a default value or wrapping it with <code>Optional</code>. <code>Greedy</code>, <code>str</code>, <code>None</code>, <code>Optional</code> are also not allowed as parameters in <code>Greedy</code>. <code>Greedy</code> cannot be used as a variable or keyword-only argument.</p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#help-command","title":"Help Command","text":"<p>There is no automatically added help command in <code>NAFF</code>. However, you can use <code>PrefixedHelpCommand</code> to create one with ease. Using it looks like so:</p> <pre><code>from naff.ext.prefixed_help import PrefixedHelpCommand\n\n# There are a variety of options - adjust them to your liking!\nhelp_cmd = PrefixedHelpCommand(bot, ...)\nhelp_cmd.register()\n</code></pre> <p>With the default options, the result looks like:</p> <p></p>"},{"location":"Guides/07%20Creating%20Prefixed%20Commands/#other-notes","title":"Other Notes","text":"<ul> <li>Checks, cooldowns, and concurrency all work as-is with prefixed commands.</li> <li>Prefixed commands use a different method to process <code>Converter</code>s compared to slash commands. While they should roughly give the same result, they may act slightly differently.</li> <li>All prefixed commands use <code>PrefixedContext</code>, which contains useful information based on the current instance of the command.</li> </ul>"},{"location":"Guides/08%20Converters/","title":"Converters","text":"<p>If your bot is complex enough, you might find yourself wanting to use custom models in your commands. Converters are classes that allow you to do just that, and can be used in both slash and prefixed commands.</p> <p>This can be useful if you frequently find yourself starting commands with <code>thing = lookup(thing_name)</code>.</p>"},{"location":"Guides/08%20Converters/#inline-converters","title":"Inline Converters","text":"<p>If you do not wish to create an entirely new class, you can simply add a <code>convert</code> function in your existing class:</p> <pre><code>class DatabaseEntry():\n    name: str\n    description: str\n    score: int\n\n    @classmethod  # you can also use staticmethod\n    async def convert(cls, ctx: Context, value: str) -&gt; DatabaseEntry:\n\"\"\"This is where the magic happens\"\"\"\n        return cls(hypothetical_database.lookup(ctx.guild.id, value))\n\n# Slash Command:\n@slash_command(name=\"lookup\", description=\"Gives info about a thing from the db\")\n@slash_option(\n    name=\"thing\",\n    description=\"The user enters a string\",\n    required=True,\n    opt_type=OptionTypes.STRING\n)\nasync def my_command_function(ctx: InteractionContext, thing: DatabaseEntry):\n    await ctx.send(f\"***{thing.name}***\\n{thing.description}\\nScore: {thing.score}/10\")\n\n# Prefixed Command:\n@prefixed_command()\nasync def my_command_function(ctx: InteractionContext, thing: DatabaseEntry):\n    await ctx.reply(f\"***{thing.name}***\\n{thing.description}\\nScore: {thing.score}/10\")\n</code></pre> <p>As you can see, a converter can transparently convert what Discord sends you (a string, a user, etc) into something more complex (a pokemon card, a scoresheet, etc).</p>"},{"location":"Guides/08%20Converters/#converter","title":"<code>Converter</code>","text":"<p>You may also use the <code>Converter</code> class that <code>NAFF</code> has as well.</p> <pre><code>class UpperConverter(Converter):\n    async def convert(ctx: PrefixedContext, argument: str):\n        return argument.upper()\n\n# Slash Command:\n@slash_command(name=\"upper\", description=\"Sends back the input in all caps.\")\n@slash_option(\n    name=\"to_upper\",\n    description=\"The thing to make all caps.\",\n    required=True,\n    opt_type=OptionTypes.STRING\n)\nasync def upper(ctx: InteractionContext, to_upper: UpperConverter):\n    await ctx.send(to_upper)\n\n# Prefixed Command:\n@prefixed_command()\nasync def upper(ctx: PrefixedContext, to_upper: UpperConverter):\n    await ctx.reply(to_upper)\n</code></pre>"},{"location":"Guides/08%20Converters/#built-in-converters","title":"Built-in Converters","text":""},{"location":"Guides/08%20Converters/#context-based-arguments","title":"Context-based Arguments","text":"<p>The library provides <code>CMD_ARGS</code>, <code>CMD_AUTHOR</code>, <code>CMD_BODY</code>, and <code>CMD_CHANNEL</code> to get the arguments, the author, the body, and the channel of an instance of a command based on its context. While you can do these yourself in the command itself, having this as an argument may be useful to you, especially for cases where you only have one argument that takes in the rest of the message:</p> <pre><code># this example is only viable for prefixed commands\n# the other CMD_* can be used with slash commands, however\n@prefixed_command()\nasync def say(ctx: PrefixedContext, content: CMD_BODY):\n    await ctx.reply(content)\n</code></pre>"},{"location":"Guides/08%20Converters/#discord-model-converters","title":"Discord Model Converters","text":"<p>There are also <code>Converter</code>s that represent some Discord models that you can subclass from. These are largely useful for prefixed commands, but you may find a use for them elsewhere.</p> <p>A table of objects and their respective converter is as follows:</p> Discord Model Converter <code>SnowflakeObject</code> <code>SnowflakeConverter</code> <code>BaseChannel</code>, <code>TYPE_ALL_CHANNEL</code> <code>BaseChannelConverter</code> <code>DMChannel</code>, <code>TYPE_DM_CHANNEL</code> <code>DMChannelConverter</code> <code>DM</code> <code>DMConverter</code> <code>DMGroup</code> <code>DMGroupConverter</code> <code>GuildChannel</code>, <code>TYPE_GUILD_CHANNEL</code> <code>GuildChannelConverter</code> <code>GuildNews</code> <code>GuildNewsConverter</code> <code>GuildCategory</code> <code>GuildCategoryConverter</code> <code>GuildText</code> <code>GuildTextConverter</code> <code>ThreadChannel</code>, <code>TYPE_THREAD_CHANNEL</code> <code>ThreadChannelConverter</code> <code>GuildNewsThread</code> <code>GuildNewsThreadConverter</code> <code>GuildPublicThread</code> <code>GuildPublicThreadConverter</code> <code>GuildPrivateThread</code> <code>GuildPrivateThreadConverter</code> <code>VoiceChannel</code>, <code>TYPE_VOICE_CHANNEL</code> <code>VoiceChannelConverter</code> <code>GuildVoice</code> <code>GuildVoiceConverter</code> <code>GuildStageVoice</code> <code>GuildStageVoiceConverter</code> <code>TYPE_MESSAGEABLE_CHANNEL</code> <code>MessageableChannelConverter</code> <code>User</code> <code>UserConverter</code> <code>Member</code> <code>MemberConverter</code> <code>Guild</code> <code>GuildConverter</code> <code>Role</code> <code>RoleConverter</code> <code>PartialEmoji</code> <code>PartialEmojiConverter</code> <code>CustomEmoji</code> <code>CustomEmojiConverter</code>"},{"location":"Guides/10%20Events/","title":"Events","text":"<p>Events are dispatched whenever a subscribed event gets sent by Discord.</p>"},{"location":"Guides/10%20Events/#what-events-can-i-get","title":"What Events Can I Get","text":"<p>What events you subscribe to are defined at startup by setting your <code>Intents</code>.</p> <p><code>Intents.DEFAULT</code> is a good place to start if your bot is new and small, otherwise, it is recommended to take your time and go through them one by one. <pre><code>bot = Client(intents=Intents.DEFAULT)\nbot.start(\"Put your token here\")\n</code></pre></p> <p>For more information, please visit the API reference here.</p>"},{"location":"Guides/10%20Events/#hey-listen","title":"Hey Listen!!!","text":"<p>Now you can receive events. To respond to them, you need to register a callback. Callbacks should be lower-case, use <code>_</code> instead of spaces and start with <code>on_</code>. Depending on how you register your callbacks that's not a requirement, but it is a good habit nonetheless.</p> <p>For example, the event callback for the <code>ChannelCreate</code> event should be called <code>on_channel_create</code>.</p> <p>You can find all events and their signatures here.</p> <p>Be aware that your <code>Intents</code> must be set to receive the event you are looking for.</p> <p>There are two ways to register events. Decorators are the recommended way to do this.</p>  Decorators Manual Registration <p>To use decorators, they need to be in the same file where you defined your <code>bot = Client()</code>.</p> <pre><code>bot = Client(intents=Intents.DEFAULT)\n\n@listen()\nasync def on_channel_create(event: ChannelCreate):\n    # this event is called when a channel is created in a guild where the bot is\n\n    print(f\"Channel created with name: {event.channel.name}\")\n\nbot.start(\"Put your token here\")\n</code></pre> <p>You can also use <code>@listen</code> with any function names:</p> <pre><code>@listen(ChannelCreate)\nasync def my_function(event: ChannelCreate):\n    # you can pass the event\n    ...\n\n@listen(\"on_channel_create\")\nasync def my_function(event: ChannelCreate):\n    # you can also pass the event name as a string\n    ...\n\n@listen()\nasync def my_function(event: ChannelCreate):\n    # you can also use the typehint of `event`\n    ...\n</code></pre> <p>You can also register the events manually. This gives you the most flexibility, but it's not the cleanest.</p> <pre><code>async def on_channel_create(event: ChannelCreate):\n    # this event is called when a channel is created in a guild where the bot is\n\n    print(f\"Channel created with name: {event.channel.name}\")\n\n\nbot = Client(intents=Intents.DEFAULT)\nbot.add_listener(Listener(func=on_channel_create, event=\"on_channel_create\"))\nbot.start(\"Put your token here\")\n</code></pre>"},{"location":"Guides/20%20Extensions/","title":"Extensions","text":"<p>Damn, your code is getting pretty messy now, huh? Wouldn't it be nice if you could organise your commands and listeners into separate files?</p> <p>Well let me introduce you to <code>Extensions</code> Extensions allow you to split your commands and listeners into separate files to allow you to better organise your project, as well as that, they allow you to reload Extensions without having to shut down your bot.</p> <p>Sounds pretty good right? Well, let's go over how you can use them:</p>"},{"location":"Guides/20%20Extensions/#usage","title":"Usage","text":"<p>Below is an example of a bot, one with extensions, one without.</p> Example Usage: Without ExtensionsWith Extensions <pre><code># File: `main.py`\nimport logging\n\nimport naff.const\nfrom naff.client import Client\nfrom naff.models.application_commands import slash_command, slash_option\nfrom naff.models.command import prefixed_command\nfrom naff.models.context import InteractionContext\nfrom naff.models.discord_objects.components import Button, ActionRow\nfrom naff.models.enums import ButtonStyles\nfrom naff.models.enums import Intents\nfrom naff.models.events import Component\nfrom naff.models.listener import listen\n\nlogging.basicConfig()\ncls_log = logging.getLogger(naff.const.logger_name)\ncls_log.setLevel(logging.DEBUG)\n\nbot = Client(intents=Intents.DEFAULT, sync_interactions=True, asyncio_debug=True)\n\n\n@listen()\nasync def on_ready():\n    print(\"Ready\")\n    print(f\"This bot is owned by {bot.owner}\")\n\n\n@listen()\nasync def on_guild_create(event):\n    print(f\"guild created : {event.guild.name}\")\n\n\n@listen()\nasync def on_message_create(event):\n    print(f\"message received: {event.message.content}\")\n\n\n@listen()\nasync def on_component(event: Component):\n    ctx = event.context\n    await ctx.edit_origin(\"test\")\n\n\n@prefixed_command()\nasync def multiple_buttons(ctx):\n    await ctx.send(\n        \"2 buttons in a row\",\n        components=[Button(ButtonStyles.BLURPLE, \"A blurple button\"), Button(ButtonStyles.RED, \"A red button\")],\n    )\n\n\n@prefixed_command()\nasync def action_rows(ctx):\n    await ctx.send(\n        \"2 buttons in 2 rows, using nested lists\",\n        components=[[Button(ButtonStyles.BLURPLE, \"A blurple button\")], [Button(ButtonStyles.RED, \"A red button\")]],\n    )\n\n\n@prefixed_command()\nasync def action_rows_more(ctx):\n    await ctx.send(\n        \"2 buttons in 2 rows, using explicit action_rows lists\",\n        components=[\n            ActionRow(Button(ButtonStyles.BLURPLE, \"A blurple button\")),\n            ActionRow(Button(ButtonStyles.RED, \"A red button\")),\n        ],\n    )\n\n\nbot.start(\"Token\")\n</code></pre> <p><pre><code># File: `main.py`\nimport logging\n\nimport naff.const\nfrom naff.client import Client\nfrom naff.models.context import ComponentContext\nfrom naff.models.enums import Intents\nfrom naff.models.events import Component\nfrom naff.models.listener import listen\n\n\nlogging.basicConfig()\ncls_log = logging.getLogger(naff.const.logger_name)\ncls_log.setLevel(logging.DEBUG)\n\nbot = Client(intents=Intents.DEFAULT, sync_interactions=True, asyncio_debug=True)\n\n\n@listen()\nasync def on_ready():\n    print(\"Ready\")\n    print(f\"This bot is owned by {bot.owner}\")\n\n\n@listen()\nasync def on_guild_create(event):\n    print(f\"guild created : {event.guild.name}\")\n\n\n@listen()\nasync def on_message_create(event):\n    print(f\"message received: {event.message.content}\")\n\n\n@listen()\nasync def on_component(event: Component):\n    ctx = event.context\n    await ctx.edit_origin(\"test\")\n\n\nbot.load_extension(\"test_components\")\nbot.start(\"Token\")\n</code></pre> <pre><code># File: `test_components.py`\n\nfrom naff.models.command import prefixed_command\nfrom naff.models.discord_objects.components import Button, ActionRow\nfrom naff.models.enums import ButtonStyles\nfrom naff.models.extension import Extension\n\n\nclass ButtonExampleSkin(Extension):\n    @prefixed_command()\n    async def blurple_button(self, ctx):\n        await ctx.send(\"hello there\", components=Button(ButtonStyles.BLURPLE, \"A blurple button\"))\n\n    @prefixed_command()\n    async def multiple_buttons(self, ctx):\n        await ctx.send(\n            \"2 buttons in a row\",\n            components=[Button(ButtonStyles.BLURPLE, \"A blurple button\"), Button(ButtonStyles.RED, \"A red button\")],\n        )\n\n    @prefixed_command()\n    async def action_rows(self, ctx):\n        await ctx.send(\n            \"2 buttons in 2 rows, using nested lists\",\n            components=[[Button(ButtonStyles.BLURPLE, \"A blurple button\")], [Button(ButtonStyles.RED, \"A red button\")]],\n        )\n\n    @prefixed_command()\n    async def action_rows_more(self, ctx):\n        await ctx.send(\n            \"2 buttons in 2 rows, using explicit action_rows lists\",\n            components=[\n                ActionRow(Button(ButtonStyles.BLURPLE, \"A blurple button\")),\n                ActionRow(Button(ButtonStyles.RED, \"A red button\")),\n            ],\n        )\n\n\ndef setup(bot):\n    ButtonExampleSkin(bot)\n</code></pre></p> <p>Extensions are effectively just another python file that contains a class that inherits from an object called <code>Extension</code>, inside this extension, you can put whatever you would like. And upon loading, the contents are added to the bot.</p> <p><pre><code>from naff import Extension\n\n\nclass SomeClass(Extension):\n    ...\n\n\ndef setup(bot):\n    # This is called by naff so it knows how to load the Extension\n    SomeClass(bot)\n</code></pre> As you can see, there's one extra bit, a function called <code>setup</code>, this function acts as an entry point for NAFF, so it knows how to load the extension properly.</p> <p>To load a extension, you simply add the following to your <code>main</code> script, just above <code>bot.start</code>:</p> <pre><code>...\n\nbot.load_extension(\"Filename_here\")\n\nbot.start(\"token\")\n</code></pre> <p>Now, for the cool bit of Extensions, reloading. Extensions allow you to edit your code, and reload it, without restarting the bot. To do this, simply run <code>bot.reload_extension(\"Filename_here\")</code> and your new code will be used. Bare in mind any tasks your extension is doing will be abruptly stopped.</p> <p>You can pass keyword-arguments to the <code>load_extension</code>, <code>unload_extension</code> and <code>reload_extension</code> extension management methods. Any arguments you pass to the <code>setup</code> or <code>teardown</code> methods, will also be passed to the <code>Extension.drop</code> method.</p> <p>Here is a basic \"Extension switching\" example:</p> <pre><code>from naff import Extension\n\n\nclass SomeExtension(Extension):\n    def __init__(self, bot, some_arg: int = 0):\n        ...\n\n\nclass AnotherExtension(Extension):\n    def __init__(self, bot, another_arg: float = 0.0):\n        ...\n\n\ndef setup(bot, default_extension: bool, **kwargs):  # We don't care about other arguments here.\n    if default_extension:\n        SomeExtension(bot, **kwargs)\n    else:\n        AnotherExtension(bot, **kwargs)\n\n\n...\n\nbot.load_extension(\"Filename_here\", default_extension=False, another_arg=3.14)\n# OR\nbot.load_extension(\"Filename_here\", default_extension=True, some_arg=555)\n</code></pre>"},{"location":"Guides/21%20Advanced%20Extension%20Usage/","title":"Advanced Extension Usage","text":"<p>You have learned how to create interactions and how to keep your code clean with extensions. The following examples show you how to elevate your extensions to the next level.</p>"},{"location":"Guides/21%20Advanced%20Extension%20Usage/#check-this-out","title":"Check This Out","text":"<p>It would be cool the check some condition before invoking a command, wouldn't it? You are in luck, that is exactly what checks are for.</p> <p>Checks prohibit the interaction from running if they return <code>False</code>.</p> <p>You can add your own check to your extension. In this example, we only want a user whose name starts with \"a\" to run any command from this extension. <pre><code>class MyExtension(Extension):\n    def __init__(self, client: Client):\n        self.client = client\n        self.add_ext_check(self.a_check)\n\n    async def a_check(ctx: InteractionContext) -&gt; bool:\n        return bool(ctx.author.name.startswith(\"a\"))\n\n    @slash_command(...)\n    async def my_command(...):\n        ...\n\ndef setup(client):\n    MyExtension(client)\n</code></pre></p>"},{"location":"Guides/21%20Advanced%20Extension%20Usage/#pre-and-post-run-events","title":"Pre- And Post-Run Events","text":"<p>Pre- and Post-Run events are similar to checks. They run before and after an interaction is invoked, respectively.</p> <p>In this example, we are just printing some stats before and after the interaction. <pre><code>class MyExt(Extension):\n    def __init__(self, client: Client):\n        self.client = client\n        self.add_extension_prerun(self.pre_run)\n        self.add_extension_postrun(self.post_run)\n\n    async def pre_run(ctx: InteractionContext):\n        print(f\"Command started at: {datetime.datetime.now()}\")\n\n    async def post_run(ctx: InteractionContext):\n        print(f\"Command done at: {datetime.datetime.now()}\")\n\n    @slash_command(...)\n    async def my_command(...):\n        ...\n\ndef setup(client):\n    MyExtension(client)\n</code></pre></p>"},{"location":"Guides/21%20Advanced%20Extension%20Usage/#global-checks","title":"Global Checks","text":"<p>Now you learned how to make checks for a extension right after we told you to use extensions to split your code into different files. Ironic, if you want a check for any interaction in any extension.</p> <p>Lucky you, however, since you seem to have forgotten about python subclassing. By subclassing your own custom extension, your can still split your code into as many files as you want without having to redefine your checks.</p>"},{"location":"Guides/21%20Advanced%20Extension%20Usage/#file-1","title":"File 1","text":"<pre><code>class CustomExtension(Extension):\n    def __init__(self, client: Client):\n        self.client = client\n        self.add_ext_check(self.a_check)\n\n    async def a_check(ctx: InteractionContext) -&gt; bool:\n        return bool(ctx.author.name.startswith(\"a\"))\n</code></pre>"},{"location":"Guides/21%20Advanced%20Extension%20Usage/#file-2","title":"File 2","text":"<pre><code>class MyExtension(CustomExtension):\n    @slash_command(...)\n    async def my_command(...):\n        ...\n\ndef setup(client):\n    MyExtension(client)\n</code></pre>"},{"location":"Guides/22%20Live%20Patching/","title":"Live Patching","text":"<p>NAFF has a few built-in extensions that add some features, primarily for debugging. One of these extensions that you can enable separately is to add <code>jurigged</code> for live patching of code.</p>"},{"location":"Guides/22%20Live%20Patching/#how-to-enable","title":"How to enable","text":"<pre><code>bot.load_extension(\"naff.ext.jurigged\")\n</code></pre> <p>That's it! The extension will handle all of the leg work, and all you'll notice is that you have more messages in your logs (depending on the log level).</p>"},{"location":"Guides/22%20Live%20Patching/#what-is-jurigged","title":"What is jurigged?","text":"<p><code>jurigged</code> is a library written to allow code hot reloading in Python. It allows you to edit code and have it automagically be updated in your program the next time it is run. The code under the hood is extremely complicated, but the interface to use it is relatively simple.</p>"},{"location":"Guides/22%20Live%20Patching/#how-is-this-useful","title":"How is this useful?","text":"<p>NAFF takes advantage of jurigged to reload any and all commands that were edited whenever a change is made, allowing you to have more uptime with while still adding/improving features of your bot.</p>"},{"location":"Guides/23%20Voice/","title":"Voice Support","text":"<p>So you want to start playing some \ud83c\udfb5tunes\ud83c\udfb6 in voice channels? Well let's get that going for you.</p> <p>First you're going to want to get the voice dependencies installed: <pre><code>pip install dis-snek[voice]\n</code></pre></p> <p>Then you'll need to download FFmpeg and place it in your project directory or PATH.</p> <p>Now you've got those; let's make a simple play command to get you started.</p> <pre><code>import naff\nfrom naff.api.voice.audio import AudioVolume\n\n\n@naff.slash_command(\"play\", \"play a song!\")\n@naff.slash_option(\"song\", \"The song to play\", 3, True)\nasync def play(self, ctx: naff.InteractionContext, song: str):\n    if not ctx.voice_state:\n        # if we haven't already joined a voice channel\n        # join the authors vc\n        await ctx.author.voice.channel.connect()\n\n    # Get the audio using YTDL\n    audio = await AudioVolume(song)\n    await ctx.send(f\"Now Playing: **{song}**\")\n    # Play the audio\n    await ctx.voice_state.play(audio)\n</code></pre> <p>Now just join a voice channel, and type run the \"play\" slash command with a song of your choice.</p> <p>Congratulations! You've got a music-bot.</p>"},{"location":"Guides/23%20Voice/#but-what-about-local-music","title":"But what about local music?","text":"<p>If you want to play your own files, you can do that too! Create an <code>AudioVolume</code> object and away you go.</p> <p>Note</p> <p>If your audio is already encoded, use the standard <code>Audio</code> object instead. You'll lose volume manipulation, however.</p> <pre><code>import naff\nfrom naff.api.voice.audio import AudioVolume\n\n\n@naff.slash_command(\"play\", \"play a song!\")\nasync def play_file(ctx: naff.InteractionContext):\n    audio = AudioVolume(\"some_file.wav\")\n    await ctx.voice_state.play(audio)\n</code></pre> <p>Check out Active Voice State for a list of available methods and attributes.</p>"},{"location":"Guides/23%20Voice/#okay-but-what-about-soundcloud","title":"Okay, but what about Soundcloud?","text":"<p>NAFF has an extension library called <code>NAFFAudio</code> which can help with that. It has an object called <code>YTAudio</code> which can be used to play audio from Soundcloud and other video platforms.</p> <pre><code>pip install naff_audio\n</code></pre> <pre><code>from naff_audio import YTAudio\n\naudio = await YTAudio.from_url(\"https://soundcloud.com/rick-astley-official/never-gonna-give-you-up-4\")\nawait voice_state.play(audio)\n</code></pre> <p><code>NAFFAudio</code> also contains other useful features for audio-bots. Check it out if that's your jam.</p>"},{"location":"Guides/24%20Localisation/","title":"Localising","text":"<p>So your bot has grown, and now you need to localize localise your bot. Well thank god we support localisation then, huh?</p> <p>To clarify; localisation is a feature of application commands that discord offers, this means the same command will have different names and descriptions depending on the user's locale settings.</p>"},{"location":"Guides/24%20Localisation/#how-its-made","title":"How its made:","text":"<p>Let's take this nice and simple <code>hello</code> command</p> <p><pre><code>import naff\n\n\n@naff.slash_command(name=\"hello\")\nasync def hello_cmd(ctx: naff.InteractionContext):\n    await ctx.send(f\"Hello {ctx.author.display_name}\")\n</code></pre> This command was immensely popular, and now we have some \ud83c\uddeb\ud83c\uddf7 French users. Wouldn't it be nice if we could speak their language.</p> <p><pre><code>import naff\nfrom naff import LocalisedName\n\n\n@naff.slash_command(name=LocalisedName(english_us=\"hello\", french=\"salut\"))\nasync def hello_cmd(ctx: naff.InteractionContext):\n    await ctx.send(f\"Hello {ctx.author.display_name}\")\n</code></pre> All we need to do is set the field to a <code>Localised</code> object, and NAFF and discord wil handle the rest for you. For extra flavour lets make this command more dynamic.</p> <p><pre><code>import naff\nfrom naff import LocalisedName\n\n\n@naff.slash_command(name=LocalisedName(english_us=\"hello\", french=\"salut\"))\nasync def hello_cmd(ctx: naff.InteractionContext):\n    await ctx.send(f\"{ctx.invoked_name} {ctx.author.display_name}\")\n</code></pre> Simply by changing <code>\"hello\"</code> to <code>ctx.invoked_name</code> the command will always use whatever the user typed to greet them. If you want to know what locale the user is in, simply use <code>ctx.locale</code>.</p> <p>This will work for any object with a <code>name</code> or <code>description</code> field. Simply use <code>LocalisedDesc</code> instead for descriptions. For example, you can localise options, choices, and subcommands.</p>"},{"location":"Guides/25%20Error%20Tracking/","title":"Error Tracking","text":"<p>So, you've finally got your bot running on a server somewhere.  Chances are, you're not checking the console output 24/7, looking for exceptions.</p> <p>You're going to want to have some way of tracking if errors occur.</p>"},{"location":"Guides/25%20Error%20Tracking/#the-simple-and-dirty-method","title":"The simple and dirty method","text":"<p>!!! Please don't actually do this.</p> <p>The most obvious solution is to think \"Well, I'm writing a Discord Bot.  Why not send my errors to a discord channel?\"</p> <pre><code>@listen()\nasync def on_error(error):\n    await bot.get_channel(LOGGING_CHANNEL_ID).send(f\"```\\n{error.source}\\n{error.error}\\n```)\n</code></pre> <p>And this is great when debugging.  But it consumes your rate limit, can run into the 2000 character message limit, and won't work on shards that don't contain your personal server.  It's also very hard to notice patterns and can be noisy.</p>"},{"location":"Guides/25%20Error%20Tracking/#so-what-should-i-do-instead","title":"So what should I do instead?","text":"<p>NAFF contains built-in support for Sentry.io, a cloud error tracking platform.</p> <p>To enable it, call <code>bot.load_extension('naff.ext.sentry', token=SENTRY_TOKEN)</code> as early as possible in your startup. (Load it before your own extensions, so it can catch intitialization errors in those extensions)</p>"},{"location":"Guides/25%20Error%20Tracking/#what-does-this-do-that-vanilla-sentry-doesnt","title":"What does this do that vanilla Sentry doesn't?","text":"<p>We add some tags and contexts that might be useful, and filter out some internal-errors that you probably don't want to see.</p>"},{"location":"Guides/30%20Pagination/","title":"Pagination","text":"<p>Pagination, also known as paging, is the process of dividing a document into discrete pages, either electronic pages or printed pages.</p> <p>We've all hit that point where Discord won't let you send enough characters, at that point you can either flood the channel with multiple messages, or you can start paginating your messages.</p> <p>NAFF comes builtin with a pagination utility that splits your messages up into pages, which your user can navigate through.</p> <p></p> <p>To use it, you only need 3 lines.</p> <pre><code>from naff.ext.paginators import Paginator\n\npaginator = Paginator.create_from_string(bot, your_content, page_size=1000)\nawait paginator.send(ctx)\n</code></pre> <p>But let's say you have fancy embedded content you want to use. Well don't worry, NAFF can handle that too: <pre><code>embeds = [Embed(\"Page 1 content\"), Embed(\"Page 2 embed\"), Embed(\"Page 3 embed\"), Embed(\"Page 4 embed\")]\npaginator = Paginator.create_from_embeds(bot, *embeds)\n</code></pre></p> <p>Paginators are configurable, you can choose which buttons show, add timeouts, add select menu navigation, and even add callbacks. To see your options, check out their documentation here.</p>"},{"location":"Guides/40%20Tasks/","title":"Tasks","text":"<p>Tasks are background processes that can be used to asynchronously run code with a specified trigger.</p>"},{"location":"Guides/40%20Tasks/#how-they-work","title":"How They Work","text":"<p>Tasks work by creating an <code>asyncio.Task</code> to run a loop to check if the task is ready to be run based on the provided trigger. Using them is fairly easy, and the easiest way is via Decorators.</p>  Decorators Manual Registration <p>Decorators are by far the easier way to run tasks, with very simple syntax to get started.</p> <p><pre><code>from naff import Task, IntervalTrigger\n\n@Task.create(IntervalTrigger(minutes=10)) # (1)!\nasync def print_every_ten():\n    print(\"It's been 10 minutes!\")\n</code></pre></p> <ol> <li>This will create a task that runs every 10 minutes</li> </ol> <p>You can also manually register tasks</p> <pre><code>from naff import Task, IntervalTrigger\n\nasync def print_every_ten():\n    print(\"It's been 10 minutes!\")\n\ntask = Task(print_every_ten, IntervalTrigger(minutes=10))\n</code></pre> <p>By default, there are a few triggers available to the user.</p>  IntervalTrigger DateTrigger TimeTrigger OrTrigger <p>These triggers run every set interval.</p> <pre><code>from naff import Task, IntervalTrigger\n\n@Task.create(IntervalTrigger(minutes=10))\nasync def print_every_ten():\n    print(\"It's been 10 minutes!\")\n</code></pre> <p>These triggers are similar to IntervalTriggers, but instead run when a specified datetime is reached.</p> <p><pre><code>from datetime import datetime, timedelta\nfrom naff import Task, DateTrigger\n\nfuture = datetime.strptime(\"%d-%m-%Y\", \"01-01-2100\") # (1)!\n\n@Task.create(DateTrigger(future)) # (2)!\nasync def new_century():\n    print(\"Welcome to the 22nd Century!\")\n</code></pre></p> <ol> <li>This create a <code>datetime</code> object for January 1, 2100</li> <li>This uses the <code>future</code> object to create a <code>Task</code> scheduled for January 1, 2100</li> </ol> <p>These triggers are similar to DateTriggers, but trigger daily at the specified hour, minute, and second.</p> <p><pre><code>from naff import Task, TimeTrigger\n\n@Task.create(TimeTrigger(hour=0, minute=0)) # (1)!\nasync def midnight():\n    print(\"It's midnight!\")\n</code></pre></p> <ol> <li>This creates a task to run at midnight every day</li> </ol> <p>These triggers are special, in that you can pass in a list of different triggers, and if any of them are triggered, it runs the function.</p> <p><pre><code>from naff import Task, OrTrigger, TimeTrigger\n\n@Task.create(OrTrigger(TimeTrigger(hour=5, minute=0), TimeTrigger(hour=17, minute=0)) # (1)!\nasync def five():\n    print(\"It's 5 O'clock somewhere, and that somewhere is here!\")\n</code></pre></p> <ol> <li>This creates a task that triggers at either 5 AM local time or 5 PM local time</li> </ol>"},{"location":"Guides/40%20Tasks/#starting-a-task","title":"Starting a task","text":"<p>To start a task that has been created, you need to run the <code>Task.start()</code> method from an <code>async</code> function. A good place to do this is during <code>on_startup</code>:</p>  Decorators Manual Registration <p><pre><code>from naff import Client, Intents, Task, IntervalTrigger, listen\n\n@Task.create(IntervalTrigger(minutes=10))\nasync def print_every_ten():\n    print(\"It's been 10 minutes!\")\n\nbot = Client(intents=Intents.DEFAULT)\n\n@listen()\nasync def on_startup(): # (1)!\n    await print_every_ten.start()\n</code></pre></p> <ol> <li>See Events for more information</li> </ol> <pre><code>from naff import Client, Intents, Task, IntervalTrigger, listen\n\nasync def print_every_ten():\n    print(\"It's been 10 minutes!\")\n\nbot = Client(intents=Intents.DEFAULT)\ntask = Task(IntervalTrigger(minutes=10))\n\n@listen()\nasync def on_startup():\n    await task.start()\n</code></pre>"},{"location":"Guides/80%20Sharding/","title":"Sharding","text":"<p>Oh damn, your bot is getting pretty big, huh? Well I guess its time we discuss sharding.</p> <p>Sharding, in the simplest sense, is splitting up the load on your bot. Discord requires sharding once you reach 2500 guilds, but your bot might be able to handle more than that with a single process. That's where the AutoShardedClient comes in.</p> <p>The AutoShardedClient is a subclass of the Client class, and it's basically the same as the Client class, except it's automatically sharding your bot under the hood. Simply start your bot with this client, and it will automatically shard based on Discord's requests. If you need to, you can also manually specify shards.</p> <p>How do you use it? Well that's the easy part, lets say this is your code</p> <p><pre><code>from naff import Client, listen\n\nclass Bot(Client):\n    async def on_ready(self):\n        print(\"Ready\")\n        print(f\"This bot is owned by {self.owner}\")\n\n    @listen()\n    async def on_message_create(self, event):\n        print(f\"message received: {event.message.content}\")\n</code></pre> To make it sharded we make one change: <pre><code>from naff import AutoShardedClient, listen\n\nclass Bot(AutoShardedClient):\n    async def on_ready(self):\n        print(\"Ready\")\n        print(f\"This bot is owned by {self.owner}\")\n\n    @listen()\n    async def on_message_create(self, event):\n        print(f\"message received: {event.message.content}\")\n</code></pre> And that's it, your bot is now able to automatically shard.</p> <p>Sounds pretty cool, huh? So what's the catch? Well, this keeps the bot in a single process, meaning there is no load-balancing. If your bot is getting large, no matter how many shards you have, it will be slow. That's where splitting the bot into multiple processes is the best solution. But that's outside the scope of this guide \ud83d\ude09.</p>"},{"location":"Guides/90%20Example/","title":"Examples","text":""},{"location":"Guides/90%20Example/#mainpy","title":"<code>main.py</code>","text":"<pre><code>import logging\n\nfrom naff import Client, Intents, listen\nfrom naff.api.events import Component\n\n# define your own logger with custom logging settings\nlogging.basicConfig()\ncls_log = logging.getLogger(\"MyLogger\")\ncls_log.setLevel(logging.DEBUG)\n\nbot = Client(intents=Intents.DEFAULT, sync_interactions=True, asyncio_debug=True, logger=cls_log)\n\n\n@listen()\nasync def on_ready():\n    print(\"Ready\")\n    print(f\"This bot is owned by {bot.owner}\")\n\n\n@listen()\nasync def on_guild_create(event):\n    print(f\"guild created : {event.guild.name}\")\n\n\n@listen()\nasync def on_message_create(event):\n    print(f\"message received: {event.message.content}\")\n\n\n@listen()\nasync def on_component(event: Component):\n    ctx = event.context\n    await ctx.edit_origin(\"test\")\n\n\nbot.load_extension(\"test_components\")\nbot.load_extension(\"test_application_commands\")\nbot.start(\"Token\")\n</code></pre>"},{"location":"Guides/90%20Example/#test_componentspy","title":"<code>test_components.py</code>","text":"<pre><code>from naff import prefixed_command, Button, ActionRow, ButtonStyles, Extension\n\n\nclass ButtonExampleSkin(Extension):\n    @prefixed_command()\n    async def blurple_button(self, ctx):\n        await ctx.send(\"hello there\", components=Button(ButtonStyles.BLURPLE, \"A blurple button\"))\n\n    @prefixed_command()\n    async def multiple_buttons(self, ctx):\n        await ctx.send(\n            \"2 buttons in a row\",\n            components=[Button(ButtonStyles.BLURPLE, \"A blurple button\"), Button(ButtonStyles.RED, \"A red button\")],\n        )\n\n    @prefixed_command()\n    async def action_rows(self, ctx):\n        await ctx.send(\n            \"2 buttons in 2 rows, using nested lists\",\n            components=[[Button(ButtonStyles.BLURPLE, \"A blurple button\")], [Button(ButtonStyles.RED, \"A red button\")]],\n        )\n\n    @prefixed_command()\n    async def action_rows_more(self, ctx):\n        await ctx.send(\n            \"2 buttons in 2 rows, using explicit action_rows lists\",\n            components=[\n                ActionRow(Button(ButtonStyles.BLURPLE, \"A blurple button\")),\n                ActionRow(Button(ButtonStyles.RED, \"A red button\")),\n            ],\n        )\n\n\ndef setup(bot):\n    ButtonExampleSkin(bot)\n</code></pre>"},{"location":"Guides/90%20Example/#test_application_commandspy","title":"<code>test_application_commands.py</code>","text":"<pre><code>from naff import slash_command, slash_option, InteractionContext, context_menu, CommandTypes, Button, ActionRow, ButtonStyles, Extension\n\n\nclass CommandsExampleSkin(Extension):\n    @slash_command(\"command\", description=\"This is a test\", scopes=701347683591389185)\n    @slash_option(\"another\", \"str option\", 3, required=True)\n    @slash_option(\"option\", \"int option\", 4, required=True)\n    async def command(self, ctx: InteractionContext, **kwargs):\n        await ctx.send(str(ctx.resolved))\n        await ctx.send(f\"Test: {kwargs}\", components=[ActionRow(Button(1, \"Test\"))])\n        print(ctx.resolved)\n\n    @command.error\n    async def command_error(self, e, *args, **kwargs):\n        print(f\"Command hit error with {args=}, {kwargs=}\")\n\n    @command.pre_run\n    async def command_pre_run(self, context, *args, **kwargs):\n        print(\"I ran before the command did!\")\n\n    @context_menu(name=\"user menu\", context_type=CommandTypes.USER, scopes=701347683591389185)\n    async def user_context(self, ctx):\n        await ctx.send(\"Context menu:: user\")\n\n\ndef setup(bot):\n    CommandsExampleSkin(bot)\n</code></pre>"},{"location":"Guides/98%202.x%20Migration/","title":"1.x -&gt; 2.x Migration Guide","text":"<p>2.x Was a rewrite of various parts of Naff, and as such, there are a few breaking changes. This guide will help you migrate your code from 1.x to 2.x.</p> <p>Please note; there are other additions to 2.x, but they are not breaking changes, and as such, are not covered in this guide.</p>"},{"location":"Guides/98%202.x%20Migration/#misc","title":"Misc.","text":"<ul> <li>All <code>edit</code> methods are now keyword arguments only.</li> <li>The exception is <code>content</code> on message edits, which is positional.</li> <li><code>context.interaciton_id</code> is now an <code>int</code> instead of a <code>str</code>.</li> </ul>"},{"location":"Guides/98%202.x%20Migration/#selects","title":"Selects","text":"<p>To simplify SelectMenus, NAFF made some changes to how SelectMenus are used. - Options can now be and reasonable type, be it <code>SelectOption</code>, <code>dict</code>, <code>iterable</code> or <code>str</code> - All parameters are now keyword only, excpet for <code>options</code> which remains positional or keyword - <code>Select</code> was renamed to <code>StringSelectMenu</code> - New select menus were implemented to support API changes   - https://discord.com/developers/docs/interactions/message-components#select-menus   - <code>UserSelectMenu</code>   - <code>RoleSelectMenu</code>   - <code>MentionableSelectMenu</code>   - <code>ChannelSelectMenu</code>   - <code>ChannelSelectMenu</code></p>"},{"location":"Guides/98%202.x%20Migration/#before","title":"Before","text":"<pre><code>from naff import Select, SelectOption\nawait channel.send(\n        \"Old SelectUX\",\n        components=Select(\n            options=[\n                SelectOption(\"test1\", \"test1\"),\n                SelectOption(\"test2\", \"test2\"),\n                SelectOption(\"test3\", \"test3\"),\n            ],\n            placeholder=\"test\",\n        ),\n    )\n</code></pre>"},{"location":"Guides/98%202.x%20Migration/#after","title":"After","text":"<pre><code>from naff import StringSelectMenu\n\nawait channel.send(\n        \"New SelectMenu Menu UX test\", components=StringSelectMenu([\"test1\", \"test2\", \"test3\"], placeholder=\"test\")\n    )\n</code></pre>"},{"location":"Guides/98%202.x%20Migration/#listeners","title":"Listeners","text":"<p>Listeners have received a series of ease-of-use updates for both extension and bot developers alike.</p> <ul> <li>All internal listeners now have a <code>is_default_listener</code> attribute to make it easier to differentiate between the library's listeners and user defined listeners.</li> <li><code>override_default_listeners</code> allows you to completely override the library's listeners with your own.</li> <li>Note it might be worth looking into processors if you're doing this; as they allow acting on the raw-payloads before they're processed by the library.</li> <li>All event objects now have a shortcut to listen to them via <code>BaseEvent.listen(coro, Client)</code></li> <li>Listeners can now be delayed until the client is ready with a <code>delay_until_ready</code> argument.</li> </ul>"},{"location":"Guides/98%202.x%20Migration/#events","title":"Events","text":"<ul> <li>All event objects now have a shortcut to listen to them via <code>BaseEvent.listen(coro, Client)</code></li> <li>New Events!</li> <li><code>ComponentCompletion</code> - Dispatched after the library ran any component callback.</li> <li><code>AutocompleteCompletion</code> - Dispatched after the library ran any autocomplete callback.</li> <li><code>ModalCompletion</code> - Dispatched after the library ran any modal callback.</li> <li><code>Error</code> - Dispatched whenever the libray encounters an unhandled exception.<ul> <li>Previously this was done by overriding the <code>on_error</code> method on the client, or in extensions</li> </ul> </li> <li><code>CommandError</code> - Dispatched whenever a command encounters an unhandled exception.</li> <li><code>ComponentError</code> - Dispatched whenever a component encounters an unhandled exception.</li> <li><code>AutocompleteError</code> - Dispatched whenever an autocomplete encounters an unhandled exception.</li> <li><code>ModalError</code> - Dispatched whenever a modal encounters an unhandled exception.</li> <li><code>NewThreadCreate</code> - Dispatched whenever a thread is newly created</li> <li><code>GuildAvailable</code> - Dispatched whenever a guild becomes available<ul> <li>note this requires the guild cache to be enabled</li> </ul> </li> <li><code>ApplicationCommandPermissionsUpdate</code> - Dispatched whenever a guild's application command permissions are updated</li> <li><code>VoiceUserDeafen</code> - Dispatched whenever a user's deafen status changes</li> <li><code>VoiceUserJoin</code> - Dispatched whenever a user joins a voice channel</li> <li><code>VoiceUserLeave</code> - Dispatched whenever a user leaves a voice channel</li> <li><code>VoiceUserMove</code> - Dispatched whenever a user moves to a different voice channel</li> <li><code>VoiceUserMute</code> - Dispatched whenever a user's mute status changes</li> <li>Event Renamed</li> <li><code>Button</code> has been renamed to <code>ButtonPressed</code> to avoid naming conflicts</li> <li>All events with a <code>context</code> attribute have had it renamed to <code>ctx</code> for consistency</li> </ul>"},{"location":"Guides/98%202.x%20Migration/#client-changes","title":"Client Changes","text":"<ul> <li>dm commands can now be disabled completely via the <code>disable_dm_commands</code> kwarg</li> <li><code>Client.interaction_tree</code> offers a command tree of all application commands registered to the client</li> <li>The <code>Client</code> now sanity checks the cache configuration</li> <li>The <code>Client</code> will no longer warn you if a cache timeout occurs during startup</li> <li>These are caused by T&amp;S shadow-deleting guilds, and are not a concern</li> <li><code>async_startup_tasks</code> are now performed as soon as the client successfully connects to the REST API</li> <li>Note this is before the gateway connection is established, use a <code>on_ready</code> listener if you need to wait for the gateway connection</li> <li>Application Command syncing is now more error tolerant</li> </ul>"},{"location":"Guides/98%202.x%20Migration/#extensions","title":"Extensions","text":"<ul> <li>Extensions no longer require a <code>setup</code> entrypoint function.</li> <li>For complex setups, I would still advise using an entrypoint function</li> </ul>"},{"location":"Guides/98%202.x%20Migration/#caching","title":"Caching","text":"<ul> <li>A <code>NullCache</code> object is now used to represent a disabled cache, to use it use <code>create_cache(0, 0, 0)</code> in a client kwarg as before</li> <li>This is a very niche-use-case and most people won't need to use it</li> <li>The <code>Client</code> will log a warning if <code>NullCache</code> is used for sanity checking</li> <li>The serializer now respects <code>no_export</code> metadata when using <code>as_dict</code></li> </ul>"},{"location":"Guides/98%202.x%20Migration/#forums","title":"Forums","text":"<ul> <li>Forums now utilise the new API spec instead of the private-beta API</li> <li>A new <code>NewThreadCreate</code> event is now dispatched for brand new threads</li> <li>Add various helper methods to <code>Forum</code> objects</li> <li><code>create_post</code> now handles <code>str</code>, <code>int</code> <code>Tag</code> objects for available tags</li> </ul>"},{"location":"Guides/98%202.x%20Migration/#emoji","title":"Emoji","text":"<ul> <li><code>PartialEmoji.from_str</code> can now return None if no emoji is found</li> </ul>"},{"location":"Guides/99%20Migration%20From%20D.py/","title":"Migration From discord.py","text":"<ol> <li> <p>NAFF requires python 3.10 (as compared to dpy's 3.5), you may need to upgrade python.</p> <ul> <li>If you see <code>ERROR: Could not find a version that satisfies the requirement naff (from versions: none)</code> when trying to <code>pip install NAFF</code>, this is your problem.</li> </ul> </li> <li> <p>Classes/Models</p> <ul> <li>Your client is <code>naff.Client</code>.  (Note that commands are a first-class feature, so this is a replacement to both <code>discord.Client</code> and <code>discord.ext.commands.Bot</code>)</li> <li>Cogs are <code>Extensions</code>.</li> <li><code>Member</code> is not a subclass of <code>User</code>, if you're using <code>isinstance</code>, you'll want to check both explicitly.</li> </ul> </li> <li> <p>Extensions (Cogs)</p> <ul> <li>These work mostly the same, with a few notable changes:</li> <li>Your setup function doesn't need to do <code>bot.add_cog()</code>.  Simply call <code>MyCog(bot)</code>, and it'll automatically register itself.</li> <li>Extensions already define <code>self.bot</code>, you don't need to do that in your <code>__init__</code> function.</li> <li>For a full example, see here</li> </ul> </li> <li> <p>Event handlers</p> <ul> <li>Register event handlers with <code>@naff.listen</code></li> <li>Where possible, we use the official names for events, most notably <code>on_message_create</code> instead of dpy's <code>on_message</code>.</li> <li>A full list can be found here.</li> <li>Event details are stored on a model, passed as a single parameter. (eg: <code>on_member_update(before, after)</code> becomes <code>on_member_update(event)</code>, where event has a <code>.before</code> and <code>.after</code>.</li> <li><code>on_ready</code> is called whenever the gateway resumes. If you are looking to run stuff once upon startup, use the <code>on_startup</code> handler instead.</li> <li>For more details, read the Events guide.</li> </ul> </li> <li> <p>Migrating your commands</p> <ul> <li>If you were already using dpy's command extension, migrating to slash commands is fairly simple.  You just need to convert the decorators as per the Slash Commands guide</li> <li>If you wish to keep using prefixed commands (sometimes called message or text-based commands), you can use our <code>@naff.prefixed_command</code> decorator, which has an extensive guide for them. The syntax should be very similar to discord.py with a few exceptions.</li> <li>If you were manually handling commands with <code>on_message</code>, you'll probably need to figure it out yourself, as this guide doesn't know how you wrote your parser.  Consider using the provided command handlers.</li> </ul> </li> </ol> Note <p>This guide was written based on the experiences of porting a small handful of bots.  There may be gotchas that we did not encounter.  If you run into anything you'd like to have known, let us know in our Discord, and we'll add it to this document.</p>"}]}